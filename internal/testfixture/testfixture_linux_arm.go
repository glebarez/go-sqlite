// Code generated by 'ccgo -DSQLITE_OMIT_LOAD_EXTENSION -DSQLITE_SERIES_CONSTRAINT_VERIFY=1 -DSQLITE_SERVER=1 -DTCLSH_INIT_PROC=sqlite3TestInit -D_HAVE_SQLITE_CONFIG_H -I/usr/include/tcl8.6 -export-defines "" -export-fields F -trace-translation-units -volatile=sqlite3_io_error_pending,sqlite3_open_file_count,sqlite3_pager_readdb_count,sqlite3_pager_writedb_count,sqlite3_pager_writej_count,sqlite3_search_count,sqlite3_sort_count,saved_cnt -lmodernc.org/sqlite/libtest -lmodernc.org/tcl/lib -lmodernc.org/z/lib -o internal/testfixture/testfixture_linux_arm.go -Itestdata/sqlite-src-3360000/ext/async -Itestdata/sqlite-src-3360000/ext/fts3 -Itestdata/sqlite-src-3360000/ext/icu -Itestdata/sqlite-src-3360000/ext/rtree -Itestdata/sqlite-src-3360000/ext/session -Itestdata/sqlite-src-3360000/ext/userauth -Itestdata/sqlite-src-3360000/src -Itestdata/sqlite-amalgamation-3360000 -Itestdata/sqlite-src-3360000 testdata/sqlite-src-3360000/ext/expert/sqlite3expert.c testdata/sqlite-src-3360000/ext/expert/test_expert.c testdata/sqlite-src-3360000/ext/fts3/fts3_term.c testdata/sqlite-src-3360000/ext/fts3/fts3_test.c testdata/sqlite-src-3360000/ext/fts5/fts5_tcl.c testdata/sqlite-src-3360000/ext/fts5/fts5_test_mi.c testdata/sqlite-src-3360000/ext/fts5/fts5_test_tok.c testdata/sqlite-src-3360000/ext/misc/appendvfs.c testdata/sqlite-src-3360000/ext/misc/amatch.c testdata/sqlite-src-3360000/ext/misc/carray.c testdata/sqlite-src-3360000/ext/misc/cksumvfs.c testdata/sqlite-src-3360000/ext/misc/closure.c testdata/sqlite-src-3360000/ext/misc/csv.c testdata/sqlite-src-3360000/ext/misc/decimal.c testdata/sqlite-src-3360000/ext/misc/eval.c testdata/sqlite-src-3360000/ext/misc/explain.c testdata/sqlite-src-3360000/ext/misc/fileio.c testdata/sqlite-src-3360000/ext/misc/fuzzer.c testdata/sqlite-src-3360000/ext/misc/ieee754.c testdata/sqlite-src-3360000/ext/misc/mmapwarm.c testdata/sqlite-src-3360000/ext/misc/nextchar.c testdata/sqlite-src-3360000/ext/misc/normalize.c testdata/sqlite-src-3360000/ext/misc/percentile.c testdata/sqlite-src-3360000/ext/misc/prefixes.c testdata/sqlite-src-3360000/ext/misc/regexp.c testdata/sqlite-src-3360000/ext/misc/remember.c testdata/sqlite-src-3360000/ext/misc/series.c testdata/sqlite-src-3360000/ext/misc/spellfix.c testdata/sqlite-src-3360000/ext/misc/totype.c testdata/sqlite-src-3360000/ext/misc/unionvtab.c testdata/sqlite-src-3360000/ext/misc/wholenumber.c testdata/sqlite-src-3360000/ext/misc/zipfile.c testdata/sqlite-src-3360000/ext/rbu/test_rbu.c testdata/sqlite-src-3360000/ext/userauth/userauth.c testdata/sqlite-src-3360000/src/tclsqlite.c testdata/sqlite-src-3360000/src/test1.c testdata/sqlite-src-3360000/src/test2.c testdata/sqlite-src-3360000/src/test3.c testdata/sqlite-src-3360000/src/test4.c testdata/sqlite-src-3360000/src/test5.c testdata/sqlite-src-3360000/src/test6.c testdata/sqlite-src-3360000/src/test7.c testdata/sqlite-src-3360000/src/test8.c testdata/sqlite-src-3360000/src/test9.c testdata/sqlite-src-3360000/src/test_async.c testdata/sqlite-src-3360000/src/test_autoext.c testdata/sqlite-src-3360000/src/test_backup.c testdata/sqlite-src-3360000/src/test_bestindex.c testdata/sqlite-src-3360000/src/test_blob.c testdata/sqlite-src-3360000/src/test_btree.c testdata/sqlite-src-3360000/src/test_config.c testdata/sqlite-src-3360000/src/test_delete.c testdata/sqlite-src-3360000/src/test_demovfs.c testdata/sqlite-src-3360000/src/test_devsym.c testdata/sqlite-src-3360000/src/test_fs.c testdata/sqlite-src-3360000/src/test_func.c testdata/sqlite-src-3360000/src/test_hexio.c testdata/sqlite-src-3360000/src/test_init.c testdata/sqlite-src-3360000/src/test_intarray.c testdata/sqlite-src-3360000/src/test_journal.c testdata/sqlite-src-3360000/src/test_malloc.c testdata/sqlite-src-3360000/src/test_md5.c testdata/sqlite-src-3360000/src/test_multiplex.c testdata/sqlite-src-3360000/src/test_mutex.c testdata/sqlite-src-3360000/src/test_onefile.c testdata/sqlite-src-3360000/src/test_osinst.c testdata/sqlite-src-3360000/src/test_pcache.c testdata/sqlite-src-3360000/src/test_quota.c testdata/sqlite-src-3360000/src/test_rtree.c testdata/sqlite-src-3360000/src/test_schema.c testdata/sqlite-src-3360000/src/test_server.c testdata/sqlite-src-3360000/src/test_superlock.c testdata/sqlite-src-3360000/src/test_syscall.c testdata/sqlite-src-3360000/src/test_tclsh.c testdata/sqlite-src-3360000/src/test_tclvar.c testdata/sqlite-src-3360000/src/test_thread.c testdata/sqlite-src-3360000/src/test_vdbecov.c testdata/sqlite-src-3360000/src/test_vfs.c testdata/sqlite-src-3360000/src/test_windirent.c testdata/sqlite-src-3360000/src/test_window.c testdata/sqlite-src-3360000/src/test_wsd.c -DNDEBUG -DHAVE_USLEEP -DLONGDOUBLE_TYPE=double -DSQLITE_CKSUMVFS_STATIC -DSQLITE_CORE -DSQLITE_DEFAULT_MEMSTATUS=0 -DSQLITE_DEFAULT_PAGE_SIZE=1024 -DSQLITE_ENABLE_BYTECODE_VTAB -DSQLITE_ENABLE_COLUMN_METADATA -DSQLITE_ENABLE_DBPAGE_VTAB -DSQLITE_ENABLE_DBSTAT_VTAB -DSQLITE_ENABLE_DESERIALIZE -DSQLITE_ENABLE_EXPLAIN_COMMENTS -DSQLITE_ENABLE_FTS5 -DSQLITE_ENABLE_GEOPOLY -DSQLITE_ENABLE_JSON1 -DSQLITE_ENABLE_MEMORY_MANAGEMENT -DSQLITE_ENABLE_OFFSET_SQL_FUNC -DSQLITE_ENABLE_PREUPDATE_HOOK -DSQLITE_ENABLE_RBU -DSQLITE_ENABLE_RTREE -DSQLITE_ENABLE_SNAPSHOT -DSQLITE_ENABLE_STAT4 -DSQLITE_ENABLE_STMTVTAB -DSQLITE_ENABLE_UNLOCK_NOTIFY -DSQLITE_HAVE_ZLIB=1 -DSQLITE_LIKE_DOESNT_MATCH_BLOBS -DSQLITE_MUTEX_APPDEF=1 -DSQLITE_SOUNDEX -DSQLITE_TEMP_STORE=1 -DSQLITE_TEST -DSQLITE_THREADSAFE=1 -DSQLITE_MUTEX_NOOP -lmodernc.org/sqlite/internal/libc2', DO NOT EDIT.

package main

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
	"modernc.org/sqlite/internal/libc2"
	"modernc.org/sqlite/libtest"
	"modernc.org/tcl/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ types.Size_t

func main() { libc.Start(main1) }

const (
	BUFSIZ                                = 8192
	EOF                                   = -1
	EXPERT_CONFIG_SAMPLE                  = 1
	EXPERT_REPORT_CANDIDATES              = 4
	EXPERT_REPORT_INDEXES                 = 2
	EXPERT_REPORT_PLAN                    = 3
	EXPERT_REPORT_SQL                     = 1
	FILENAME_MAX                          = 4096
	FOPEN_MAX                             = 16
	FTS5_TOKENIZE_AUX                     = 0x0008
	FTS5_TOKENIZE_DOCUMENT                = 0x0004
	FTS5_TOKENIZE_PREFIX                  = 0x0002
	FTS5_TOKENIZE_QUERY                   = 0x0001
	FTS5_TOKEN_COLOCATED                  = 0x0001
	FULLY_WITHIN                          = 2
	HAVE_USLEEP                           = 1
	IDX_HASH_SIZE                         = 1023
	L_ctermid                             = 9
	L_tmpnam                              = 20
	NDEBUG                                = 1
	NOT_WITHIN                            = 0
	PARTLY_WITHIN                         = 1
	P_tmpdir                              = "/tmp"
	SEEK_CUR                              = 1
	SEEK_END                              = 2
	SEEK_SET                              = 0
	SQLITE3_H                             = 0
	SQLITE3_TEXT                          = 3
	SQLITEEXPERT_H                        = 1
	SQLITE_ABORT                          = 4
	SQLITE_ABORT_ROLLBACK                 = 516
	SQLITE_ACCESS_EXISTS                  = 0
	SQLITE_ACCESS_READ                    = 2
	SQLITE_ACCESS_READWRITE               = 1
	SQLITE_ALTER_TABLE                    = 26
	SQLITE_ANALYZE                        = 28
	SQLITE_ANY                            = 5
	SQLITE_API                            = 0
	SQLITE_APICALL                        = 0
	SQLITE_ATTACH                         = 24
	SQLITE_AUTH                           = 23
	SQLITE_AUTH_USER                      = 279
	SQLITE_BLOB                           = 4
	SQLITE_BUSY                           = 5
	SQLITE_BUSY_RECOVERY                  = 261
	SQLITE_BUSY_SNAPSHOT                  = 517
	SQLITE_BUSY_TIMEOUT                   = 773
	SQLITE_CALLBACK                       = 0
	SQLITE_CANTOPEN                       = 14
	SQLITE_CANTOPEN_CONVPATH              = 1038
	SQLITE_CANTOPEN_DIRTYWAL              = 1294
	SQLITE_CANTOPEN_FULLPATH              = 782
	SQLITE_CANTOPEN_ISDIR                 = 526
	SQLITE_CANTOPEN_NOTEMPDIR             = 270
	SQLITE_CANTOPEN_SYMLINK               = 1550
	SQLITE_CDECL                          = 0
	SQLITE_CHECKPOINT_FULL                = 1
	SQLITE_CHECKPOINT_PASSIVE             = 0
	SQLITE_CHECKPOINT_RESTART             = 2
	SQLITE_CHECKPOINT_TRUNCATE            = 3
	SQLITE_CKSUMVFS_STATIC                = 1
	SQLITE_CONFIG_COVERING_INDEX_SCAN     = 20
	SQLITE_CONFIG_GETMALLOC               = 5
	SQLITE_CONFIG_GETMUTEX                = 11
	SQLITE_CONFIG_GETPCACHE               = 15
	SQLITE_CONFIG_GETPCACHE2              = 19
	SQLITE_CONFIG_HEAP                    = 8
	SQLITE_CONFIG_LOG                     = 16
	SQLITE_CONFIG_LOOKASIDE               = 13
	SQLITE_CONFIG_MALLOC                  = 4
	SQLITE_CONFIG_MEMDB_MAXSIZE           = 29
	SQLITE_CONFIG_MEMSTATUS               = 9
	SQLITE_CONFIG_MMAP_SIZE               = 22
	SQLITE_CONFIG_MULTITHREAD             = 2
	SQLITE_CONFIG_MUTEX                   = 10
	SQLITE_CONFIG_PAGECACHE               = 7
	SQLITE_CONFIG_PCACHE                  = 14
	SQLITE_CONFIG_PCACHE2                 = 18
	SQLITE_CONFIG_PCACHE_HDRSZ            = 24
	SQLITE_CONFIG_PMASZ                   = 25
	SQLITE_CONFIG_SCRATCH                 = 6
	SQLITE_CONFIG_SERIALIZED              = 3
	SQLITE_CONFIG_SINGLETHREAD            = 1
	SQLITE_CONFIG_SMALL_MALLOC            = 27
	SQLITE_CONFIG_SORTERREF_SIZE          = 28
	SQLITE_CONFIG_SQLLOG                  = 21
	SQLITE_CONFIG_STMTJRNL_SPILL          = 26
	SQLITE_CONFIG_URI                     = 17
	SQLITE_CONFIG_WIN32_HEAPSIZE          = 23
	SQLITE_CONSTRAINT                     = 19
	SQLITE_CONSTRAINT_CHECK               = 275
	SQLITE_CONSTRAINT_COMMITHOOK          = 531
	SQLITE_CONSTRAINT_FOREIGNKEY          = 787
	SQLITE_CONSTRAINT_FUNCTION            = 1043
	SQLITE_CONSTRAINT_NOTNULL             = 1299
	SQLITE_CONSTRAINT_PINNED              = 2835
	SQLITE_CONSTRAINT_PRIMARYKEY          = 1555
	SQLITE_CONSTRAINT_ROWID               = 2579
	SQLITE_CONSTRAINT_TRIGGER             = 1811
	SQLITE_CONSTRAINT_UNIQUE              = 2067
	SQLITE_CONSTRAINT_VTAB                = 2323
	SQLITE_COPY                           = 0
	SQLITE_CORE                           = 1
	SQLITE_CORRUPT                        = 11
	SQLITE_CORRUPT_INDEX                  = 779
	SQLITE_CORRUPT_SEQUENCE               = 523
	SQLITE_CORRUPT_VTAB                   = 267
	SQLITE_CREATE_INDEX                   = 1
	SQLITE_CREATE_TABLE                   = 2
	SQLITE_CREATE_TEMP_INDEX              = 3
	SQLITE_CREATE_TEMP_TABLE              = 4
	SQLITE_CREATE_TEMP_TRIGGER            = 5
	SQLITE_CREATE_TEMP_VIEW               = 6
	SQLITE_CREATE_TRIGGER                 = 7
	SQLITE_CREATE_VIEW                    = 8
	SQLITE_CREATE_VTABLE                  = 29
	SQLITE_DBCONFIG_DEFENSIVE             = 1010
	SQLITE_DBCONFIG_DQS_DDL               = 1014
	SQLITE_DBCONFIG_DQS_DML               = 1013
	SQLITE_DBCONFIG_ENABLE_FKEY           = 1002
	SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = 1004
	SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005
	SQLITE_DBCONFIG_ENABLE_QPSG           = 1007
	SQLITE_DBCONFIG_ENABLE_TRIGGER        = 1003
	SQLITE_DBCONFIG_ENABLE_VIEW           = 1015
	SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    = 1012
	SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    = 1016
	SQLITE_DBCONFIG_LOOKASIDE             = 1001
	SQLITE_DBCONFIG_MAINDBNAME            = 1000
	SQLITE_DBCONFIG_MAX                   = 1017
	SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      = 1006
	SQLITE_DBCONFIG_RESET_DATABASE        = 1009
	SQLITE_DBCONFIG_TRIGGER_EQP           = 1008
	SQLITE_DBCONFIG_TRUSTED_SCHEMA        = 1017
	SQLITE_DBCONFIG_WRITABLE_SCHEMA       = 1011
	SQLITE_DBSTATUS_CACHE_HIT             = 7
	SQLITE_DBSTATUS_CACHE_MISS            = 8
	SQLITE_DBSTATUS_CACHE_SPILL           = 12
	SQLITE_DBSTATUS_CACHE_USED            = 1
	SQLITE_DBSTATUS_CACHE_USED_SHARED     = 11
	SQLITE_DBSTATUS_CACHE_WRITE           = 9
	SQLITE_DBSTATUS_DEFERRED_FKS          = 10
	SQLITE_DBSTATUS_LOOKASIDE_HIT         = 4
	SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL   = 6
	SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE   = 5
	SQLITE_DBSTATUS_LOOKASIDE_USED        = 0
	SQLITE_DBSTATUS_MAX                   = 12
	SQLITE_DBSTATUS_SCHEMA_USED           = 2
	SQLITE_DBSTATUS_STMT_USED             = 3
	SQLITE_DEFAULT_MEMSTATUS              = 0
	SQLITE_DEFAULT_PAGE_SIZE              = 1024
	SQLITE_DELETE                         = 9
	SQLITE_DENY                           = 1
	SQLITE_DEPRECATED                     = 0
	SQLITE_DESERIALIZE_FREEONCLOSE        = 1
	SQLITE_DESERIALIZE_READONLY           = 4
	SQLITE_DESERIALIZE_RESIZEABLE         = 2
	SQLITE_DETACH                         = 25
	SQLITE_DETERMINISTIC                  = 0x000000800
	SQLITE_DIRECTONLY                     = 0x000080000
	SQLITE_DONE                           = 101
	SQLITE_DROP_INDEX                     = 10
	SQLITE_DROP_TABLE                     = 11
	SQLITE_DROP_TEMP_INDEX                = 12
	SQLITE_DROP_TEMP_TABLE                = 13
	SQLITE_DROP_TEMP_TRIGGER              = 14
	SQLITE_DROP_TEMP_VIEW                 = 15
	SQLITE_DROP_TRIGGER                   = 16
	SQLITE_DROP_VIEW                      = 17
	SQLITE_DROP_VTABLE                    = 30
	SQLITE_EMPTY                          = 16
	SQLITE_ENABLE_BYTECODE_VTAB           = 1
	SQLITE_ENABLE_COLUMN_METADATA         = 1
	SQLITE_ENABLE_DBPAGE_VTAB             = 1
	SQLITE_ENABLE_DBSTAT_VTAB             = 1
	SQLITE_ENABLE_DESERIALIZE             = 1
	SQLITE_ENABLE_EXPLAIN_COMMENTS        = 1
	SQLITE_ENABLE_FTS5                    = 1
	SQLITE_ENABLE_GEOPOLY                 = 1
	SQLITE_ENABLE_JSON1                   = 1
	SQLITE_ENABLE_MEMORY_MANAGEMENT       = 1
	SQLITE_ENABLE_OFFSET_SQL_FUNC         = 1
	SQLITE_ENABLE_PREUPDATE_HOOK          = 1
	SQLITE_ENABLE_RBU                     = 1
	SQLITE_ENABLE_RTREE                   = 1
	SQLITE_ENABLE_SNAPSHOT                = 1
	SQLITE_ENABLE_STAT4                   = 1
	SQLITE_ENABLE_STMTVTAB                = 1
	SQLITE_ENABLE_UNLOCK_NOTIFY           = 1
	SQLITE_ERROR                          = 1
	SQLITE_ERROR_MISSING_COLLSEQ          = 257
	SQLITE_ERROR_RETRY                    = 513
	SQLITE_ERROR_SNAPSHOT                 = 769
	SQLITE_EXPERIMENTAL                   = 0
	SQLITE_FAIL                           = 3
	SQLITE_FCNTL_BEGIN_ATOMIC_WRITE       = 31
	SQLITE_FCNTL_BUSYHANDLER              = 15
	SQLITE_FCNTL_CHUNK_SIZE               = 6
	SQLITE_FCNTL_CKPT_DONE                = 37
	SQLITE_FCNTL_CKPT_START               = 39
	SQLITE_FCNTL_CKSM_FILE                = 41
	SQLITE_FCNTL_COMMIT_ATOMIC_WRITE      = 32
	SQLITE_FCNTL_COMMIT_PHASETWO          = 22
	SQLITE_FCNTL_DATA_VERSION             = 35
	SQLITE_FCNTL_EXTERNAL_READER          = 40
	SQLITE_FCNTL_FILE_POINTER             = 7
	SQLITE_FCNTL_GET_LOCKPROXYFILE        = 2
	SQLITE_FCNTL_HAS_MOVED                = 20
	SQLITE_FCNTL_JOURNAL_POINTER          = 28
	SQLITE_FCNTL_LAST_ERRNO               = 4
	SQLITE_FCNTL_LOCKSTATE                = 1
	SQLITE_FCNTL_LOCK_TIMEOUT             = 34
	SQLITE_FCNTL_MMAP_SIZE                = 18
	SQLITE_FCNTL_OVERWRITE                = 11
	SQLITE_FCNTL_PDB                      = 30
	SQLITE_FCNTL_PERSIST_WAL              = 10
	SQLITE_FCNTL_POWERSAFE_OVERWRITE      = 13
	SQLITE_FCNTL_PRAGMA                   = 14
	SQLITE_FCNTL_RBU                      = 26
	SQLITE_FCNTL_RESERVE_BYTES            = 38
	SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE    = 33
	SQLITE_FCNTL_SET_LOCKPROXYFILE        = 3
	SQLITE_FCNTL_SIZE_HINT                = 5
	SQLITE_FCNTL_SIZE_LIMIT               = 36
	SQLITE_FCNTL_SYNC                     = 21
	SQLITE_FCNTL_SYNC_OMITTED             = 8
	SQLITE_FCNTL_TEMPFILENAME             = 16
	SQLITE_FCNTL_TRACE                    = 19
	SQLITE_FCNTL_VFSNAME                  = 12
	SQLITE_FCNTL_VFS_POINTER              = 27
	SQLITE_FCNTL_WAL_BLOCK                = 24
	SQLITE_FCNTL_WIN32_AV_RETRY           = 9
	SQLITE_FCNTL_WIN32_GET_HANDLE         = 29
	SQLITE_FCNTL_WIN32_SET_HANDLE         = 23
	SQLITE_FCNTL_ZIPVFS                   = 25
	SQLITE_FLOAT                          = 2
	SQLITE_FORMAT                         = 24
	SQLITE_FULL                           = 13
	SQLITE_FUNCTION                       = 31
	SQLITE_GET_LOCKPROXYFILE              = 2
	SQLITE_HAVE_ZLIB                      = 1
	SQLITE_IGNORE                         = 2
	SQLITE_INDEX_CONSTRAINT_EQ            = 2
	SQLITE_INDEX_CONSTRAINT_FUNCTION      = 150
	SQLITE_INDEX_CONSTRAINT_GE            = 32
	SQLITE_INDEX_CONSTRAINT_GLOB          = 66
	SQLITE_INDEX_CONSTRAINT_GT            = 4
	SQLITE_INDEX_CONSTRAINT_IS            = 72
	SQLITE_INDEX_CONSTRAINT_ISNOT         = 69
	SQLITE_INDEX_CONSTRAINT_ISNOTNULL     = 70
	SQLITE_INDEX_CONSTRAINT_ISNULL        = 71
	SQLITE_INDEX_CONSTRAINT_LE            = 8
	SQLITE_INDEX_CONSTRAINT_LIKE          = 65
	SQLITE_INDEX_CONSTRAINT_LT            = 16
	SQLITE_INDEX_CONSTRAINT_MATCH         = 64
	SQLITE_INDEX_CONSTRAINT_NE            = 68
	SQLITE_INDEX_CONSTRAINT_REGEXP        = 67
	SQLITE_INDEX_SCAN_UNIQUE              = 1
	SQLITE_INNOCUOUS                      = 0x000200000
	SQLITE_INSERT                         = 18
	SQLITE_INTEGER                        = 1
	SQLITE_INTERNAL                       = 2
	SQLITE_INTERRUPT                      = 9
	SQLITE_IOCAP_ATOMIC                   = 0x00000001
	SQLITE_IOCAP_ATOMIC16K                = 0x00000040
	SQLITE_IOCAP_ATOMIC1K                 = 0x00000004
	SQLITE_IOCAP_ATOMIC2K                 = 0x00000008
	SQLITE_IOCAP_ATOMIC32K                = 0x00000080
	SQLITE_IOCAP_ATOMIC4K                 = 0x00000010
	SQLITE_IOCAP_ATOMIC512                = 0x00000002
	SQLITE_IOCAP_ATOMIC64K                = 0x00000100
	SQLITE_IOCAP_ATOMIC8K                 = 0x00000020
	SQLITE_IOCAP_BATCH_ATOMIC             = 0x00004000
	SQLITE_IOCAP_IMMUTABLE                = 0x00002000
	SQLITE_IOCAP_POWERSAFE_OVERWRITE      = 0x00001000
	SQLITE_IOCAP_SAFE_APPEND              = 0x00000200
	SQLITE_IOCAP_SEQUENTIAL               = 0x00000400
	SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN    = 0x00000800
	SQLITE_IOERR                          = 10
	SQLITE_IOERR_ACCESS                   = 3338
	SQLITE_IOERR_AUTH                     = 7178
	SQLITE_IOERR_BEGIN_ATOMIC             = 7434
	SQLITE_IOERR_BLOCKED                  = 2826
	SQLITE_IOERR_CHECKRESERVEDLOCK        = 3594
	SQLITE_IOERR_CLOSE                    = 4106
	SQLITE_IOERR_COMMIT_ATOMIC            = 7690
	SQLITE_IOERR_CONVPATH                 = 6666
	SQLITE_IOERR_CORRUPTFS                = 8458
	SQLITE_IOERR_DATA                     = 8202
	SQLITE_IOERR_DELETE                   = 2570
	SQLITE_IOERR_DELETE_NOENT             = 5898
	SQLITE_IOERR_DIR_CLOSE                = 4362
	SQLITE_IOERR_DIR_FSYNC                = 1290
	SQLITE_IOERR_FSTAT                    = 1802
	SQLITE_IOERR_FSYNC                    = 1034
	SQLITE_IOERR_GETTEMPPATH              = 6410
	SQLITE_IOERR_LOCK                     = 3850
	SQLITE_IOERR_MMAP                     = 6154
	SQLITE_IOERR_NOMEM                    = 3082
	SQLITE_IOERR_RDLOCK                   = 2314
	SQLITE_IOERR_READ                     = 266
	SQLITE_IOERR_ROLLBACK_ATOMIC          = 7946
	SQLITE_IOERR_SEEK                     = 5642
	SQLITE_IOERR_SHMLOCK                  = 5130
	SQLITE_IOERR_SHMMAP                   = 5386
	SQLITE_IOERR_SHMOPEN                  = 4618
	SQLITE_IOERR_SHMSIZE                  = 4874
	SQLITE_IOERR_SHORT_READ               = 522
	SQLITE_IOERR_TRUNCATE                 = 1546
	SQLITE_IOERR_UNLOCK                   = 2058
	SQLITE_IOERR_VNODE                    = 6922
	SQLITE_IOERR_WRITE                    = 778
	SQLITE_LAST_ERRNO                     = 4
	SQLITE_LIKE_DOESNT_MATCH_BLOBS        = 1
	SQLITE_LIMIT_ATTACHED                 = 7
	SQLITE_LIMIT_COLUMN                   = 2
	SQLITE_LIMIT_COMPOUND_SELECT          = 4
	SQLITE_LIMIT_EXPR_DEPTH               = 3
	SQLITE_LIMIT_FUNCTION_ARG             = 6
	SQLITE_LIMIT_LENGTH                   = 0
	SQLITE_LIMIT_LIKE_PATTERN_LENGTH      = 8
	SQLITE_LIMIT_SQL_LENGTH               = 1
	SQLITE_LIMIT_TRIGGER_DEPTH            = 10
	SQLITE_LIMIT_VARIABLE_NUMBER          = 9
	SQLITE_LIMIT_VDBE_OP                  = 5
	SQLITE_LIMIT_WORKER_THREADS           = 11
	SQLITE_LOCKED                         = 6
	SQLITE_LOCKED_SHAREDCACHE             = 262
	SQLITE_LOCKED_VTAB                    = 518
	SQLITE_LOCK_EXCLUSIVE                 = 4
	SQLITE_LOCK_NONE                      = 0
	SQLITE_LOCK_PENDING                   = 3
	SQLITE_LOCK_RESERVED                  = 2
	SQLITE_LOCK_SHARED                    = 1
	SQLITE_MISMATCH                       = 20
	SQLITE_MISUSE                         = 21
	SQLITE_MUTEX_APPDEF                   = 1
	SQLITE_MUTEX_FAST                     = 0
	SQLITE_MUTEX_NOOP                     = 1
	SQLITE_MUTEX_RECURSIVE                = 1
	SQLITE_MUTEX_STATIC_APP1              = 8
	SQLITE_MUTEX_STATIC_APP2              = 9
	SQLITE_MUTEX_STATIC_APP3              = 10
	SQLITE_MUTEX_STATIC_LRU               = 6
	SQLITE_MUTEX_STATIC_LRU2              = 7
	SQLITE_MUTEX_STATIC_MAIN              = 2
	SQLITE_MUTEX_STATIC_MASTER            = 2
	SQLITE_MUTEX_STATIC_MEM               = 3
	SQLITE_MUTEX_STATIC_MEM2              = 4
	SQLITE_MUTEX_STATIC_OPEN              = 4
	SQLITE_MUTEX_STATIC_PMEM              = 7
	SQLITE_MUTEX_STATIC_PRNG              = 5
	SQLITE_MUTEX_STATIC_VFS1              = 11
	SQLITE_MUTEX_STATIC_VFS2              = 12
	SQLITE_MUTEX_STATIC_VFS3              = 13
	SQLITE_NOLFS                          = 22
	SQLITE_NOMEM                          = 7
	SQLITE_NOTADB                         = 26
	SQLITE_NOTFOUND                       = 12
	SQLITE_NOTICE                         = 27
	SQLITE_NOTICE_RECOVER_ROLLBACK        = 539
	SQLITE_NOTICE_RECOVER_WAL             = 283
	SQLITE_NULL                           = 5
	SQLITE_OK                             = 0
	SQLITE_OK_LOAD_PERMANENTLY            = 256
	SQLITE_OK_SYMLINK                     = 512
	SQLITE_OMIT_LOAD_EXTENSION            = 1
	SQLITE_OPEN_AUTOPROXY                 = 0x00000020
	SQLITE_OPEN_CREATE                    = 0x00000004
	SQLITE_OPEN_DELETEONCLOSE             = 0x00000008
	SQLITE_OPEN_EXCLUSIVE                 = 0x00000010
	SQLITE_OPEN_FULLMUTEX                 = 0x00010000
	SQLITE_OPEN_MAIN_DB                   = 0x00000100
	SQLITE_OPEN_MAIN_JOURNAL              = 0x00000800
	SQLITE_OPEN_MASTER_JOURNAL            = 0x00004000
	SQLITE_OPEN_MEMORY                    = 0x00000080
	SQLITE_OPEN_NOFOLLOW                  = 0x01000000
	SQLITE_OPEN_NOMUTEX                   = 0x00008000
	SQLITE_OPEN_PRIVATECACHE              = 0x00040000
	SQLITE_OPEN_READONLY                  = 0x00000001
	SQLITE_OPEN_READWRITE                 = 0x00000002
	SQLITE_OPEN_SHAREDCACHE               = 0x00020000
	SQLITE_OPEN_SUBJOURNAL                = 0x00002000
	SQLITE_OPEN_SUPER_JOURNAL             = 0x00004000
	SQLITE_OPEN_TEMP_DB                   = 0x00000200
	SQLITE_OPEN_TEMP_JOURNAL              = 0x00001000
	SQLITE_OPEN_TRANSIENT_DB              = 0x00000400
	SQLITE_OPEN_URI                       = 0x00000040
	SQLITE_OPEN_WAL                       = 0x00080000
	SQLITE_PERM                           = 3
	SQLITE_PRAGMA                         = 19
	SQLITE_PREPARE_NORMALIZE              = 0x02
	SQLITE_PREPARE_NO_VTAB                = 0x04
	SQLITE_PREPARE_PERSISTENT             = 0x01
	SQLITE_PROTOCOL                       = 15
	SQLITE_RANGE                          = 25
	SQLITE_READ                           = 20
	SQLITE_READONLY                       = 8
	SQLITE_READONLY_CANTINIT              = 1288
	SQLITE_READONLY_CANTLOCK              = 520
	SQLITE_READONLY_DBMOVED               = 1032
	SQLITE_READONLY_DIRECTORY             = 1544
	SQLITE_READONLY_RECOVERY              = 264
	SQLITE_READONLY_ROLLBACK              = 776
	SQLITE_RECURSIVE                      = 33
	SQLITE_REINDEX                        = 27
	SQLITE_REPLACE                        = 5
	SQLITE_ROLLBACK                       = 1
	SQLITE_ROW                            = 100
	SQLITE_SAVEPOINT                      = 32
	SQLITE_SCANSTAT_EST                   = 2
	SQLITE_SCANSTAT_EXPLAIN               = 4
	SQLITE_SCANSTAT_NAME                  = 3
	SQLITE_SCANSTAT_NLOOP                 = 0
	SQLITE_SCANSTAT_NVISIT                = 1
	SQLITE_SCANSTAT_SELECTID              = 5
	SQLITE_SCHEMA                         = 17
	SQLITE_SELECT                         = 21
	SQLITE_SERIALIZE_NOCOPY               = 0x001
	SQLITE_SERIES_CONSTRAINT_VERIFY       = 1
	SQLITE_SERVER                         = 1
	SQLITE_SET_LOCKPROXYFILE              = 3
	SQLITE_SHM_EXCLUSIVE                  = 8
	SQLITE_SHM_LOCK                       = 2
	SQLITE_SHM_NLOCK                      = 8
	SQLITE_SHM_SHARED                     = 4
	SQLITE_SHM_UNLOCK                     = 1
	SQLITE_SOUNDEX                        = 1
	SQLITE_SOURCE_ID                      = "2021-06-18 18:36:39 5c9a6c06871cb9fe42814af9c039eb6da5427a6ec28f187af7ebfb62eafa66e5"
	SQLITE_STATUS_MALLOC_COUNT            = 9
	SQLITE_STATUS_MALLOC_SIZE             = 5
	SQLITE_STATUS_MEMORY_USED             = 0
	SQLITE_STATUS_PAGECACHE_OVERFLOW      = 2
	SQLITE_STATUS_PAGECACHE_SIZE          = 7
	SQLITE_STATUS_PAGECACHE_USED          = 1
	SQLITE_STATUS_PARSER_STACK            = 6
	SQLITE_STATUS_SCRATCH_OVERFLOW        = 4
	SQLITE_STATUS_SCRATCH_SIZE            = 8
	SQLITE_STATUS_SCRATCH_USED            = 3
	SQLITE_STDCALL                        = 0
	SQLITE_STMTSTATUS_AUTOINDEX           = 3
	SQLITE_STMTSTATUS_FULLSCAN_STEP       = 1
	SQLITE_STMTSTATUS_MEMUSED             = 99
	SQLITE_STMTSTATUS_REPREPARE           = 5
	SQLITE_STMTSTATUS_RUN                 = 6
	SQLITE_STMTSTATUS_SORT                = 2
	SQLITE_STMTSTATUS_VM_STEP             = 4
	SQLITE_SUBTYPE                        = 0x000100000
	SQLITE_SYNC_DATAONLY                  = 0x00010
	SQLITE_SYNC_FULL                      = 0x00003
	SQLITE_SYNC_NORMAL                    = 0x00002
	SQLITE_SYSAPI                         = 0
	SQLITE_TEMP_STORE                     = 1
	SQLITE_TEST                           = 1
	SQLITE_TESTCTRL_ALWAYS                = 13
	SQLITE_TESTCTRL_ASSERT                = 12
	SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS   = 10
	SQLITE_TESTCTRL_BITVEC_TEST           = 8
	SQLITE_TESTCTRL_BYTEORDER             = 22
	SQLITE_TESTCTRL_EXPLAIN_STMT          = 19
	SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS   = 29
	SQLITE_TESTCTRL_FAULT_INSTALL         = 9
	SQLITE_TESTCTRL_FIRST                 = 5
	SQLITE_TESTCTRL_IMPOSTER              = 25
	SQLITE_TESTCTRL_INTERNAL_FUNCTIONS    = 17
	SQLITE_TESTCTRL_ISINIT                = 23
	SQLITE_TESTCTRL_ISKEYWORD             = 16
	SQLITE_TESTCTRL_LAST                  = 32
	SQLITE_TESTCTRL_LOCALTIME_FAULT       = 18
	SQLITE_TESTCTRL_NEVER_CORRUPT         = 20
	SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD  = 19
	SQLITE_TESTCTRL_OPTIMIZATIONS         = 15
	SQLITE_TESTCTRL_PARSER_COVERAGE       = 26
	SQLITE_TESTCTRL_PENDING_BYTE          = 11
	SQLITE_TESTCTRL_PRNG_RESET            = 7
	SQLITE_TESTCTRL_PRNG_RESTORE          = 6
	SQLITE_TESTCTRL_PRNG_SAVE             = 5
	SQLITE_TESTCTRL_PRNG_SEED             = 28
	SQLITE_TESTCTRL_RESERVE               = 14
	SQLITE_TESTCTRL_RESULT_INTREAL        = 27
	SQLITE_TESTCTRL_SCRATCHMALLOC         = 17
	SQLITE_TESTCTRL_SEEK_COUNT            = 30
	SQLITE_TESTCTRL_SORTER_MMAP           = 24
	SQLITE_TESTCTRL_TRACEFLAGS            = 31
	SQLITE_TESTCTRL_TUNE                  = 32
	SQLITE_TESTCTRL_VDBE_COVERAGE         = 21
	SQLITE_TEXT                           = 3
	SQLITE_THREADSAFE                     = 1
	SQLITE_TOOBIG                         = 18
	SQLITE_TRACE_CLOSE                    = 0x08
	SQLITE_TRACE_PROFILE                  = 0x02
	SQLITE_TRACE_ROW                      = 0x04
	SQLITE_TRACE_STMT                     = 0x01
	SQLITE_TRANSACTION                    = 22
	SQLITE_TXN_NONE                       = 0
	SQLITE_TXN_READ                       = 1
	SQLITE_TXN_WRITE                      = 2
	SQLITE_UPDATE                         = 23
	SQLITE_UTF16                          = 4
	SQLITE_UTF16BE                        = 3
	SQLITE_UTF16LE                        = 2
	SQLITE_UTF16_ALIGNED                  = 8
	SQLITE_UTF8                           = 1
	SQLITE_VERSION                        = "3.36.0"
	SQLITE_VERSION_NUMBER                 = 3036000
	SQLITE_VTAB_CONSTRAINT_SUPPORT        = 1
	SQLITE_VTAB_DIRECTONLY                = 3
	SQLITE_VTAB_INNOCUOUS                 = 2
	SQLITE_WARNING                        = 28
	SQLITE_WARNING_AUTOINDEX              = 284
	SQLITE_WIN32_DATA_DIRECTORY_TYPE      = 1
	SQLITE_WIN32_TEMP_DIRECTORY_TYPE      = 2
	TMP_MAX                               = 238328
	UNIQUE_TABLE_NAME                     = "t592690916721053953805701627921227776"
	X_ANSI_STDARG_H_                      = 0
	X_ASSERT_H                            = 1
	X_ATFILE_SOURCE                       = 1
	X_BITS_STDIO_LIM_H                    = 1
	X_BITS_TYPESIZES_H                    = 1
	X_BITS_TYPES_H                        = 1
	X_BITS_TYPES_LOCALE_T_H               = 1
	X_BITS_TYPES___LOCALE_T_H             = 1
	X_BSD_SIZE_T_                         = 0
	X_BSD_SIZE_T_DEFINED_                 = 0
	X_DEFAULT_SOURCE                      = 1
	X_FEATURES_H                          = 1
	X_FILE_OFFSET_BITS                    = 64
	X_FTS5_H                              = 0
	X_GCC_SIZE_T                          = 0
	X_HAVE_SQLITE_CONFIG_H                = 1
	X_IOFBF                               = 0
	X_IOLBF                               = 1
	X_IONBF                               = 2
	X_IO_EOF_SEEN                         = 0x0010
	X_IO_ERR_SEEN                         = 0x0020
	X_IO_USER_LOCK                        = 0x8000
	X_POSIX_C_SOURCE                      = 200809
	X_POSIX_SOURCE                        = 1
	X_SIZET_                              = 0
	X_SIZE_T                              = 0
	X_SIZE_T_                             = 0
	X_SIZE_T_DECLARED                     = 0
	X_SIZE_T_DEFINED                      = 0
	X_SIZE_T_DEFINED_                     = 0
	X_SQLITE3RTREE_H_                     = 0
	X_STDARG_H                            = 0
	X_STDC_PREDEF_H                       = 1
	X_STDIO_H                             = 1
	X_STRINGS_H                           = 1
	X_STRING_H                            = 1
	X_SYS_CDEFS_H                         = 1
	X_SYS_SIZE_T_H                        = 0
	X_T_SIZE                              = 0
	X_T_SIZE_                             = 0
	X_VA_LIST                             = 0
	X_VA_LIST_                            = 0
	X_VA_LIST_DEFINED                     = 0
	X_VA_LIST_T_H                         = 0
	Linux                                 = 1
	Unix                                  = 1
	CRTIMPORT                             = 0
	DLLIMPORT                             = 0
	INLINE                                = 0
	MP_DIGIT_DECLARED                     = 0
	MP_INT_DECLARED                       = 0
	NUM_STATIC_TOKENS                     = 20
	SQLITE_TCLAPI                         = 0
	TCL_ALLOW_INLINE_COMPILATION          = 0x20000
	TCL_ALL_EVENTS                        = -3
	TCL_ALPHA_RELEASE                     = 0
	TCL_APPEND_VALUE                      = 4
	TCL_ARGV_CONSTANT                     = 15
	TCL_ARGV_END                          = 23
	TCL_ARGV_FLOAT                        = 19
	TCL_ARGV_FUNC                         = 20
	TCL_ARGV_GENFUNC                      = 21
	TCL_ARGV_HELP                         = 22
	TCL_ARGV_INT                          = 16
	TCL_ARGV_REST                         = 18
	TCL_ARGV_STRING                       = 17
	TCL_BETA_RELEASE                      = 1
	TCL_BREAK                             = 3
	TCL_CANCEL_UNWIND                     = 0x100000
	TCL_CHANNEL_THREAD_INSERT             = 0
	TCL_CHANNEL_THREAD_REMOVE             = 1
	TCL_CLOSE_READ                        = 2
	TCL_CLOSE_WRITE                       = 4
	TCL_CONTINUE                          = 4
	TCL_CONVERT_MULTIBYTE                 = -1
	TCL_CONVERT_NOSPACE                   = -4
	TCL_CONVERT_SYNTAX                    = -2
	TCL_CONVERT_UNKNOWN                   = -3
	TCL_CREATE_HARD_LINK                  = 0x02
	TCL_CREATE_SYMBOLIC_LINK              = 0x01
	TCL_CUSTOM_PTR_KEYS                   = -1
	TCL_CUSTOM_TYPE_KEYS                  = -2
	TCL_DONT_QUOTE_HASH                   = 8
	TCL_DONT_USE_BRACES                   = 1
	TCL_DONT_WAIT                         = 2
	TCL_DOUBLE_SPACE                      = 27
	TCL_DSTRING_STATIC_SIZE               = 200
	TCL_ENCODING_CHAR_LIMIT               = 0x10
	TCL_ENCODING_END                      = 0x02
	TCL_ENCODING_NO_TERMINATE             = 0x08
	TCL_ENCODING_START                    = 0x01
	TCL_ENCODING_STOPONERROR              = 0x04
	TCL_ENFORCE_MODE                      = 16
	TCL_ENSEMBLE_PREFIX                   = 0x02
	TCL_ERROR                             = 1
	TCL_EVAL_DIRECT                       = 0x040000
	TCL_EVAL_GLOBAL                       = 0x020000
	TCL_EVAL_INVOKE                       = 0x080000
	TCL_EVAL_NOERR                        = 0x200000
	TCL_EXACT                             = 1
	TCL_EXCEPTION                         = 8
	TCL_FILE_EVENTS                       = 8
	TCL_FINAL_RELEASE                     = 2
	TCL_GLOBAL_ONLY                       = 1
	TCL_GLOB_PERM_HIDDEN                  = 2
	TCL_GLOB_PERM_R                       = 4
	TCL_GLOB_PERM_RONLY                   = 1
	TCL_GLOB_PERM_W                       = 8
	TCL_GLOB_PERM_X                       = 16
	TCL_GLOB_TYPE_BLOCK                   = 1
	TCL_GLOB_TYPE_CHAR                    = 2
	TCL_GLOB_TYPE_DIR                     = 4
	TCL_GLOB_TYPE_FILE                    = 16
	TCL_GLOB_TYPE_LINK                    = 32
	TCL_GLOB_TYPE_MOUNT                   = 128
	TCL_GLOB_TYPE_PIPE                    = 8
	TCL_GLOB_TYPE_SOCK                    = 64
	TCL_HASH_KEY_RANDOMIZE_HASH           = 0x1
	TCL_HASH_KEY_STORE_HASH               = 1
	TCL_HASH_KEY_SYSTEM_HASH              = 0x2
	TCL_HASH_KEY_TYPE_VERSION             = 1
	TCL_IDLE_EVENTS                       = 32
	TCL_INTEGER_SPACE                     = 24
	TCL_INTERP_DESTROYED                  = 0x100
	TCL_LEAVE_ERR_MSG                     = 0x200
	TCL_LIMIT_COMMANDS                    = 0x01
	TCL_LIMIT_TIME                        = 0x02
	TCL_LINK_BOOLEAN                      = 3
	TCL_LINK_CHAR                         = 6
	TCL_LINK_DOUBLE                       = 2
	TCL_LINK_FLOAT                        = 13
	TCL_LINK_INT                          = 1
	TCL_LINK_LONG                         = 11
	TCL_LINK_READ_ONLY                    = 0x80
	TCL_LINK_SHORT                        = 8
	TCL_LINK_STRING                       = 4
	TCL_LINK_UCHAR                        = 7
	TCL_LINK_UINT                         = 10
	TCL_LINK_ULONG                        = 12
	TCL_LINK_USHORT                       = 9
	TCL_LINK_WIDE_INT                     = 5
	TCL_LINK_WIDE_UINT                    = 14
	TCL_LIST_ELEMENT                      = 8
	TCL_LL_MODIFIER                       = "ll"
	TCL_LOAD_GLOBAL                       = 1
	TCL_LOAD_LAZY                         = 2
	TCL_MAJOR_VERSION                     = 8
	TCL_MATCH_NOCASE                      = 1
	TCL_MAX_PREC                          = 17
	TCL_MINOR_VERSION                     = 6
	TCL_MODE_BLOCKING                     = 0
	TCL_MODE_NONBLOCKING                  = 1
	TCL_NAMESPACE_ONLY                    = 2
	TCL_NORETURN1                         = 0
	TCL_NO_EVAL                           = 0x010000
	TCL_OK                                = 0
	TCL_ONE_WORD_KEYS                     = 1
	TCL_PARSE_BAD_NUMBER                  = 9
	TCL_PARSE_BRACE_EXTRA                 = 2
	TCL_PARSE_MISSING_BRACE               = 3
	TCL_PARSE_MISSING_BRACKET             = 4
	TCL_PARSE_MISSING_PAREN               = 5
	TCL_PARSE_MISSING_QUOTE               = 6
	TCL_PARSE_MISSING_VAR_BRACE           = 7
	TCL_PARSE_PART1                       = 0x400
	TCL_PARSE_QUOTE_EXTRA                 = 1
	TCL_PARSE_SUCCESS                     = 0
	TCL_PARSE_SYNTAX                      = 8
	TCL_PATCH_LEVEL                       = "8.6.9"
	TCL_READABLE                          = 2
	TCL_REG_ADVANCED                      = 000003
	TCL_REG_ADVF                          = 000002
	TCL_REG_BASIC                         = 000000
	TCL_REG_CANMATCH                      = 001000
	TCL_REG_EXPANDED                      = 000040
	TCL_REG_EXTENDED                      = 000001
	TCL_REG_NEWLINE                       = 000300
	TCL_REG_NLANCH                        = 000200
	TCL_REG_NLSTOP                        = 000100
	TCL_REG_NOCASE                        = 000010
	TCL_REG_NOSUB                         = 000020
	TCL_REG_NOTBOL                        = 0001
	TCL_REG_NOTEOL                        = 0002
	TCL_REG_QUOTE                         = 000004
	TCL_RELEASE_LEVEL                     = 2
	TCL_RELEASE_SERIAL                    = 9
	TCL_RESULT_SIZE                       = 200
	TCL_RETURN                            = 2
	TCL_SERVICE_ALL                       = 1
	TCL_SERVICE_NONE                      = 0
	TCL_SMALL_HASH_TABLE                  = 4
	TCL_STDERR                            = 8
	TCL_STDIN                             = 2
	TCL_STDOUT                            = 4
	TCL_STORAGE_CLASS                     = 0
	TCL_STRING_KEYS                       = 0
	TCL_SUBST_ALL                         = 007
	TCL_SUBST_BACKSLASHES                 = 004
	TCL_SUBST_COMMANDS                    = 001
	TCL_SUBST_VARIABLES                   = 002
	TCL_THREAD_CREATE_RETURN              = 0
	TCL_THREAD_JOINABLE                   = 1
	TCL_THREAD_NOFLAGS                    = 0
	TCL_THREAD_STACK_DEFAULT              = 0
	TCL_TIMER_EVENTS                      = 16
	TCL_TOKEN_BS                          = 8
	TCL_TOKEN_COMMAND                     = 16
	TCL_TOKEN_EXPAND_WORD                 = 256
	TCL_TOKEN_OPERATOR                    = 128
	TCL_TOKEN_SIMPLE_WORD                 = 2
	TCL_TOKEN_SUB_EXPR                    = 64
	TCL_TOKEN_TEXT                        = 4
	TCL_TOKEN_VARIABLE                    = 32
	TCL_TOKEN_WORD                        = 1
	TCL_TRACE_ARRAY                       = 0x800
	TCL_TRACE_DELETE                      = 0x4000
	TCL_TRACE_DESTROYED                   = 0x80
	TCL_TRACE_OLD_STYLE                   = 0x1000
	TCL_TRACE_READS                       = 0x10
	TCL_TRACE_RENAME                      = 0x2000
	TCL_TRACE_RESULT_DYNAMIC              = 0x8000
	TCL_TRACE_RESULT_OBJECT               = 0x10000
	TCL_TRACE_UNSETS                      = 0x40
	TCL_TRACE_WRITES                      = 0x20
	TCL_UNLOAD_DETACH_FROM_INTERPRETER    = 1
	TCL_UNLOAD_DETACH_FROM_PROCESS        = 2
	TCL_UTF_MAX                           = 3
	TCL_VERSION                           = "8.6"
	TCL_WINDOW_EVENTS                     = 4
	TCL_WRITABLE                          = 4
	TCL_ZLIB_COMPRESS_BEST                = 9
	TCL_ZLIB_COMPRESS_DEFAULT             = -1
	TCL_ZLIB_COMPRESS_FAST                = 1
	TCL_ZLIB_COMPRESS_NONE                = 0
	TCL_ZLIB_FINALIZE                     = 4
	TCL_ZLIB_FLUSH                        = 2
	TCL_ZLIB_FORMAT_AUTO                  = 8
	TCL_ZLIB_FORMAT_GZIP                  = 4
	TCL_ZLIB_FORMAT_RAW                   = 1
	TCL_ZLIB_FORMAT_ZLIB                  = 2
	TCL_ZLIB_FULLFLUSH                    = 3
	TCL_ZLIB_NO_FLUSH                     = 0
	TCL_ZLIB_STREAM_DEFLATE               = 16
	TCL_ZLIB_STREAM_INFLATE               = 32
	X_CLIENTDATA                          = 0
	X_TCL                                 = 0
	X_TCLDECLS                            = 0
	X_TCLPLATDECLS                        = 0
	X_FTSINT_H                            = 0
	FTS3_TOK_SCHEMA                       = "CREATE TABLE x(input HIDDEN, token, start, end, position)"
	APND_MARK_FOS_SZ                      = 8
	APND_MARK_PREFIX                      = "Start-Of-SQLite3-"
	APND_MARK_PREFIX_SZ                   = 17
	APND_MARK_SIZE                        = 25
	APND_MAX_SIZE                         = 1073741824
	APND_ROUNDUP                          = 4096
	SQLITE3EXT_H                          = 0
	SQLITE_EXTENSION_INIT1                = 0
	SQLITE_EXTENSION_INIT3                = 0
	AMATCH_COL_COMMAND                    = 3
	AMATCH_COL_DISTANCE                   = 1
	AMATCH_COL_LANGUAGE                   = 2
	AMATCH_COL_NWORD                      = 4
	AMATCH_COL_WORD                       = 0
	AMATCH_MX_COST                        = 1000
	AMATCH_MX_LANGID                      = 2147483647
	AMATCH_MX_LENGTH                      = 50
	BIG_ENDIAN                            = 4321
	BYTE_ORDER                            = 1234
	EXIT_FAILURE                          = 1
	EXIT_SUCCESS                          = 0
	FD_SETSIZE                            = 1024
	LITTLE_ENDIAN                         = 1234
	PDP_ENDIAN                            = 3412
	RAND_MAX                              = 2147483647
	WCONTINUED                            = 8
	WEXITED                               = 4
	WNOHANG                               = 1
	WNOWAIT                               = 0x01000000
	WSTOPPED                              = 2
	WUNTRACED                             = 2
	X_ALLOCA_H                            = 1
	X_BITS_BYTESWAP_H                     = 1
	X_BITS_FLOATN_COMMON_H                = 0
	X_BITS_PTHREADTYPES_ARCH_H            = 1
	X_BITS_PTHREADTYPES_COMMON_H          = 1
	X_BITS_STDINT_INTN_H                  = 1
	X_BITS_UINTN_IDENTITY_H               = 1
	X_CTYPE_H                             = 1
	X_ENDIAN_H                            = 1
	X_GCC_WCHAR_T                         = 0
	X_STDLIB_H                            = 1
	X_STRUCT_TIMESPEC                     = 1
	X_SYS_SELECT_H                        = 1
	X_SYS_TYPES_H                         = 1
	X_THREAD_SHARED_TYPES_H               = 1
	X_T_WCHAR                             = 0
	X_T_WCHAR_                            = 0
	X_WCHAR_T                             = 0
	X_WCHAR_T_                            = 0
	X_WCHAR_T_DECLARED                    = 0
	X_WCHAR_T_DEFINED                     = 0
	X_WCHAR_T_DEFINED_                    = 0
	X_WCHAR_T_H                           = 0
	CARRAY_COLUMN_COUNT                   = 2
	CARRAY_COLUMN_CTYPE                   = 3
	CARRAY_COLUMN_POINTER                 = 1
	CARRAY_COLUMN_VALUE                   = 0
	CARRAY_DOUBLE                         = 2
	CARRAY_INT32                          = 0
	CARRAY_INT64                          = 1
	CARRAY_TEXT                           = 3
	CLOSURE_COL_DEPTH                     = 1
	CLOSURE_COL_ID                        = 0
	CLOSURE_COL_IDCOLUMN                  = 4
	CLOSURE_COL_PARENTCOLUMN              = 5
	CLOSURE_COL_ROOT                      = 2
	CLOSURE_COL_TABLENAME                 = 3
	CSVTEST_FIDX                          = 0x0001
	CSV_INBUFSZ                           = 1024
	CSV_MXERR                             = 200
	EXPLN_COLUMN_ADDR                     = 0
	EXPLN_COLUMN_COMMENT                  = 7
	EXPLN_COLUMN_OPCODE                   = 1
	EXPLN_COLUMN_P1                       = 2
	EXPLN_COLUMN_P2                       = 3
	EXPLN_COLUMN_P3                       = 4
	EXPLN_COLUMN_P4                       = 5
	EXPLN_COLUMN_P5                       = 6
	EXPLN_COLUMN_SQL                      = 8
	ACCESSPERMS                           = 511
	AIO_PRIO_DELTA_MAX                    = 20
	ALLPERMS                              = 4095
	AT_EACCESS                            = 0x200
	AT_FDCWD                              = -100
	AT_REMOVEDIR                          = 0x200
	AT_SYMLINK_FOLLOW                     = 0x400
	AT_SYMLINK_NOFOLLOW                   = 0x100
	CLOCK_BOOTTIME                        = 7
	CLOCK_BOOTTIME_ALARM                  = 9
	CLOCK_MONOTONIC                       = 1
	CLOCK_MONOTONIC_COARSE                = 6
	CLOCK_MONOTONIC_RAW                   = 4
	CLOCK_PROCESS_CPUTIME_ID              = 2
	CLOCK_REALTIME                        = 0
	CLOCK_REALTIME_ALARM                  = 8
	CLOCK_REALTIME_COARSE                 = 5
	CLOCK_TAI                             = 11
	CLOCK_THREAD_CPUTIME_ID               = 3
	DEFFILEMODE                           = 438
	DELAYTIMER_MAX                        = 2147483647
	E2BIG                                 = 7
	EACCES                                = 13
	EADDRINUSE                            = 98
	EADDRNOTAVAIL                         = 99
	EADV                                  = 68
	EAFNOSUPPORT                          = 97
	EAGAIN                                = 11
	EALREADY                              = 114
	EBADE                                 = 52
	EBADF                                 = 9
	EBADFD                                = 77
	EBADMSG                               = 74
	EBADR                                 = 53
	EBADRQC                               = 56
	EBADSLT                               = 57
	EBFONT                                = 59
	EBUSY                                 = 16
	ECANCELED                             = 125
	ECHILD                                = 10
	ECHRNG                                = 44
	ECOMM                                 = 70
	ECONNABORTED                          = 103
	ECONNREFUSED                          = 111
	ECONNRESET                            = 104
	EDEADLK                               = 35
	EDEADLOCK                             = 35
	EDESTADDRREQ                          = 89
	EDOM                                  = 33
	EDOTDOT                               = 73
	EDQUOT                                = 122
	EEXIST                                = 17
	EFAULT                                = 14
	EFBIG                                 = 27
	EHOSTDOWN                             = 112
	EHOSTUNREACH                          = 113
	EHWPOISON                             = 133
	EIDRM                                 = 43
	EILSEQ                                = 84
	EINPROGRESS                           = 115
	EINTR                                 = 4
	EINVAL                                = 22
	EIO                                   = 5
	EISCONN                               = 106
	EISDIR                                = 21
	EISNAM                                = 120
	EKEYEXPIRED                           = 127
	EKEYREJECTED                          = 129
	EKEYREVOKED                           = 128
	EL2HLT                                = 51
	EL2NSYNC                              = 45
	EL3HLT                                = 46
	EL3RST                                = 47
	ELIBACC                               = 79
	ELIBBAD                               = 80
	ELIBEXEC                              = 83
	ELIBMAX                               = 82
	ELIBSCN                               = 81
	ELNRNG                                = 48
	ELOOP                                 = 40
	EMEDIUMTYPE                           = 124
	EMFILE                                = 24
	EMLINK                                = 31
	EMSGSIZE                              = 90
	EMULTIHOP                             = 72
	ENAMETOOLONG                          = 36
	ENAVAIL                               = 119
	ENETDOWN                              = 100
	ENETRESET                             = 102
	ENETUNREACH                           = 101
	ENFILE                                = 23
	ENOANO                                = 55
	ENOBUFS                               = 105
	ENOCSI                                = 50
	ENODATA                               = 61
	ENODEV                                = 19
	ENOENT                                = 2
	ENOEXEC                               = 8
	ENOKEY                                = 126
	ENOLCK                                = 37
	ENOLINK                               = 67
	ENOMEDIUM                             = 123
	ENOMEM                                = 12
	ENOMSG                                = 42
	ENONET                                = 64
	ENOPKG                                = 65
	ENOPROTOOPT                           = 92
	ENOSPC                                = 28
	ENOSR                                 = 63
	ENOSTR                                = 60
	ENOSYS                                = 38
	ENOTBLK                               = 15
	ENOTCONN                              = 107
	ENOTDIR                               = 20
	ENOTEMPTY                             = 39
	ENOTNAM                               = 118
	ENOTRECOVERABLE                       = 131
	ENOTSOCK                              = 88
	ENOTSUP                               = 95
	ENOTTY                                = 25
	ENOTUNIQ                              = 76
	ENXIO                                 = 6
	EOPNOTSUPP                            = 95
	EOVERFLOW                             = 75
	EOWNERDEAD                            = 130
	EPERM                                 = 1
	EPFNOSUPPORT                          = 96
	EPIPE                                 = 32
	EPROTO                                = 71
	EPROTONOSUPPORT                       = 93
	EPROTOTYPE                            = 91
	ERANGE                                = 34
	EREMCHG                               = 78
	EREMOTE                               = 66
	EREMOTEIO                             = 121
	ERESTART                              = 85
	ERFKILL                               = 132
	EROFS                                 = 30
	ESHUTDOWN                             = 108
	ESOCKTNOSUPPORT                       = 94
	ESPIPE                                = 29
	ESRCH                                 = 3
	ESRMNT                                = 69
	ESTALE                                = 116
	ESTRPIPE                              = 86
	ETIME                                 = 62
	ETIMEDOUT                             = 110
	ETOOMANYREFS                          = 109
	ETXTBSY                               = 26
	EUCLEAN                               = 117
	EUNATCH                               = 49
	EUSERS                                = 87
	EWOULDBLOCK                           = 11
	EXDEV                                 = 18
	EXFULL                                = 54
	FAPPEND                               = 1024
	FASYNC                                = 8192
	FD_CLOEXEC                            = 1
	FFSYNC                                = 1052672
	FNDELAY                               = 2048
	FNONBLOCK                             = 2048
	FSDIR_COLUMN_DATA                     = 3
	FSDIR_COLUMN_DIR                      = 5
	FSDIR_COLUMN_MODE                     = 1
	FSDIR_COLUMN_MTIME                    = 2
	FSDIR_COLUMN_NAME                     = 0
	FSDIR_COLUMN_PATH                     = 4
	FSDIR_SCHEMA                          = "(name,mode,mtime,data,path HIDDEN,dir HIDDEN)"
	F_DUPFD                               = 0
	F_DUPFD_CLOEXEC                       = 1030
	F_EXLCK                               = 4
	F_GETFD                               = 1
	F_GETFL                               = 3
	F_GETLK                               = 12
	F_GETLK64                             = 12
	F_GETOWN                              = 9
	F_LOCK                                = 1
	F_OK                                  = 0
	F_RDLCK                               = 0
	F_SETFD                               = 2
	F_SETFL                               = 4
	F_SETLK                               = 13
	F_SETLK64                             = 13
	F_SETLKW                              = 14
	F_SETLKW64                            = 14
	F_SETOWN                              = 8
	F_SHLCK                               = 8
	F_TEST                                = 3
	F_TLOCK                               = 2
	F_ULOCK                               = 0
	F_UNLCK                               = 2
	F_WRLCK                               = 1
	HOST_NAME_MAX                         = 64
	LOCK_EX                               = 2
	LOCK_NB                               = 4
	LOCK_SH                               = 1
	LOCK_UN                               = 8
	LOGIN_NAME_MAX                        = 256
	L_INCR                                = 1
	L_SET                                 = 0
	L_XTND                                = 2
	MAXNAMLEN                             = 255
	MAX_CANON                             = 255
	MAX_INPUT                             = 255
	MQ_PRIO_MAX                           = 32768
	NAME_MAX                              = 255
	NGROUPS_MAX                           = 65536
	O_ACCMODE                             = 0003
	O_APPEND                              = 02000
	O_ASYNC                               = 020000
	O_CLOEXEC                             = 524288
	O_CREAT                               = 0100
	O_DIRECTORY                           = 16384
	O_DSYNC                               = 4096
	O_EXCL                                = 0200
	O_FSYNC                               = 1052672
	O_NDELAY                              = 2048
	O_NOCTTY                              = 0400
	O_NOFOLLOW                            = 32768
	O_NONBLOCK                            = 04000
	O_RDONLY                              = 00
	O_RDWR                                = 02
	O_RSYNC                               = 1052672
	O_SYNC                                = 04010000
	O_TRUNC                               = 01000
	O_WRONLY                              = 01
	PATH_MAX                              = 4096
	PIPE_BUF                              = 4096
	POSIX_FADV_DONTNEED                   = 4
	POSIX_FADV_NOREUSE                    = 5
	POSIX_FADV_NORMAL                     = 0
	POSIX_FADV_RANDOM                     = 1
	POSIX_FADV_SEQUENTIAL                 = 2
	POSIX_FADV_WILLNEED                   = 3
	PTHREAD_DESTRUCTOR_ITERATIONS         = 4
	PTHREAD_KEYS_MAX                      = 1024
	PTHREAD_STACK_MIN                     = 16384
	RTSIG_MAX                             = 32
	R_OK                                  = 4
	SEM_VALUE_MAX                         = 2147483647
	STDERR_FILENO                         = 2
	STDIN_FILENO                          = 0
	STDOUT_FILENO                         = 1
	S_BLKSIZE                             = 512
	S_IEXEC                               = 64
	S_IFBLK                               = 24576
	S_IFCHR                               = 8192
	S_IFDIR                               = 16384
	S_IFIFO                               = 4096
	S_IFLNK                               = 40960
	S_IFMT                                = 61440
	S_IFREG                               = 32768
	S_IFSOCK                              = 49152
	S_IREAD                               = 256
	S_IRGRP                               = 32
	S_IROTH                               = 4
	S_IRUSR                               = 256
	S_IRWXG                               = 56
	S_IRWXO                               = 7
	S_IRWXU                               = 448
	S_ISGID                               = 1024
	S_ISUID                               = 2048
	S_ISVTX                               = 512
	S_IWGRP                               = 16
	S_IWOTH                               = 2
	S_IWRITE                              = 128
	S_IWUSR                               = 128
	S_IXGRP                               = 8
	S_IXOTH                               = 1
	S_IXUSR                               = 64
	TIMER_ABSTIME                         = 1
	TIME_UTC                              = 1
	TTY_NAME_MAX                          = 32
	UTIME_NOW                             = 1073741823
	UTIME_OMIT                            = 1073741822
	W_OK                                  = 2
	XATTR_LIST_MAX                        = 65536
	XATTR_NAME_MAX                        = 255
	XATTR_SIZE_MAX                        = 65536
	X_OK                                  = 1
	X_ASM_GENERIC_ERRNO_BASE_H            = 0
	X_ASM_GENERIC_ERRNO_H                 = 0
	X_BITS_ERRNO_H                        = 1
	X_BITS_POSIX1_LIM_H                   = 1
	X_BITS_POSIX_OPT_H                    = 1
	X_BITS_STAT_H                         = 1
	X_BITS_TIME_H                         = 1
	X_DIRENT_H                            = 1
	X_DIRENT_HAVE_D_OFF                   = 0
	X_DIRENT_HAVE_D_RECLEN                = 0
	X_DIRENT_HAVE_D_TYPE                  = 0
	X_DIRENT_MATCHES_DIRENT64             = 0
	X_ERRNO_H                             = 1
	X_FCNTL_H                             = 1
	X_GETOPT_CORE_H                       = 1
	X_GETOPT_POSIX_H                      = 1
	X_LFS64_ASYNCHRONOUS_IO               = 1
	X_LFS64_LARGEFILE                     = 1
	X_LFS64_STDIO                         = 1
	X_LFS_ASYNCHRONOUS_IO                 = 1
	X_LFS_LARGEFILE                       = 1
	X_LINUX_LIMITS_H                      = 0
	X_MKNOD_VER                           = 1
	X_MKNOD_VER_LINUX                     = 1
	X_MKNOD_VER_SVR4                      = 2
	X_POSIX2_CHAR_TERM                    = 200809
	X_POSIX2_C_BIND                       = 200809
	X_POSIX2_C_DEV                        = 200809
	X_POSIX2_C_VERSION                    = 200809
	X_POSIX2_LOCALEDEF                    = 200809
	X_POSIX2_SW_DEV                       = 200809
	X_POSIX2_VERSION                      = 200809
	X_POSIX_ADVISORY_INFO                 = 200809
	X_POSIX_AIO_LISTIO_MAX                = 2
	X_POSIX_AIO_MAX                       = 1
	X_POSIX_ARG_MAX                       = 4096
	X_POSIX_ASYNCHRONOUS_IO               = 200809
	X_POSIX_ASYNC_IO                      = 1
	X_POSIX_BARRIERS                      = 200809
	X_POSIX_CHILD_MAX                     = 25
	X_POSIX_CHOWN_RESTRICTED              = 0
	X_POSIX_CLOCKRES_MIN                  = 20000000
	X_POSIX_CLOCK_SELECTION               = 200809
	X_POSIX_CPUTIME                       = 0
	X_POSIX_DELAYTIMER_MAX                = 32
	X_POSIX_FSYNC                         = 200809
	X_POSIX_HOST_NAME_MAX                 = 255
	X_POSIX_IPV6                          = 200809
	X_POSIX_JOB_CONTROL                   = 1
	X_POSIX_LINK_MAX                      = 8
	X_POSIX_LOGIN_NAME_MAX                = 9
	X_POSIX_MAPPED_FILES                  = 200809
	X_POSIX_MAX_CANON                     = 255
	X_POSIX_MAX_INPUT                     = 255
	X_POSIX_MEMLOCK                       = 200809
	X_POSIX_MEMLOCK_RANGE                 = 200809
	X_POSIX_MEMORY_PROTECTION             = 200809
	X_POSIX_MESSAGE_PASSING               = 200809
	X_POSIX_MONOTONIC_CLOCK               = 0
	X_POSIX_MQ_OPEN_MAX                   = 8
	X_POSIX_MQ_PRIO_MAX                   = 32
	X_POSIX_NAME_MAX                      = 14
	X_POSIX_NGROUPS_MAX                   = 8
	X_POSIX_NO_TRUNC                      = 1
	X_POSIX_OPEN_MAX                      = 20
	X_POSIX_PATH_MAX                      = 256
	X_POSIX_PIPE_BUF                      = 512
	X_POSIX_PRIORITIZED_IO                = 200809
	X_POSIX_PRIORITY_SCHEDULING           = 200809
	X_POSIX_RAW_SOCKETS                   = 200809
	X_POSIX_READER_WRITER_LOCKS           = 200809
	X_POSIX_REALTIME_SIGNALS              = 200809
	X_POSIX_REENTRANT_FUNCTIONS           = 1
	X_POSIX_REGEXP                        = 1
	X_POSIX_RE_DUP_MAX                    = 255
	X_POSIX_RTSIG_MAX                     = 8
	X_POSIX_SAVED_IDS                     = 1
	X_POSIX_SEMAPHORES                    = 200809
	X_POSIX_SEM_NSEMS_MAX                 = 256
	X_POSIX_SEM_VALUE_MAX                 = 32767
	X_POSIX_SHARED_MEMORY_OBJECTS         = 200809
	X_POSIX_SHELL                         = 1
	X_POSIX_SIGQUEUE_MAX                  = 32
	X_POSIX_SPAWN                         = 200809
	X_POSIX_SPIN_LOCKS                    = 200809
	X_POSIX_SPORADIC_SERVER               = -1
	X_POSIX_SSIZE_MAX                     = 32767
	X_POSIX_STREAM_MAX                    = 8
	X_POSIX_SYMLINK_MAX                   = 255
	X_POSIX_SYMLOOP_MAX                   = 8
	X_POSIX_SYNCHRONIZED_IO               = 200809
	X_POSIX_THREADS                       = 200809
	X_POSIX_THREAD_ATTR_STACKADDR         = 200809
	X_POSIX_THREAD_ATTR_STACKSIZE         = 200809
	X_POSIX_THREAD_CPUTIME                = 0
	X_POSIX_THREAD_DESTRUCTOR_ITERATIONS  = 4
	X_POSIX_THREAD_KEYS_MAX               = 128
	X_POSIX_THREAD_PRIORITY_SCHEDULING    = 200809
	X_POSIX_THREAD_PRIO_INHERIT           = 200809
	X_POSIX_THREAD_PRIO_PROTECT           = 200809
	X_POSIX_THREAD_PROCESS_SHARED         = 200809
	X_POSIX_THREAD_ROBUST_PRIO_INHERIT    = 200809
	X_POSIX_THREAD_ROBUST_PRIO_PROTECT    = -1
	X_POSIX_THREAD_SAFE_FUNCTIONS         = 200809
	X_POSIX_THREAD_SPORADIC_SERVER        = -1
	X_POSIX_THREAD_THREADS_MAX            = 64
	X_POSIX_TIMEOUTS                      = 200809
	X_POSIX_TIMERS                        = 200809
	X_POSIX_TIMER_MAX                     = 32
	X_POSIX_TRACE                         = -1
	X_POSIX_TRACE_EVENT_FILTER            = -1
	X_POSIX_TRACE_INHERIT                 = -1
	X_POSIX_TRACE_LOG                     = -1
	X_POSIX_TTY_NAME_MAX                  = 9
	X_POSIX_TYPED_MEMORY_OBJECTS          = -1
	X_POSIX_TZNAME_MAX                    = 6
	X_POSIX_V6_ILP32_OFF32                = 1
	X_POSIX_V6_ILP32_OFFBIG               = 1
	X_POSIX_V6_LP64_OFF64                 = -1
	X_POSIX_V6_LPBIG_OFFBIG               = -1
	X_POSIX_V7_ILP32_OFF32                = 1
	X_POSIX_V7_ILP32_OFFBIG               = 1
	X_POSIX_V7_LP64_OFF64                 = -1
	X_POSIX_V7_LPBIG_OFFBIG               = -1
	X_POSIX_VDISABLE                      = 0
	X_POSIX_VERSION                       = 200809
	X_STATBUF_ST_BLKSIZE                  = 0
	X_STATBUF_ST_NSEC                     = 0
	X_STATBUF_ST_RDEV                     = 0
	X_STAT_VER                            = 3
	X_STAT_VER_KERNEL                     = 1
	X_STAT_VER_LINUX                      = 3
	X_STAT_VER_LINUX_OLD                  = 1
	X_STAT_VER_SVR4                       = 2
	X_SYS_STAT_H                          = 1
	X_SYS_TIME_H                          = 1
	X_TIME_H                              = 1
	X_UNISTD_H                            = 1
	X_UTIME_H                             = 1
	X_XBS5_ILP32_OFF32                    = 1
	X_XBS5_ILP32_OFFBIG                   = 1
	X_XBS5_LP64_OFF64                     = -1
	X_XBS5_LPBIG_OFFBIG                   = -1
	X_XOPEN_ENH_I18N                      = 1
	X_XOPEN_LEGACY                        = 1
	X_XOPEN_REALTIME                      = 1
	X_XOPEN_REALTIME_THREADS              = 1
	X_XOPEN_SHM                           = 1
	X_XOPEN_UNIX                          = 1
	X_XOPEN_VERSION                       = 700
	X_XOPEN_XCU_VERSION                   = 4
	X_XOPEN_XPG2                          = 1
	X_XOPEN_XPG3                          = 1
	X_XOPEN_XPG4                          = 1
	FUZZER_HASH                           = 4001
	FUZZER_MX_COST                        = 1000
	FUZZER_MX_LENGTH                      = 50
	FUZZER_MX_OUTPUT_LENGTH               = 100
	FUZZER_MX_RULEID                      = 2147483647
	FUZZER_NQUEUE                         = 20
	CC_AND                                = 24
	CC_BANG                               = 15
	CC_COMMA                              = 23
	CC_DIGIT                              = 3
	CC_DOLLAR                             = 4
	CC_DOT                                = 26
	CC_EQ                                 = 14
	CC_GT                                 = 13
	CC_ID                                 = 2
	CC_ILLEGAL                            = 27
	CC_KYWD                               = 1
	CC_LP                                 = 17
	CC_LT                                 = 12
	CC_MINUS                              = 11
	CC_PERCENT                            = 22
	CC_PIPE                               = 10
	CC_PLUS                               = 20
	CC_QUOTE                              = 8
	CC_QUOTE2                             = 9
	CC_RP                                 = 18
	CC_SEMI                               = 19
	CC_SLASH                              = 16
	CC_SPACE                              = 7
	CC_STAR                               = 21
	CC_TILDA                              = 25
	CC_VARALPHA                           = 5
	CC_VARNUM                             = 6
	CC_X                                  = 0
	TK_BITAND                             = 3
	TK_BITNOT                             = 3
	TK_BITOR                              = 3
	TK_BLOB                               = 2
	TK_COMMA                              = 3
	TK_CONCAT                             = 3
	TK_DOT                                = 3
	TK_EQ                                 = 3
	TK_ERROR                              = 4
	TK_FLOAT                              = 2
	TK_GE                                 = 3
	TK_GT                                 = 3
	TK_ID                                 = 1
	TK_ILLEGAL                            = 4
	TK_INTEGER                            = 2
	TK_LE                                 = 3
	TK_LITERAL                            = 2
	TK_LP                                 = 3
	TK_LSHIFT                             = 3
	TK_LT                                 = 3
	TK_MINUS                              = 3
	TK_NAME                               = 1
	TK_NE                                 = 3
	TK_PLUS                               = 3
	TK_PUNCT                              = 3
	TK_REM                                = 3
	TK_RP                                 = 3
	TK_RSHIFT                             = 3
	TK_SEMI                               = 3
	TK_SLASH                              = 3
	TK_SPACE                              = 0
	TK_STAR                               = 3
	TK_STRING                             = 2
	TK_VARIABLE                           = 2
	Deliberate_fall_through               = 0
	RE_EOF                                = 0
	RE_OP_ACCEPT                          = 6
	RE_OP_ANY                             = 2
	RE_OP_ANYSTAR                         = 3
	RE_OP_BOUNDARY                        = 17
	RE_OP_CC_EXC                          = 8
	RE_OP_CC_INC                          = 7
	RE_OP_CC_RANGE                        = 10
	RE_OP_CC_VALUE                        = 9
	RE_OP_DIGIT                           = 13
	RE_OP_FORK                            = 4
	RE_OP_GOTO                            = 5
	RE_OP_MATCH                           = 1
	RE_OP_NOTDIGIT                        = 14
	RE_OP_NOTSPACE                        = 16
	RE_OP_NOTWORD                         = 12
	RE_OP_SPACE                           = 15
	RE_OP_WORD                            = 11
	SERIES_COLUMN_START                   = 1
	SERIES_COLUMN_STEP                    = 3
	SERIES_COLUMN_STOP                    = 2
	SERIES_COLUMN_VALUE                   = 0
	CCLASS_B                              = 2
	CCLASS_C                              = 3
	CCLASS_D                              = 4
	CCLASS_DIGIT                          = 10
	CCLASS_H                              = 5
	CCLASS_L                              = 6
	CCLASS_M                              = 8
	CCLASS_OTHER                          = 12
	CCLASS_R                              = 7
	CCLASS_SILENT                         = 0
	CCLASS_SPACE                          = 11
	CCLASS_VOWEL                          = 1
	CCLASS_Y                              = 9
	FINAL_INS_COST_DIV                    = 4
	SCRIPT_ARABIC                         = 0x0010
	SCRIPT_CYRILLIC                       = 0x0002
	SCRIPT_GREEK                          = 0x0004
	SCRIPT_HEBREW                         = 0x0008
	SCRIPT_LATIN                          = 0x0001
	SPELLFIX_COL_COMMAND                  = 11
	SPELLFIX_COL_DISTANCE                 = 2
	SPELLFIX_COL_LANGID                   = 3
	SPELLFIX_COL_MATCHLEN                 = 5
	SPELLFIX_COL_PHONEHASH                = 6
	SPELLFIX_COL_RANK                     = 1
	SPELLFIX_COL_SCOPE                    = 8
	SPELLFIX_COL_SCORE                    = 4
	SPELLFIX_COL_SOUNDSLIKE               = 10
	SPELLFIX_COL_SRCHCNT                  = 9
	SPELLFIX_COL_TOP                      = 7
	SPELLFIX_COL_WORD                     = 0
	SPELLFIX_IDXNUM_DIST                  = 48
	SPELLFIX_IDXNUM_DISTLE                = 0x20
	SPELLFIX_IDXNUM_DISTLT                = 0x10
	SPELLFIX_IDXNUM_LANGID                = 0x02
	SPELLFIX_IDXNUM_MATCH                 = 0x01
	SPELLFIX_IDXNUM_ROWID                 = 0x40
	SPELLFIX_IDXNUM_SCOPE                 = 0x08
	SPELLFIX_IDXNUM_TOP                   = 0x04
	SPELLFIX_MX_HASH                      = 32
	SPELLFIX_MX_RUN                       = 1
	SQLITE_SPELLFIX_STACKALLOC_SZ         = 1024
	SWARMVTAB_MAX_OPEN                    = 9
	BC_BASE_MAX                           = 99
	BC_DIM_MAX                            = 2048
	BC_SCALE_MAX                          = 99
	BC_STRING_MAX                         = 1000
	CHARCLASS_NAME_MAX                    = 2048
	CHAR_BIT                              = 8
	CHAR_MAX                              = 255
	CHAR_MIN                              = 0
	COLL_WEIGHTS_MAX                      = 255
	EXPR_NEST_MAX                         = 32
	FAR                                   = 0
	INT_MAX                               = 2147483647
	INT_MIN                               = -2147483648
	LINE_MAX                              = 2048
	LLONG_MAX                             = 9223372036854775807
	LLONG_MIN                             = -9223372036854775808
	LONG_MAX                              = 2147483647
	LONG_MIN                              = -2147483648
	MAX_MEM_LEVEL                         = 9
	MAX_WBITS                             = 15
	MB_LEN_MAX                            = 16
	RE_DUP_MAX                            = 32767
	SCHAR_MAX                             = 127
	SCHAR_MIN                             = -128
	SHRT_MAX                              = 32767
	SHRT_MIN                              = -32768
	STDC                                  = 0
	STDC99                                = 0
	UCHAR_MAX                             = 255
	UINT_MAX                              = 4294967295
	ULLONG_MAX                            = 18446744073709551615
	ULONG_MAX                             = 4294967295
	USHRT_MAX                             = 65535
	ZCONF_H                               = 0
	ZEXPORT                               = 0
	ZEXPORTVA                             = 0
	ZIPFILE_BUFFER_SIZE                   = 65536
	ZIPFILE_CDS_FIXED_SZ                  = 46
	ZIPFILE_CDS_NFILE_OFF                 = 28
	ZIPFILE_CDS_SZCOMPRESSED_OFF          = 20
	ZIPFILE_EOCD_FIXED_SZ                 = 22
	ZIPFILE_EXTRA_TIMESTAMP               = 0x5455
	ZIPFILE_F_COLUMN_IDX                  = 7
	ZIPFILE_LFH_FIXED_SZ                  = 30
	ZIPFILE_NEWENTRY_FLAGS                = 0x800
	ZIPFILE_NEWENTRY_MADEBY               = 798
	ZIPFILE_NEWENTRY_REQUIRED             = 20
	ZIPFILE_SIGNATURE_CDS                 = 0x02014b50
	ZIPFILE_SIGNATURE_EOCD                = 0x06054b50
	ZIPFILE_SIGNATURE_LFH                 = 0x04034b50
	ZLIB_H                                = 0
	ZLIB_VERNUM                           = 0x12b0
	ZLIB_VERSION                          = "1.2.11"
	ZLIB_VER_MAJOR                        = 1
	ZLIB_VER_MINOR                        = 2
	ZLIB_VER_REVISION                     = 11
	ZLIB_VER_SUBREVISION                  = 0
	Z_ASCII                               = 1
	Z_BEST_COMPRESSION                    = 9
	Z_BEST_SPEED                          = 1
	Z_BINARY                              = 0
	Z_BLOCK                               = 5
	Z_BUF_ERROR                           = -5
	Z_DATA_ERROR                          = -3
	Z_DEFAULT_COMPRESSION                 = -1
	Z_DEFAULT_STRATEGY                    = 0
	Z_DEFLATED                            = 8
	Z_ERRNO                               = -1
	Z_FILTERED                            = 1
	Z_FINISH                              = 4
	Z_FIXED                               = 4
	Z_FULL_FLUSH                          = 3
	Z_HAVE_STDARG_H                       = 0
	Z_HAVE_UNISTD_H                       = 0
	Z_HUFFMAN_ONLY                        = 2
	Z_LFS64                               = 0
	Z_MEM_ERROR                           = -4
	Z_NEED_DICT                           = 2
	Z_NO_COMPRESSION                      = 0
	Z_NO_FLUSH                            = 0
	Z_NULL                                = 0
	Z_OK                                  = 0
	Z_PARTIAL_FLUSH                       = 1
	Z_RLE                                 = 3
	Z_STREAM_END                          = 1
	Z_STREAM_ERROR                        = -2
	Z_SYNC_FLUSH                          = 2
	Z_TEXT                                = 1
	Z_TREES                               = 6
	Z_UNKNOWN                             = 2
	Z_VERSION_ERROR                       = -6
	Z_WANT64                              = 0
	X_ANSI_STDDEF_H                       = 0
	X_BITS_POSIX2_LIM_H                   = 1
	X_BSD_PTRDIFF_T_                      = 0
	X_GCC_LIMITS_H_                       = 0
	X_GCC_MAX_ALIGN_T                     = 0
	X_GCC_PTRDIFF_T                       = 0
	X_LIBC_LIMITS_H_                      = 1
	X_LIMITS_H___                         = 0
	X_POSIX2_BC_BASE_MAX                  = 99
	X_POSIX2_BC_DIM_MAX                   = 2048
	X_POSIX2_BC_SCALE_MAX                 = 99
	X_POSIX2_BC_STRING_MAX                = 1000
	X_POSIX2_CHARCLASS_NAME_MAX           = 14
	X_POSIX2_COLL_WEIGHTS_MAX             = 2
	X_POSIX2_EXPR_NEST_MAX                = 32
	X_POSIX2_LINE_MAX                     = 2048
	X_POSIX2_RE_DUP_MAX                   = 255
	X_PTRDIFF_T                           = 0
	X_PTRDIFF_T_                          = 0
	X_PTRDIFF_T_DECLARED                  = 0
	X_STDDEF_H                            = 0
	X_STDDEF_H_                           = 0
	X_T_PTRDIFF                           = 0
	X_T_PTRDIFF_                          = 0
	Z_const                               = 0
	SQLITE_RBU_STATE_CHECKPOINT           = 3
	SQLITE_RBU_STATE_DONE                 = 4
	SQLITE_RBU_STATE_ERROR                = 5
	SQLITE_RBU_STATE_MOVE                 = 2
	SQLITE_RBU_STATE_OAL                  = 1
	X_SQLITE3RBU_H                        = 0
	MAX_PREPARED_STMTS                    = 100
	MINSIGSTKSZ                           = 2048
	NGREG                                 = 18
	NSIG                                  = 65
	NUM_PREPARED_STMTS                    = 10
	SA_INTERRUPT                          = 0x20000000
	SA_NOCLDSTOP                          = 1
	SA_NOCLDWAIT                          = 2
	SA_NODEFER                            = 0x40000000
	SA_NOMASK                             = 1073741824
	SA_ONESHOT                            = 2147483648
	SA_ONSTACK                            = 0x08000000
	SA_RESETHAND                          = 0x80000000
	SA_RESTART                            = 0x10000000
	SA_SIGINFO                            = 4
	SA_STACK                              = 134217728
	SIGABRT                               = 6
	SIGALRM                               = 14
	SIGBUS                                = 7
	SIGCHLD                               = 17
	SIGCLD                                = 17
	SIGCONT                               = 18
	SIGFPE                                = 8
	SIGHUP                                = 1
	SIGILL                                = 4
	SIGINT                                = 2
	SIGIO                                 = 29
	SIGIOT                                = 6
	SIGKILL                               = 9
	SIGPIPE                               = 13
	SIGPOLL                               = 29
	SIGPROF                               = 27
	SIGPWR                                = 30
	SIGQUIT                               = 3
	SIGSEGV                               = 11
	SIGSTKFLT                             = 16
	SIGSTKSZ                              = 8192
	SIGSTOP                               = 19
	SIGSYS                                = 31
	SIGTERM                               = 15
	SIGTRAP                               = 5
	SIGTSTP                               = 20
	SIGTTIN                               = 21
	SIGTTOU                               = 22
	SIGURG                                = 23
	SIGUSR1                               = 10
	SIGUSR2                               = 12
	SIGVTALRM                             = 26
	SIGWINCH                              = 28
	SIGXCPU                               = 24
	SIGXFSZ                               = 25
	SIG_BLOCK                             = 0
	SIG_SETMASK                           = 2
	SIG_UNBLOCK                           = 1
	SQLITE_EVAL_WITHOUTNULLS              = 0x00001
	SQLITE_TCL_NRE                        = 1
	TCLSH                                 = 1
	X_ASMARM_SIGCONTEXT_H                 = 0
	X_BITS_SIGACTION_H                    = 1
	X_BITS_SIGCONTEXT_H                   = 1
	X_BITS_SIGEVENT_CONSTS_H              = 1
	X_BITS_SIGINFO_ARCH_H                 = 1
	X_BITS_SIGINFO_CONSTS_H               = 1
	X_BITS_SIGNUM_GENERIC_H               = 1
	X_BITS_SIGNUM_H                       = 1
	X_BITS_SIGSTACK_H                     = 1
	X_BITS_SIGTHREAD_H                    = 1
	X_BITS_SS_FLAGS_H                     = 1
	X_NSIG                                = 65
	X_SIGNAL_H                            = 0
	X_SYS_UCONTEXT_H                      = 1
	ALT_SCHEMA_TABLE                      = "sqlite_schema"
	ALT_TEMP_SCHEMA_TABLE                 = "sqlite_temp_schema"
	BTREE_APPEND                          = 0x08
	BTREE_APPLICATION_ID                  = 8
	BTREE_AUTOVACUUM_FULL                 = 1
	BTREE_AUTOVACUUM_INCR                 = 2
	BTREE_AUTOVACUUM_NONE                 = 0
	BTREE_AUXDELETE                       = 0x04
	BTREE_BLOBKEY                         = 2
	BTREE_BULKLOAD                        = 0x00000001
	BTREE_DATA_VERSION                    = 15
	BTREE_DEFAULT_CACHE_SIZE              = 3
	BTREE_FILE_FORMAT                     = 2
	BTREE_FORDELETE                       = 0x00000008
	BTREE_FREE_PAGE_COUNT                 = 0
	BTREE_HINT_RANGE                      = 0
	BTREE_INCR_VACUUM                     = 7
	BTREE_INTKEY                          = 1
	BTREE_LARGEST_ROOT_PAGE               = 4
	BTREE_MEMORY                          = 2
	BTREE_OMIT_JOURNAL                    = 1
	BTREE_PREFORMAT                       = 0x80
	BTREE_SAVEPOSITION                    = 0x02
	BTREE_SCHEMA_VERSION                  = 1
	BTREE_SEEK_EQ                         = 0x00000002
	BTREE_SINGLE                          = 4
	BTREE_TEXT_ENCODING                   = 5
	BTREE_UNORDERED                       = 8
	BTREE_USER_VERSION                    = 6
	BTREE_WRCSR                           = 0x00000004
	CACHE_STALE                           = 0
	COLFLAG_BUSY                          = 0x0100
	COLFLAG_GENERATED                     = 0x0060
	COLFLAG_HASTYPE                       = 0x0004
	COLFLAG_HIDDEN                        = 0x0002
	COLFLAG_NOINSERT                      = 0x0062
	COLFLAG_NOTAVAIL                      = 0x0080
	COLFLAG_PRIMKEY                       = 0x0001
	COLFLAG_SORTERREF                     = 0x0010
	COLFLAG_STORED                        = 0x0040
	COLFLAG_UNIQUE                        = 0x0008
	COLFLAG_VIRTUAL                       = 0x0020
	COLNAME_COLUMN                        = 4
	COLNAME_DATABASE                      = 2
	COLNAME_DECLTYPE                      = 1
	COLNAME_N                             = 5
	COLNAME_NAME                          = 0
	COLNAME_TABLE                         = 3
	CURTYPE_BTREE                         = 0
	CURTYPE_PSEUDO                        = 3
	CURTYPE_SORTER                        = 1
	CURTYPE_VTAB                          = 2
	DBFLAG_EncodingFixed                  = 0x0040
	DBFLAG_InternalFunc                   = 0x0020
	DBFLAG_PreferBuiltin                  = 0x0002
	DBFLAG_SchemaChange                   = 0x0001
	DBFLAG_SchemaKnownOk                  = 0x0010
	DBFLAG_Vacuum                         = 0x0004
	DBFLAG_VacuumInto                     = 0x0008
	DB_ResetWanted                        = 0x0008
	DB_SchemaLoaded                       = 0x0001
	DB_UnresetViews                       = 0x0002
	DFLT_SCHEMA_TABLE                     = "sqlite_master"
	DFLT_TEMP_SCHEMA_TABLE                = "sqlite_temp_master"
	ENAME_NAME                            = 0
	ENAME_SPAN                            = 1
	ENAME_TAB                             = 2
	EP_Agg                                = 0x000010
	EP_CanBeNull                          = 0x100000
	EP_Collate                            = 0x000100
	EP_Commuted                           = 0x000200
	EP_ConstFunc                          = 0x080000
	EP_DblQuoted                          = 0x000040
	EP_Distinct                           = 0x000002
	EP_FixedCol                           = 0x000008
	EP_FromDDL                            = 0x40000000
	EP_FromJoin                           = 0x000001
	EP_HasFunc                            = 0x000004
	EP_IfNullRow                          = 0x020000
	EP_Immutable                          = 0x02
	EP_InfixFunc                          = 0x000080
	EP_IntValue                           = 0x000400
	EP_IsFalse                            = 0x20000000
	EP_IsTrue                             = 0x10000000
	EP_Leaf                               = 0x800000
	EP_MemToken                           = 0x010000
	EP_NoReduce                           = 0x01
	EP_Propagate                          = 2097412
	EP_Quoted                             = 0x4000000
	EP_Reduced                            = 0x002000
	EP_Skip                               = 0x001000
	EP_Static                             = 0x8000000
	EP_Subquery                           = 0x200000
	EP_Subrtn                             = 0x2000000
	EP_TokenOnly                          = 0x004000
	EP_Unlikely                           = 0x040000
	EP_VarSelect                          = 0x000020
	EP_Win                                = 0x008000
	EP_WinFunc                            = 0x1000000
	EP_xIsSelect                          = 0x000800
	EXCLUSIVE_LOCK                        = 4
	EXPRDUP_REDUCE                        = 0x0001
	GCC_VERSION                           = 8003000
	HAVE_DLFCN_H                          = 1
	HAVE_FCHOWN                           = 1
	HAVE_FDATASYNC                        = 1
	HAVE_GMTIME_R                         = 1
	HAVE_INT16_T                          = 1
	HAVE_INT32_T                          = 1
	HAVE_INT64_T                          = 1
	HAVE_INT8_T                           = 1
	HAVE_INTPTR_T                         = 1
	HAVE_INTTYPES_H                       = 1
	HAVE_ISNAN                            = 1
	HAVE_LOCALTIME_R                      = 1
	HAVE_LSTAT                            = 1
	HAVE_MALLOC_H                         = 1
	HAVE_MALLOC_USABLE_SIZE               = 1
	HAVE_MEMORY_H                         = 1
	HAVE_PREAD                            = 1
	HAVE_PREAD64                          = 1
	HAVE_PWRITE                           = 1
	HAVE_PWRITE64                         = 1
	HAVE_READLINK                         = 1
	HAVE_STDINT_H                         = 1
	HAVE_STDLIB_H                         = 1
	HAVE_STRCHRNUL                        = 1
	HAVE_STRINGS_H                        = 1
	HAVE_STRING_H                         = 1
	HAVE_SYS_STAT_H                       = 1
	HAVE_SYS_TYPES_H                      = 1
	HAVE_UINT16_T                         = 1
	HAVE_UINT32_T                         = 1
	HAVE_UINT64_T                         = 1
	HAVE_UINT8_T                          = 1
	HAVE_UINTPTR_T                        = 1
	HAVE_UNISTD_H                         = 1
	HAVE_UTIME                            = 1
	INITFLAG_AlterDrop                    = 0x0002
	INITFLAG_AlterRename                  = 0x0001
	INLINEFUNC_affinity                   = 4
	INLINEFUNC_coalesce                   = 0
	INLINEFUNC_expr_compare               = 3
	INLINEFUNC_expr_implies_expr          = 2
	INLINEFUNC_iif                        = 5
	INLINEFUNC_implies_nonnull_row        = 1
	INLINEFUNC_unlikely                   = 99
	INT16_MAX                             = 32767
	INT16_MIN                             = -32768
	INT16_WIDTH                           = 16
	INT32_MAX                             = 2147483647
	INT32_MIN                             = -2147483648
	INT32_WIDTH                           = 32
	INT64_MAX                             = 9223372036854775807
	INT64_MIN                             = -9223372036854775808
	INT64_WIDTH                           = 64
	INT8_MAX                              = 127
	INT8_MIN                              = -128
	INT8_WIDTH                            = 8
	INTMAX_MAX                            = 9223372036854775807
	INTMAX_MIN                            = -9223372036854775808
	INTMAX_WIDTH                          = 64
	INTPTR_MAX                            = 2147483647
	INTPTR_MIN                            = -2147483648
	INTPTR_WIDTH                          = 32
	INT_FAST16_MAX                        = 2147483647
	INT_FAST16_MIN                        = -2147483648
	INT_FAST16_WIDTH                      = 32
	INT_FAST32_MAX                        = 2147483647
	INT_FAST32_MIN                        = -2147483648
	INT_FAST32_WIDTH                      = 32
	INT_FAST64_MAX                        = 9223372036854775807
	INT_FAST64_MIN                        = -9223372036854775808
	INT_FAST64_WIDTH                      = 64
	INT_FAST8_MAX                         = 127
	INT_FAST8_MIN                         = -128
	INT_FAST8_WIDTH                       = 8
	INT_LEAST16_MAX                       = 32767
	INT_LEAST16_MIN                       = -32768
	INT_LEAST16_WIDTH                     = 16
	INT_LEAST32_MAX                       = 2147483647
	INT_LEAST32_MIN                       = -2147483648
	INT_LEAST32_WIDTH                     = 32
	INT_LEAST64_MAX                       = 9223372036854775807
	INT_LEAST64_MIN                       = -9223372036854775808
	INT_LEAST64_WIDTH                     = 64
	INT_LEAST8_MAX                        = 127
	INT_LEAST8_MIN                        = -128
	INT_LEAST8_WIDTH                      = 8
	IN_INDEX_EPH                          = 2
	IN_INDEX_INDEX_ASC                    = 3
	IN_INDEX_INDEX_DESC                   = 4
	IN_INDEX_LOOP                         = 0x0004
	IN_INDEX_MEMBERSHIP                   = 0x0002
	IN_INDEX_NOOP                         = 5
	IN_INDEX_NOOP_OK                      = 0x0001
	IN_INDEX_ROWID                        = 1
	JT_CROSS                              = 0x0002
	JT_ERROR                              = 0x0040
	JT_INNER                              = 0x0001
	JT_LEFT                               = 0x0008
	JT_NATURAL                            = 0x0004
	JT_OUTER                              = 0x0020
	JT_RIGHT                              = 0x0010
	KEYINFO_ORDER_BIGNULL                 = 0x02
	KEYINFO_ORDER_DESC                    = 0x01
	LOCATE_NOERR                          = 0x02
	LOCATE_VIEW                           = 0x01
	LOOKASIDE_SMALL                       = 128
	LT_OBJDIR                             = ".libs/"
	L_cuserid                             = 9
	M10d_Any                              = 1
	M10d_No                               = 2
	M10d_Yes                              = 0
	MEMTYPE_HEAP                          = 0x01
	MEMTYPE_LOOKASIDE                     = 0x02
	MEMTYPE_PCACHE                        = 0x04
	MEM_AffMask                           = 0x003f
	MEM_Agg                               = 0x2000
	MEM_Blob                              = 0x0010
	MEM_Cleared                           = 0x0100
	MEM_Dyn                               = 0x0400
	MEM_Ephem                             = 0x1000
	MEM_FromBind                          = 0x0040
	MEM_Int                               = 0x0004
	MEM_IntReal                           = 0x0020
	MEM_Null                              = 0x0001
	MEM_Real                              = 0x0008
	MEM_Static                            = 0x0800
	MEM_Str                               = 0x0002
	MEM_Subtype                           = 0x8000
	MEM_Term                              = 0x0200
	MEM_TypeMask                          = 0xc1bf
	MEM_Undefined                         = 0x0080
	MEM_Zero                              = 0x4000
	MSVC_VERSION                          = 0
	NC_AllowAgg                           = 0x00001
	NC_AllowWin                           = 0x04000
	NC_Complex                            = 0x02000
	NC_FromDDL                            = 0x40000
	NC_GenCol                             = 0x00008
	NC_HasAgg                             = 0x00010
	NC_HasWin                             = 0x08000
	NC_IdxExpr                            = 0x00020
	NC_InAggFunc                          = 0x20000
	NC_IsCheck                            = 0x00004
	NC_IsDDL                              = 0x10000
	NC_MinMaxAgg                          = 0x01000
	NC_NoSelect                           = 0x80000
	NC_PartIdx                            = 0x00002
	NC_SelfRef                            = 0x0002e
	NC_UAggInfo                           = 0x00100
	NC_UBaseReg                           = 0x00400
	NC_UEList                             = 0x00080
	NC_UUpsert                            = 0x00200
	NC_VarSelect                          = 0x00040
	NO_LOCK                               = 0
	OE_Abort                              = 2
	OE_Cascade                            = 10
	OE_Default                            = 11
	OE_Fail                               = 3
	OE_Ignore                             = 4
	OE_None                               = 0
	OE_Replace                            = 5
	OE_Restrict                           = 7
	OE_Rollback                           = 1
	OE_SetDflt                            = 9
	OE_SetNull                            = 8
	OE_Update                             = 6
	OMIT_TEMPDB                           = 0
	ONEPASS_MULTI                         = 2
	ONEPASS_OFF                           = 0
	ONEPASS_SINGLE                        = 1
	OPFLAG_APPEND                         = 0x08
	OPFLAG_AUXDELETE                      = 0x04
	OPFLAG_BULKCSR                        = 0x01
	OPFLAG_EPHEM                          = 0x01
	OPFLAG_FORDELETE                      = 0x08
	OPFLAG_ISNOOP                         = 0x40
	OPFLAG_ISUPDATE                       = 0x04
	OPFLAG_LASTROWID                      = 0x20
	OPFLAG_LENGTHARG                      = 0x40
	OPFLAG_NCHANGE                        = 0x01
	OPFLAG_NOCHNG                         = 0x01
	OPFLAG_NOCHNG_MAGIC                   = 0x6d
	OPFLAG_P2ISREG                        = 0x10
	OPFLAG_PERMUTE                        = 0x01
	OPFLAG_PREFORMAT                      = 0x80
	OPFLAG_SAVEPOSITION                   = 0x02
	OPFLAG_SEEKEQ                         = 0x02
	OPFLAG_TYPEOFARG                      = 0x80
	OPFLAG_USESEEKRESULT                  = 0x10
	OPFLG_IN1                             = 0x02
	OPFLG_IN2                             = 0x04
	OPFLG_IN3                             = 0x08
	OPFLG_JUMP                            = 0x01
	OPFLG_OUT2                            = 0x10
	OPFLG_OUT3                            = 0x20
	OP_Abortable                          = 179
	OP_Add                                = 106
	OP_AddImm                             = 83
	OP_Affinity                           = 92
	OP_AggFinal                           = 161
	OP_AggInverse                         = 157
	OP_AggStep                            = 158
	OP_AggStep1                           = 159
	OP_AggValue                           = 160
	OP_And                                = 44
	OP_AutoCommit                         = 1
	OP_BitAnd                             = 102
	OP_BitNot                             = 113
	OP_BitOr                              = 103
	OP_Blob                               = 74
	OP_Cast                               = 85
	OP_Checkpoint                         = 6
	OP_ChngCntRow                         = 80
	OP_Clear                              = 141
	OP_Close                              = 118
	OP_CollSeq                            = 82
	OP_Column                             = 91
	OP_ColumnsUsed                        = 119
	OP_Compare                            = 87
	OP_Concat                             = 111
	OP_Copy                               = 77
	OP_Count                              = 94
	OP_CreateBtree                        = 143
	OP_CursorHint                         = 175
	OP_CursorLock                         = 163
	OP_CursorUnlock                       = 164
	OP_DecrJumpZero                       = 59
	OP_DeferredSeek                       = 137
	OP_Delete                             = 126
	OP_Destroy                            = 140
	OP_Divide                             = 109
	OP_DropIndex                          = 148
	OP_DropTable                          = 147
	OP_DropTrigger                        = 149
	OP_ElseEq                             = 58
	OP_EndCoroutine                       = 66
	OP_Eq                                 = 53
	OP_Expire                             = 162
	OP_Explain                            = 178
	OP_FinishSeek                         = 139
	OP_FkCounter                          = 154
	OP_FkIfZero                           = 47
	OP_Found                              = 30
	OP_Function                           = 64
	OP_Ge                                 = 57
	OP_Gosub                              = 12
	OP_Goto                               = 11
	OP_Gt                                 = 54
	OP_Halt                               = 68
	OP_HaltIfNull                         = 67
	OP_IdxDelete                          = 136
	OP_IdxGE                              = 41
	OP_IdxGT                              = 39
	OP_IdxInsert                          = 134
	OP_IdxLE                              = 38
	OP_IdxLT                              = 40
	OP_IdxRowid                           = 138
	OP_If                                 = 18
	OP_IfNoHope                           = 27
	OP_IfNot                              = 20
	OP_IfNotOpen                          = 26
	OP_IfNotZero                          = 49
	OP_IfNullRow                          = 21
	OP_IfPos                              = 48
	OP_IfSmaller                          = 34
	OP_IncrVacuum                         = 60
	OP_Init                               = 62
	OP_InitCoroutine                      = 13
	OP_Insert                             = 124
	OP_Int64                              = 70
	OP_IntCopy                            = 79
	OP_Integer                            = 69
	OP_IntegrityCk                        = 150
	OP_IsNull                             = 50
	OP_IsTrue                             = 88
	OP_JournalMode                        = 7
	OP_Jump                               = 16
	OP_Last                               = 33
	OP_Le                                 = 55
	OP_LoadAnalysis                       = 146
	OP_Lt                                 = 56
	OP_MakeRecord                         = 93
	OP_MaxPgcnt                           = 173
	OP_MemMax                             = 155
	OP_Move                               = 76
	OP_Multiply                           = 108
	OP_MustBeInt                          = 15
	OP_Ne                                 = 52
	OP_NewRowid                           = 123
	OP_Next                               = 5
	OP_NoConflict                         = 28
	OP_Noop                               = 177
	OP_Not                                = 19
	OP_NotExists                          = 32
	OP_NotFound                           = 29
	OP_NotNull                            = 51
	OP_Null                               = 72
	OP_NullRow                            = 132
	OP_Offset                             = 90
	OP_OffsetLimit                        = 156
	OP_Once                               = 17
	OP_OpenAutoindex                      = 101
	OP_OpenDup                            = 100
	OP_OpenEphemeral                      = 112
	OP_OpenPseudo                         = 117
	OP_OpenRead                           = 98
	OP_OpenWrite                          = 99
	OP_Or                                 = 43
	OP_Pagecount                          = 172
	OP_Param                              = 153
	OP_ParseSchema                        = 145
	OP_Permutation                        = 86
	OP_Prev                               = 4
	OP_Program                            = 46
	OP_PureFunc                           = 63
	OP_ReadCookie                         = 95
	OP_Real                               = 152
	OP_RealAffinity                       = 84
	OP_ReleaseReg                         = 176
	OP_Remainder                          = 110
	OP_ReopenIdx                          = 97
	OP_ResetCount                         = 127
	OP_ResetSorter                        = 142
	OP_ResultRow                          = 81
	OP_Return                             = 65
	OP_Rewind                             = 37
	OP_RowCell                            = 125
	OP_RowData                            = 130
	OP_RowSetAdd                          = 151
	OP_RowSetRead                         = 42
	OP_RowSetTest                         = 45
	OP_Rowid                              = 131
	OP_SCopy                              = 78
	OP_Savepoint                          = 0
	OP_SeekEnd                            = 133
	OP_SeekGE                             = 24
	OP_SeekGT                             = 25
	OP_SeekHit                            = 121
	OP_SeekLE                             = 23
	OP_SeekLT                             = 22
	OP_SeekRowid                          = 31
	OP_SeekScan                           = 120
	OP_Sequence                           = 122
	OP_SequenceTest                       = 115
	OP_SetCookie                          = 96
	OP_ShiftLeft                          = 104
	OP_ShiftRight                         = 105
	OP_SoftNull                           = 73
	OP_Sort                               = 36
	OP_SorterCompare                      = 128
	OP_SorterData                         = 129
	OP_SorterInsert                       = 135
	OP_SorterNext                         = 3
	OP_SorterOpen                         = 114
	OP_SorterSort                         = 35
	OP_SqlExec                            = 144
	OP_String                             = 71
	OP_String8                            = 116
	OP_Subtract                           = 107
	OP_TableLock                          = 165
	OP_Trace                              = 174
	OP_Transaction                        = 2
	OP_VBegin                             = 166
	OP_VColumn                            = 170
	OP_VCreate                            = 167
	OP_VDestroy                           = 168
	OP_VFilter                            = 9
	OP_VNext                              = 61
	OP_VOpen                              = 169
	OP_VRename                            = 171
	OP_VUpdate                            = 10
	OP_Vacuum                             = 8
	OP_Variable                           = 75
	OP_Yield                              = 14
	OP_ZeroOrNull                         = 89
	OS_VXWORKS                            = 0
	P4_ADVANCE                            = -5
	P4_COLLSEQ                            = -2
	P4_DYNAMIC                            = -7
	P4_DYNBLOB                            = -17
	P4_EXPR                               = -10
	P4_FREE_IF_LE                         = -7
	P4_FUNCCTX                            = -16
	P4_FUNCDEF                            = -8
	P4_INT32                              = -3
	P4_INT64                              = -14
	P4_INTARRAY                           = -15
	P4_KEYINFO                            = -9
	P4_MEM                                = -11
	P4_NOTUSED                            = 0
	P4_REAL                               = -13
	P4_STATIC                             = -1
	P4_SUBPROGRAM                         = -4
	P4_TABLE                              = -6
	P4_TRANSIENT                          = 0
	P4_VTAB                               = -12
	P5_ConstraintCheck                    = 3
	P5_ConstraintFK                       = 4
	P5_ConstraintNotNull                  = 1
	P5_ConstraintUnique                   = 2
	PACKAGE_BUGREPORT                     = ""
	PACKAGE_NAME                          = "sqlite"
	PACKAGE_STRING                        = "sqlite 3.36.0"
	PACKAGE_TARNAME                       = "sqlite"
	PAGER_CACHESPILL                      = 0x20
	PAGER_CKPT_FULLFSYNC                  = 0x10
	PAGER_FLAGS_MASK                      = 0x38
	PAGER_FULLFSYNC                       = 0x08
	PAGER_GET_NOCONTENT                   = 0x01
	PAGER_GET_READONLY                    = 0x02
	PAGER_JOURNALMODE_DELETE              = 0
	PAGER_JOURNALMODE_MEMORY              = 4
	PAGER_JOURNALMODE_OFF                 = 2
	PAGER_JOURNALMODE_PERSIST             = 1
	PAGER_JOURNALMODE_QUERY               = -1
	PAGER_JOURNALMODE_TRUNCATE            = 3
	PAGER_JOURNALMODE_WAL                 = 5
	PAGER_LOCKINGMODE_EXCLUSIVE           = 1
	PAGER_LOCKINGMODE_NORMAL              = 0
	PAGER_LOCKINGMODE_QUERY               = -1
	PAGER_MEMORY                          = 0x0002
	PAGER_OMIT_JOURNAL                    = 0x0001
	PAGER_SYNCHRONOUS_EXTRA               = 0x04
	PAGER_SYNCHRONOUS_FULL                = 0x03
	PAGER_SYNCHRONOUS_MASK                = 0x07
	PAGER_SYNCHRONOUS_NORMAL              = 0x02
	PAGER_SYNCHRONOUS_OFF                 = 0x01
	PARSE_MODE_DECLARE_VTAB               = 1
	PARSE_MODE_NORMAL                     = 0
	PARSE_MODE_RENAME                     = 2
	PARSE_MODE_UNMAP                      = 3
	PENDING_LOCK                          = 3
	PGHDR_CLEAN                           = 0x001
	PGHDR_DIRTY                           = 0x002
	PGHDR_DONT_WRITE                      = 0x010
	PGHDR_MMAP                            = 0x020
	PGHDR_NEED_SYNC                       = 0x008
	PGHDR_WAL_APPEND                      = 0x040
	PGHDR_WRITEABLE                       = 0x004
	PRIO_MAX                              = 20
	PRIO_MIN                              = -20
	PRIX16                                = "X"
	PRIX32                                = "X"
	PRIX8                                 = "X"
	PRIXFAST8                             = "X"
	PRIXLEAST16                           = "X"
	PRIXLEAST32                           = "X"
	PRIXLEAST8                            = "X"
	PRId16                                = "d"
	PRId32                                = "d"
	PRId8                                 = "d"
	PRIdFAST8                             = "d"
	PRIdLEAST16                           = "d"
	PRIdLEAST32                           = "d"
	PRIdLEAST8                            = "d"
	PRIi16                                = "i"
	PRIi32                                = "i"
	PRIi8                                 = "i"
	PRIiFAST8                             = "i"
	PRIiLEAST16                           = "i"
	PRIiLEAST32                           = "i"
	PRIiLEAST8                            = "i"
	PRIo16                                = "o"
	PRIo32                                = "o"
	PRIo8                                 = "o"
	PRIoFAST8                             = "o"
	PRIoLEAST16                           = "o"
	PRIoLEAST32                           = "o"
	PRIoLEAST8                            = "o"
	PRIu16                                = "u"
	PRIu32                                = "u"
	PRIu8                                 = "u"
	PRIuFAST8                             = "u"
	PRIuLEAST16                           = "u"
	PRIuLEAST32                           = "u"
	PRIuLEAST8                            = "u"
	PRIx16                                = "x"
	PRIx32                                = "x"
	PRIx8                                 = "x"
	PRIxFAST8                             = "x"
	PRIxLEAST16                           = "x"
	PRIxLEAST32                           = "x"
	PRIxLEAST8                            = "x"
	PTRDIFF_MAX                           = 2147483647
	PTRDIFF_MIN                           = -2147483648
	PTRDIFF_WIDTH                         = 32
	RENAME_EXCHANGE                       = 2
	RENAME_NOREPLACE                      = 1
	RENAME_WHITEOUT                       = 4
	RESERVED_LOCK                         = 2
	RLIM64_INFINITY                       = 0xffffffffffffffff
	RLIM_INFINITY                         = 0xffffffffffffffff
	RLIM_SAVED_CUR                        = 18446744073709551615
	RLIM_SAVED_MAX                        = 18446744073709551615
	SAVEPOINT_BEGIN                       = 0
	SAVEPOINT_RELEASE                     = 1
	SAVEPOINT_ROLLBACK                    = 2
	SCHEMA_ROOT                           = 1
	SCNd16                                = "hd"
	SCNd32                                = "d"
	SCNd8                                 = "hhd"
	SCNdFAST8                             = "hhd"
	SCNdLEAST16                           = "hd"
	SCNdLEAST32                           = "d"
	SCNdLEAST8                            = "hhd"
	SCNi16                                = "hi"
	SCNi32                                = "i"
	SCNi8                                 = "hhi"
	SCNiFAST8                             = "hhi"
	SCNiLEAST16                           = "hi"
	SCNiLEAST32                           = "i"
	SCNiLEAST8                            = "hhi"
	SCNo16                                = "ho"
	SCNo32                                = "o"
	SCNo8                                 = "hho"
	SCNoFAST8                             = "hho"
	SCNoLEAST16                           = "ho"
	SCNoLEAST32                           = "o"
	SCNoLEAST8                            = "hho"
	SCNu16                                = "hu"
	SCNu32                                = "u"
	SCNu8                                 = "hhu"
	SCNuFAST8                             = "hhu"
	SCNuLEAST16                           = "hu"
	SCNuLEAST32                           = "u"
	SCNuLEAST8                            = "hhu"
	SCNx16                                = "hx"
	SCNx32                                = "x"
	SCNx8                                 = "hhx"
	SCNxFAST8                             = "hhx"
	SCNxLEAST16                           = "hx"
	SCNxLEAST32                           = "x"
	SCNxLEAST8                            = "hhx"
	SEEK_DATA                             = 3
	SEEK_HOLE                             = 4
	SELECTTRACE_ENABLED                   = 0
	SF_Aggregate                          = 0x0000008
	SF_All                                = 0x0000002
	SF_ComplexResult                      = 0x0040000
	SF_Compound                           = 0x0000100
	SF_Converted                          = 0x0010000
	SF_CopyCte                            = 0x4000000
	SF_Distinct                           = 0x0000001
	SF_Expanded                           = 0x0000040
	SF_FixedLimit                         = 0x0004000
	SF_HasAgg                             = 0x0000010
	SF_HasTypeInfo                        = 0x0000080
	SF_IncludeHidden                      = 0x0020000
	SF_MaybeConvert                       = 0x0008000
	SF_MinMaxAgg                          = 0x0001000
	SF_MultiPart                          = 0x2000000
	SF_MultiValue                         = 0x0000400
	SF_NestedFrom                         = 0x0000800
	SF_NoopOrderBy                        = 0x0400000
	SF_PushDown                           = 0x1000000
	SF_Recursive                          = 0x0002000
	SF_Resolved                           = 0x0000004
	SF_UpdateFrom                         = 0x0800000
	SF_UsesEphemeral                      = 0x0000020
	SF_Values                             = 0x0000200
	SF_View                               = 0x0200000
	SF_WhereBegin                         = 0x0080000
	SF_WinRewrite                         = 0x0100000
	SHARED_LOCK                           = 1
	SHARED_SIZE                           = 510
	SIG_ATOMIC_MAX                        = 2147483647
	SIG_ATOMIC_MIN                        = -2147483648
	SIG_ATOMIC_WIDTH                      = 32
	SIZE_MAX                              = 4294967295
	SIZE_WIDTH                            = 32
	SQLITECONFIG_H                        = 1
	SQLITEINT_H                           = 0
	SQLITE_AFF_BLOB                       = 0x41
	SQLITE_AFF_INTEGER                    = 0x44
	SQLITE_AFF_MASK                       = 0x47
	SQLITE_AFF_NONE                       = 0x40
	SQLITE_AFF_NUMERIC                    = 0x43
	SQLITE_AFF_REAL                       = 0x45
	SQLITE_AFF_TEXT                       = 0x42
	SQLITE_ASCII                          = 1
	SQLITE_AllOpts                        = 0xffffffff
	SQLITE_AutoIndex                      = 0x00008000
	SQLITE_BIGENDIAN                      = 0
	SQLITE_BIG_DBL                        = 0
	SQLITE_BTREE_H                        = 0
	SQLITE_BYTEORDER                      = 1234
	SQLITE_CacheSpill                     = 0x00000020
	SQLITE_CellSizeCk                     = 0x00200000
	SQLITE_CkptFullFSync                  = 0x00000010
	SQLITE_CountOfView                    = 0x00000200
	SQLITE_CoverIdxScan                   = 0x00000020
	SQLITE_CursorHints                    = 0x00000400
	SQLITE_DEFAULT_AUTOVACUUM             = 0
	SQLITE_DEFAULT_CACHE_SIZE             = -2000
	SQLITE_DEFAULT_FILE_FORMAT            = 4
	SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT     = -1
	SQLITE_DEFAULT_MMAP_SIZE              = 0
	SQLITE_DEFAULT_PCACHE_INITSZ          = 20
	SQLITE_DEFAULT_RECURSIVE_TRIGGERS     = 0
	SQLITE_DEFAULT_SECTOR_SIZE            = 4096
	SQLITE_DEFAULT_SORTERREF_SIZE         = 0x7fffffff
	SQLITE_DEFAULT_SYNCHRONOUS            = 2
	SQLITE_DEFAULT_WAL_AUTOCHECKPOINT     = 1000
	SQLITE_DEFAULT_WAL_SYNCHRONOUS        = 2
	SQLITE_DEFAULT_WORKER_THREADS         = 0
	SQLITE_Defensive                      = 0x10000000
	SQLITE_DeferFKs                       = 0x00080000
	SQLITE_DistinctOpt                    = 0x00000010
	SQLITE_DqsDDL                         = 0x20000000
	SQLITE_DqsDML                         = 0x40000000
	SQLITE_ECEL_DUP                       = 0x01
	SQLITE_ECEL_FACTOR                    = 0x02
	SQLITE_ECEL_OMITREF                   = 0x08
	SQLITE_ECEL_REF                       = 0x04
	SQLITE_ENABLE_LOCKING_STYLE           = 0
	SQLITE_EnableQPSG                     = 0x00800000
	SQLITE_EnableTrigger                  = 0x00040000
	SQLITE_EnableView                     = 0x80000000
	SQLITE_FAULTINJECTOR_COUNT            = 1
	SQLITE_FAULTINJECTOR_MALLOC           = 0
	SQLITE_FCNTL_DB_UNCHANGED             = 0xca093fa0
	SQLITE_FRAME_MAGIC                    = 0x879fb71e
	SQLITE_FUNC_CASE                      = 0x0008
	SQLITE_FUNC_CONSTANT                  = 0x0800
	SQLITE_FUNC_COUNT                     = 0x0100
	SQLITE_FUNC_DIRECT                    = 0x00080000
	SQLITE_FUNC_ENCMASK                   = 0x0003
	SQLITE_FUNC_EPHEM                     = 0x0010
	SQLITE_FUNC_HASH_SZ                   = 23
	SQLITE_FUNC_INLINE                    = 0x00400000
	SQLITE_FUNC_INTERNAL                  = 0x00040000
	SQLITE_FUNC_LENGTH                    = 0x0040
	SQLITE_FUNC_LIKE                      = 0x0004
	SQLITE_FUNC_MINMAX                    = 0x1000
	SQLITE_FUNC_NEEDCOLL                  = 0x0020
	SQLITE_FUNC_OFFSET                    = 0x8000
	SQLITE_FUNC_SLOCHNG                   = 0x2000
	SQLITE_FUNC_SUBTYPE                   = 0x00100000
	SQLITE_FUNC_TEST                      = 0x4000
	SQLITE_FUNC_TYPEOF                    = 0x0080
	SQLITE_FUNC_UNLIKELY                  = 0x0400
	SQLITE_FUNC_UNSAFE                    = 0x00200000
	SQLITE_FUNC_WINDOW                    = 0x00010000
	SQLITE_FactorOutConst                 = 0x00000008
	SQLITE_ForeignKeys                    = 0x00004000
	SQLITE_Fts3Tokenizer                  = 0x00400000
	SQLITE_FullColNames                   = 0x00000004
	SQLITE_FullFSync                      = 0x00000008
	SQLITE_GroupByOrder                   = 0x00000004
	SQLITE_HASH_H                         = 0
	SQLITE_HAVE_C99_MATH_FUNCS            = 1
	SQLITE_HAVE_OS_TRACE                  = 0
	SQLITE_IDXTYPE_APPDEF                 = 0
	SQLITE_IDXTYPE_IPK                    = 3
	SQLITE_IDXTYPE_PRIMARYKEY             = 2
	SQLITE_IDXTYPE_UNIQUE                 = 1
	SQLITE_IOERR_NOMEM_BKPT               = 3082
	SQLITE_IgnoreChecks                   = 0x00000200
	SQLITE_JUMPIFNULL                     = 0x10
	SQLITE_LITTLEENDIAN                   = 1
	SQLITE_LegacyAlter                    = 0x04000000
	SQLITE_LegacyFileFmt                  = 0x00000002
	SQLITE_LoadExtFunc                    = 0x00020000
	SQLITE_LoadExtension                  = 0x00010000
	SQLITE_MAGIC_BUSY                     = 0xf03b7906
	SQLITE_MAGIC_CLOSED                   = 0x9f3c2d33
	SQLITE_MAGIC_ERROR                    = 0xb5357930
	SQLITE_MAGIC_OPEN                     = 0xa029a697
	SQLITE_MAGIC_SICK                     = 0x4b771290
	SQLITE_MAGIC_ZOMBIE                   = 0x64cffc7f
	SQLITE_MALLOC_SOFT_LIMIT              = 1024
	SQLITE_MAX_ATTACHED                   = 10
	SQLITE_MAX_COLUMN                     = 2000
	SQLITE_MAX_COMPOUND_SELECT            = 500
	SQLITE_MAX_DB                         = 12
	SQLITE_MAX_DEFAULT_PAGE_SIZE          = 8192
	SQLITE_MAX_EXPR_DEPTH                 = 1000
	SQLITE_MAX_FILE_FORMAT                = 4
	SQLITE_MAX_FUNCTION_ARG               = 127
	SQLITE_MAX_LENGTH                     = 1000000000
	SQLITE_MAX_LIKE_PATTERN_LENGTH        = 50000
	SQLITE_MAX_MMAP_SIZE                  = 0x7fff0000
	SQLITE_MAX_PAGE_COUNT                 = 1073741823
	SQLITE_MAX_PAGE_SIZE                  = 65536
	SQLITE_MAX_PATHLEN                    = 4096
	SQLITE_MAX_SCHEMA_RETRY               = 50
	SQLITE_MAX_SQL_LENGTH                 = 1000000000
	SQLITE_MAX_TRIGGER_DEPTH              = 1000
	SQLITE_MAX_VARIABLE_NUMBER            = 32766
	SQLITE_MAX_VDBE_OP                    = 250000000
	SQLITE_MAX_WORKER_THREADS             = 8
	SQLITE_MSVC_H                         = 0
	SQLITE_MX_JUMP_OPCODE                 = 62
	SQLITE_MinMaxOpt                      = 0x00010000
	SQLITE_NEED_ERR_NAME                  = 0
	SQLITE_NOMEM_BKPT                     = 7
	SQLITE_NOTNULL                        = 0x90
	SQLITE_NTUNE                          = 6
	SQLITE_NULLEQ                         = 0x80
	SQLITE_N_BTREE_META                   = 16
	SQLITE_N_LIMIT                        = 12
	SQLITE_NoCkptOnClose                  = 0x00000800
	SQLITE_NoSchemaError                  = 0x08000000
	SQLITE_NullCallback                   = 0x00000100
	SQLITE_OS_OTHER                       = 0
	SQLITE_OS_SETUP_H                     = 0
	SQLITE_OS_UNIX                        = 1
	SQLITE_OS_WIN                         = 0
	SQLITE_OmitNoopJoin                   = 0x00000100
	SQLITE_OrderByIdxJoin                 = 0x00000040
	SQLITE_PAGER_H                        = 0
	SQLITE_POWERSAFE_OVERWRITE            = 1
	SQLITE_PREPARE_MASK                   = 0x0f
	SQLITE_PREPARE_SAVESQL                = 0x80
	SQLITE_PRINTF_INTERNAL                = 0x01
	SQLITE_PRINTF_MALLOCED                = 0x04
	SQLITE_PRINTF_SQLFUNC                 = 0x02
	SQLITE_PTRSIZE                        = 4
	SQLITE_PropagateConst                 = 0x00008000
	SQLITE_PushDown                       = 0x00001000
	SQLITE_QueryFlattener                 = 0x00000001
	SQLITE_QueryOnly                      = 0x00100000
	SQLITE_ReadUncommit                   = 0x00000400
	SQLITE_RecTriggers                    = 0x00002000
	SQLITE_ResetDatabase                  = 0x02000000
	SQLITE_ReverseOrder                   = 0x00001000
	SQLITE_SO_ASC                         = 0
	SQLITE_SO_DESC                        = 1
	SQLITE_SO_UNDEFINED                   = -1
	SQLITE_SYSTEM_MALLOC                  = 1
	SQLITE_SeekScan                       = 0x00020000
	SQLITE_ShortColNames                  = 0x00000040
	SQLITE_SimplifyJoin                   = 0x00002000
	SQLITE_SkipScan                       = 0x00004000
	SQLITE_Stat4                          = 0x00000800
	SQLITE_TEMP_FILE_PREFIX               = "etilqs_"
	SQLITE_TOKEN_KEYWORD                  = 0x2
	SQLITE_TOKEN_QUOTED                   = 0x1
	SQLITE_TRACE_LEGACY                   = 0x40
	SQLITE_TRACE_NONLEGACY_MASK           = 0x0f
	SQLITE_TRACE_XPROFILE                 = 0x80
	SQLITE_Transitive                     = 0x00000080
	SQLITE_TriggerEQP                     = 0x01000000
	SQLITE_TrustedSchema                  = 0x00000080
	SQLITE_UTF16NATIVE                    = 2
	SQLITE_VDBEINT_H                      = 0
	SQLITE_VDBE_H                         = 0
	SQLITE_VTABRISK_High                  = 2
	SQLITE_VTABRISK_Low                   = 0
	SQLITE_VTABRISK_Normal                = 1
	SQLITE_WSD                            = 0
	SQLITE_WindowFunc                     = 0x00000002
	SQLITE_WriteSchema                    = 0x00000001
	SRT_Coroutine                         = 13
	SRT_Discard                           = 4
	SRT_DistFifo                          = 5
	SRT_DistQueue                         = 6
	SRT_EphemTab                          = 12
	SRT_Except                            = 2
	SRT_Exists                            = 3
	SRT_Fifo                              = 8
	SRT_Mem                               = 10
	SRT_Output                            = 9
	SRT_Queue                             = 7
	SRT_Set                               = 11
	SRT_Table                             = 14
	SRT_Union                             = 1
	SRT_Upfrom                            = 15
	STDC_HEADERS                          = 1
	TF_Autoincrement                      = 0x0008
	TF_Ephemeral                          = 0x4000
	TF_Eponymous                          = 0x8000
	TF_HasGenerated                       = 0x0060
	TF_HasHidden                          = 0x0002
	TF_HasNotNull                         = 0x0800
	TF_HasPrimaryKey                      = 0x0004
	TF_HasStat1                           = 0x0010
	TF_HasStat4                           = 0x2000
	TF_HasStored                          = 0x0040
	TF_HasVirtual                         = 0x0020
	TF_NoVisibleRowid                     = 0x0200
	TF_OOOHidden                          = 0x0400
	TF_Readonly                           = 0x0001
	TF_Shadow                             = 0x1000
	TF_StatsUsed                          = 0x0100
	TF_WithoutRowid                       = 0x0080
	TK_ABORT                              = 27
	TK_ACTION                             = 28
	TK_ADD                                = 162
	TK_AFTER                              = 29
	TK_AGG_COLUMN                         = 168
	TK_AGG_FUNCTION                       = 167
	TK_ALL                                = 134
	TK_ALTER                              = 161
	TK_ALWAYS                             = 96
	TK_ANALYZE                            = 30
	TK_AND                                = 44
	TK_ANY                                = 101
	TK_AS                                 = 24
	TK_ASC                                = 31
	TK_ASTERISK                           = 179
	TK_ATTACH                             = 32
	TK_AUTOINCR                           = 125
	TK_BEFORE                             = 33
	TK_BEGIN                              = 5
	TK_BETWEEN                            = 48
	TK_BY                                 = 34
	TK_CASCADE                            = 35
	TK_CASE                               = 156
	TK_CAST                               = 36
	TK_CHECK                              = 123
	TK_COLLATE                            = 112
	TK_COLUMN                             = 166
	TK_COLUMNKW                           = 60
	TK_COMMIT                             = 10
	TK_CONFLICT                           = 37
	TK_CONSTRAINT                         = 118
	TK_CREATE                             = 17
	TK_CTIME_KW                           = 100
	TK_CURRENT                            = 85
	TK_DATABASE                           = 38
	TK_DEFAULT                            = 119
	TK_DEFERRABLE                         = 130
	TK_DEFERRED                           = 7
	TK_DELETE                             = 127
	TK_DESC                               = 39
	TK_DETACH                             = 40
	TK_DISTINCT                           = 139
	TK_DO                                 = 61
	TK_DROP                               = 132
	TK_EACH                               = 41
	TK_ELSE                               = 159
	TK_END                                = 11
	TK_ESCAPE                             = 58
	TK_EXCEPT                             = 135
	TK_EXCLUDE                            = 91
	TK_EXCLUSIVE                          = 9
	TK_EXISTS                             = 20
	TK_EXPLAIN                            = 2
	TK_FAIL                               = 42
	TK_FILTER                             = 165
	TK_FIRST                              = 83
	TK_FOLLOWING                          = 86
	TK_FOR                                = 62
	TK_FOREIGN                            = 131
	TK_FROM                               = 141
	TK_FUNCTION                           = 171
	TK_GENERATED                          = 95
	TK_GROUP                              = 145
	TK_GROUPS                             = 92
	TK_HAVING                             = 146
	TK_IF                                 = 18
	TK_IF_NULL_ROW                        = 178
	TK_IGNORE                             = 63
	TK_IMMEDIATE                          = 8
	TK_IN                                 = 49
	TK_INDEX                              = 160
	TK_INDEXED                            = 115
	TK_INITIALLY                          = 64
	TK_INSERT                             = 126
	TK_INSTEAD                            = 65
	TK_INTERSECT                          = 136
	TK_INTO                               = 150
	TK_IS                                 = 45
	TK_ISNOT                              = 170
	TK_ISNULL                             = 50
	TK_JOIN                               = 142
	TK_JOIN_KW                            = 117
	TK_KEY                                = 67
	TK_LAST                               = 84
	TK_LIKE_KW                            = 47
	TK_LIMIT                              = 147
	TK_MATCH                              = 46
	TK_MATERIALIZED                       = 97
	TK_NO                                 = 66
	TK_NOT                                = 19
	TK_NOTHING                            = 151
	TK_NOTNULL                            = 51
	TK_NULL                               = 120
	TK_NULLS                              = 82
	TK_OF                                 = 68
	TK_OFFSET                             = 69
	TK_ON                                 = 114
	TK_OR                                 = 43
	TK_ORDER                              = 144
	TK_OTHERS                             = 93
	TK_OVER                               = 164
	TK_PARTITION                          = 87
	TK_PLAN                               = 4
	TK_PRAGMA                             = 70
	TK_PRECEDING                          = 88
	TK_PRIMARY                            = 121
	TK_QUERY                              = 3
	TK_RAISE                              = 71
	TK_RANGE                              = 89
	TK_RECURSIVE                          = 72
	TK_REFERENCES                         = 124
	TK_REGISTER                           = 175
	TK_REINDEX                            = 98
	TK_RELEASE                            = 14
	TK_RENAME                             = 99
	TK_REPLACE                            = 73
	TK_RESTRICT                           = 74
	TK_RETURNING                          = 149
	TK_ROLLBACK                           = 12
	TK_ROW                                = 75
	TK_ROWS                               = 76
	TK_SAVEPOINT                          = 13
	TK_SELECT                             = 137
	TK_SELECT_COLUMN                      = 177
	TK_SET                                = 129
	TK_SPAN                               = 180
	TK_TABLE                              = 16
	TK_TEMP                               = 21
	TK_THEN                               = 158
	TK_TIES                               = 94
	TK_TO                                 = 15
	TK_TRANSACTION                        = 6
	TK_TRIGGER                            = 77
	TK_TRUEFALSE                          = 169
	TK_TRUTH                              = 174
	TK_UMINUS                             = 172
	TK_UNBOUNDED                          = 90
	TK_UNION                              = 133
	TK_UNIQUE                             = 122
	TK_UPDATE                             = 128
	TK_UPLUS                              = 173
	TK_USING                              = 143
	TK_VACUUM                             = 78
	TK_VALUES                             = 138
	TK_VECTOR                             = 176
	TK_VIEW                               = 79
	TK_VIRTUAL                            = 80
	TK_WHEN                               = 157
	TK_WHERE                              = 148
	TK_WINDOW                             = 163
	TK_WITH                               = 81
	TK_WITHOUT                            = 25
	TRIGGER_AFTER                         = 2
	TRIGGER_BEFORE                        = 1
	UINT16_MAX                            = 65535
	UINT16_WIDTH                          = 16
	UINT32_MAX                            = 4294967295
	UINT32_WIDTH                          = 32
	UINT64_MAX                            = 18446744073709551615
	UINT64_WIDTH                          = 64
	UINT8_MAX                             = 255
	UINT8_WIDTH                           = 8
	UINTMAX_MAX                           = 18446744073709551615
	UINTMAX_WIDTH                         = 64
	UINTPTR_MAX                           = 4294967295
	UINTPTR_WIDTH                         = 32
	UINT_FAST16_MAX                       = 4294967295
	UINT_FAST16_WIDTH                     = 32
	UINT_FAST32_MAX                       = 4294967295
	UINT_FAST32_WIDTH                     = 32
	UINT_FAST64_MAX                       = 18446744073709551615
	UINT_FAST64_WIDTH                     = 64
	UINT_FAST8_MAX                        = 255
	UINT_FAST8_WIDTH                      = 8
	UINT_LEAST16_MAX                      = 65535
	UINT_LEAST16_WIDTH                    = 16
	UINT_LEAST32_MAX                      = 4294967295
	UINT_LEAST32_WIDTH                    = 32
	UINT_LEAST64_MAX                      = 18446744073709551615
	UINT_LEAST64_WIDTH                    = 64
	UINT_LEAST8_MAX                       = 255
	UINT_LEAST8_WIDTH                     = 8
	VDBE_DISPLAY_P4                       = 1
	VDBE_MAGIC_DEAD                       = 0x5606c3c8
	VDBE_MAGIC_HALT                       = 0x319c2973
	VDBE_MAGIC_INIT                       = 0x16bceaa5
	VDBE_MAGIC_RESET                      = 0x48fa9f76
	VDBE_MAGIC_RUN                        = 0x2df20da3
	WCHAR_MAX                             = 4294967295
	WCHAR_MIN                             = 0
	WCHAR_WIDTH                           = 32
	WHERE_AGG_DISTINCT                    = 0x0400
	WHERE_DISTINCTBY                      = 0x0080
	WHERE_DISTINCT_NOOP                   = 0
	WHERE_DISTINCT_ORDERED                = 2
	WHERE_DISTINCT_UNIQUE                 = 1
	WHERE_DISTINCT_UNORDERED              = 3
	WHERE_DUPLICATES_OK                   = 0x0010
	WHERE_GROUPBY                         = 0x0040
	WHERE_ONEPASS_DESIRED                 = 0x0004
	WHERE_ONEPASS_MULTIROW                = 0x0008
	WHERE_ORDERBY_LIMIT                   = 0x0800
	WHERE_ORDERBY_MAX                     = 0x0002
	WHERE_ORDERBY_MIN                     = 0x0001
	WHERE_ORDERBY_NORMAL                  = 0x0000
	WHERE_OR_SUBCLAUSE                    = 0x0020
	WHERE_SORTBYGROUP                     = 0x0200
	WHERE_USE_LIMIT                       = 0x4000
	WHERE_WANT_DISTINCT                   = 0x0100
	WINT_MAX                              = 4294967295
	WINT_MIN                              = 0
	WINT_WIDTH                            = 32
	WRC_Abort                             = 2
	WRC_Continue                          = 0
	WRC_Prune                             = 1
	XN_EXPR                               = -2
	XN_ROWID                              = -1
	X_BITS_STDINT_UINTN_H                 = 1
	X_BITS_WCHAR_H                        = 1
	X_GCC_WRAP_STDINT_H                   = 0
	X_GNU_SOURCE                          = 0
	X_INTTYPES_H                          = 1
	X_ISOC11_SOURCE                       = 1
	X_ISOC95_SOURCE                       = 1
	X_ISOC99_SOURCE                       = 1
	X_LARGEFILE64_SOURCE                  = 1
	X_LARGEFILE_SOURCE                    = 1
	X_LARGE_FILE                          = 1
	X_SQLITE_OS_H_                        = 0
	X_STDINT_H                            = 1
	X_SYS_RESOURCE_H                      = 1
	X_XOPEN_SOURCE                        = 700
	X_XOPEN_SOURCE_EXTENDED               = 1
	BTCF_AtLast                           = 0x08
	BTCF_Incrblob                         = 0x10
	BTCF_Multiple                         = 0x20
	BTCF_Pinned                           = 0x40
	BTCF_ValidNKey                        = 0x02
	BTCF_ValidOvfl                        = 0x04
	BTCF_WriteFlag                        = 0x01
	BTCURSOR_MAX_DEPTH                    = 20
	BTS_EXCLUSIVE                         = 0x0040
	BTS_FAST_SECURE                       = 0x000c
	BTS_INITIALLY_EMPTY                   = 0x0010
	BTS_NO_WAL                            = 0x0020
	BTS_OVERWRITE                         = 0x0008
	BTS_PAGESIZE_FIXED                    = 0x0002
	BTS_PENDING                           = 0x0080
	BTS_READ_ONLY                         = 0x0001
	BTS_SECURE_DELETE                     = 0x0004
	CURSOR_FAULT                          = 4
	CURSOR_INVALID                        = 1
	CURSOR_REQUIRESEEK                    = 3
	CURSOR_SKIPNEXT                       = 2
	CURSOR_VALID                          = 0
	PTF_INTKEY                            = 0x01
	PTF_LEAF                              = 0x08
	PTF_LEAFDATA                          = 0x04
	PTF_ZERODATA                          = 0x02
	PTRMAP_BTREE                          = 5
	PTRMAP_FREEPAGE                       = 2
	PTRMAP_OVERFLOW1                      = 3
	PTRMAP_OVERFLOW2                      = 4
	PTRMAP_ROOTPAGE                       = 1
	READ_LOCK                             = 1
	SQLITE_FILE_HEADER                    = "SQLite format 3"
	TRANS_NONE                            = 0
	TRANS_READ                            = 1
	TRANS_WRITE                           = 2
	WRITE_LOCK                            = 2
	ADJ_ESTERROR                          = 0x0008
	ADJ_FREQUENCY                         = 0x0002
	ADJ_MAXERROR                          = 0x0004
	ADJ_MICRO                             = 0x1000
	ADJ_NANO                              = 0x2000
	ADJ_OFFSET                            = 0x0001
	ADJ_OFFSET_SINGLESHOT                 = 0x8001
	ADJ_OFFSET_SS_READ                    = 0xa001
	ADJ_SETOFFSET                         = 0x0100
	ADJ_STATUS                            = 0x0010
	ADJ_TAI                               = 0x0080
	ADJ_TICK                              = 0x4000
	ADJ_TIMECONST                         = 0x0020
	CLONE_CHILD_CLEARTID                  = 0x00200000
	CLONE_CHILD_SETTID                    = 0x01000000
	CLONE_DETACHED                        = 0x00400000
	CLONE_FILES                           = 0x00000400
	CLONE_FS                              = 0x00000200
	CLONE_IO                              = 0x80000000
	CLONE_NEWCGROUP                       = 0x02000000
	CLONE_NEWIPC                          = 0x08000000
	CLONE_NEWNET                          = 0x40000000
	CLONE_NEWNS                           = 0x00020000
	CLONE_NEWPID                          = 0x20000000
	CLONE_NEWUSER                         = 0x10000000
	CLONE_NEWUTS                          = 0x04000000
	CLONE_PARENT                          = 0x00008000
	CLONE_PARENT_SETTID                   = 0x00100000
	CLONE_PTRACE                          = 0x00002000
	CLONE_SETTLS                          = 0x00080000
	CLONE_SIGHAND                         = 0x00000800
	CLONE_SYSVSEM                         = 0x00040000
	CLONE_THREAD                          = 0x00010000
	CLONE_UNTRACED                        = 0x00800000
	CLONE_VFORK                           = 0x00004000
	CLONE_VM                              = 0x00000100
	CPU_SETSIZE                           = 1024
	CSIGNAL                               = 0x000000ff
	MOD_CLKA                              = 32769
	MOD_CLKB                              = 16384
	MOD_ESTERROR                          = 8
	MOD_FREQUENCY                         = 2
	MOD_MAXERROR                          = 4
	MOD_MICRO                             = 4096
	MOD_NANO                              = 8192
	MOD_OFFSET                            = 1
	MOD_STATUS                            = 16
	MOD_TAI                               = 128
	MOD_TIMECONST                         = 32
	N_THREAD                              = 26
	PTHREAD_BARRIER_SERIAL_THREAD         = -1
	PTHREAD_ONCE_INIT                     = 0
	SCHED_BATCH                           = 3
	SCHED_DEADLINE                        = 6
	SCHED_FIFO                            = 1
	SCHED_IDLE                            = 5
	SCHED_ISO                             = 4
	SCHED_OTHER                           = 0
	SCHED_RESET_ON_FORK                   = 0x40000000
	SCHED_RR                              = 2
	STA_CLK                               = 0x8000
	STA_CLOCKERR                          = 0x1000
	STA_DEL                               = 0x0020
	STA_FLL                               = 0x0008
	STA_FREQHOLD                          = 0x0080
	STA_INS                               = 0x0010
	STA_MODE                              = 0x4000
	STA_NANO                              = 0x2000
	STA_PLL                               = 0x0001
	STA_PPSERROR                          = 0x0800
	STA_PPSFREQ                           = 0x0002
	STA_PPSJITTER                         = 0x0200
	STA_PPSSIGNAL                         = 0x0100
	STA_PPSTIME                           = 0x0004
	STA_PPSWANDER                         = 0x0400
	STA_RONLY                             = 65280
	STA_UNSYNC                            = 0x0040
	X_BITS_CPU_SET_H                      = 1
	X_BITS_SCHED_H                        = 1
	X_BITS_SETJMP_H                       = 1
	X_BITS_TIMEX_H                        = 1
	X_BITS_TYPES_STRUCT_SCHED_PARAM       = 1
	X_PTHREAD_H                           = 1
	X_SCHED_H                             = 1
	TCL_THREADS                           = 0
	MX_CHUNK_NUMBER                       = 299
	SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET   = 400
	SQLITE_MULTIPLEX_WAL_8_3_OFFSET       = 700
	DEVSYM_MAX_PATHNAME                   = 512
	DEVSYM_VFS_NAME                       = "devsym"
	WRITECRASH_NAME                       = "writecrash"
	AT_EMPTY_PATH                         = 0x1000
	AT_NO_AUTOMOUNT                       = 0x800
	AT_STATX_DONT_SYNC                    = 0x4000
	AT_STATX_FORCE_SYNC                   = 0x2000
	AT_STATX_SYNC_AS_STAT                 = 0x0000
	AT_STATX_SYNC_TYPE                    = 0x6000
	DN_ACCESS                             = 0x00000001
	DN_ATTRIB                             = 0x00000020
	DN_CREATE                             = 0x00000004
	DN_DELETE                             = 0x00000008
	DN_MODIFY                             = 0x00000002
	DN_MULTISHOT                          = 0x80000000
	DN_RENAME                             = 0x00000010
	FALLOC_FL_COLLAPSE_RANGE              = 0x08
	FALLOC_FL_INSERT_RANGE                = 0x20
	FALLOC_FL_KEEP_SIZE                   = 0x01
	FALLOC_FL_NO_HIDE_STALE               = 0x04
	FALLOC_FL_PUNCH_HOLE                  = 0x02
	FALLOC_FL_UNSHARE_RANGE               = 0x40
	FALLOC_FL_ZERO_RANGE                  = 0x10
	F_ADD_SEALS                           = 1033
	F_GETLEASE                            = 1025
	F_GETOWN_EX                           = 16
	F_GETPIPE_SZ                          = 1032
	F_GETSIG                              = 11
	F_GET_FILE_RW_HINT                    = 1037
	F_GET_RW_HINT                         = 1035
	F_GET_SEALS                           = 1034
	F_NOTIFY                              = 1026
	F_OFD_GETLK                           = 36
	F_OFD_SETLK                           = 37
	F_OFD_SETLKW                          = 38
	F_SEAL_GROW                           = 0x0004
	F_SEAL_SEAL                           = 0x0001
	F_SEAL_SHRINK                         = 0x0002
	F_SEAL_WRITE                          = 0x0008
	F_SETLEASE                            = 1024
	F_SETOWN_EX                           = 15
	F_SETPIPE_SZ                          = 1031
	F_SETSIG                              = 10
	F_SET_FILE_RW_HINT                    = 1038
	F_SET_RW_HINT                         = 1036
	LOCK_MAND                             = 32
	LOCK_READ                             = 64
	LOCK_RW                               = 192
	LOCK_WRITE                            = 128
	MAX_HANDLE_SZ                         = 128
	O_DIRECT                              = 65536
	O_LARGEFILE                           = 131072
	O_NOATIME                             = 262144
	O_PATH                                = 2097152
	O_TMPFILE                             = 4210688
	RWF_WRITE_LIFE_NOT_SET                = 0
	RWH_WRITE_LIFE_EXTREME                = 5
	RWH_WRITE_LIFE_LONG                   = 4
	RWH_WRITE_LIFE_MEDIUM                 = 3
	RWH_WRITE_LIFE_NONE                   = 1
	RWH_WRITE_LIFE_SHORT                  = 2
	SPLICE_F_GIFT                         = 8
	SPLICE_F_MORE                         = 4
	SPLICE_F_MOVE                         = 1
	SPLICE_F_NONBLOCK                     = 2
	STATX_ALL                             = 0x0fff
	STATX_ATIME                           = 0x0020
	STATX_ATTR_APPEND                     = 0x0020
	STATX_ATTR_AUTOMOUNT                  = 0x1000
	STATX_ATTR_COMPRESSED                 = 0x0004
	STATX_ATTR_ENCRYPTED                  = 0x0800
	STATX_ATTR_IMMUTABLE                  = 0x0010
	STATX_ATTR_NODUMP                     = 0x0040
	STATX_BASIC_STATS                     = 0x07ff
	STATX_BLOCKS                          = 0x0400
	STATX_BTIME                           = 0x0800
	STATX_CTIME                           = 0x0080
	STATX_GID                             = 0x0010
	STATX_INO                             = 0x0100
	STATX_MODE                            = 0x0002
	STATX_MTIME                           = 0x0040
	STATX_NLINK                           = 0x0004
	STATX_SIZE                            = 0x0200
	STATX_TYPE                            = 0x0001
	STATX_UID                             = 0x0008
	STATX__RESERVED                       = 0x80000000
	SYNC_FILE_RANGE_WAIT_AFTER            = 4
	SYNC_FILE_RANGE_WAIT_BEFORE           = 1
	SYNC_FILE_RANGE_WRITE                 = 2
	X_FALLOC_H_                           = 0
	X_POSIX_FD_SETSIZE                    = 20
	X_POSIX_HIWAT                         = 512
	X_POSIX_QLIMIT                        = 1
	X_POSIX_UIO_MAXIOV                    = 16
	SQLITE_INTARRAY_H                     = 0
	JT_MAX_PATHNAME                       = 512
	JT_VFS_NAME                           = "jt"
	MALLOC_LOG_FRAMES                     = 10
	DEFAULT_SECTOR_SIZE                   = 0x1000
	MAX_PAGE_SIZE                         = 0x10000
	MULTIPLEX_CTRL_ENABLE                 = 214014
	MULTIPLEX_CTRL_SET_CHUNK_SIZE         = 214015
	MULTIPLEX_CTRL_SET_MAX_CHUNKS         = 214016
	SQLITE_MULTIPLEX_CHUNK_SIZE           = 2147418112
	SQLITE_MULTIPLEX_MAX_CHUNKS           = 12
	SQLITE_MULTIPLEX_VFS_NAME             = "multiplex"
	SQLITE_TEST_MULTIPLEX_H               = 0
	MAX_MUTEXES                           = 14
	STATIC_MUTEXES                        = 12
	BLOBSIZE                              = 10485760
	BLOCKSIZE                             = 512
	DATABASE_FILE                         = 1
	FS_VFS_NAME                           = "fs"
	JOURNAL_FILE                          = 2
	INST_MAX_PATHNAME                     = 512
	OS_ACCESS                             = 1
	OS_ANNOTATE                           = 28
	OS_CHECKRESERVEDLOCK                  = 2
	OS_CLOSE                              = 3
	OS_CURRENTTIME                        = 4
	OS_DELETE                             = 5
	OS_DEVCHAR                            = 6
	OS_FILECONTROL                        = 7
	OS_FILESIZE                           = 8
	OS_FULLPATHNAME                       = 9
	OS_LOCK                               = 11
	OS_NUMEVENTS                          = 29
	OS_OPEN                               = 12
	OS_RANDOMNESS                         = 13
	OS_READ                               = 14
	OS_SECTORSIZE                         = 15
	OS_SHMBARRIER                         = 26
	OS_SHMLOCK                            = 25
	OS_SHMMAP                             = 23
	OS_SHMUNMAP                           = 22
	OS_SLEEP                              = 16
	OS_SYNC                               = 17
	OS_TRUNCATE                           = 18
	OS_UNLOCK                             = 19
	OS_WRITE                              = 20
	VFSLOG_BUFFERSIZE                     = 8192
	TESTPCACHE_CLEAR                      = 0xd42670d4
	TESTPCACHE_NPAGE                      = 217
	TESTPCACHE_RESERVE                    = 17
	TESTPCACHE_VALID                      = 0x364585fd
	MSG_Close                             = 6
	MSG_Done                              = 7
	MSG_Finalize                          = 5
	MSG_Open                              = 1
	MSG_Prepare                           = 2
	MSG_Reset                             = 4
	MSG_Step                              = 3
	MADV_DODUMP                           = 17
	MADV_DOFORK                           = 11
	MADV_DONTDUMP                         = 16
	MADV_DONTFORK                         = 10
	MADV_DONTNEED                         = 4
	MADV_FREE                             = 8
	MADV_HUGEPAGE                         = 14
	MADV_HWPOISON                         = 100
	MADV_KEEPONFORK                       = 19
	MADV_MERGEABLE                        = 12
	MADV_NOHUGEPAGE                       = 15
	MADV_NORMAL                           = 0
	MADV_RANDOM                           = 1
	MADV_REMOVE                           = 9
	MADV_SEQUENTIAL                       = 2
	MADV_UNMERGEABLE                      = 13
	MADV_WILLNEED                         = 3
	MADV_WIPEONFORK                       = 18
	MAP_ANON                              = 32
	MAP_ANONYMOUS                         = 0x20
	MAP_DENYWRITE                         = 0x00800
	MAP_EXECUTABLE                        = 0x01000
	MAP_FILE                              = 0
	MAP_FIXED                             = 0x10
	MAP_FIXED_NOREPLACE                   = 0x100000
	MAP_GROWSDOWN                         = 0x00100
	MAP_HUGETLB                           = 0x40000
	MAP_HUGE_MASK                         = 0x3f
	MAP_HUGE_SHIFT                        = 26
	MAP_LOCKED                            = 0x02000
	MAP_NONBLOCK                          = 0x10000
	MAP_NORESERVE                         = 0x04000
	MAP_POPULATE                          = 0x08000
	MAP_PRIVATE                           = 0x02
	MAP_SHARED                            = 0x01
	MAP_SHARED_VALIDATE                   = 0x03
	MAP_STACK                             = 0x20000
	MAP_SYNC                              = 0x80000
	MAP_TYPE                              = 0x0f
	MCL_CURRENT                           = 1
	MCL_FUTURE                            = 2
	MCL_ONFAULT                           = 4
	MFD_ALLOW_SEALING                     = 2
	MFD_CLOEXEC                           = 1
	MFD_HUGETLB                           = 4
	MLOCK_ONFAULT                         = 1
	MREMAP_FIXED                          = 2
	MREMAP_MAYMOVE                        = 1
	MS_ASYNC                              = 1
	MS_INVALIDATE                         = 2
	MS_SYNC                               = 4
	PKEY_DISABLE_ACCESS                   = 0x1
	PKEY_DISABLE_WRITE                    = 0x2
	POSIX_MADV_DONTNEED                   = 4
	POSIX_MADV_NORMAL                     = 0
	POSIX_MADV_RANDOM                     = 1
	POSIX_MADV_SEQUENTIAL                 = 2
	POSIX_MADV_WILLNEED                   = 3
	PROT_EXEC                             = 0x4
	PROT_GROWSDOWN                        = 0x01000000
	PROT_GROWSUP                          = 0x02000000
	PROT_NONE                             = 0x0
	PROT_READ                             = 0x1
	PROT_WRITE                            = 0x2
	X_SYS_MMAN_H                          = 1
	TCLVAR_NAME_EQ                        = 101
	TCLVAR_NAME_MATCH                     = 109
	TCLVAR_VALUE_GLOB                     = 103
	TCLVAR_VALUE_LIKE                     = 108
	TCLVAR_VALUE_REGEXP                   = 114
	FAULT_INJECT_NONE                     = 0
	FAULT_INJECT_PERSISTENT               = 2
	FAULT_INJECT_TRANSIENT                = 1
	TESTVFS_ACCESS_MASK                   = 0x00004000
	TESTVFS_ALL_MASK                      = 0x001FFFFF
	TESTVFS_CKLOCK_MASK                   = 0x00080000
	TESTVFS_CLOSE_MASK                    = 0x00000800
	TESTVFS_DELETE_MASK                   = 0x00000400
	TESTVFS_FCNTL_MASK                    = 0x00100000
	TESTVFS_FULLPATHNAME_MASK             = 0x00008000
	TESTVFS_LOCK_MASK                     = 0x00040000
	TESTVFS_MAX_ARGS                      = 12
	TESTVFS_MAX_PAGES                     = 1024
	TESTVFS_OPEN_MASK                     = 0x00000100
	TESTVFS_READ_MASK                     = 0x00010000
	TESTVFS_SHMBARRIER_MASK               = 0x00000040
	TESTVFS_SHMCLOSE_MASK                 = 0x00000080
	TESTVFS_SHMLOCK_MASK                  = 0x00000010
	TESTVFS_SHMMAP_MASK                   = 0x00000020
	TESTVFS_SHMOPEN_MASK                  = 0x00000001
	TESTVFS_SYNC_MASK                     = 0x00000200
	TESTVFS_TRUNCATE_MASK                 = 0x00002000
	TESTVFS_UNLOCK_MASK                   = 0x00020000
	TESTVFS_WRITE_MASK                    = 0x00001000
)

// Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
//    the `_SC_*' symbols for the NAME argument to `sysconf';
//    and the `_CS_*' symbols for the NAME argument to `confstr'.
// `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
//    Copyright (C) 1993-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Values for the NAME argument to `pathconf' and `fpathconf'.
const ( /* confname.h:24:1: */
	_PC_LINK_MAX           = 0
	_PC_MAX_CANON          = 1
	_PC_MAX_INPUT          = 2
	_PC_NAME_MAX           = 3
	_PC_PATH_MAX           = 4
	_PC_PIPE_BUF           = 5
	_PC_CHOWN_RESTRICTED   = 6
	_PC_NO_TRUNC           = 7
	_PC_VDISABLE           = 8
	_PC_SYNC_IO            = 9
	_PC_ASYNC_IO           = 10
	_PC_PRIO_IO            = 11
	_PC_SOCK_MAXBUF        = 12
	_PC_FILESIZEBITS       = 13
	_PC_REC_INCR_XFER_SIZE = 14
	_PC_REC_MAX_XFER_SIZE  = 15
	_PC_REC_MIN_XFER_SIZE  = 16
	_PC_REC_XFER_ALIGN     = 17
	_PC_ALLOC_SIZE_MIN     = 18
	_PC_SYMLINK_MAX        = 19
	_PC_2_SYMLINKS         = 20
)

// Values for the NAME argument to `confstr'.
const ( /* confname.h:533:1: */
	_CS_PATH = 0 // The default search path.

	_CS_V6_WIDTH_RESTRICTED_ENVS = 1

	_CS_GNU_LIBC_VERSION       = 2
	_CS_GNU_LIBPTHREAD_VERSION = 3

	_CS_V5_WIDTH_RESTRICTED_ENVS = 4

	_CS_V7_WIDTH_RESTRICTED_ENVS = 5

	_CS_LFS_CFLAGS      = 1000
	_CS_LFS_LDFLAGS     = 1001
	_CS_LFS_LIBS        = 1002
	_CS_LFS_LINTFLAGS   = 1003
	_CS_LFS64_CFLAGS    = 1004
	_CS_LFS64_LDFLAGS   = 1005
	_CS_LFS64_LIBS      = 1006
	_CS_LFS64_LINTFLAGS = 1007

	_CS_XBS5_ILP32_OFF32_CFLAGS     = 1100
	_CS_XBS5_ILP32_OFF32_LDFLAGS    = 1101
	_CS_XBS5_ILP32_OFF32_LIBS       = 1102
	_CS_XBS5_ILP32_OFF32_LINTFLAGS  = 1103
	_CS_XBS5_ILP32_OFFBIG_CFLAGS    = 1104
	_CS_XBS5_ILP32_OFFBIG_LDFLAGS   = 1105
	_CS_XBS5_ILP32_OFFBIG_LIBS      = 1106
	_CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107
	_CS_XBS5_LP64_OFF64_CFLAGS      = 1108
	_CS_XBS5_LP64_OFF64_LDFLAGS     = 1109
	_CS_XBS5_LP64_OFF64_LIBS        = 1110
	_CS_XBS5_LP64_OFF64_LINTFLAGS   = 1111
	_CS_XBS5_LPBIG_OFFBIG_CFLAGS    = 1112
	_CS_XBS5_LPBIG_OFFBIG_LDFLAGS   = 1113
	_CS_XBS5_LPBIG_OFFBIG_LIBS      = 1114
	_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115

	_CS_POSIX_V6_ILP32_OFF32_CFLAGS     = 1116
	_CS_POSIX_V6_ILP32_OFF32_LDFLAGS    = 1117
	_CS_POSIX_V6_ILP32_OFF32_LIBS       = 1118
	_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS  = 1119
	_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS    = 1120
	_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS   = 1121
	_CS_POSIX_V6_ILP32_OFFBIG_LIBS      = 1122
	_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123
	_CS_POSIX_V6_LP64_OFF64_CFLAGS      = 1124
	_CS_POSIX_V6_LP64_OFF64_LDFLAGS     = 1125
	_CS_POSIX_V6_LP64_OFF64_LIBS        = 1126
	_CS_POSIX_V6_LP64_OFF64_LINTFLAGS   = 1127
	_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS    = 1128
	_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS   = 1129
	_CS_POSIX_V6_LPBIG_OFFBIG_LIBS      = 1130
	_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131

	_CS_POSIX_V7_ILP32_OFF32_CFLAGS     = 1132
	_CS_POSIX_V7_ILP32_OFF32_LDFLAGS    = 1133
	_CS_POSIX_V7_ILP32_OFF32_LIBS       = 1134
	_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS  = 1135
	_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS    = 1136
	_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS   = 1137
	_CS_POSIX_V7_ILP32_OFFBIG_LIBS      = 1138
	_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139
	_CS_POSIX_V7_LP64_OFF64_CFLAGS      = 1140
	_CS_POSIX_V7_LP64_OFF64_LDFLAGS     = 1141
	_CS_POSIX_V7_LP64_OFF64_LIBS        = 1142
	_CS_POSIX_V7_LP64_OFF64_LINTFLAGS   = 1143
	_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS    = 1144
	_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS   = 1145
	_CS_POSIX_V7_LPBIG_OFFBIG_LIBS      = 1146
	_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147

	_CS_V6_ENV = 1148
	_CS_V7_ENV = 1149
)

// Values for the argument to `sysconf'.
const ( /* confname.h:71:1: */
	_SC_ARG_MAX               = 0
	_SC_CHILD_MAX             = 1
	_SC_CLK_TCK               = 2
	_SC_NGROUPS_MAX           = 3
	_SC_OPEN_MAX              = 4
	_SC_STREAM_MAX            = 5
	_SC_TZNAME_MAX            = 6
	_SC_JOB_CONTROL           = 7
	_SC_SAVED_IDS             = 8
	_SC_REALTIME_SIGNALS      = 9
	_SC_PRIORITY_SCHEDULING   = 10
	_SC_TIMERS                = 11
	_SC_ASYNCHRONOUS_IO       = 12
	_SC_PRIORITIZED_IO        = 13
	_SC_SYNCHRONIZED_IO       = 14
	_SC_FSYNC                 = 15
	_SC_MAPPED_FILES          = 16
	_SC_MEMLOCK               = 17
	_SC_MEMLOCK_RANGE         = 18
	_SC_MEMORY_PROTECTION     = 19
	_SC_MESSAGE_PASSING       = 20
	_SC_SEMAPHORES            = 21
	_SC_SHARED_MEMORY_OBJECTS = 22
	_SC_AIO_LISTIO_MAX        = 23
	_SC_AIO_MAX               = 24
	_SC_AIO_PRIO_DELTA_MAX    = 25
	_SC_DELAYTIMER_MAX        = 26
	_SC_MQ_OPEN_MAX           = 27
	_SC_MQ_PRIO_MAX           = 28
	_SC_VERSION               = 29
	_SC_PAGESIZE              = 30
	_SC_RTSIG_MAX             = 31
	_SC_SEM_NSEMS_MAX         = 32
	_SC_SEM_VALUE_MAX         = 33
	_SC_SIGQUEUE_MAX          = 34
	_SC_TIMER_MAX             = 35

	// Values for the argument to `sysconf'
	//        corresponding to _POSIX2_* symbols.
	_SC_BC_BASE_MAX        = 36
	_SC_BC_DIM_MAX         = 37
	_SC_BC_SCALE_MAX       = 38
	_SC_BC_STRING_MAX      = 39
	_SC_COLL_WEIGHTS_MAX   = 40
	_SC_EQUIV_CLASS_MAX    = 41
	_SC_EXPR_NEST_MAX      = 42
	_SC_LINE_MAX           = 43
	_SC_RE_DUP_MAX         = 44
	_SC_CHARCLASS_NAME_MAX = 45

	_SC_2_VERSION   = 46
	_SC_2_C_BIND    = 47
	_SC_2_C_DEV     = 48
	_SC_2_FORT_DEV  = 49
	_SC_2_FORT_RUN  = 50
	_SC_2_SW_DEV    = 51
	_SC_2_LOCALEDEF = 52

	_SC_PII                 = 53
	_SC_PII_XTI             = 54
	_SC_PII_SOCKET          = 55
	_SC_PII_INTERNET        = 56
	_SC_PII_OSI             = 57
	_SC_POLL                = 58
	_SC_SELECT              = 59
	_SC_UIO_MAXIOV          = 60
	_SC_IOV_MAX             = 60
	_SC_PII_INTERNET_STREAM = 61
	_SC_PII_INTERNET_DGRAM  = 62
	_SC_PII_OSI_COTS        = 63
	_SC_PII_OSI_CLTS        = 64
	_SC_PII_OSI_M           = 65
	_SC_T_IOV_MAX           = 66

	// Values according to POSIX 1003.1c (POSIX threads).
	_SC_THREADS                      = 67
	_SC_THREAD_SAFE_FUNCTIONS        = 68
	_SC_GETGR_R_SIZE_MAX             = 69
	_SC_GETPW_R_SIZE_MAX             = 70
	_SC_LOGIN_NAME_MAX               = 71
	_SC_TTY_NAME_MAX                 = 72
	_SC_THREAD_DESTRUCTOR_ITERATIONS = 73
	_SC_THREAD_KEYS_MAX              = 74
	_SC_THREAD_STACK_MIN             = 75
	_SC_THREAD_THREADS_MAX           = 76
	_SC_THREAD_ATTR_STACKADDR        = 77
	_SC_THREAD_ATTR_STACKSIZE        = 78
	_SC_THREAD_PRIORITY_SCHEDULING   = 79
	_SC_THREAD_PRIO_INHERIT          = 80
	_SC_THREAD_PRIO_PROTECT          = 81
	_SC_THREAD_PROCESS_SHARED        = 82

	_SC_NPROCESSORS_CONF = 83
	_SC_NPROCESSORS_ONLN = 84
	_SC_PHYS_PAGES       = 85
	_SC_AVPHYS_PAGES     = 86
	_SC_ATEXIT_MAX       = 87
	_SC_PASS_MAX         = 88

	_SC_XOPEN_VERSION     = 89
	_SC_XOPEN_XCU_VERSION = 90
	_SC_XOPEN_UNIX        = 91
	_SC_XOPEN_CRYPT       = 92
	_SC_XOPEN_ENH_I18N    = 93
	_SC_XOPEN_SHM         = 94

	_SC_2_CHAR_TERM = 95
	_SC_2_C_VERSION = 96
	_SC_2_UPE       = 97

	_SC_XOPEN_XPG2 = 98
	_SC_XOPEN_XPG3 = 99
	_SC_XOPEN_XPG4 = 100

	_SC_CHAR_BIT   = 101
	_SC_CHAR_MAX   = 102
	_SC_CHAR_MIN   = 103
	_SC_INT_MAX    = 104
	_SC_INT_MIN    = 105
	_SC_LONG_BIT   = 106
	_SC_WORD_BIT   = 107
	_SC_MB_LEN_MAX = 108
	_SC_NZERO      = 109
	_SC_SSIZE_MAX  = 110
	_SC_SCHAR_MAX  = 111
	_SC_SCHAR_MIN  = 112
	_SC_SHRT_MAX   = 113
	_SC_SHRT_MIN   = 114
	_SC_UCHAR_MAX  = 115
	_SC_UINT_MAX   = 116
	_SC_ULONG_MAX  = 117
	_SC_USHRT_MAX  = 118

	_SC_NL_ARGMAX  = 119
	_SC_NL_LANGMAX = 120
	_SC_NL_MSGMAX  = 121
	_SC_NL_NMAX    = 122
	_SC_NL_SETMAX  = 123
	_SC_NL_TEXTMAX = 124

	_SC_XBS5_ILP32_OFF32  = 125
	_SC_XBS5_ILP32_OFFBIG = 126
	_SC_XBS5_LP64_OFF64   = 127
	_SC_XBS5_LPBIG_OFFBIG = 128

	_SC_XOPEN_LEGACY           = 129
	_SC_XOPEN_REALTIME         = 130
	_SC_XOPEN_REALTIME_THREADS = 131

	_SC_ADVISORY_INFO          = 132
	_SC_BARRIERS               = 133
	_SC_BASE                   = 134
	_SC_C_LANG_SUPPORT         = 135
	_SC_C_LANG_SUPPORT_R       = 136
	_SC_CLOCK_SELECTION        = 137
	_SC_CPUTIME                = 138
	_SC_THREAD_CPUTIME         = 139
	_SC_DEVICE_IO              = 140
	_SC_DEVICE_SPECIFIC        = 141
	_SC_DEVICE_SPECIFIC_R      = 142
	_SC_FD_MGMT                = 143
	_SC_FIFO                   = 144
	_SC_PIPE                   = 145
	_SC_FILE_ATTRIBUTES        = 146
	_SC_FILE_LOCKING           = 147
	_SC_FILE_SYSTEM            = 148
	_SC_MONOTONIC_CLOCK        = 149
	_SC_MULTI_PROCESS          = 150
	_SC_SINGLE_PROCESS         = 151
	_SC_NETWORKING             = 152
	_SC_READER_WRITER_LOCKS    = 153
	_SC_SPIN_LOCKS             = 154
	_SC_REGEXP                 = 155
	_SC_REGEX_VERSION          = 156
	_SC_SHELL                  = 157
	_SC_SIGNALS                = 158
	_SC_SPAWN                  = 159
	_SC_SPORADIC_SERVER        = 160
	_SC_THREAD_SPORADIC_SERVER = 161
	_SC_SYSTEM_DATABASE        = 162
	_SC_SYSTEM_DATABASE_R      = 163
	_SC_TIMEOUTS               = 164
	_SC_TYPED_MEMORY_OBJECTS   = 165
	_SC_USER_GROUPS            = 166
	_SC_USER_GROUPS_R          = 167
	_SC_2_PBS                  = 168
	_SC_2_PBS_ACCOUNTING       = 169
	_SC_2_PBS_LOCATE           = 170
	_SC_2_PBS_MESSAGE          = 171
	_SC_2_PBS_TRACK            = 172
	_SC_SYMLOOP_MAX            = 173
	_SC_STREAMS                = 174
	_SC_2_PBS_CHECKPOINT       = 175

	_SC_V6_ILP32_OFF32  = 176
	_SC_V6_ILP32_OFFBIG = 177
	_SC_V6_LP64_OFF64   = 178
	_SC_V6_LPBIG_OFFBIG = 179

	_SC_HOST_NAME_MAX      = 180
	_SC_TRACE              = 181
	_SC_TRACE_EVENT_FILTER = 182
	_SC_TRACE_INHERIT      = 183
	_SC_TRACE_LOG          = 184

	_SC_LEVEL1_ICACHE_SIZE     = 185
	_SC_LEVEL1_ICACHE_ASSOC    = 186
	_SC_LEVEL1_ICACHE_LINESIZE = 187
	_SC_LEVEL1_DCACHE_SIZE     = 188
	_SC_LEVEL1_DCACHE_ASSOC    = 189
	_SC_LEVEL1_DCACHE_LINESIZE = 190
	_SC_LEVEL2_CACHE_SIZE      = 191
	_SC_LEVEL2_CACHE_ASSOC     = 192
	_SC_LEVEL2_CACHE_LINESIZE  = 193
	_SC_LEVEL3_CACHE_SIZE      = 194
	_SC_LEVEL3_CACHE_ASSOC     = 195
	_SC_LEVEL3_CACHE_LINESIZE  = 196
	_SC_LEVEL4_CACHE_SIZE      = 197
	_SC_LEVEL4_CACHE_ASSOC     = 198
	_SC_LEVEL4_CACHE_LINESIZE  = 199
	// Leave room here, maybe we need a few more cache levels some day.

	_SC_IPV6        = 235
	_SC_RAW_SOCKETS = 236

	_SC_V7_ILP32_OFF32  = 237
	_SC_V7_ILP32_OFFBIG = 238
	_SC_V7_LP64_OFF64   = 239
	_SC_V7_LPBIG_OFFBIG = 240

	_SC_SS_REPL_MAX = 241

	_SC_TRACE_EVENT_NAME_MAX = 242
	_SC_TRACE_NAME_MAX       = 243
	_SC_TRACE_SYS_MAX        = 244
	_SC_TRACE_USER_EVENT_MAX = 245

	_SC_XOPEN_STREAMS = 246

	_SC_THREAD_ROBUST_PRIO_INHERIT = 247
	_SC_THREAD_ROBUST_PRIO_PROTECT = 248
)

// open/fcntl.

// open file description locks.
//
//    Usually record locks held by a process are released on *any* close and are
//    not inherited across a fork.
//
//    These cmd values will set locks that conflict with process-associated record
//    locks, but are "owned" by the opened file description, not the process.
//    This means that they are inherited across fork or clone with CLONE_FILES
//    like BSD (flock) locks, and they are only released automatically when the
//    last reference to the the file description against which they were acquired
//    is put.

// For now, Linux has no separate synchronicity options for read
//    operations.  We define O_RSYNC therefore as the same as O_SYNC
//    since this is a superset.

// Values for the second argument to `fcntl'.

// Set / get write life time hints.

// For F_[GET|SET]FD.

// For posix fcntl() and `l_type' field of a `struct flock' for lockf().

// For old implementation of BSD flock.

// Operations for BSD flock, also used by the kernel implementation.

// Types of directory notifications that may be requested with F_NOTIFY.

// Owner types.
const ( /* fcntl-linux.h:265:1: */
	F_OWNER_TID  = 0 // Kernel thread.
	F_OWNER_PID  = 1 // Process.
	F_OWNER_PGRP = 2 // Process group.
	F_OWNER_GID  = 2
)

// Whose usage statistics do you want?
const ( /* resource.h:158:1: */
	// The calling process.
	RUSAGE_SELF = 0

	// All of its terminated child processes.
	RUSAGE_CHILDREN = -1
	// The calling thread.
	RUSAGE_THREAD = 1
)

// Priority limits.

// The type of the WHICH argument to `getpriority' and `setpriority',
//    indicating what flavor of entity the WHO argument specifies.
const ( /* resource.h:187:1: */
	PRIO_PROCESS = 0 // WHO is a process ID.
	PRIO_PGRP    = 1 // WHO is a process group ID.
	PRIO_USER    = 2
)

// Convenience macros for operations on timevals.
//    NOTE: `timercmp' does not work for >= or <=.

// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Get the system-dependent definitions of structures and bit values.
// Bit values & structures for resource limits.  Linux version.
//    Copyright (C) 1994-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Transmute defines to enumerations.  The macro re-definitions are
//    necessary because some programs want to test for operating system
//    features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
//    definition is a no-op.

// Kinds of resource limit.
const ( /* resource.h:31:1: */
	// Per-process CPU limit, in seconds.
	RLIMIT_CPU = 0

	// Largest file that can be created, in bytes.
	RLIMIT_FSIZE = 1

	// Maximum size of data segment, in bytes.
	RLIMIT_DATA = 2

	// Maximum size of stack segment, in bytes.
	RLIMIT_STACK = 3

	// Largest core file that can be created, in bytes.
	RLIMIT_CORE = 4

	// Largest resident set size, in bytes.
	//      This affects swapping; processes that are exceeding their
	//      resident set size will be more likely to have physical memory
	//      taken from them.
	__RLIMIT_RSS = 5

	// Number of open files.
	RLIMIT_NOFILE  = 7
	__RLIMIT_OFILE = 7 // BSD name for same.

	// Address space limit.
	RLIMIT_AS = 9

	// Number of processes.
	__RLIMIT_NPROC = 6

	// Locked-in-memory address space.
	__RLIMIT_MEMLOCK = 8

	// Maximum number of file locks.
	__RLIMIT_LOCKS = 10

	// Maximum number of pending signals.
	__RLIMIT_SIGPENDING = 11

	// Maximum bytes in POSIX message queues.
	__RLIMIT_MSGQUEUE = 12

	// Maximum nice priority allowed to raise to.
	//      Nice levels 19 .. -20 correspond to 0 .. 39
	//      values of this resource limit.
	__RLIMIT_NICE = 13

	// Maximum realtime priority allowed for non-priviledged
	//      processes.
	__RLIMIT_RTPRIO = 14

	// Maximum CPU time in s that a process scheduled under a real-time
	//      scheduling policy may consume without making a blocking system
	//      call before being forcibly descheduled.
	__RLIMIT_RTTIME = 15

	__RLIMIT_NLIMITS = 16
	__RLIM_NLIMITS   = 16
)

// POSIX names to access some of the members.

// sigevent constants.  Linux version.
//    Copyright (C) 1997-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// `sigev_notify' values.
const ( /* sigevent-consts.h:27:1: */
	SIGEV_SIGNAL = 0 // Notify via signal.
	SIGEV_NONE   = 1 // Other notification: meaningless.
	SIGEV_THREAD = 2 // Deliver via thread creation.

	SIGEV_THREAD_ID = 4
)

// `si_code' values for SIGSEGV signal.
const ( /* siginfo-consts.h:110:1: */
	SEGV_MAPERR = 1 // Address not mapped to object.
	SEGV_ACCERR = 2 // Invalid permissions for mapped object.
	SEGV_BNDERR = 3 // Bounds checking failure.
	SEGV_PKUERR = 4
)

// `si_code' values for SIGBUS signal.
const ( /* siginfo-consts.h:123:1: */
	BUS_ADRALN    = 1 // Invalid address alignment.
	BUS_ADRERR    = 2 // Non-existant physical address.
	BUS_OBJERR    = 3 // Object specific hardware error.
	BUS_MCEERR_AR = 4 // Hardware memory error: action required.
	BUS_MCEERR_AO = 5
)

// `si_code' values for SIGCHLD signal.
const ( /* siginfo-consts.h:151:1: */
	CLD_EXITED    = 1 // Child has exited.
	CLD_KILLED    = 2 // Child was killed.
	CLD_DUMPED    = 3 // Child terminated abnormally.
	CLD_TRAPPED   = 4 // Traced child has trapped.
	CLD_STOPPED   = 5 // Child has stopped.
	CLD_CONTINUED = 6
)

// `si_code' values for SIGPOLL signal.
const ( /* siginfo-consts.h:168:1: */
	POLL_IN  = 1 // Data input available.
	POLL_OUT = 2 // Output buffers available.
	POLL_MSG = 3 // Input message available.
	POLL_ERR = 4 // I/O error.
	POLL_PRI = 5 // High priority input available.
	POLL_HUP = 6
)

// X/Open requires some more fields with fixed names.

// siginfo constants.  Linux version.
//    Copyright (C) 1997-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Most of these constants are uniform across all architectures, but there
//    is one exception.
// Architecture-specific adjustments to siginfo_t.

// Values for `si_code'.  Positive values are reserved for kernel-generated
//    signals.
const ( /* siginfo-consts.h:35:1: */
	SI_ASYNCNL = -60 // Sent by asynch name lookup completion.
	SI_TKILL   = -6  // Sent by tkill.
	SI_SIGIO   = -5  // Sent by queued SIGIO.
	SI_ASYNCIO = -4  // Sent by AIO completion.
	SI_MESGQ   = -3  // Sent by real time mesq state change.
	SI_TIMER   = -2  // Sent by timer expiration.
	SI_QUEUE   = -1  // Sent by sigqueue.
	SI_USER    = 0   // Sent by kill, sigsend.
	SI_KERNEL  = 128
)

// `si_code' values for SIGILL signal.
const ( /* siginfo-consts.h:68:1: */
	ILL_ILLOPC = 1 // Illegal opcode.
	ILL_ILLOPN = 2 // Illegal operand.
	ILL_ILLADR = 3 // Illegal addressing mode.
	ILL_ILLTRP = 4 // Illegal trap.
	ILL_PRVOPC = 5 // Privileged opcode.
	ILL_PRVREG = 6 // Privileged register.
	ILL_COPROC = 7 // Coprocessor error.
	ILL_BADSTK = 8
)

// `si_code' values for SIGFPE signal.
const ( /* siginfo-consts.h:89:1: */
	FPE_INTDIV = 1 // Integer divide by zero.
	FPE_INTOVF = 2 // Integer overflow.
	FPE_FLTDIV = 3 // Floating point divide by zero.
	FPE_FLTOVF = 4 // Floating point overflow.
	FPE_FLTUND = 5 // Floating point underflow.
	FPE_FLTRES = 6 // Floating point inexact result.
	FPE_FLTINV = 7 // Floating point invalid operation.
	FPE_FLTSUB = 8
)

// sigstack, sigaltstack definitions.
//    Copyright (C) 1998-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Minimum stack size for a signal handler.

// System default stack size.

// ss_flags values for stack_t.  Linux version.
//    Copyright (C) 1998-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Possible values for `ss_flags'.
const ( /* ss_flags.h:27:1: */
	SS_ONSTACK = 1
	SS_DISABLE = 2
)

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//    which causes a conflict if the include order is reversed.

const ( /* waitflags.h:52:1: */
	P_ALL  = 0 // Wait for any child.
	P_PID  = 1 // Wait for specified process.
	P_PGID = 2
)

// Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard 7.4: Character handling	<ctype.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// These are all the characteristics of characters.
//    If there get to be more than 16 distinct characteristics,
//    many things must be changed that use `unsigned short int's.
//
//    The characteristics are stored always in network byte order (big
//    endian).  We define the bit value interpretations here dependent on the
//    machine's byte order.

// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

const ( /* ctype.h:46:1: */
	_ISupper  = 256   // UPPERCASE.
	_ISlower  = 512   // lowercase.
	_ISalpha  = 1024  // Alphabetic.
	_ISdigit  = 2048  // Numeric.
	_ISxdigit = 4096  // Hexadecimal numeric.
	_ISspace  = 8192  // Whitespace.
	_ISprint  = 16384 // Printing.
	_ISgraph  = 32768 // Graphical.
	_ISblank  = 1     // Blank (usually SPC and TAB).
	_IScntrl  = 2     // Control character.
	_ISpunct  = 4     // Punctuation.
	_ISalnum  = 8
)

// These macros extract size information from a `struct dirent *'.
//    They may evaluate their argument multiple times, so it must not
//    have side effects.  Each of these may involve a relatively costly
//    call to `strlen' on some systems, so these values should be cached.
//
//    _D_EXACT_NAMLEN (DP)	returns the length of DP->d_name, not including
//    its terminating null character.
//
//    _D_ALLOC_NAMLEN (DP)	returns a size at least (_D_EXACT_NAMLEN (DP) + 1);
//    that is, the allocation size needed to hold the DP->d_name string.
//    Use this macro when you don't need the exact length, just an upper bound.
//    This macro is less likely to require calling `strlen' than _D_EXACT_NAMLEN.
//

// File types for `d_type'.
const ( /* dirent.h:97:1: */
	DT_UNKNOWN = 0
	DT_FIFO    = 1
	DT_CHR     = 2
	DT_DIR     = 4
	DT_BLK     = 6
	DT_REG     = 8
	DT_LNK     = 10
	DT_SOCK    = 12
	DT_WHT     = 14
)

// Read-write lock types.
const ( /* pthread.h:115:1: */
	PTHREAD_RWLOCK_PREFER_READER_NP              = 0
	PTHREAD_RWLOCK_PREFER_WRITER_NP              = 1
	PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2
	PTHREAD_RWLOCK_DEFAULT_NP                    = 0
)

// Define __PTHREAD_RWLOCK_INT_FLAGS_SHARED to 1 if pthread_rwlock_t
//    has the shared field.  All 64-bit architectures have the shared field
//    in pthread_rwlock_t.

// Read-write lock initializers.

// Scheduler inheritance.
const ( /* pthread.h:156:1: */
	PTHREAD_INHERIT_SCHED  = 0
	PTHREAD_EXPLICIT_SCHED = 1
)

// Scope handling.
const ( /* pthread.h:166:1: */
	PTHREAD_SCOPE_SYSTEM  = 0
	PTHREAD_SCOPE_PROCESS = 1
)

// Process shared or private flag.
const ( /* pthread.h:176:1: */
	PTHREAD_PROCESS_PRIVATE = 0
	PTHREAD_PROCESS_SHARED  = 1
)

// Cancellation
const ( /* pthread.h:200:1: */
	PTHREAD_CANCEL_ENABLE  = 0
	PTHREAD_CANCEL_DISABLE = 1
)
const ( /* pthread.h:207:1: */
	PTHREAD_CANCEL_DEFERRED     = 0
	PTHREAD_CANCEL_ASYNCHRONOUS = 1
)

// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// NB: Include guard matches what <linux/time.h> uses.

// Detach state.
const ( /* pthread.h:33:1: */
	PTHREAD_CREATE_JOINABLE = 0
	PTHREAD_CREATE_DETACHED = 1
)

// Mutex types.
const ( /* pthread.h:43:1: */
	PTHREAD_MUTEX_TIMED_NP      = 0
	PTHREAD_MUTEX_RECURSIVE_NP  = 1
	PTHREAD_MUTEX_ERRORCHECK_NP = 2
	PTHREAD_MUTEX_ADAPTIVE_NP   = 3
	PTHREAD_MUTEX_NORMAL        = 0
	PTHREAD_MUTEX_RECURSIVE     = 1
	PTHREAD_MUTEX_ERRORCHECK    = 2
	PTHREAD_MUTEX_DEFAULT       = 0
	PTHREAD_MUTEX_FAST_NP       = 0
)

// Robust mutex or not flags.
const ( /* pthread.h:65:1: */
	PTHREAD_MUTEX_STALLED    = 0
	PTHREAD_MUTEX_STALLED_NP = 0
	PTHREAD_MUTEX_ROBUST     = 1
	PTHREAD_MUTEX_ROBUST_NP  = 1
)

// Mutex protocols.
const ( /* pthread.h:77:1: */
	PTHREAD_PRIO_NONE    = 0
	PTHREAD_PRIO_INHERIT = 1
	PTHREAD_PRIO_PROTECT = 2
)

// Values for the first argument to `getitimer' and `setitimer'.
const ( /* time.h:88:1: */
	// Timers run in real time.
	ITIMER_REAL = 0
	// Timers run only when the process is executing.
	ITIMER_VIRTUAL = 1
	// Timers run when the process is executing and when
	//        the system is executing on behalf of the process.
	ITIMER_PROF = 2
)

// Number of each register is the `gregset_t' array.
const ( /* ucontext.h:45:1: */
	REG_R0  = 0
	REG_R1  = 1
	REG_R2  = 2
	REG_R3  = 3
	REG_R4  = 4
	REG_R5  = 5
	REG_R6  = 6
	REG_R7  = 7
	REG_R8  = 8
	REG_R9  = 9
	REG_R10 = 10
	REG_R11 = 11
	REG_R12 = 12
	REG_R13 = 13
	REG_R14 = 14
	REG_R15 = 15
)

// Positions to pass to Tcl_QueueEvent:

const ( /* tcl.h:1387:1: */
	TCL_QUEUE_TAIL = 0
	TCL_QUEUE_HEAD = 1
	TCL_QUEUE_MARK = 2
)

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

const ( /* tcl.h:1609:1: */
	TCL_PATH_ABSOLUTE        = 0
	TCL_PATH_RELATIVE        = 1
	TCL_PATH_VOLUME_RELATIVE = 2
)

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

const ( /* tcl.h:690:1: */
	TCL_INT      = 0
	TCL_DOUBLE   = 1
	TCL_EITHER   = 2
	TCL_WIDE_INT = 3
)

type ptrdiff_t = int32 /* <builtin>:3:26 */

type size_t = uint32 /* <builtin>:9:23 */

type wchar_t = uint32 /* <builtin>:15:24 */

// Define the standard macros for the user,
//    if this invocation was from the user program.

// Define va_list, if desired, from __gnuc_va_list.
// We deliberately do not define va_list when called from
//    stdio.h, because ANSI C says that stdio.h is not supposed to define
//    va_list.  stdio.h needs to have access to that data type,
//    but must not use that name.  It should use the name __gnuc_va_list,
//    which is safe because it is reserved for the implementation.

// The macro _VA_LIST_ is the same thing used by this file in Ultrix.
//    But on BSD NET2 we must not test or define or undef it.
//    (Note that the comments in NET 2's ansi.h
//    are incorrect for _VA_LIST_--see stdio.h!)
// The macro _VA_LIST_DEFINED is used in Windows NT 3.5
// The macro _VA_LIST is used in SCO Unix 3.2.
// The macro _VA_LIST_T_H is used in the Bull dpx2
// The macro __va_list__ is used by BeOS.
type va_list = uintptr /* stdarg.h:99:24 */

// CAPI3REF: Database Connection Handle
// KEYWORDS: {database connection} {database connections}
//
// Each open SQLite database is represented by a pointer to an instance of
// the opaque structure named "sqlite3".  It is useful to think of an sqlite3
// pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and
// [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]
// and [sqlite3_close_v2()] are its destructors.  There are many other
// interfaces (such as
// [sqlite3_prepare_v2()], [sqlite3_create_function()], and
// [sqlite3_busy_timeout()] to name but three) that are methods on an
// sqlite3 object.
type sqlite32 = struct {
	FpVfs                   uintptr
	FpVdbe                  uintptr
	FpDfltColl              uintptr
	Fmutex                  uintptr
	FaDb                    uintptr
	FnDb                    int32
	FmDbFlags               u32
	_                       [4]byte
	Fflags                  u64
	FlastRowid              i64
	FszMmap                 i64
	FnSchemaLock            u32
	FopenFlags              uint32
	FerrCode                int32
	FerrMask                int32
	FiSysErrno              int32
	FdbOptFlags             u32
	Fenc                    u8
	FautoCommit             u8
	Ftemp_store             u8
	FmallocFailed           u8
	FbBenignMalloc          u8
	FdfltLockMode           u8
	FnextAutovac            int8
	FsuppressErr            u8
	FvtabOnConflict         u8
	FisTransactionSavepoint u8
	FmTrace                 u8
	FnoSharedCache          u8
	FnSqlExec               u8
	_                       [3]byte
	FnextPagesize           int32
	Fmagic                  u32
	FnChange                int32
	FnTotalChange           int32
	FaLimit                 [12]int32
	FnMaxSorterMmap         int32
	Finit                   struct {
		FnewTnum       Pgno
		FiDb           u8
		Fbusy          u8
		_              [2]byte
		ForphanTrigger uint8 /* unsigned orphanTrigger: 1, unsigned imposterTable: 1, unsigned reopenMemdb: 1 */
		_              [3]byte
		FazInit        uintptr
	}
	FnVdbeActive        int32
	FnVdbeRead          int32
	FnVdbeWrite         int32
	FnVdbeExec          int32
	FnVDestroy          int32
	FnExtension         int32
	FaExtension         uintptr
	Ftrace              struct{ FxLegacy uintptr }
	FpTraceArg          uintptr
	FxProfile           uintptr
	FpProfileArg        uintptr
	FpCommitArg         uintptr
	FxCommitCallback    uintptr
	FpRollbackArg       uintptr
	FxRollbackCallback  uintptr
	FpUpdateArg         uintptr
	FxUpdateCallback    uintptr
	FpParse             uintptr
	FpPreUpdateArg      uintptr
	FxPreUpdateCallback uintptr
	FpPreUpdate         uintptr
	FxWalCallback       uintptr
	FpWalArg            uintptr
	FxCollNeeded        uintptr
	FxCollNeeded16      uintptr
	FpCollNeededArg     uintptr
	FpErr               uintptr
	Fu1                 struct {
		_              [0]uint64
		FisInterrupted int32
		_              [4]byte
	}
	Flookaside           Lookaside
	FxAuth               sqlite3_xauth
	FpAuthArg            uintptr
	FxProgress           uintptr
	FpProgressArg        uintptr
	FnProgressOps        uint32
	FnVTrans             int32
	FaModule             Hash
	FpVtabCtx            uintptr
	FaVTrans             uintptr
	FpDisconnect         uintptr
	FaFunc               Hash
	FaCollSeq            Hash
	FbusyHandler         BusyHandler
	FaDbStatic           [2]Db
	FpSavepoint          uintptr
	FnAnalysisLimit      int32
	FbusyTimeout         int32
	FnSavepoint          int32
	FnStatement          int32
	_                    [4]byte
	FnDeferredCons       i64
	FnDeferredImmCons    i64
	FpnBytesFreed        uintptr
	FpBlockingConnection uintptr
	FpUnlockConnection   uintptr
	FpUnlockArg          uintptr
	FxUnlockNotify       uintptr
	FpNextBlocked        uintptr
} /* sqlite3.h:249:9 */

// CAPI3REF: 64-Bit Integer Types
// KEYWORDS: sqlite_int64 sqlite_uint64
//
// Because there is no cross-platform way to specify 64-bit integer types
// SQLite includes typedefs for 64-bit signed and unsigned integers.
//
// The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.
// The sqlite_int64 and sqlite_uint64 types are supported for backwards
// compatibility only.
//
// ^The sqlite3_int64 and sqlite_int64 types can store integer values
// between -9223372036854775808 and +9223372036854775807 inclusive.  ^The
// sqlite3_uint64 and sqlite_uint64 types can store integer values
// between 0 and +18446744073709551615 inclusive.
type sqlite_int64 = int64           /* sqlite3.h:278:25 */
type sqlite_uint64 = uint64         /* sqlite3.h:279:34 */
type sqlite3_int64 = sqlite_int64   /* sqlite3.h:281:22 */
type sqlite3_uint64 = sqlite_uint64 /* sqlite3.h:282:23 */

// The type for a callback function.
// This is legacy and deprecated.  It is included for historical
// compatibility and is not documented.
type sqlite3_callback = uintptr /* sqlite3.h:338:13 */

// CAPI3REF: Result Codes
// KEYWORDS: {result code definitions}
//
// Many SQLite functions return an integer result code from the set shown
// here in order to indicate success or failure.
//
// New error codes may be added in future versions of SQLite.
//
// See also: [extended result code definitions]
// beginning-of-error-codes
// end-of-error-codes

// CAPI3REF: Extended Result Codes
// KEYWORDS: {extended result code definitions}
//
// In its default configuration, SQLite API routines return one of 30 integer
// [result codes].  However, experience has shown that many of
// these result codes are too coarse-grained.  They do not provide as
// much information about problems as programmers might like.  In an effort to
// address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
// and later) include
// support for additional result codes that provide more detailed information
// about errors. These [extended result codes] are enabled or disabled
// on a per database connection basis using the
// [sqlite3_extended_result_codes()] API.  Or, the extended code for
// the most recent error can be obtained using
// [sqlite3_extended_errcode()].

// CAPI3REF: Flags For File Open Operations
//
// These bit values are intended for use in the
// 3rd parameter to the [sqlite3_open_v2()] interface and
// in the 4th parameter to the [sqlite3_vfs.xOpen] method.

// Reserved:                         0x00F00000
// Legacy compatibility:

// CAPI3REF: Device Characteristics
//
// The xDeviceCharacteristics method of the [sqlite3_io_methods]
// object returns an integer which is a vector of these
// bit values expressing I/O characteristics of the mass storage
// device that holds the file that the [sqlite3_io_methods]
// refers to.
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
// after reboot following a crash or power loss, the only bytes in a
// file that were written at the application level might have changed
// and that adjacent bytes, even bytes within the same sector are
// guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
// flag indicates that a file cannot be deleted when open.  The
// SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
// read-only media and cannot be changed even by processes with
// elevated privileges.
//
// The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
// filesystem supports doing multiple write operations atomically when those
// write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
// [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].

// CAPI3REF: File Locking Levels
//
// SQLite uses one of these integer values as the second
// argument to calls it makes to the xLock() and xUnlock() methods
// of an [sqlite3_io_methods] object.

// CAPI3REF: Synchronization Type Flags
//
// When SQLite invokes the xSync() method of an
// [sqlite3_io_methods] object it uses a combination of
// these integer values as the second argument.
//
// When the SQLITE_SYNC_DATAONLY flag is used, it means that the
// sync operation only needs to flush data to mass storage.  Inode
// information need not be flushed. If the lower four bits of the flag
// equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
// If the lower four bits equal SQLITE_SYNC_FULL, that means
// to use Mac OS X style fullsync instead of fsync().
//
// Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
// with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
// settings.  The [synchronous pragma] determines when calls to the
// xSync VFS method occur and applies uniformly across all platforms.
// The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
// energetic or rigorous or forceful the sync operations are and
// only make a difference on Mac OSX for the default SQLite code.
// (Third-party VFS implementations might also make the distinction
// between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
// operating systems natively supported by SQLite, only Mac OSX
// cares about the difference.)

// CAPI3REF: OS Interface Open File Handle
//
// An [sqlite3_file] object represents an open file in the
// [sqlite3_vfs | OS interface layer].  Individual OS interface
// implementations will
// want to subclass this object by appending additional fields
// for their own use.  The pMethods entry is a pointer to an
// [sqlite3_io_methods] object that defines methods for performing
// I/O operations on the open file.
type sqlite3_file1 = struct{ FpMethods uintptr } /* sqlite3.h:684:9 */

// CAPI3REF: Result Codes
// KEYWORDS: {result code definitions}
//
// Many SQLite functions return an integer result code from the set shown
// here in order to indicate success or failure.
//
// New error codes may be added in future versions of SQLite.
//
// See also: [extended result code definitions]
// beginning-of-error-codes
// end-of-error-codes

// CAPI3REF: Extended Result Codes
// KEYWORDS: {extended result code definitions}
//
// In its default configuration, SQLite API routines return one of 30 integer
// [result codes].  However, experience has shown that many of
// these result codes are too coarse-grained.  They do not provide as
// much information about problems as programmers might like.  In an effort to
// address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
// and later) include
// support for additional result codes that provide more detailed information
// about errors. These [extended result codes] are enabled or disabled
// on a per database connection basis using the
// [sqlite3_extended_result_codes()] API.  Or, the extended code for
// the most recent error can be obtained using
// [sqlite3_extended_errcode()].

// CAPI3REF: Flags For File Open Operations
//
// These bit values are intended for use in the
// 3rd parameter to the [sqlite3_open_v2()] interface and
// in the 4th parameter to the [sqlite3_vfs.xOpen] method.

// Reserved:                         0x00F00000
// Legacy compatibility:

// CAPI3REF: Device Characteristics
//
// The xDeviceCharacteristics method of the [sqlite3_io_methods]
// object returns an integer which is a vector of these
// bit values expressing I/O characteristics of the mass storage
// device that holds the file that the [sqlite3_io_methods]
// refers to.
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
// after reboot following a crash or power loss, the only bytes in a
// file that were written at the application level might have changed
// and that adjacent bytes, even bytes within the same sector are
// guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
// flag indicates that a file cannot be deleted when open.  The
// SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
// read-only media and cannot be changed even by processes with
// elevated privileges.
//
// The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
// filesystem supports doing multiple write operations atomically when those
// write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
// [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].

// CAPI3REF: File Locking Levels
//
// SQLite uses one of these integer values as the second
// argument to calls it makes to the xLock() and xUnlock() methods
// of an [sqlite3_io_methods] object.

// CAPI3REF: Synchronization Type Flags
//
// When SQLite invokes the xSync() method of an
// [sqlite3_io_methods] object it uses a combination of
// these integer values as the second argument.
//
// When the SQLITE_SYNC_DATAONLY flag is used, it means that the
// sync operation only needs to flush data to mass storage.  Inode
// information need not be flushed. If the lower four bits of the flag
// equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
// If the lower four bits equal SQLITE_SYNC_FULL, that means
// to use Mac OS X style fullsync instead of fsync().
//
// Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
// with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
// settings.  The [synchronous pragma] determines when calls to the
// xSync VFS method occur and applies uniformly across all platforms.
// The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
// energetic or rigorous or forceful the sync operations are and
// only make a difference on Mac OSX for the default SQLite code.
// (Third-party VFS implementations might also make the distinction
// between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
// operating systems natively supported by SQLite, only Mac OSX
// cares about the difference.)

// CAPI3REF: OS Interface Open File Handle
//
// An [sqlite3_file] object represents an open file in the
// [sqlite3_vfs | OS interface layer].  Individual OS interface
// implementations will
// want to subclass this object by appending additional fields
// for their own use.  The pMethods entry is a pointer to an
// [sqlite3_io_methods] object that defines methods for performing
// I/O operations on the open file.
type sqlite3_file = sqlite3_file1 /* sqlite3.h:684:29 */
type sqlite3_io_methods1 = struct {
	FiVersion               int32
	FxClose                 uintptr
	FxRead                  uintptr
	FxWrite                 uintptr
	FxTruncate              uintptr
	FxSync                  uintptr
	FxFileSize              uintptr
	FxLock                  uintptr
	FxUnlock                uintptr
	FxCheckReservedLock     uintptr
	FxFileControl           uintptr
	FxSectorSize            uintptr
	FxDeviceCharacteristics uintptr
	FxShmMap                uintptr
	FxShmLock               uintptr
	FxShmBarrier            uintptr
	FxShmUnmap              uintptr
	FxFetch                 uintptr
	FxUnfetch               uintptr
} /* sqlite3.h:684:9 */

// CAPI3REF: OS Interface File Virtual Methods Object
//
// Every file opened by the [sqlite3_vfs.xOpen] method populates an
// [sqlite3_file] object (or, more commonly, a subclass of the
// [sqlite3_file] object) with a pointer to an instance of this object.
// This object defines the methods used to perform various operations
// against the open file represented by the [sqlite3_file] object.
//
// If the [sqlite3_vfs.xOpen] method sets the sqlite3_file.pMethods element
// to a non-NULL pointer, then the sqlite3_io_methods.xClose method
// may be invoked even if the [sqlite3_vfs.xOpen] reported that it failed.  The
// only way to prevent a call to xClose following a failed [sqlite3_vfs.xOpen]
// is for the [sqlite3_vfs.xOpen] to set the sqlite3_file.pMethods element
// to NULL.
//
// The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or
// [SQLITE_SYNC_FULL].  The first choice is the normal fsync().
// The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]
// flag may be ORed in to indicate that only the data of the file
// and not its inode needs to be synced.
//
// The integer values to xLock() and xUnlock() are one of
// <ul>
// <li> [SQLITE_LOCK_NONE],
// <li> [SQLITE_LOCK_SHARED],
// <li> [SQLITE_LOCK_RESERVED],
// <li> [SQLITE_LOCK_PENDING], or
// <li> [SQLITE_LOCK_EXCLUSIVE].
// </ul>
// xLock() increases the lock. xUnlock() decreases the lock.
// The xCheckReservedLock() method checks whether any database connection,
// either in this process or in some other process, is holding a RESERVED,
// PENDING, or EXCLUSIVE lock on the file.  It returns true
// if such a lock exists and false otherwise.
//
// The xFileControl() method is a generic interface that allows custom
// VFS implementations to directly control an open file using the
// [sqlite3_file_control()] interface.  The second "op" argument is an
// integer opcode.  The third argument is a generic pointer intended to
// point to a structure that may contain arguments or space in which to
// write return values.  Potential uses for xFileControl() might be
// functions to enable blocking locks with timeouts, to change the
// locking strategy (for example to use dot-file locks), to inquire
// about the status of a lock, or to break stale locks.  The SQLite
// core reserves all opcodes less than 100 for its own use.
// A [file control opcodes | list of opcodes] less than 100 is available.
// Applications that define a custom xFileControl method should use opcodes
// greater than 100 to avoid conflicts.  VFS implementations should
// return [SQLITE_NOTFOUND] for file control opcodes that they do not
// recognize.
//
// The xSectorSize() method returns the sector size of the
// device that underlies the file.  The sector size is the
// minimum write that can be performed without disturbing
// other bytes in the file.  The xDeviceCharacteristics()
// method returns a bit vector describing behaviors of the
// underlying device:
//
// <ul>
// <li> [SQLITE_IOCAP_ATOMIC]
// <li> [SQLITE_IOCAP_ATOMIC512]
// <li> [SQLITE_IOCAP_ATOMIC1K]
// <li> [SQLITE_IOCAP_ATOMIC2K]
// <li> [SQLITE_IOCAP_ATOMIC4K]
// <li> [SQLITE_IOCAP_ATOMIC8K]
// <li> [SQLITE_IOCAP_ATOMIC16K]
// <li> [SQLITE_IOCAP_ATOMIC32K]
// <li> [SQLITE_IOCAP_ATOMIC64K]
// <li> [SQLITE_IOCAP_SAFE_APPEND]
// <li> [SQLITE_IOCAP_SEQUENTIAL]
// <li> [SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN]
// <li> [SQLITE_IOCAP_POWERSAFE_OVERWRITE]
// <li> [SQLITE_IOCAP_IMMUTABLE]
// <li> [SQLITE_IOCAP_BATCH_ATOMIC]
// </ul>
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().
//
// If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill
// in the unread portions of the buffer with zeros.  A VFS that
// fails to zero-fill short reads might seem to work.  However,
// failure to zero-fill short reads will eventually lead to
// database corruption.
type sqlite3_io_methods = sqlite3_io_methods1 /* sqlite3.h:783:35 */

// CAPI3REF: Standard File Control Opcodes
// KEYWORDS: {file control opcodes} {file control opcode}
//
// These integer constants are opcodes for the xFileControl method
// of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]
// interface.
//
// <ul>
// <li>[[SQLITE_FCNTL_LOCKSTATE]]
// The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This
// opcode causes the xFileControl method to write the current state of
// the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],
// [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])
// into an integer that the pArg argument points to. This capability
// is used during testing and is only available when the SQLITE_TEST
// compile-time option is used.
//
// <li>[[SQLITE_FCNTL_SIZE_HINT]]
// The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS
// layer a hint of how large the database file will grow to be during the
// current transaction.  This hint is not guaranteed to be accurate but it
// is often close.  The underlying VFS might choose to preallocate database
// file space based on this hint in order to help writes to the database
// file run faster.
//
// <li>[[SQLITE_FCNTL_SIZE_LIMIT]]
// The [SQLITE_FCNTL_SIZE_LIMIT] opcode is used by in-memory VFS that
// implements [sqlite3_deserialize()] to set an upper bound on the size
// of the in-memory database.  The argument is a pointer to a [sqlite3_int64].
// If the integer pointed to is negative, then it is filled in with the
// current limit.  Otherwise the limit is set to the larger of the value
// of the integer pointed to and the current database size.  The integer
// pointed to is set to the new limit.
//
// <li>[[SQLITE_FCNTL_CHUNK_SIZE]]
// The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFS
// extends and truncates the database file in chunks of a size specified
// by the user. The fourth argument to [sqlite3_file_control()] should
// point to an integer (type int) containing the new chunk-size to use
// for the nominated database. Allocating database file space in large
// chunks (say 1MB at a time), may reduce file-system fragmentation and
// improve performance on some systems.
//
// <li>[[SQLITE_FCNTL_FILE_POINTER]]
// The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with a particular database
// connection.  See also [SQLITE_FCNTL_JOURNAL_POINTER].
//
// <li>[[SQLITE_FCNTL_JOURNAL_POINTER]]
// The [SQLITE_FCNTL_JOURNAL_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with the journal file (either
// the [rollback journal] or the [write-ahead log]) for a particular database
// connection.  See also [SQLITE_FCNTL_FILE_POINTER].
//
// <li>[[SQLITE_FCNTL_SYNC_OMITTED]]
// No longer in use.
//
// <li>[[SQLITE_FCNTL_SYNC]]
// The [SQLITE_FCNTL_SYNC] opcode is generated internally by SQLite and
// sent to the VFS immediately before the xSync method is invoked on a
// database file descriptor. Or, if the xSync method is not invoked
// because the user has configured SQLite with
// [PRAGMA synchronous | PRAGMA synchronous=OFF] it is invoked in place
// of the xSync method. In most cases, the pointer argument passed with
// this file-control is NULL. However, if the database file is being synced
// as part of a multi-database commit, the argument points to a nul-terminated
// string containing the transactions super-journal file name. VFSes that
// do not need this signal should silently ignore this opcode. Applications
// should not call [sqlite3_file_control()] with this opcode as doing so may
// disrupt the operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_COMMIT_PHASETWO]]
// The [SQLITE_FCNTL_COMMIT_PHASETWO] opcode is generated internally by SQLite
// and sent to the VFS after a transaction has been committed immediately
// but before the database is unlocked. VFSes that do not need this signal
// should silently ignore this opcode. Applications should not call
// [sqlite3_file_control()] with this opcode as doing so may disrupt the
// operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]
// ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automatic
// retry counts and intervals for certain disk I/O operations for the
// windows [VFS] in order to provide robustness in the presence of
// anti-virus programs.  By default, the windows VFS will retry file read,
// file write, and file delete operations up to 10 times, with a delay
// of 25 milliseconds before the first retry and with the delay increasing
// by an additional 25 milliseconds with each subsequent retry.  This
// opcode allows these two values (10 retries and 25 milliseconds of delay)
// to be adjusted.  The values are changed for all database connections
// within the same process.  The argument is a pointer to an array of two
// integers where the first integer is the new retry count and the second
// integer is the delay.  If either integer is negative, then the setting
// is not changed but instead the prior value of that setting is written
// into the array entry, allowing the current retry settings to be
// interrogated.  The zDbName parameter is ignored.
//
// <li>[[SQLITE_FCNTL_PERSIST_WAL]]
// ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query the
// persistent [WAL | Write Ahead Log] setting.  By default, the auxiliary
// write ahead log ([WAL file]) and shared memory
// files used for transaction control
// are automatically deleted when the latest connection to the database
// closes.  Setting persistent WAL mode causes those files to persist after
// close.  Persisting the files is useful when other processes that do not
// have write permission on the directory containing the database file want
// to read the database file, as the WAL and shared memory files must exist
// in order for the database to be readable.  The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable persistent WAL mode or 1 to enable persistent
// WAL mode.  If the integer is -1, then it is overwritten with the current
// WAL persistence setting.
//
// <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]
// ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query the
// persistent "powersafe-overwrite" or "PSOW" setting.  The PSOW setting
// determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of the
// xDeviceCharacteristics methods. The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable zero-damage mode or 1 to enable zero-damage
// mode.  If the integer is -1, then it is overwritten with the current
// zero-damage mode setting.
//
// <li>[[SQLITE_FCNTL_OVERWRITE]]
// ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after opening
// a write transaction to indicate that, unless it is rolled back for some
// reason, the entire database file will be overwritten by the current
// transaction. This is used by VACUUM operations.
//
// <li>[[SQLITE_FCNTL_VFSNAME]]
// ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names of
// all [VFSes] in the VFS stack.  The names are of all VFS shims and the
// final bottom-level VFS are written into memory obtained from
// [sqlite3_malloc()] and the result is stored in the char* variable
// that the fourth parameter of [sqlite3_file_control()] points to.
// The caller is responsible for freeing the memory when done.  As with
// all file-control actions, there is no guarantee that this will actually
// do anything.  Callers should initialize the char* variable to a NULL
// pointer in case this file-control is not implemented.  This file-control
// is intended for diagnostic use only.
//
// <li>[[SQLITE_FCNTL_VFS_POINTER]]
// ^The [SQLITE_FCNTL_VFS_POINTER] opcode finds a pointer to the top-level
// [VFSes] currently in use.  ^(The argument X in
// sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be
// of type "[sqlite3_vfs] **".  This opcodes will set *X
// to a pointer to the top-level VFS.)^
// ^When there are multiple VFS shims in the stack, this opcode finds the
// upper-most shim only.
//
// <li>[[SQLITE_FCNTL_PRAGMA]]
// ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA]
// file control is sent to the open [sqlite3_file] object corresponding
// to the database file to which the pragma statement refers. ^The argument
// to the [SQLITE_FCNTL_PRAGMA] file control is an array of
// pointers to strings (char**) in which the second element of the array
// is the name of the pragma and the third element is the argument to the
// pragma or NULL if the pragma has no argument.  ^The handler for an
// [SQLITE_FCNTL_PRAGMA] file control can optionally make the first element
// of the char** argument point to a string obtained from [sqlite3_mprintf()]
// or the equivalent and that string will become the result of the pragma or
// the error message if the pragma fails. ^If the
// [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal
// [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]
// file control returns [SQLITE_OK], then the parser assumes that the
// VFS has handled the PRAGMA itself and the parser generates a no-op
// prepared statement if result string is NULL, or that returns a copy
// of the result string if the string is non-NULL.
// ^If the [SQLITE_FCNTL_PRAGMA] file control returns
// any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means
// that the VFS encountered an error while handling the [PRAGMA] and the
// compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]
// file control occurs at the beginning of pragma statement analysis and so
// it is able to override built-in [PRAGMA] statements.
//
// <li>[[SQLITE_FCNTL_BUSYHANDLER]]
// ^The [SQLITE_FCNTL_BUSYHANDLER]
// file-control may be invoked by SQLite on the database file handle
// shortly after it is opened in order to provide a custom VFS with access
// to the connection's busy-handler callback. The argument is of type (void**)
// - an array of two (void *) values. The first (void *) actually points
// to a function of type (int (*)(void *)). In order to invoke the connection's
// busy-handler, this function should be invoked with the second (void *) in
// the array as the only argument. If it returns non-zero, then the operation
// should be retried. If it returns zero, the custom VFS should abandon the
// current operation.
//
// <li>[[SQLITE_FCNTL_TEMPFILENAME]]
// ^Applications can invoke the [SQLITE_FCNTL_TEMPFILENAME] file-control
// to have SQLite generate a
// temporary filename using the same algorithm that is followed to generate
// temporary filenames for TEMP tables and other internal uses.  The
// argument should be a char** which will be filled with the filename
// written into memory obtained from [sqlite3_malloc()].  The caller should
// invoke [sqlite3_free()] on the result to avoid a memory leak.
//
// <li>[[SQLITE_FCNTL_MMAP_SIZE]]
// The [SQLITE_FCNTL_MMAP_SIZE] file control is used to query or set the
// maximum number of bytes that will be used for memory-mapped I/O.
// The argument is a pointer to a value of type sqlite3_int64 that
// is an advisory maximum number of bytes in the file to memory map.  The
// pointer is overwritten with the old value.  The limit is not changed if
// the value originally pointed to is negative, and so the current limit
// can be queried by passing in a pointer to a negative number.  This
// file-control is used internally to implement [PRAGMA mmap_size].
//
// <li>[[SQLITE_FCNTL_TRACE]]
// The [SQLITE_FCNTL_TRACE] file control provides advisory information
// to the VFS about what the higher layers of the SQLite stack are doing.
// This file control is used by some VFS activity tracing [shims].
// The argument is a zero-terminated string.  Higher layers in the
// SQLite stack may generate instances of this file control if
// the [SQLITE_USE_FCNTL_TRACE] compile-time option is enabled.
//
// <li>[[SQLITE_FCNTL_HAS_MOVED]]
// The [SQLITE_FCNTL_HAS_MOVED] file control interprets its argument as a
// pointer to an integer and it writes a boolean into that integer depending
// on whether or not the file has been renamed, moved, or deleted since it
// was first opened.
//
// <li>[[SQLITE_FCNTL_WIN32_GET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_GET_HANDLE] opcode can be used to obtain the
// underlying native file handle associated with a file handle.  This file
// control interprets its argument as a pointer to a native file handle and
// writes the resulting value there.
//
// <li>[[SQLITE_FCNTL_WIN32_SET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_SET_HANDLE] opcode is used for debugging.  This
// opcode causes the xFileControl method to swap the file handle with the one
// pointed to by the pArg argument.  This capability is used during testing
// and only needs to be supported when SQLITE_TEST is defined.
//
// <li>[[SQLITE_FCNTL_WAL_BLOCK]]
// The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it might
// be advantageous to block on the next WAL lock if the lock is not immediately
// available.  The WAL subsystem issues this signal during rare
// circumstances in order to fix a problem with priority inversion.
// Applications should <em>not</em> use this file-control.
//
// <li>[[SQLITE_FCNTL_ZIPVFS]]
// The [SQLITE_FCNTL_ZIPVFS] opcode is implemented by zipvfs only. All other
// VFS should return SQLITE_NOTFOUND for this opcode.
//
// <li>[[SQLITE_FCNTL_RBU]]
// The [SQLITE_FCNTL_RBU] opcode is implemented by the special VFS used by
// the RBU extension only.  All other VFS should return SQLITE_NOTFOUND for
// this opcode.
//
// <li>[[SQLITE_FCNTL_BEGIN_ATOMIC_WRITE]]
// If the [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] opcode returns SQLITE_OK, then
// the file descriptor is placed in "batch write mode", which
// means all subsequent write operations will be deferred and done
// atomically at the next [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].  Systems
// that do not support batch atomic writes will return SQLITE_NOTFOUND.
// ^Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to
// the closing [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] or
// [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE], SQLite will make
// no VFS interface calls on the same [sqlite3_file] file descriptor
// except for calls to the xWrite method and the xFileControl method
// with [SQLITE_FCNTL_SIZE_HINT].
//
// <li>[[SQLITE_FCNTL_COMMIT_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be performed atomically.
// This file control returns [SQLITE_OK] if and only if the writes were
// all performed successfully and have been committed to persistent storage.
// ^Regardless of whether or not it is successful, this file control takes
// the file descriptor out of batch write mode so that all subsequent
// write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be rolled back.
// ^This file control takes the file descriptor out of batch write mode
// so that all subsequent write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]
// The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode is used to configure a VFS
// to block for up to M milliseconds before failing when attempting to
// obtain a file lock using the xLock or xShmLock methods of the VFS.
// The parameter is a pointer to a 32-bit signed integer that contains
// the value that M is to be set to. Before returning, the 32-bit signed
// integer is overwritten with the previous value of M.
//
// <li>[[SQLITE_FCNTL_DATA_VERSION]]
// The [SQLITE_FCNTL_DATA_VERSION] opcode is used to detect changes to
// a database file.  The argument is a pointer to a 32-bit unsigned integer.
// The "data version" for the pager is written into the pointer.  The
// "data version" changes whenever any change occurs to the corresponding
// database file, either through SQL statements on the same database
// connection or through transactions committed by separate database
// connections possibly in other processes. The [sqlite3_total_changes()]
// interface can be used to find if any database on the connection has changed,
// but that interface responds to changes on TEMP as well as MAIN and does
// not provide a mechanism to detect changes to MAIN only.  Also, the
// [sqlite3_total_changes()] interface responds to internal changes only and
// omits changes made by other database connections.  The
// [PRAGMA data_version] command provides a mechanism to detect changes to
// a single attached database that occur due to other database connections,
// but omits changes implemented by the database connection on which it is
// called.  This file control is the only mechanism to detect changes that
// happen either internally or externally and that are associated with
// a particular attached database.
//
// <li>[[SQLITE_FCNTL_CKPT_START]]
// The [SQLITE_FCNTL_CKPT_START] opcode is invoked from within a checkpoint
// in wal mode before the client starts to copy pages from the wal
// file to the database file.
//
// <li>[[SQLITE_FCNTL_CKPT_DONE]]
// The [SQLITE_FCNTL_CKPT_DONE] opcode is invoked from within a checkpoint
// in wal mode after the client has finished copying pages from the wal
// file to the database file, but before the *-shm file is updated to
// record the fact that the pages have been checkpointed.
// </ul>
//
// <li>[[SQLITE_FCNTL_EXTERNAL_READER]]
// The EXPERIMENTAL [SQLITE_FCNTL_EXTERNAL_READER] opcode is used to detect
// whether or not there is a database client in another process with a wal-mode
// transaction open on the database or not. It is only available on unix.The
// (void*) argument passed with this file-control should be a pointer to a
// value of type (int). The integer value is set to 1 if the database is a wal
// mode database and there exists at least one client in another process that
// currently has an SQL transaction open on the database. It is set to 0 if
// the database is not a wal-mode db, or if there is no such connection in any
// other process. This opcode cannot be used to detect transactions opened
// by clients within the current process, only within other processes.
// </ul>
//
// <li>[[SQLITE_FCNTL_CKSM_FILE]]
// Used by the cksmvfs VFS module only.
// </ul>

// deprecated names

// CAPI3REF: Mutex Handle
//
// The mutex module within SQLite defines [sqlite3_mutex] to be an
// abstract type for a mutex object.  The SQLite core never looks
// at the internal representation of an [sqlite3_mutex].  It only
// deals with pointers to the [sqlite3_mutex] object.
//
// Mutexes are created using [sqlite3_mutex_alloc()].
type sqlite3_mutex1 = struct {
	FpReal uintptr
	FeType int32
} /* sqlite3.h:1206:9 */

// CAPI3REF: Loadable Extension Thunk
//
// A pointer to the opaque sqlite3_api_routines structure is passed as
// the third parameter to entry points of [loadable extensions].  This
// structure must be typedefed in order to work around compiler warnings
// on some platforms.
type sqlite3_api_routines1 = struct {
	Faggregate_context      uintptr
	Faggregate_count        uintptr
	Fbind_blob              uintptr
	Fbind_double            uintptr
	Fbind_int               uintptr
	Fbind_int64             uintptr
	Fbind_null              uintptr
	Fbind_parameter_count   uintptr
	Fbind_parameter_index   uintptr
	Fbind_parameter_name    uintptr
	Fbind_text              uintptr
	Fbind_text16            uintptr
	Fbind_value             uintptr
	Fbusy_handler           uintptr
	Fbusy_timeout           uintptr
	Fchanges                uintptr
	Fclose                  uintptr
	Fcollation_needed       uintptr
	Fcollation_needed16     uintptr
	Fcolumn_blob            uintptr
	Fcolumn_bytes           uintptr
	Fcolumn_bytes16         uintptr
	Fcolumn_count           uintptr
	Fcolumn_database_name   uintptr
	Fcolumn_database_name16 uintptr
	Fcolumn_decltype        uintptr
	Fcolumn_decltype16      uintptr
	Fcolumn_double          uintptr
	Fcolumn_int             uintptr
	Fcolumn_int64           uintptr
	Fcolumn_name            uintptr
	Fcolumn_name16          uintptr
	Fcolumn_origin_name     uintptr
	Fcolumn_origin_name16   uintptr
	Fcolumn_table_name      uintptr
	Fcolumn_table_name16    uintptr
	Fcolumn_text            uintptr
	Fcolumn_text16          uintptr
	Fcolumn_type            uintptr
	Fcolumn_value           uintptr
	Fcommit_hook            uintptr
	Fcomplete               uintptr
	Fcomplete16             uintptr
	Fcreate_collation       uintptr
	Fcreate_collation16     uintptr
	Fcreate_function        uintptr
	Fcreate_function16      uintptr
	Fcreate_module          uintptr
	Fdata_count             uintptr
	Fdb_handle              uintptr
	Fdeclare_vtab           uintptr
	Fenable_shared_cache    uintptr
	Ferrcode                uintptr
	Ferrmsg                 uintptr
	Ferrmsg16               uintptr
	Fexec                   uintptr
	Fexpired                uintptr
	Ffinalize               uintptr
	Ffree                   uintptr
	Ffree_table             uintptr
	Fget_autocommit         uintptr
	Fget_auxdata            uintptr
	Fget_table              uintptr
	Fglobal_recover         uintptr
	Finterruptx             uintptr
	Flast_insert_rowid      uintptr
	Flibversion             uintptr
	Flibversion_number      uintptr
	Fmalloc                 uintptr
	Fmprintf                uintptr
	Fopen                   uintptr
	Fopen16                 uintptr
	Fprepare                uintptr
	Fprepare16              uintptr
	Fprofile                uintptr
	Fprogress_handler       uintptr
	Frealloc                uintptr
	Freset                  uintptr
	Fresult_blob            uintptr
	Fresult_double          uintptr
	Fresult_error           uintptr
	Fresult_error16         uintptr
	Fresult_int             uintptr
	Fresult_int64           uintptr
	Fresult_null            uintptr
	Fresult_text            uintptr
	Fresult_text16          uintptr
	Fresult_text16be        uintptr
	Fresult_text16le        uintptr
	Fresult_value           uintptr
	Frollback_hook          uintptr
	Fset_authorizer         uintptr
	Fset_auxdata            uintptr
	Fxsnprintf              uintptr
	Fstep                   uintptr
	Ftable_column_metadata  uintptr
	Fthread_cleanup         uintptr
	Ftotal_changes          uintptr
	Ftrace                  uintptr
	Ftransfer_bindings      uintptr
	Fupdate_hook            uintptr
	Fuser_data              uintptr
	Fvalue_blob             uintptr
	Fvalue_bytes            uintptr
	Fvalue_bytes16          uintptr
	Fvalue_double           uintptr
	Fvalue_int              uintptr
	Fvalue_int64            uintptr
	Fvalue_numeric_type     uintptr
	Fvalue_text             uintptr
	Fvalue_text16           uintptr
	Fvalue_text16be         uintptr
	Fvalue_text16le         uintptr
	Fvalue_type             uintptr
	Fvmprintf               uintptr
	Foverload_function      uintptr
	Fprepare_v2             uintptr
	Fprepare16_v2           uintptr
	Fclear_bindings         uintptr
	Fcreate_module_v2       uintptr
	Fbind_zeroblob          uintptr
	Fblob_bytes             uintptr
	Fblob_close             uintptr
	Fblob_open              uintptr
	Fblob_read              uintptr
	Fblob_write             uintptr
	Fcreate_collation_v2    uintptr
	Ffile_control           uintptr
	Fmemory_highwater       uintptr
	Fmemory_used            uintptr
	Fmutex_alloc            uintptr
	Fmutex_enter            uintptr
	Fmutex_free             uintptr
	Fmutex_leave            uintptr
	Fmutex_try              uintptr
	Fopen_v2                uintptr
	Frelease_memory         uintptr
	Fresult_error_nomem     uintptr
	Fresult_error_toobig    uintptr
	Fsleep                  uintptr
	Fsoft_heap_limit        uintptr
	Fvfs_find               uintptr
	Fvfs_register           uintptr
	Fvfs_unregister         uintptr
	Fxthreadsafe            uintptr
	Fresult_zeroblob        uintptr
	Fresult_error_code      uintptr
	Ftest_control           uintptr
	Frandomness             uintptr
	Fcontext_db_handle      uintptr
	Fextended_result_codes  uintptr
	Flimit                  uintptr
	Fnext_stmt              uintptr
	Fsql                    uintptr
	Fstatus                 uintptr
	Fbackup_finish          uintptr
	Fbackup_init            uintptr
	Fbackup_pagecount       uintptr
	Fbackup_remaining       uintptr
	Fbackup_step            uintptr
	Fcompileoption_get      uintptr
	Fcompileoption_used     uintptr
	Fcreate_function_v2     uintptr
	Fdb_config              uintptr
	Fdb_mutex               uintptr
	Fdb_status              uintptr
	Fextended_errcode       uintptr
	Flog                    uintptr
	Fsoft_heap_limit64      uintptr
	Fsourceid               uintptr
	Fstmt_status            uintptr
	Fstrnicmp               uintptr
	Funlock_notify          uintptr
	Fwal_autocheckpoint     uintptr
	Fwal_checkpoint         uintptr
	Fwal_hook               uintptr
	Fblob_reopen            uintptr
	Fvtab_config            uintptr
	Fvtab_on_conflict       uintptr
	Fclose_v2               uintptr
	Fdb_filename            uintptr
	Fdb_readonly            uintptr
	Fdb_release_memory      uintptr
	Ferrstr                 uintptr
	Fstmt_busy              uintptr
	Fstmt_readonly          uintptr
	Fstricmp                uintptr
	Furi_boolean            uintptr
	Furi_int64              uintptr
	Furi_parameter          uintptr
	Fxvsnprintf             uintptr
	Fwal_checkpoint_v2      uintptr
	Fauto_extension         uintptr
	Fbind_blob64            uintptr
	Fbind_text64            uintptr
	Fcancel_auto_extension  uintptr
	Fload_extension         uintptr
	Fmalloc64               uintptr
	Fmsize                  uintptr
	Frealloc64              uintptr
	Freset_auto_extension   uintptr
	Fresult_blob64          uintptr
	Fresult_text64          uintptr
	Fstrglob                uintptr
	Fvalue_dup              uintptr
	Fvalue_free             uintptr
	Fresult_zeroblob64      uintptr
	Fbind_zeroblob64        uintptr
	Fvalue_subtype          uintptr
	Fresult_subtype         uintptr
	Fstatus64               uintptr
	Fstrlike                uintptr
	Fdb_cacheflush          uintptr
	Fsystem_errno           uintptr
	Ftrace_v2               uintptr
	Fexpanded_sql           uintptr
	Fset_last_insert_rowid  uintptr
	Fprepare_v3             uintptr
	Fprepare16_v3           uintptr
	Fbind_pointer           uintptr
	Fresult_pointer         uintptr
	Fvalue_pointer          uintptr
	Fvtab_nochange          uintptr
	Fvalue_nochange         uintptr
	Fvtab_collation         uintptr
	Fkeyword_count          uintptr
	Fkeyword_name           uintptr
	Fkeyword_check          uintptr
	Fstr_new                uintptr
	Fstr_finish             uintptr
	Fstr_appendf            uintptr
	Fstr_vappendf           uintptr
	Fstr_append             uintptr
	Fstr_appendall          uintptr
	Fstr_appendchar         uintptr
	Fstr_reset              uintptr
	Fstr_errcode            uintptr
	Fstr_length             uintptr
	Fstr_value              uintptr
	Fcreate_window_function uintptr
	Fnormalized_sql         uintptr
	Fstmt_isexplain         uintptr
	Fvalue_frombind         uintptr
	Fdrop_modules           uintptr
	Fhard_heap_limit64      uintptr
	Furi_key                uintptr
	Ffilename_database      uintptr
	Ffilename_journal       uintptr
	Ffilename_wal           uintptr
	Fcreate_filename        uintptr
	Ffree_filename          uintptr
	Fdatabase_file_object   uintptr
	Ftxn_state              uintptr
} /* sqlite3.h:1216:9 */

// CAPI3REF: OS Interface Object
//
// An instance of the sqlite3_vfs object defines the interface between
// the SQLite core and the underlying operating system.  The "vfs"
// in the name of the object stands for "virtual file system".  See
// the [VFS | VFS documentation] for further information.
//
// The VFS interface is sometimes extended by adding new methods onto
// the end.  Each time such an extension occurs, the iVersion field
// is incremented.  The iVersion value started out as 1 in
// SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
// with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
// to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
// may be appended to the sqlite3_vfs object and the iVersion value
// may increase again in future versions of SQLite.
// Note that due to an oversight, the structure
// of the sqlite3_vfs object changed in the transition from
// SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
// and yet the iVersion field was not increased.
//
// The szOsFile field is the size of the subclassed [sqlite3_file]
// structure used by this VFS.  mxPathname is the maximum length of
// a pathname in this VFS.
//
// Registered sqlite3_vfs objects are kept on a linked list formed by
// the pNext pointer.  The [sqlite3_vfs_register()]
// and [sqlite3_vfs_unregister()] interfaces manage this list
// in a thread-safe way.  The [sqlite3_vfs_find()] interface
// searches the list.  Neither the application code nor the VFS
// implementation should use the pNext pointer.
//
// The pNext field is the only field in the sqlite3_vfs
// structure that SQLite will ever modify.  SQLite will only access
// or modify this field while holding a particular static mutex.
// The application should never modify anything within the sqlite3_vfs
// object once the object has been registered.
//
// The zName field holds the name of the VFS module.  The name must
// be unique across all VFS modules.
//
// [[sqlite3_vfs.xOpen]]
// ^SQLite guarantees that the zFilename parameter to xOpen
// is either a NULL pointer or string obtained
// from xFullPathname() with an optional suffix added.
// ^If a suffix is added to the zFilename parameter, it will
// consist of a single "-" character followed by no more than
// 11 alphanumeric and/or "-" characters.
// ^SQLite further guarantees that
// the string will be valid and unchanged until xClose() is
// called. Because of the previous sentence,
// the [sqlite3_file] can safely store a pointer to the
// filename if it needs to remember the filename for some reason.
// If the zFilename parameter to xOpen is a NULL pointer then xOpen
// must invent its own temporary name for the file.  ^Whenever the
// xFilename parameter is NULL it will also be the case that the
// flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
//
// The flags argument to xOpen() includes all bits set in
// the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
// or [sqlite3_open16()] is used, then flags includes at least
// [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
// If xOpen() opens a file read-only then it sets *pOutFlags to
// include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
//
// ^(SQLite will also add one of the following flags to the xOpen()
// call, depending on the object being opened:
//
// <ul>
// <li>  [SQLITE_OPEN_MAIN_DB]
// <li>  [SQLITE_OPEN_MAIN_JOURNAL]
// <li>  [SQLITE_OPEN_TEMP_DB]
// <li>  [SQLITE_OPEN_TEMP_JOURNAL]
// <li>  [SQLITE_OPEN_TRANSIENT_DB]
// <li>  [SQLITE_OPEN_SUBJOURNAL]
// <li>  [SQLITE_OPEN_SUPER_JOURNAL]
// <li>  [SQLITE_OPEN_WAL]
// </ul>)^
//
// The file I/O implementation can use the object type flags to
// change the way it deals with files.  For example, an application
// that does not care about crash recovery or rollback might make
// the open of a journal file a no-op.  Writes to this journal would
// also be no-ops, and any attempt to read the journal would return
// SQLITE_IOERR.  Or the implementation might recognize that a database
// file will be doing page-aligned sector reads and writes in a random
// order and set up its I/O subsystem accordingly.
//
// SQLite might also add one of the following flags to the xOpen method:
//
// <ul>
// <li> [SQLITE_OPEN_DELETEONCLOSE]
// <li> [SQLITE_OPEN_EXCLUSIVE]
// </ul>
//
// The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
// deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
// will be set for TEMP databases and their journals, transient
// databases, and subjournals.
//
// ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
// with the [SQLITE_OPEN_CREATE] flag, which are both directly
// analogous to the O_EXCL and O_CREAT flags of the POSIX open()
// API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
// SQLITE_OPEN_CREATE, is used to indicate that file should always
// be created, and that it is an error if it already exists.
// It is <i>not</i> used to indicate the file should be opened
// for exclusive access.
//
// ^At least szOsFile bytes of memory are allocated by SQLite
// to hold the [sqlite3_file] structure passed as the third
// argument to xOpen.  The xOpen method does not have to
// allocate the structure; it should just fill it in.  Note that
// the xOpen method must set the sqlite3_file.pMethods to either
// a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
// this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
// element will be valid after xOpen returns regardless of the success
// or failure of the xOpen call.
//
// [[sqlite3_vfs.xAccess]]
// ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
// to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
// test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
// to test whether a file is at least readable.  The SQLITE_ACCESS_READ
// flag is never actually used and is not implemented in the built-in
// VFSes of SQLite.  The file is named by the second argument and can be a
// directory. The xAccess method returns [SQLITE_OK] on success or some
// non-zero error code if there is an I/O error or if the name of
// the file given in the second argument is illegal.  If SQLITE_OK
// is returned, then non-zero or zero is written into *pResOut to indicate
// whether or not the file is accessible.
//
// ^SQLite will always allocate at least mxPathname+1 bytes for the
// output buffer xFullPathname.  The exact size of the output buffer
// is also passed as a parameter to both  methods. If the output buffer
// is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
// handled as a fatal error by SQLite, vfs implementations should endeavor
// to prevent this by setting mxPathname to a sufficiently large value.
//
// The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
// interfaces are not strictly a part of the filesystem, but they are
// included in the VFS structure for completeness.
// The xRandomness() function attempts to return nBytes bytes
// of good-quality randomness into zOut.  The return value is
// the actual number of bytes of randomness obtained.
// The xSleep() method causes the calling thread to sleep for at
// least the number of microseconds given.  ^The xCurrentTime()
// method returns a Julian Day Number for the current date and time as
// a floating point value.
// ^The xCurrentTimeInt64() method returns, as an integer, the Julian
// Day Number multiplied by 86400000 (the number of milliseconds in
// a 24-hour day).
// ^SQLite will use the xCurrentTimeInt64() method to get the current
// date and time if that method is available (if iVersion is 2 or
// greater and the function pointer is not NULL) and will fall back
// to xCurrentTime() if xCurrentTimeInt64() is unavailable.
//
// ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
// are not used by the SQLite core.  These optional interfaces are provided
// by some VFSes to facilitate testing of the VFS code. By overriding
// system calls with functions under its control, a test program can
// simulate faults and error conditions that would otherwise be difficult
// or impossible to induce.  The set of system calls that can be overridden
// varies from one VFS to another, and from one version of the same VFS to the
// next.  Applications that use these interfaces must be prepared for any
// or all of these interfaces to be NULL or for their behavior to change
// from one release to the next.  Applications must not attempt to access
// any of these methods if the iVersion of the VFS is less than 3.
type sqlite3_vfs1 = struct {
	FiVersion          int32
	FszOsFile          int32
	FmxPathname        int32
	FpNext             uintptr
	FzName             uintptr
	FpAppData          uintptr
	FxOpen             uintptr
	FxDelete           uintptr
	FxAccess           uintptr
	FxFullPathname     uintptr
	FxDlOpen           uintptr
	FxDlError          uintptr
	FxDlSym            uintptr
	FxDlClose          uintptr
	FxRandomness       uintptr
	FxSleep            uintptr
	FxCurrentTime      uintptr
	FxGetLastError     uintptr
	FxCurrentTimeInt64 uintptr
	FxSetSystemCall    uintptr
	FxGetSystemCall    uintptr
	FxNextSystemCall   uintptr
} /* sqlite3.h:1387:9 */

// CAPI3REF: OS Interface Object
//
// An instance of the sqlite3_vfs object defines the interface between
// the SQLite core and the underlying operating system.  The "vfs"
// in the name of the object stands for "virtual file system".  See
// the [VFS | VFS documentation] for further information.
//
// The VFS interface is sometimes extended by adding new methods onto
// the end.  Each time such an extension occurs, the iVersion field
// is incremented.  The iVersion value started out as 1 in
// SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
// with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
// to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
// may be appended to the sqlite3_vfs object and the iVersion value
// may increase again in future versions of SQLite.
// Note that due to an oversight, the structure
// of the sqlite3_vfs object changed in the transition from
// SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
// and yet the iVersion field was not increased.
//
// The szOsFile field is the size of the subclassed [sqlite3_file]
// structure used by this VFS.  mxPathname is the maximum length of
// a pathname in this VFS.
//
// Registered sqlite3_vfs objects are kept on a linked list formed by
// the pNext pointer.  The [sqlite3_vfs_register()]
// and [sqlite3_vfs_unregister()] interfaces manage this list
// in a thread-safe way.  The [sqlite3_vfs_find()] interface
// searches the list.  Neither the application code nor the VFS
// implementation should use the pNext pointer.
//
// The pNext field is the only field in the sqlite3_vfs
// structure that SQLite will ever modify.  SQLite will only access
// or modify this field while holding a particular static mutex.
// The application should never modify anything within the sqlite3_vfs
// object once the object has been registered.
//
// The zName field holds the name of the VFS module.  The name must
// be unique across all VFS modules.
//
// [[sqlite3_vfs.xOpen]]
// ^SQLite guarantees that the zFilename parameter to xOpen
// is either a NULL pointer or string obtained
// from xFullPathname() with an optional suffix added.
// ^If a suffix is added to the zFilename parameter, it will
// consist of a single "-" character followed by no more than
// 11 alphanumeric and/or "-" characters.
// ^SQLite further guarantees that
// the string will be valid and unchanged until xClose() is
// called. Because of the previous sentence,
// the [sqlite3_file] can safely store a pointer to the
// filename if it needs to remember the filename for some reason.
// If the zFilename parameter to xOpen is a NULL pointer then xOpen
// must invent its own temporary name for the file.  ^Whenever the
// xFilename parameter is NULL it will also be the case that the
// flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
//
// The flags argument to xOpen() includes all bits set in
// the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
// or [sqlite3_open16()] is used, then flags includes at least
// [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
// If xOpen() opens a file read-only then it sets *pOutFlags to
// include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
//
// ^(SQLite will also add one of the following flags to the xOpen()
// call, depending on the object being opened:
//
// <ul>
// <li>  [SQLITE_OPEN_MAIN_DB]
// <li>  [SQLITE_OPEN_MAIN_JOURNAL]
// <li>  [SQLITE_OPEN_TEMP_DB]
// <li>  [SQLITE_OPEN_TEMP_JOURNAL]
// <li>  [SQLITE_OPEN_TRANSIENT_DB]
// <li>  [SQLITE_OPEN_SUBJOURNAL]
// <li>  [SQLITE_OPEN_SUPER_JOURNAL]
// <li>  [SQLITE_OPEN_WAL]
// </ul>)^
//
// The file I/O implementation can use the object type flags to
// change the way it deals with files.  For example, an application
// that does not care about crash recovery or rollback might make
// the open of a journal file a no-op.  Writes to this journal would
// also be no-ops, and any attempt to read the journal would return
// SQLITE_IOERR.  Or the implementation might recognize that a database
// file will be doing page-aligned sector reads and writes in a random
// order and set up its I/O subsystem accordingly.
//
// SQLite might also add one of the following flags to the xOpen method:
//
// <ul>
// <li> [SQLITE_OPEN_DELETEONCLOSE]
// <li> [SQLITE_OPEN_EXCLUSIVE]
// </ul>
//
// The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
// deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
// will be set for TEMP databases and their journals, transient
// databases, and subjournals.
//
// ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
// with the [SQLITE_OPEN_CREATE] flag, which are both directly
// analogous to the O_EXCL and O_CREAT flags of the POSIX open()
// API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
// SQLITE_OPEN_CREATE, is used to indicate that file should always
// be created, and that it is an error if it already exists.
// It is <i>not</i> used to indicate the file should be opened
// for exclusive access.
//
// ^At least szOsFile bytes of memory are allocated by SQLite
// to hold the [sqlite3_file] structure passed as the third
// argument to xOpen.  The xOpen method does not have to
// allocate the structure; it should just fill it in.  Note that
// the xOpen method must set the sqlite3_file.pMethods to either
// a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
// this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
// element will be valid after xOpen returns regardless of the success
// or failure of the xOpen call.
//
// [[sqlite3_vfs.xAccess]]
// ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
// to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
// test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
// to test whether a file is at least readable.  The SQLITE_ACCESS_READ
// flag is never actually used and is not implemented in the built-in
// VFSes of SQLite.  The file is named by the second argument and can be a
// directory. The xAccess method returns [SQLITE_OK] on success or some
// non-zero error code if there is an I/O error or if the name of
// the file given in the second argument is illegal.  If SQLITE_OK
// is returned, then non-zero or zero is written into *pResOut to indicate
// whether or not the file is accessible.
//
// ^SQLite will always allocate at least mxPathname+1 bytes for the
// output buffer xFullPathname.  The exact size of the output buffer
// is also passed as a parameter to both  methods. If the output buffer
// is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
// handled as a fatal error by SQLite, vfs implementations should endeavor
// to prevent this by setting mxPathname to a sufficiently large value.
//
// The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
// interfaces are not strictly a part of the filesystem, but they are
// included in the VFS structure for completeness.
// The xRandomness() function attempts to return nBytes bytes
// of good-quality randomness into zOut.  The return value is
// the actual number of bytes of randomness obtained.
// The xSleep() method causes the calling thread to sleep for at
// least the number of microseconds given.  ^The xCurrentTime()
// method returns a Julian Day Number for the current date and time as
// a floating point value.
// ^The xCurrentTimeInt64() method returns, as an integer, the Julian
// Day Number multiplied by 86400000 (the number of milliseconds in
// a 24-hour day).
// ^SQLite will use the xCurrentTimeInt64() method to get the current
// date and time if that method is available (if iVersion is 2 or
// greater and the function pointer is not NULL) and will fall back
// to xCurrentTime() if xCurrentTimeInt64() is unavailable.
//
// ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
// are not used by the SQLite core.  These optional interfaces are provided
// by some VFSes to facilitate testing of the VFS code. By overriding
// system calls with functions under its control, a test program can
// simulate faults and error conditions that would otherwise be difficult
// or impossible to induce.  The set of system calls that can be overridden
// varies from one VFS to another, and from one version of the same VFS to the
// next.  Applications that use these interfaces must be prepared for any
// or all of these interfaces to be NULL or for their behavior to change
// from one release to the next.  Applications must not attempt to access
// any of these methods if the iVersion of the VFS is less than 3.
type sqlite3_vfs = sqlite3_vfs1    /* sqlite3.h:1387:28 */
type sqlite3_syscall_ptr = uintptr /* sqlite3.h:1388:14 */

// CAPI3REF: Memory Allocation Routines
//
// An instance of this object defines the interface between SQLite
// and low-level memory allocation routines.
//
// This object is used in only one place in the SQLite interface.
// A pointer to an instance of this object is the argument to
// [sqlite3_config()] when the configuration option is
// [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
// By creating an instance of this object
// and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
// during configuration, an application can specify an alternative
// memory allocation subsystem for SQLite to use for all of its
// dynamic memory needs.
//
// Note that SQLite comes with several [built-in memory allocators]
// that are perfectly adequate for the overwhelming majority of applications
// and that this object is only useful to a tiny minority of applications
// with specialized memory allocation requirements.  This object is
// also used during testing of SQLite in order to specify an alternative
// memory allocator that simulates memory out-of-memory conditions in
// order to verify that SQLite recovers gracefully from such
// conditions.
//
// The xMalloc, xRealloc, and xFree methods must work like the
// malloc(), realloc() and free() functions from the standard C library.
// ^SQLite guarantees that the second argument to
// xRealloc is always a value returned by a prior call to xRoundup.
//
// xSize should return the allocated size of a memory allocation
// previously obtained from xMalloc or xRealloc.  The allocated size
// is always at least as big as the requested size but may be larger.
//
// The xRoundup method returns what would be the allocated size of
// a memory allocation given a particular requested size.  Most memory
// allocators round up memory allocations at least to the next multiple
// of 8.  Some allocators round up to a larger multiple or to a power of 2.
// Every memory allocation request coming in through [sqlite3_malloc()]
// or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
// that causes the corresponding memory allocation to fail.
//
// The xInit method initializes the memory allocator.  For example,
// it might allocate any required mutexes or initialize internal data
// structures.  The xShutdown method is invoked (indirectly) by
// [sqlite3_shutdown()] and should deallocate any resources acquired
// by xInit.  The pAppData pointer is used as the only parameter to
// xInit and xShutdown.
//
// SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes
// the xInit method, so the xInit method need not be threadsafe.  The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  For all other methods, SQLite
// holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
// [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
// it is by default) and so the methods are automatically serialized.
// However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
// methods must be threadsafe or else make their own arrangements for
// serialization.
//
// SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
type sqlite3_mem_methods1 = struct {
	FxMalloc   uintptr
	FxFree     uintptr
	FxRealloc  uintptr
	FxSize     uintptr
	FxRoundup  uintptr
	FxInit     uintptr
	FxShutdown uintptr
	FpAppData  uintptr
} /* sqlite3.h:1685:9 */

// CAPI3REF: Memory Allocation Routines
//
// An instance of this object defines the interface between SQLite
// and low-level memory allocation routines.
//
// This object is used in only one place in the SQLite interface.
// A pointer to an instance of this object is the argument to
// [sqlite3_config()] when the configuration option is
// [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
// By creating an instance of this object
// and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
// during configuration, an application can specify an alternative
// memory allocation subsystem for SQLite to use for all of its
// dynamic memory needs.
//
// Note that SQLite comes with several [built-in memory allocators]
// that are perfectly adequate for the overwhelming majority of applications
// and that this object is only useful to a tiny minority of applications
// with specialized memory allocation requirements.  This object is
// also used during testing of SQLite in order to specify an alternative
// memory allocator that simulates memory out-of-memory conditions in
// order to verify that SQLite recovers gracefully from such
// conditions.
//
// The xMalloc, xRealloc, and xFree methods must work like the
// malloc(), realloc() and free() functions from the standard C library.
// ^SQLite guarantees that the second argument to
// xRealloc is always a value returned by a prior call to xRoundup.
//
// xSize should return the allocated size of a memory allocation
// previously obtained from xMalloc or xRealloc.  The allocated size
// is always at least as big as the requested size but may be larger.
//
// The xRoundup method returns what would be the allocated size of
// a memory allocation given a particular requested size.  Most memory
// allocators round up memory allocations at least to the next multiple
// of 8.  Some allocators round up to a larger multiple or to a power of 2.
// Every memory allocation request coming in through [sqlite3_malloc()]
// or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
// that causes the corresponding memory allocation to fail.
//
// The xInit method initializes the memory allocator.  For example,
// it might allocate any required mutexes or initialize internal data
// structures.  The xShutdown method is invoked (indirectly) by
// [sqlite3_shutdown()] and should deallocate any resources acquired
// by xInit.  The pAppData pointer is used as the only parameter to
// xInit and xShutdown.
//
// SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes
// the xInit method, so the xInit method need not be threadsafe.  The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  For all other methods, SQLite
// holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
// [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
// it is by default) and so the methods are automatically serialized.
// However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
// methods must be threadsafe or else make their own arrangements for
// serialization.
//
// SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
type sqlite3_mem_methods = sqlite3_mem_methods1 /* sqlite3.h:1685:36 */

// CAPI3REF: Dynamically Typed Value Object
// KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}
//
// SQLite uses the sqlite3_value object to represent all values
// that can be stored in a database table. SQLite uses dynamic typing
// for the values it stores.  ^Values stored in sqlite3_value objects
// can be integers, floating point values, strings, BLOBs, or NULL.
//
// An sqlite3_value object may be either "protected" or "unprotected".
// Some interfaces require a protected sqlite3_value.  Other interfaces
// will accept either a protected or an unprotected sqlite3_value.
// Every interface that accepts sqlite3_value arguments specifies
// whether or not it requires a protected sqlite3_value.  The
// [sqlite3_value_dup()] interface can be used to construct a new
// protected sqlite3_value from an unprotected sqlite3_value.
//
// The terms "protected" and "unprotected" refer to whether or not
// a mutex is held.  An internal mutex is held for a protected
// sqlite3_value object but no mutex is held for an unprotected
// sqlite3_value object.  If SQLite is compiled to be single-threaded
// (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)
// or if SQLite is run in one of reduced mutex modes
// [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]
// then there is no distinction between protected and unprotected
// sqlite3_value objects and they can be used interchangeably.  However,
// for maximum code portability it is recommended that applications
// still make the distinction between protected and unprotected
// sqlite3_value objects even when not strictly required.
//
// ^The sqlite3_value objects that are passed as parameters into the
// implementation of [application-defined SQL functions] are protected.
// ^The sqlite3_value object returned by
// [sqlite3_column_value()] is unprotected.
// Unprotected sqlite3_value objects may only be used as arguments
// to [sqlite3_result_value()], [sqlite3_bind_value()], and
// [sqlite3_value_dup()].
// The [sqlite3_value_blob | sqlite3_value_type()] family of
// interfaces require protected sqlite3_value objects.
type sqlite3_value1 = struct {
	Fu        struct{ Fr float64 }
	Fflags    u16
	Fenc      u8
	FeSubtype u8
	Fn        int32
	Fz        uintptr
	FzMalloc  uintptr
	FszMalloc int32
	FuTemp    u32
	Fdb       uintptr
	FxDel     uintptr
} /* sqlite3.h:249:9 */

// CAPI3REF: SQL Function Context Object
//
// The context in which an SQL function executes is stored in an
// sqlite3_context object.  ^A pointer to an sqlite3_context object
// is always first parameter to [application-defined SQL functions].
// The application-defined SQL function implementation will pass this
// pointer through into calls to [sqlite3_result_int | sqlite3_result()],
// [sqlite3_aggregate_context()], [sqlite3_user_data()],
// [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],
// and/or [sqlite3_set_auxdata()].
type sqlite3_context1 = struct {
	FpOut     uintptr
	FpFunc    uintptr
	FpMem     uintptr
	FpVdbe    uintptr
	FiOp      int32
	FisError  int32
	FskipFlag u8
	Fargc     u8
	_         [2]byte
	Fargv     [1]uintptr
} /* sqlite3.h:249:9 */

// CAPI3REF: Constants Defining Special Destructor Behavior
//
// These are special values for the destructor that is passed in as the
// final argument to routines like [sqlite3_result_blob()].  ^If the destructor
// argument is SQLITE_STATIC, it means that the content pointer is constant
// and will never change.  It does not need to be destroyed.  ^The
// SQLITE_TRANSIENT value means that the content will likely change in
// the near future and that SQLite should make its own private copy of
// the content before returning.
//
// The typedef is necessary to work around problems in certain
// C++ compilers.
type sqlite3_destructor_type = uintptr /* sqlite3.h:5665:14 */

// The interface to the virtual-table mechanism is currently considered
// to be experimental.  The interface might change in incompatible ways.
// If this is a problem for you, do not use the interface at this time.
//
// When the virtual-table mechanism stabilizes, we will declare the
// interface fixed, support it indefinitely, and remove this comment.

// Structures used by the virtual table interface
type sqlite3_vtab1 = struct {
	FpModule uintptr
	FnRef    int32
	FzErrMsg uintptr
} /* sqlite3.h:6784:9 */

// The interface to the virtual-table mechanism is currently considered
// to be experimental.  The interface might change in incompatible ways.
// If this is a problem for you, do not use the interface at this time.
//
// When the virtual-table mechanism stabilizes, we will declare the
// interface fixed, support it indefinitely, and remove this comment.

// Structures used by the virtual table interface
type sqlite3_vtab = sqlite3_vtab1 /* sqlite3.h:6784:29 */
type sqlite3_index_info1 = struct {
	FnConstraint      int32
	FaConstraint      uintptr
	FnOrderBy         int32
	FaOrderBy         uintptr
	FaConstraintUsage uintptr
	FidxNum           int32
	FidxStr           uintptr
	FneedToFreeIdxStr int32
	ForderByConsumed  int32
	_                 [4]byte
	FestimatedCost    float64
	FestimatedRows    sqlite3_int64
	FidxFlags         int32
	_                 [4]byte
	FcolUsed          sqlite3_uint64
} /* sqlite3.h:6785:9 */

type sqlite3_index_info = sqlite3_index_info1        /* sqlite3.h:6785:35 */
type sqlite3_vtab_cursor1 = struct{ FpVtab uintptr } /* sqlite3.h:6786:9 */

type sqlite3_vtab_cursor = sqlite3_vtab_cursor1 /* sqlite3.h:6786:36 */
type sqlite3_module1 = struct {
	FiVersion      int32
	FxCreate       uintptr
	FxConnect      uintptr
	FxBestIndex    uintptr
	FxDisconnect   uintptr
	FxDestroy      uintptr
	FxOpen         uintptr
	FxClose        uintptr
	FxFilter       uintptr
	FxNext         uintptr
	FxEof          uintptr
	FxColumn       uintptr
	FxRowid        uintptr
	FxUpdate       uintptr
	FxBegin        uintptr
	FxSync         uintptr
	FxCommit       uintptr
	FxRollback     uintptr
	FxFindFunction uintptr
	FxRename       uintptr
	FxSavepoint    uintptr
	FxRelease      uintptr
	FxRollbackTo   uintptr
	FxShadowName   uintptr
} /* sqlite3.h:6784:9 */

type sqlite3_module = sqlite3_module1 /* sqlite3.h:6787:31 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_constraint = struct {
	FiColumn     int32
	Fop          uint8
	Fusable      uint8
	_            [2]byte
	FiTermOffset int32
} /* sqlite3.h:6785:9 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_orderby = struct {
	FiColumn int32
	Fdesc    uint8
	_        [3]byte
} /* sqlite3.h:6785:9 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_constraint_usage = struct {
	FargvIndex int32
	Fomit      uint8
	_          [3]byte
} /* sqlite3.h:6785:9 */

// CAPI3REF: Mutex Methods Object
//
// An instance of this structure defines the low-level routines
// used to allocate and use mutexes.
//
// Usually, the default mutex implementations provided by SQLite are
// sufficient, however the application has the option of substituting a custom
// implementation for specialized deployments or systems for which SQLite
// does not provide a suitable implementation. In this case, the application
// creates and populates an instance of this structure to pass
// to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
// Additionally, an instance of this structure can be used as an
// output variable when querying the system for the current mutex
// implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
//
// ^The xMutexInit method defined by this structure is invoked as
// part of system initialization by the sqlite3_initialize() function.
// ^The xMutexInit routine is called by SQLite exactly once for each
// effective call to [sqlite3_initialize()].
//
// ^The xMutexEnd method defined by this structure is invoked as
// part of system shutdown by the sqlite3_shutdown() function. The
// implementation of this method is expected to release all outstanding
// resources obtained by the mutex methods implementation, especially
// those obtained by the xMutexInit method.  ^The xMutexEnd()
// interface is invoked exactly once for each call to [sqlite3_shutdown()].
//
// ^(The remaining seven methods defined by this structure (xMutexAlloc,
// xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
// xMutexNotheld) implement the following interfaces (respectively):
//
// <ul>
//   <li>  [sqlite3_mutex_alloc()] </li>
//   <li>  [sqlite3_mutex_free()] </li>
//   <li>  [sqlite3_mutex_enter()] </li>
//   <li>  [sqlite3_mutex_try()] </li>
//   <li>  [sqlite3_mutex_leave()] </li>
//   <li>  [sqlite3_mutex_held()] </li>
//   <li>  [sqlite3_mutex_notheld()] </li>
// </ul>)^
//
// The only difference is that the public sqlite3_XXX functions enumerated
// above silently ignore any invocations that pass a NULL pointer instead
// of a valid mutex handle. The implementations of the methods defined
// by this structure are not required to handle this case. The results
// of passing a NULL pointer instead of a valid mutex handle are undefined
// (i.e. it is acceptable to provide an implementation that segfaults if
// it is passed a NULL pointer).
//
// The xMutexInit() method must be threadsafe.  It must be harmless to
// invoke xMutexInit() multiple times within the same process and without
// intervening calls to xMutexEnd().  Second and subsequent calls to
// xMutexInit() must be no-ops.
//
// xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
// and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
// allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
// memory allocation for a fast or recursive mutex.
//
// ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
// called, but only if the prior call to xMutexInit returned SQLITE_OK.
// If xMutexInit fails in any way, it is expected to clean up after itself
// prior to returning.
type sqlite3_mutex_methods1 = struct {
	FxMutexInit    uintptr
	FxMutexEnd     uintptr
	FxMutexAlloc   uintptr
	FxMutexFree    uintptr
	FxMutexEnter   uintptr
	FxMutexTry     uintptr
	FxMutexLeave   uintptr
	FxMutexHeld    uintptr
	FxMutexNotheld uintptr
} /* sqlite3.h:7619:9 */

// CAPI3REF: Mutex Methods Object
//
// An instance of this structure defines the low-level routines
// used to allocate and use mutexes.
//
// Usually, the default mutex implementations provided by SQLite are
// sufficient, however the application has the option of substituting a custom
// implementation for specialized deployments or systems for which SQLite
// does not provide a suitable implementation. In this case, the application
// creates and populates an instance of this structure to pass
// to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
// Additionally, an instance of this structure can be used as an
// output variable when querying the system for the current mutex
// implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
//
// ^The xMutexInit method defined by this structure is invoked as
// part of system initialization by the sqlite3_initialize() function.
// ^The xMutexInit routine is called by SQLite exactly once for each
// effective call to [sqlite3_initialize()].
//
// ^The xMutexEnd method defined by this structure is invoked as
// part of system shutdown by the sqlite3_shutdown() function. The
// implementation of this method is expected to release all outstanding
// resources obtained by the mutex methods implementation, especially
// those obtained by the xMutexInit method.  ^The xMutexEnd()
// interface is invoked exactly once for each call to [sqlite3_shutdown()].
//
// ^(The remaining seven methods defined by this structure (xMutexAlloc,
// xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
// xMutexNotheld) implement the following interfaces (respectively):
//
// <ul>
//   <li>  [sqlite3_mutex_alloc()] </li>
//   <li>  [sqlite3_mutex_free()] </li>
//   <li>  [sqlite3_mutex_enter()] </li>
//   <li>  [sqlite3_mutex_try()] </li>
//   <li>  [sqlite3_mutex_leave()] </li>
//   <li>  [sqlite3_mutex_held()] </li>
//   <li>  [sqlite3_mutex_notheld()] </li>
// </ul>)^
//
// The only difference is that the public sqlite3_XXX functions enumerated
// above silently ignore any invocations that pass a NULL pointer instead
// of a valid mutex handle. The implementations of the methods defined
// by this structure are not required to handle this case. The results
// of passing a NULL pointer instead of a valid mutex handle are undefined
// (i.e. it is acceptable to provide an implementation that segfaults if
// it is passed a NULL pointer).
//
// The xMutexInit() method must be threadsafe.  It must be harmless to
// invoke xMutexInit() multiple times within the same process and without
// intervening calls to xMutexEnd().  Second and subsequent calls to
// xMutexInit() must be no-ops.
//
// xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
// and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
// allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
// memory allocation for a fast or recursive mutex.
//
// ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
// called, but only if the prior call to xMutexInit returned SQLITE_OK.
// If xMutexInit fails in any way, it is expected to clean up after itself
// prior to returning.
type sqlite3_mutex_methods = sqlite3_mutex_methods1 /* sqlite3.h:7619:38 */

// CAPI3REF: Dynamic String Object
// KEYWORDS: {dynamic string}
//
// An instance of the sqlite3_str object contains a dynamically-sized
// string under construction.
//
// The lifecycle of an sqlite3_str object is as follows:
// <ol>
// <li> ^The sqlite3_str object is created using [sqlite3_str_new()].
// <li> ^Text is appended to the sqlite3_str object using various
// methods, such as [sqlite3_str_appendf()].
// <li> ^The sqlite3_str object is destroyed and the string it created
// is returned using the [sqlite3_str_finish()] interface.
// </ol>
type sqlite3_str1 = struct {
	Fdb          uintptr
	FzText       uintptr
	FnAlloc      u32
	FmxAlloc     u32
	FnChar       u32
	FaccError    u8
	FprintfFlags u8
	_            [2]byte
} /* sqlite3.h:7882:9 */

// CAPI3REF: Custom Page Cache Object
//
// The sqlite3_pcache_page object represents a single page in the
// page cache.  The page cache will allocate instances of this
// object.  Various methods of the page cache use pointers to instances
// of this object as parameters or as their return value.
//
// See [sqlite3_pcache_methods2] for additional information.
type sqlite3_pcache_page1 = struct {
	FpBuf   uintptr
	FpExtra uintptr
} /* sqlite3.h:8375:9 */

// CAPI3REF: Custom Page Cache Object
//
// The sqlite3_pcache_page object represents a single page in the
// page cache.  The page cache will allocate instances of this
// object.  Various methods of the page cache use pointers to instances
// of this object as parameters or as their return value.
//
// See [sqlite3_pcache_methods2] for additional information.
type sqlite3_pcache_page = sqlite3_pcache_page1 /* sqlite3.h:8375:36 */

// CAPI3REF: Application Defined Page Cache.
// KEYWORDS: {page cache}
//
// ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
// register an alternative page cache implementation by passing in an
// instance of the sqlite3_pcache_methods2 structure.)^
// In many applications, most of the heap memory allocated by
// SQLite is used for the page cache.
// By implementing a
// custom page cache using this API, an application can better control
// the amount of memory consumed by SQLite, the way in which
// that memory is allocated and released, and the policies used to
// determine exactly which parts of a database file are cached and for
// how long.
//
// The alternative page cache mechanism is an
// extreme measure that is only needed by the most demanding applications.
// The built-in page cache is recommended for most uses.
//
// ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
// internal buffer by SQLite within the call to [sqlite3_config].  Hence
// the application may discard the parameter after the call to
// [sqlite3_config()] returns.)^
//
// [[the xInit() page cache method]]
// ^(The xInit() method is called once for each effective
// call to [sqlite3_initialize()])^
// (usually only once during the lifetime of the process). ^(The xInit()
// method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
// The intent of the xInit() method is to set up global data structures
// required by the custom page cache implementation.
// ^(If the xInit() method is NULL, then the
// built-in default page cache is used instead of the application defined
// page cache.)^
//
// [[the xShutdown() page cache method]]
// ^The xShutdown() method is called by [sqlite3_shutdown()].
// It can be used to clean up
// any outstanding resources before process shutdown, if required.
// ^The xShutdown() method may be NULL.
//
// ^SQLite automatically serializes calls to the xInit method,
// so the xInit method need not be threadsafe.  ^The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  All other methods must be threadsafe
// in multithreaded applications.
//
// ^SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
//
// [[the xCreate() page cache methods]]
// ^SQLite invokes the xCreate() method to construct a new cache instance.
// SQLite will typically create one cache instance for each open database file,
// though this is not guaranteed. ^The
// first parameter, szPage, is the size in bytes of the pages that must
// be allocated by the cache.  ^szPage will always a power of two.  ^The
// second parameter szExtra is a number of bytes of extra storage
// associated with each page cache entry.  ^The szExtra parameter will
// a number less than 250.  SQLite will use the
// extra szExtra bytes on each page to store metadata about the underlying
// database page on disk.  The value passed into szExtra depends
// on the SQLite version, the target platform, and how SQLite was compiled.
// ^The third argument to xCreate(), bPurgeable, is true if the cache being
// created will be used to cache database pages of a file stored on disk, or
// false if it is used for an in-memory database. The cache implementation
// does not have to do anything special based with the value of bPurgeable;
// it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
// never invoke xUnpin() except to deliberately delete a page.
// ^In other words, calls to xUnpin() on a cache with bPurgeable set to
// false will always have the "discard" flag set to true.
// ^Hence, a cache created with bPurgeable false will
// never contain any unpinned pages.
//
// [[the xCachesize() page cache method]]
// ^(The xCachesize() method may be called at any time by SQLite to set the
// suggested maximum cache-size (number of pages stored by) the cache
// instance passed as the first argument. This is the value configured using
// the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
// parameter, the implementation is not required to do anything with this
// value; it is advisory only.
//
// [[the xPagecount() page cache methods]]
// The xPagecount() method must return the number of pages currently
// stored in the cache, both pinned and unpinned.
//
// [[the xFetch() page cache methods]]
// The xFetch() method locates a page in the cache and returns a pointer to
// an sqlite3_pcache_page object associated with that page, or a NULL pointer.
// The pBuf element of the returned sqlite3_pcache_page object will be a
// pointer to a buffer of szPage bytes used to store the content of a
// single database page.  The pExtra element of sqlite3_pcache_page will be
// a pointer to the szExtra bytes of extra storage that SQLite has requested
// for each entry in the page cache.
//
// The page to be fetched is determined by the key. ^The minimum key value
// is 1.  After it has been retrieved using xFetch, the page is considered
// to be "pinned".
//
// If the requested page is already in the page cache, then the page cache
// implementation must return a pointer to the page buffer with its content
// intact.  If the requested page is not already in the cache, then the
// cache implementation should use the value of the createFlag
// parameter to help it determined what action to take:
//
// <table border=1 width=85% align=center>
// <tr><th> createFlag <th> Behavior when page is not already in cache
// <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
// <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
//                 Otherwise return NULL.
// <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
//                 NULL if allocating a new page is effectively impossible.
// </table>
//
// ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
// will only use a createFlag of 2 after a prior call with a createFlag of 1
// failed.)^  In between the xFetch() calls, SQLite may
// attempt to unpin one or more cache pages by spilling the content of
// pinned pages to disk and synching the operating system disk cache.
//
// [[the xUnpin() page cache method]]
// ^xUnpin() is called by SQLite with a pointer to a currently pinned page
// as its second argument.  If the third parameter, discard, is non-zero,
// then the page must be evicted from the cache.
// ^If the discard parameter is
// zero, then the page may be discarded or retained at the discretion of
// page cache implementation. ^The page cache implementation
// may choose to evict unpinned pages at any time.
//
// The cache must not perform any reference counting. A single
// call to xUnpin() unpins the page regardless of the number of prior calls
// to xFetch().
//
// [[the xRekey() page cache methods]]
// The xRekey() method is used to change the key value associated with the
// page passed as the second argument. If the cache
// previously contains an entry associated with newKey, it must be
// discarded. ^Any prior cache entry associated with newKey is guaranteed not
// to be pinned.
//
// When SQLite calls the xTruncate() method, the cache must discard all
// existing cache entries with page numbers (keys) greater than or equal
// to the value of the iLimit parameter passed to xTruncate(). If any
// of these pages are pinned, they are implicitly unpinned, meaning that
// they can be safely discarded.
//
// [[the xDestroy() page cache method]]
// ^The xDestroy() method is used to delete a cache allocated by xCreate().
// All resources associated with the specified cache should be freed. ^After
// calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
// handle invalid, and will not use it with any other sqlite3_pcache_methods2
// functions.
//
// [[the xShrink() page cache method]]
// ^SQLite invokes the xShrink() method when it wants the page cache to
// free up as much of heap memory as possible.  The page cache implementation
// is not obligated to free any memory, but well-behaved implementations should
// do their best.
type sqlite3_pcache_methods21 = struct {
	FiVersion   int32
	FpArg       uintptr
	FxInit      uintptr
	FxShutdown  uintptr
	FxCreate    uintptr
	FxCachesize uintptr
	FxPagecount uintptr
	FxFetch     uintptr
	FxUnpin     uintptr
	FxRekey     uintptr
	FxTruncate  uintptr
	FxDestroy   uintptr
	FxShrink    uintptr
} /* sqlite3.h:8540:9 */

// CAPI3REF: Application Defined Page Cache.
// KEYWORDS: {page cache}
//
// ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
// register an alternative page cache implementation by passing in an
// instance of the sqlite3_pcache_methods2 structure.)^
// In many applications, most of the heap memory allocated by
// SQLite is used for the page cache.
// By implementing a
// custom page cache using this API, an application can better control
// the amount of memory consumed by SQLite, the way in which
// that memory is allocated and released, and the policies used to
// determine exactly which parts of a database file are cached and for
// how long.
//
// The alternative page cache mechanism is an
// extreme measure that is only needed by the most demanding applications.
// The built-in page cache is recommended for most uses.
//
// ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
// internal buffer by SQLite within the call to [sqlite3_config].  Hence
// the application may discard the parameter after the call to
// [sqlite3_config()] returns.)^
//
// [[the xInit() page cache method]]
// ^(The xInit() method is called once for each effective
// call to [sqlite3_initialize()])^
// (usually only once during the lifetime of the process). ^(The xInit()
// method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
// The intent of the xInit() method is to set up global data structures
// required by the custom page cache implementation.
// ^(If the xInit() method is NULL, then the
// built-in default page cache is used instead of the application defined
// page cache.)^
//
// [[the xShutdown() page cache method]]
// ^The xShutdown() method is called by [sqlite3_shutdown()].
// It can be used to clean up
// any outstanding resources before process shutdown, if required.
// ^The xShutdown() method may be NULL.
//
// ^SQLite automatically serializes calls to the xInit method,
// so the xInit method need not be threadsafe.  ^The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  All other methods must be threadsafe
// in multithreaded applications.
//
// ^SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
//
// [[the xCreate() page cache methods]]
// ^SQLite invokes the xCreate() method to construct a new cache instance.
// SQLite will typically create one cache instance for each open database file,
// though this is not guaranteed. ^The
// first parameter, szPage, is the size in bytes of the pages that must
// be allocated by the cache.  ^szPage will always a power of two.  ^The
// second parameter szExtra is a number of bytes of extra storage
// associated with each page cache entry.  ^The szExtra parameter will
// a number less than 250.  SQLite will use the
// extra szExtra bytes on each page to store metadata about the underlying
// database page on disk.  The value passed into szExtra depends
// on the SQLite version, the target platform, and how SQLite was compiled.
// ^The third argument to xCreate(), bPurgeable, is true if the cache being
// created will be used to cache database pages of a file stored on disk, or
// false if it is used for an in-memory database. The cache implementation
// does not have to do anything special based with the value of bPurgeable;
// it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
// never invoke xUnpin() except to deliberately delete a page.
// ^In other words, calls to xUnpin() on a cache with bPurgeable set to
// false will always have the "discard" flag set to true.
// ^Hence, a cache created with bPurgeable false will
// never contain any unpinned pages.
//
// [[the xCachesize() page cache method]]
// ^(The xCachesize() method may be called at any time by SQLite to set the
// suggested maximum cache-size (number of pages stored by) the cache
// instance passed as the first argument. This is the value configured using
// the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
// parameter, the implementation is not required to do anything with this
// value; it is advisory only.
//
// [[the xPagecount() page cache methods]]
// The xPagecount() method must return the number of pages currently
// stored in the cache, both pinned and unpinned.
//
// [[the xFetch() page cache methods]]
// The xFetch() method locates a page in the cache and returns a pointer to
// an sqlite3_pcache_page object associated with that page, or a NULL pointer.
// The pBuf element of the returned sqlite3_pcache_page object will be a
// pointer to a buffer of szPage bytes used to store the content of a
// single database page.  The pExtra element of sqlite3_pcache_page will be
// a pointer to the szExtra bytes of extra storage that SQLite has requested
// for each entry in the page cache.
//
// The page to be fetched is determined by the key. ^The minimum key value
// is 1.  After it has been retrieved using xFetch, the page is considered
// to be "pinned".
//
// If the requested page is already in the page cache, then the page cache
// implementation must return a pointer to the page buffer with its content
// intact.  If the requested page is not already in the cache, then the
// cache implementation should use the value of the createFlag
// parameter to help it determined what action to take:
//
// <table border=1 width=85% align=center>
// <tr><th> createFlag <th> Behavior when page is not already in cache
// <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
// <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
//                 Otherwise return NULL.
// <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
//                 NULL if allocating a new page is effectively impossible.
// </table>
//
// ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
// will only use a createFlag of 2 after a prior call with a createFlag of 1
// failed.)^  In between the xFetch() calls, SQLite may
// attempt to unpin one or more cache pages by spilling the content of
// pinned pages to disk and synching the operating system disk cache.
//
// [[the xUnpin() page cache method]]
// ^xUnpin() is called by SQLite with a pointer to a currently pinned page
// as its second argument.  If the third parameter, discard, is non-zero,
// then the page must be evicted from the cache.
// ^If the discard parameter is
// zero, then the page may be discarded or retained at the discretion of
// page cache implementation. ^The page cache implementation
// may choose to evict unpinned pages at any time.
//
// The cache must not perform any reference counting. A single
// call to xUnpin() unpins the page regardless of the number of prior calls
// to xFetch().
//
// [[the xRekey() page cache methods]]
// The xRekey() method is used to change the key value associated with the
// page passed as the second argument. If the cache
// previously contains an entry associated with newKey, it must be
// discarded. ^Any prior cache entry associated with newKey is guaranteed not
// to be pinned.
//
// When SQLite calls the xTruncate() method, the cache must discard all
// existing cache entries with page numbers (keys) greater than or equal
// to the value of the iLimit parameter passed to xTruncate(). If any
// of these pages are pinned, they are implicitly unpinned, meaning that
// they can be safely discarded.
//
// [[the xDestroy() page cache method]]
// ^The xDestroy() method is used to delete a cache allocated by xCreate().
// All resources associated with the specified cache should be freed. ^After
// calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
// handle invalid, and will not use it with any other sqlite3_pcache_methods2
// functions.
//
// [[the xShrink() page cache method]]
// ^SQLite invokes the xShrink() method when it wants the page cache to
// free up as much of heap memory as possible.  The page cache implementation
// is not obligated to free any memory, but well-behaved implementations should
// do their best.
type sqlite3_pcache_methods2 = sqlite3_pcache_methods21 /* sqlite3.h:8540:40 */

// This is the obsolete pcache_methods object that has now been replaced
// by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
// retained in the header file for backwards compatibility only.
type sqlite3_pcache_methods1 = struct {
	FpArg       uintptr
	FxInit      uintptr
	FxShutdown  uintptr
	FxCreate    uintptr
	FxCachesize uintptr
	FxPagecount uintptr
	FxFetch     uintptr
	FxUnpin     uintptr
	FxRekey     uintptr
	FxTruncate  uintptr
	FxDestroy   uintptr
} /* sqlite3.h:8563:9 */

// This is the obsolete pcache_methods object that has now been replaced
// by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
// retained in the header file for backwards compatibility only.
type sqlite3_pcache_methods = sqlite3_pcache_methods1 /* sqlite3.h:8563:39 */

// CAPI3REF: Database Snapshot
// KEYWORDS: {snapshot} {sqlite3_snapshot}
//
// An instance of the snapshot object records the state of a [WAL mode]
// database for some specific point in history.
//
// In [WAL mode], multiple [database connections] that are open on the
// same database file can each be reading a different historical version
// of the database file.  When a [database connection] begins a read
// transaction, that connection sees an unchanging copy of the database
// as it existed for the point in time when the transaction first started.
// Subsequent changes to the database from other connections are not seen
// by the reader until a new read transaction is started.
//
// The sqlite3_snapshot object records state information about an historical
// version of the database file so that it is possible to later open a new read
// transaction that sees that historical version of the database rather than
// the most recent version.
type sqlite3_snapshot1 = struct{ Fhidden [48]uint8 } /* sqlite3.h:9630:9 */

// CAPI3REF: Database Snapshot
// KEYWORDS: {snapshot} {sqlite3_snapshot}
//
// An instance of the snapshot object records the state of a [WAL mode]
// database for some specific point in history.
//
// In [WAL mode], multiple [database connections] that are open on the
// same database file can each be reading a different historical version
// of the database file.  When a [database connection] begins a read
// transaction, that connection sees an unchanging copy of the database
// as it existed for the point in time when the transaction first started.
// Subsequent changes to the database from other connections are not seen
// by the reader until a new read transaction is started.
//
// The sqlite3_snapshot object records state information about an historical
// version of the database file so that it is possible to later open a new read
// transaction that sees that historical version of the database rather than
// the most recent version.
type sqlite3_snapshot = sqlite3_snapshot1 /* sqlite3.h:9632:3 */

// CAPI3REF: Flags for sqlite3_deserialize()
//
// The following are allowed values for 6th argument (the F argument) to
// the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
//
// The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
// in the P argument is held in memory obtained from [sqlite3_malloc64()]
// and that SQLite should take ownership of this memory and automatically
// free it when it has finished using it.  Without this flag, the caller
// is responsible for freeing any dynamically allocated memory.
//
// The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
// grow the size of the database using calls to [sqlite3_realloc64()].  This
// flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
// Without this flag, the deserialized database cannot increase in size beyond
// the number of bytes specified by the M parameter.
//
// The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
// should be treated as read-only.

// Undo the hack that converts floating point types to integer for
// builds on processors without floating point support.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

type sqlite3_rtree_geometry1 = struct {
	FpContext uintptr
	FnParam   int32
	FaParam   uintptr
	FpUser    uintptr
	FxDelUser uintptr
} /* sqlite3.h:9957:9 */

// CAPI3REF: Flags for sqlite3_deserialize()
//
// The following are allowed values for 6th argument (the F argument) to
// the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
//
// The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
// in the P argument is held in memory obtained from [sqlite3_malloc64()]
// and that SQLite should take ownership of this memory and automatically
// free it when it has finished using it.  Without this flag, the caller
// is responsible for freeing any dynamically allocated memory.
//
// The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
// grow the size of the database using calls to [sqlite3_realloc64()].  This
// flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
// Without this flag, the deserialized database cannot increase in size beyond
// the number of bytes specified by the M parameter.
//
// The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
// should be treated as read-only.

// Undo the hack that converts floating point types to integer for
// builds on processors without floating point support.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

type sqlite3_rtree_geometry = sqlite3_rtree_geometry1 /* sqlite3.h:9957:39 */
type sqlite3_rtree_query_info1 = struct {
	FpContext      uintptr
	FnParam        int32
	FaParam        uintptr
	FpUser         uintptr
	FxDelUser      uintptr
	FaCoord        uintptr
	FanQueue       uintptr
	FnCoord        int32
	FiLevel        int32
	FmxLevel       int32
	FiRowid        sqlite3_int64
	FrParentScore  sqlite3_rtree_dbl
	FeParentWithin int32
	FeWithin       int32
	FrScore        sqlite3_rtree_dbl
	FapSqlParam    uintptr
	_              [4]byte
} /* sqlite3.h:9958:9 */

type sqlite3_rtree_query_info = sqlite3_rtree_query_info1 /* sqlite3.h:9958:41 */

// The double-precision datatype used by RTree depends on the
// SQLITE_RTREE_INT_ONLY compile-time option.
type sqlite3_rtree_dbl = float64 /* sqlite3.h:9966:18 */

// Allowed values for sqlite3_rtree_query.eWithin and .eParentWithin.

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

// ************************************************************************
//
// CUSTOM AUXILIARY FUNCTIONS
//
// Virtual table implementations may overload SQL functions by implementing
// the sqlite3_module.xFindFunction() method.

type Fts5ExtensionApi1 = struct {
	FiVersion           int32
	FxUserData          uintptr
	FxColumnCount       uintptr
	FxRowCount          uintptr
	FxColumnTotalSize   uintptr
	FxTokenize          uintptr
	FxPhraseCount       uintptr
	FxPhraseSize        uintptr
	FxInstCount         uintptr
	FxInst              uintptr
	FxRowid             uintptr
	FxColumnText        uintptr
	FxColumnSize        uintptr
	FxQueryPhrase       uintptr
	FxSetAuxdata        uintptr
	FxGetAuxdata        uintptr
	FxPhraseFirst       uintptr
	FxPhraseNext        uintptr
	FxPhraseFirstColumn uintptr
	FxPhraseNextColumn  uintptr
} /* sqlite3.h:11813:9 */

// Allowed values for sqlite3_rtree_query.eWithin and .eParentWithin.

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

// ************************************************************************
//
// CUSTOM AUXILIARY FUNCTIONS
//
// Virtual table implementations may overload SQL functions by implementing
// the sqlite3_module.xFindFunction() method.

type Fts5ExtensionApi = Fts5ExtensionApi1 /* sqlite3.h:11813:33 */
type Fts5PhraseIter1 = struct {
	Fa uintptr
	Fb uintptr
} /* sqlite3.h:11815:9 */

type Fts5PhraseIter = Fts5PhraseIter1 /* sqlite3.h:11815:31 */

type fts5_extension_function = uintptr /* sqlite3.h:11817:14 */
type fts5_tokenizer1 = struct {
	FxCreate   uintptr
	FxDelete   uintptr
	FxTokenize uintptr
} /* sqlite3.h:12276:9 */

type fts5_tokenizer = fts5_tokenizer1 /* sqlite3.h:12276:31 */

// Flags that may be passed as the third argument to xTokenize()

// Flags that may be passed by the tokenizer implementation back to FTS5
// as the third argument to the supplied xToken callback.

//
// END OF CUSTOM TOKENIZERS
//

// ************************************************************************
//
// FTS5 EXTENSION REGISTRATION API
type fts5_api1 = struct {
	FiVersion         int32
	FxCreateTokenizer uintptr
	FxFindTokenizer   uintptr
	FxCreateFunction  uintptr
} /* sqlite3.h:12312:9 */

// Flags that may be passed as the third argument to xTokenize()

// Flags that may be passed by the tokenizer implementation back to FTS5
// as the third argument to the supplied xToken callback.

//
// END OF CUSTOM TOKENIZERS
//

// ************************************************************************
//
// FTS5 EXTENSION REGISTRATION API
type fts5_api = fts5_api1 /* sqlite3.h:12312:25 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

type sqlite3expert1 = struct {
	FiSample     int32
	Fdb          uintptr
	Fdbm         uintptr
	Fdbv         uintptr
	FpTable      uintptr
	FpScan       uintptr
	FpWrite      uintptr
	FpStatement  uintptr
	FbRun        int32
	FpzErrmsg    uintptr
	Frc          int32
	FhIdx        IdxHash
	FzCandidates uintptr
} /* sqlite3expert.h:17:9 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

type sqlite3expert = sqlite3expert1 /* sqlite3expert.h:17:30 */

// POSIX.1-2008 extended locale interface (see locale.h).
// Definition of locale_t.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//    Copyright (C) 1997-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//    (implementation-namespace version).  This type should be treated
//    as opaque by applications; some details are exposed for the sake of
//    efficiency in e.g. ctype functions.

type __locale_struct = struct {
	F__locales       [13]uintptr
	F__ctype_b       uintptr
	F__ctype_tolower uintptr
	F__ctype_toupper uintptr
	F__names         [13]uintptr
} /* __locale_t.h:28:1 */

type locale_t = uintptr /* locale_t.h:24:20 */

// The tag name of this struct is _G_fpos_t to preserve historic
//    C++ mangled names for functions taking fpos_t arguments.
//    That name should not be used in new code.
type _G_fpos_t = struct {
	F__pos   int32
	F__state struct {
		F__count int32
		F__value struct{ F__wch uint32 }
	}
} /* __fpos_t.h:10:9 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//    C++ mangled names for functions taking fpos_t and/or fpos64_t
//    arguments.  That name should not be used in new code.
type _G_fpos64_t = struct {
	F__pos   int64
	F__state struct {
		F__count int32
		F__value struct{ F__wch uint32 }
	}
} /* __fpos64_t.h:10:9 */

type _IO_FILE = struct {
	F_flags          int32
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     int32
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]int8
	F_lock           uintptr
	_                [4]byte
	F_offset         int64
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          size_t
	F_mode           int32
	F_unused2        [40]int8
} /* __FILE.h:4:1 */

// The opaque type of streams.  This is the definition used elsewhere.
type FILE = _IO_FILE /* FILE.h:7:25 */

// These macros are used by bits/stdio.h and internal headers.

// Many more flag bits are defined internally.

type off_t = int64 /* stdio.h:65:19 */

type ssize_t = int32 /* stdio.h:77:19 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type fpos_t = _G_fpos64_t /* stdio.h:86:20 */

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

type i64 = sqlite3_int64  /* sqlite3expert.c:20:23 */
type u64 = sqlite3_uint64 /* sqlite3expert.c:21:24 */

type IdxColumn1 = struct {
	FzName uintptr
	FzColl uintptr
	FiPk   int32
} /* sqlite3expert.h:17:9 */

type IdxColumn = IdxColumn1 /* sqlite3expert.c:23:26 */
type IdxConstraint1 = struct {
	FzColl  uintptr
	FbRange int32
	FiCol   int32
	FbFlag  int32
	FbDesc  int32
	FpNext  uintptr
	FpLink  uintptr
} /* sqlite3expert.h:17:9 */

type IdxConstraint = IdxConstraint1 /* sqlite3expert.c:24:30 */
type IdxScan1 = struct {
	FpTab      uintptr
	FiDb       int32
	Fcovering  i64
	FpOrder    uintptr
	FpEq       uintptr
	FpRange    uintptr
	FpNextScan uintptr
} /* sqlite3expert.h:17:9 */

type IdxScan = IdxScan1 /* sqlite3expert.c:25:24 */
type IdxStatement1 = struct {
	FiId   int32
	FzSql  uintptr
	FzIdx  uintptr
	FzEQP  uintptr
	FpNext uintptr
} /* sqlite3expert.h:17:9 */

type IdxStatement = IdxStatement1 /* sqlite3expert.c:26:29 */
type IdxTable1 = struct {
	FnCol  int32
	FzName uintptr
	FaCol  uintptr
	FpNext uintptr
} /* sqlite3expert.h:17:9 */

type IdxTable = IdxTable1 /* sqlite3expert.c:27:25 */
type IdxWrite1 = struct {
	FpTab  uintptr
	FeOp   int32
	FpNext uintptr
} /* sqlite3expert.h:17:9 */

type IdxWrite = IdxWrite1 /* sqlite3expert.c:28:25 */

// A hash table for storing strings. With space for a payload string
// with each entry. Methods are:
//
//   idxHashInit()
//   idxHashClear()
//   idxHashAdd()
//   idxHashSearch()
type IdxHashEntry1 = struct {
	FzKey      uintptr
	FzVal      uintptr
	FzVal2     uintptr
	FpHashNext uintptr
	FpNext     uintptr
} /* sqlite3expert.h:17:9 */

// A hash table for storing strings. With space for a payload string
// with each entry. Methods are:
//
//   idxHashInit()
//   idxHashClear()
//   idxHashAdd()
//   idxHashSearch()
type IdxHashEntry = IdxHashEntry1 /* sqlite3expert.c:120:29 */
type IdxHash1 = struct {
	FpFirst uintptr
	FaHash  [1023]uintptr
} /* sqlite3expert.h:17:9 */

type IdxHash = IdxHash1 /* sqlite3expert.c:121:24 */

// Allocate and return nByte bytes of zeroed memory using sqlite3_malloc().
// If the allocation fails, set *pRc to SQLITE_NOMEM and return NULL.
func idxMalloc(tls *libc.TLS, pRc uintptr, nByte int32) uintptr { /* sqlite3expert.c:158:13: */
	var pRet uintptr

	pRet = sqlite3.Xsqlite3_malloc(tls, nByte)
	if pRet != 0 {
		libc.Xmemset(tls, pRet, 0, uint32(nByte))
	} else {
		*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
	}
	return pRet
}

// Initialize an IdxHash hash table.
func idxHashInit(tls *libc.TLS, pHash uintptr) { /* sqlite3expert.c:174:13: */
	libc.Xmemset(tls, pHash, 0, uint32(unsafe.Sizeof(IdxHash{})))
}

// Reset an IdxHash hash table.
func idxHashClear(tls *libc.TLS, pHash uintptr) { /* sqlite3expert.c:181:13: */
	var i int32
	for i = 0; i < IDX_HASH_SIZE; i++ {
		var pEntry uintptr
		var pNext uintptr
		for pEntry = *(*uintptr)(unsafe.Pointer((pHash + 4 /* &.aHash */) + uintptr(i)*4)); pEntry != 0; pEntry = pNext {
			pNext = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext
			sqlite3.Xsqlite3_free(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2)
			sqlite3.Xsqlite3_free(tls, pEntry)
		}
	}
	libc.Xmemset(tls, pHash, 0, uint32(unsafe.Sizeof(IdxHash{})))
}

// Return the index of the hash bucket that the string specified by the
// arguments to this function belongs.
func idxHashString(tls *libc.TLS, z uintptr, n int32) int32 { /* sqlite3expert.c:199:12: */
	var ret uint32 = uint32(0)
	var i int32
	for i = 0; i < n; i++ {
		ret = ret + ((ret << 3) + uint32((uint8(*(*int8)(unsafe.Pointer(z + uintptr(i)))))))
	}
	return (int32(ret % uint32(IDX_HASH_SIZE)))
}

// If zKey is already present in the hash table, return non-zero and do
// nothing. Otherwise, add an entry with key zKey and payload string zVal to
// the hash table passed as the second argument.
func idxHashAdd(tls *libc.TLS, pRc uintptr, pHash uintptr, zKey uintptr, zVal uintptr) int32 { /* sqlite3expert.c:213:12: */
	var nKey int32 = int32(libc.Xstrlen(tls, zKey))
	var iHash int32 = idxHashString(tls, zKey, nKey)
	var nVal int32 = func() int32 {
		if zVal != 0 {
			return int32(libc.Xstrlen(tls, zVal))
		}
		return 0
	}()
	var pEntry uintptr

	for pEntry = *(*uintptr)(unsafe.Pointer((pHash + 4 /* &.aHash */) + uintptr(iHash)*4)); pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext {
		if (int32(libc.Xstrlen(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey)) == nKey) && (0 == libc.Xmemcmp(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint32(nKey))) {
			return 1
		}
	}
	pEntry = idxMalloc(tls, pRc, (int32((((uint32(unsafe.Sizeof(IdxHashEntry{})) + uint32(nKey)) + uint32(1)) + uint32(nVal)) + uint32(1))))
	if pEntry != 0 {
		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey = (pEntry + 1*20)
		libc.Xmemcpy(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint32(nKey))
		if zVal != 0 {
			(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal = ((*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey + uintptr((nKey + 1)))
			libc.Xmemcpy(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal, zVal, uint32(nVal))
		}
		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext = *(*uintptr)(unsafe.Pointer((pHash + 4 /* &.aHash */) + uintptr(iHash)*4))
		*(*uintptr)(unsafe.Pointer((pHash + 4 /* &.aHash */) + uintptr(iHash)*4)) = pEntry

		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext = (*IdxHash)(unsafe.Pointer(pHash)).FpFirst
		(*IdxHash)(unsafe.Pointer(pHash)).FpFirst = pEntry
	}
	return 0
}

// If zKey/nKey is present in the hash table, return a pointer to the
// hash-entry object.
func idxHashFind(tls *libc.TLS, pHash uintptr, zKey uintptr, nKey int32) uintptr { /* sqlite3expert.c:250:21: */
	var iHash int32
	var pEntry uintptr
	if nKey < 0 {
		nKey = int32(libc.Xstrlen(tls, zKey))
	}
	iHash = idxHashString(tls, zKey, nKey)

	for pEntry = *(*uintptr)(unsafe.Pointer((pHash + 4 /* &.aHash */) + uintptr(iHash)*4)); pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext {
		if (int32(libc.Xstrlen(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey)) == nKey) && (0 == libc.Xmemcmp(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint32(nKey))) {
			return pEntry
		}
	}
	return uintptr(0)
}

// If the hash table contains an entry with a key equal to the string
// passed as the final two arguments to this function, return a pointer
// to the payload string. Otherwise, if zKey/nKey is not present in the
// hash table, return NULL.
func idxHashSearch(tls *libc.TLS, pHash uintptr, zKey uintptr, nKey int32) uintptr { /* sqlite3expert.c:270:19: */
	var pEntry uintptr = idxHashFind(tls, pHash, zKey, nKey)
	if pEntry != 0 {
		return (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal
	}
	return uintptr(0)
}

// Allocate and return a new IdxConstraint object. Set the IdxConstraint.zColl
// variable to point to a copy of nul-terminated string zColl.
func idxNewConstraint(tls *libc.TLS, pRc uintptr, zColl uintptr) uintptr { /* sqlite3expert.c:280:22: */
	var pNew uintptr
	var nColl int32 = int32(libc.Xstrlen(tls, zColl))

	pNew = idxMalloc(tls, pRc, (int32((uint32(unsafe.Sizeof(IdxConstraint{})) * uint32(nColl)) + uint32(1))))
	if pNew != 0 {
		(*IdxConstraint)(unsafe.Pointer(pNew)).FzColl = (pNew + 1*28)
		libc.Xmemcpy(tls, (*IdxConstraint)(unsafe.Pointer(pNew)).FzColl, zColl, (uint32(nColl + 1)))
	}
	return pNew
}

// An error associated with database handle db has just occurred. Pass
// the error message to callback function xOut.
func idxDatabaseError(tls *libc.TLS, db uintptr, pzErrmsg uintptr) { /* sqlite3expert.c:297:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*uintptr)(unsafe.Pointer(pzErrmsg)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
}

// Prepare an SQL statement.
func idxPrepareStmt(tls *libc.TLS, db uintptr, ppStmt uintptr, pzErrmsg uintptr, zSql uintptr) int32 { /* sqlite3expert.c:307:12: */
	var rc int32 = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, ppStmt, uintptr(0))
	if rc != SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)
		idxDatabaseError(tls, db, pzErrmsg)
	}
	return rc
}

// Prepare an SQL statement using the results of a printf() formatting.
func idxPrintfPrepareStmt(tls *libc.TLS, db uintptr, ppStmt uintptr, pzErrmsg uintptr, zFmt uintptr, va uintptr) int32 { /* sqlite3expert.c:324:12: */
	var ap va_list
	_ = ap
	var rc int32
	var zSql uintptr
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		rc = idxPrepareStmt(tls, db, ppStmt, pzErrmsg, zSql)
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	_ = ap
	return rc
}

// ************************************************************************
//
// Beginning of virtual table implementation.
type ExpertVtab1 = struct {
	Fbase    sqlite3_vtab
	FpTab    uintptr
	FpExpert uintptr
} /* sqlite3expert.c:350:9 */

// ************************************************************************
//
// Beginning of virtual table implementation.
type ExpertVtab = ExpertVtab1 /* sqlite3expert.c:350:27 */

type ExpertCsr1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpData uintptr
} /* sqlite3expert.c:357:9 */

type ExpertCsr = ExpertCsr1 /* sqlite3expert.c:357:26 */

func expertDequote(tls *libc.TLS, zIn uintptr) uintptr { /* sqlite3expert.c:363:13: */
	var n int32 = int32(libc.Xstrlen(tls, zIn))
	var zRet uintptr = sqlite3.Xsqlite3_malloc(tls, n)

	if zRet != 0 {
		var iOut int32 = 0
		var iIn int32 = 0
		for iIn = 1; iIn < (n - 1); iIn++ {
			if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == '\'' {

				iIn++
			}
			*(*int8)(unsafe.Pointer(zRet + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
		}
		*(*int8)(unsafe.Pointer(zRet + uintptr(iOut))) = int8(0)
	}

	return zRet
}

// This function is the implementation of both the xConnect and xCreate
// methods of the r-tree virtual table.
//
//   argv[0]   -> module name
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> column names...
func expertConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:395:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pExpert uintptr = pAux
	var p uintptr = uintptr(0)
	// var rc int32 at bp, 4

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3 /* "internal error!" */, 0)
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_ERROR
	} else {
		var zCreateTable uintptr = expertDequote(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
		if zCreateTable != 0 {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3_declare_vtab(tls, db, zCreateTable)
			if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
				p = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(ExpertVtab{})))
			}
			if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
				(*ExpertVtab)(unsafe.Pointer(p)).FpExpert = pExpert
				(*ExpertVtab)(unsafe.Pointer(p)).FpTab = (*sqlite3expert)(unsafe.Pointer(pExpert)).FpTable

			}
			sqlite3.Xsqlite3_free(tls, zCreateTable)
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_NOMEM
		}
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = p
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func expertDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* sqlite3expert.c:431:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

func expertBestIndex(tls *libc.TLS, pVtab uintptr, pIdxInfo uintptr) int32 { /* sqlite3expert.c:437:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pVtab
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var n int32 = 0
	var pScan uintptr
	var opmask int32 = ((((SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_GT) | SQLITE_INDEX_CONSTRAINT_LT) | SQLITE_INDEX_CONSTRAINT_GE) | SQLITE_INDEX_CONSTRAINT_LE)

	pScan = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(IdxScan{})))
	if pScan != 0 {
		var i int32

		// Link the new scan object into the list
		(*IdxScan)(unsafe.Pointer(pScan)).FpTab = (*ExpertVtab)(unsafe.Pointer(p)).FpTab
		(*IdxScan)(unsafe.Pointer(pScan)).FpNextScan = (*sqlite3expert)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpExpert)).FpScan
		(*sqlite3expert)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpExpert)).FpScan = pScan

		// Add the constraints to the IdxScan object
		for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
			var pCons uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)
			if ((((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0) &&
				((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn >= 0)) &&
				((*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpTab)).FaCol+uintptr((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn)*12)).FiPk == 0)) &&
				((int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) & opmask) != 0) {
				var pNew uintptr
				var zColl uintptr = sqlite3.Xsqlite3_vtab_collation(tls, pIdxInfo, i)
				pNew = idxNewConstraint(tls, bp /* &rc */, zColl)
				if pNew != 0 {
					(*IdxConstraint)(unsafe.Pointer(pNew)).FiCol = (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn
					if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
						(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpEq
						(*IdxScan)(unsafe.Pointer(pScan)).FpEq = pNew
					} else {
						(*IdxConstraint)(unsafe.Pointer(pNew)).FbRange = 1
						(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpRange
						(*IdxScan)(unsafe.Pointer(pScan)).FpRange = pNew
					}
				}
				n++
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = n
			}
		}

		// Add the ORDER BY to the IdxScan object
		for i = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy - 1); i >= 0; i-- {
			var iCol int32 = (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(i)*8)).FiColumn
			if iCol >= 0 {
				var pNew uintptr = idxNewConstraint(tls, bp /* &rc */, (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpTab)).FaCol+uintptr(iCol)*12)).FzColl)
				if pNew != 0 {
					(*IdxConstraint)(unsafe.Pointer(pNew)).FiCol = iCol
					(*IdxConstraint)(unsafe.Pointer(pNew)).FbDesc = int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(i)*8)).Fdesc)
					(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpOrder
					(*IdxConstraint)(unsafe.Pointer(pNew)).FpLink = (*IdxScan)(unsafe.Pointer(pScan)).FpOrder
					(*IdxScan)(unsafe.Pointer(pScan)).FpOrder = pNew
					n++
				}
			}
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = (1000000.0 / (float64(n + 1)))
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func expertUpdate(tls *libc.TLS, pVtab uintptr, nData int32, azData uintptr, pRowid uintptr) int32 { /* sqlite3expert.c:504:12: */
	_ = pVtab
	_ = nData
	_ = azData
	_ = pRowid
	return SQLITE_OK
}

// Virtual table module xOpen method.
func expertOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* sqlite3expert.c:520:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pCsr uintptr
	_ = pVTab
	pCsr = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(ExpertCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCsr
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Virtual table module xClose method.
func expertClose(tls *libc.TLS, cur uintptr) int32 { /* sqlite3expert.c:532:12: */
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

// Virtual table module xEof method.
//
// Return non-zero if the cursor does not currently point to a valid
// record (i.e if the scan has finished), or zero otherwise.
func expertEof(tls *libc.TLS, cur uintptr) int32 { /* sqlite3expert.c:545:12: */
	var pCsr uintptr = cur
	return (libc.Bool32((*ExpertCsr)(unsafe.Pointer(pCsr)).FpData == uintptr(0)))
}

// Virtual table module xNext method.
func expertNext(tls *libc.TLS, cur uintptr) int32 { /* sqlite3expert.c:553:12: */
	var pCsr uintptr = cur
	var rc int32 = SQLITE_OK

	rc = sqlite3.Xsqlite3_step(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	if rc != SQLITE_ROW {
		rc = sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
		(*ExpertCsr)(unsafe.Pointer(pCsr)).FpData = uintptr(0)
	} else {
		rc = SQLITE_OK
	}

	return rc
}

// Virtual table module xRowid method.
func expertRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* sqlite3expert.c:572:12: */
	_ = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return SQLITE_OK
}

// Virtual table module xColumn method.
func expertColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* sqlite3expert.c:581:12: */
	var pCsr uintptr = cur
	var pVal uintptr
	pVal = sqlite3.Xsqlite3_column_value(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData, i)
	if pVal != 0 {
		sqlite3.Xsqlite3_result_value(tls, ctx, pVal)
	}
	return SQLITE_OK
}

// Virtual table module xFilter method.
func expertFilter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* sqlite3expert.c:594:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCsr uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	var pExpert uintptr = (*ExpertVtab)(unsafe.Pointer(pVtab)).FpExpert
	var rc int32

	_ = idxNum
	_ = idxStr
	_ = argc
	_ = argv
	rc = sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	(*ExpertCsr)(unsafe.Pointer(pCsr)).FpData = uintptr(0)
	if rc == SQLITE_OK {
		rc = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(pExpert)).Fdb, (pCsr + 4 /* &.pData */), (pVtab /* &.base */ + 8 /* &.zErrMsg */),
			ts+19 /* "SELECT * FROM ma..." */, libc.VaList(bp, (*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(pVtab)).FpTab)).FzName))
	}

	if rc == SQLITE_OK {
		rc = expertNext(tls, cur)
	}
	return rc
}

func idxRegisterVtab(tls *libc.TLS, p uintptr) int32 { /* sqlite3expert.c:622:12: */

	return sqlite3.Xsqlite3_create_module(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, ts+56 /* "expert" */, uintptr(unsafe.Pointer(&expertModule)), p)
}

var expertModule = sqlite3_module{
	FiVersion:    2, // iVersion
	FxCreate:     0, // xCreate - create a table
	FxConnect:    0, // xConnect - connect to an existing table
	FxBestIndex:  0, // xBestIndex - Determine search strategy
	FxDisconnect: 0, // xDisconnect - Disconnect from a table
	FxDestroy:    0, // xDestroy - Drop a table
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRowid - read data
	FxUpdate:     0, // xShadowName
} /* sqlite3expert.c:623:25 */

//
// End of virtual table implementation.
//
// Finalize SQL statement pStmt. If (*pRc) is SQLITE_OK when this function
// is called, set it to the return value of sqlite3_finalize() before
// returning. Otherwise, discard the sqlite3_finalize() return value.
func idxFinalize(tls *libc.TLS, pRc uintptr, pStmt uintptr) { /* sqlite3expert.c:660:13: */
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, pStmt)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(pRc)) = rc
	}
}

// Attempt to allocate an IdxTable structure corresponding to table zTab
// in the main database of connection db. If successful, set (*ppOut) to
// point to the new object and return SQLITE_OK. Otherwise, return an
// SQLite error code and set (*ppOut) to NULL. In this case *pzErrmsg may be
// set to point to an error string.
//
// It is the responsibility of the caller to eventually free either the
// IdxTable object or error message using sqlite3_free().
func idxGetTableInfo(tls *libc.TLS, db uintptr, zTab uintptr, ppOut uintptr, pzErrmsg uintptr) int32 { /* sqlite3expert.c:675:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)) = uintptr(0)
	var nCol int32 = 0
	var nTab int32 = int32(libc.Xstrlen(tls, zTab))
	var nByte int32 = (int32((uint32(unsafe.Sizeof(IdxTable{})) + uint32(nTab)) + uint32(1)))
	var pNew uintptr = uintptr(0)
	// var rc int32 at bp+16, 4

	var rc2 int32
	var pCsr uintptr = uintptr(0)
	var nPk int32 = 0

	*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = idxPrintfPrepareStmt(tls, db, bp+8 /* &p1 */, pzErrmsg, ts+63 /* "PRAGMA table_xin..." */, libc.VaList(bp, zTab))
	for (*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)))) {
		*(*uintptr)(unsafe.Pointer(bp + 12 /* zCol */)) = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)), 1)
		nByte = nByte + (1 + int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 12 /* zCol */)))))
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_table_column_metadata(tls,
			db, ts+85 /* "main" */, zTab, *(*uintptr)(unsafe.Pointer(bp + 12 /* zCol */)), uintptr(0), bp+12 /* &zCol */, uintptr(0), uintptr(0), uintptr(0))
		nByte = nByte + (1 + int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 12 /* zCol */)))))
		nCol++
		nPk = nPk + (libc.Bool32(sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)), 5) > 0))
	}
	rc2 = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)))
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = rc2
	}

	nByte = int32(uint32(nByte) + (uint32(unsafe.Sizeof(IdxColumn{})) * uint32(nCol)))
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
		pNew = idxMalloc(tls, bp+16 /* &rc */, nByte)
	}
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
		(*IdxTable)(unsafe.Pointer(pNew)).FaCol = (pNew + 1*16)
		(*IdxTable)(unsafe.Pointer(pNew)).FnCol = nCol
		pCsr = ((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*12)
	}

	nCol = 0
	for (*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)))) {
		*(*uintptr)(unsafe.Pointer(bp + 20 /* zCol */)) = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)), 1)
		var nCopy int32 = (int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* zCol */)))) + 1)
		(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*12)).FzName = pCsr
		(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*12)).FiPk = (libc.Bool32((sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)), 5) == 1) && (nPk == 1)))
		libc.Xmemcpy(tls, pCsr, *(*uintptr)(unsafe.Pointer(bp + 20 /* zCol */)), uint32(nCopy))
		pCsr += uintptr(nCopy)

		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_table_column_metadata(tls,
			db, ts+85 /* "main" */, zTab, *(*uintptr)(unsafe.Pointer(bp + 20 /* zCol */)), uintptr(0), bp+20 /* &zCol */, uintptr(0), uintptr(0), uintptr(0))
		if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
			nCopy = (int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* zCol */)))) + 1)
			(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*12)).FzColl = pCsr
			libc.Xmemcpy(tls, pCsr, *(*uintptr)(unsafe.Pointer(bp + 20 /* zCol */)), uint32(nCopy))
			pCsr += uintptr(nCopy)
		}

		nCol++
	}
	idxFinalize(tls, bp+16 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)))

	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) != SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, pNew)
		pNew = uintptr(0)
	} else {
		(*IdxTable)(unsafe.Pointer(pNew)).FzName = pCsr
		libc.Xmemcpy(tls, (*IdxTable)(unsafe.Pointer(pNew)).FzName, zTab, (uint32(nTab + 1)))
	}

	*(*uintptr)(unsafe.Pointer(ppOut)) = pNew
	return *(*int32)(unsafe.Pointer(bp + 16 /* rc */))
}

// This function is a no-op if *pRc is set to anything other than
// SQLITE_OK when it is called.
//
// If *pRc is initially set to SQLITE_OK, then the text specified by
// the printf() style arguments is appended to zIn and the result returned
// in a buffer allocated by sqlite3_malloc(). sqlite3_free() is called on
// zIn before returning.
func idxAppendText(tls *libc.TLS, pRc uintptr, zIn uintptr, zFmt uintptr, va uintptr) uintptr { /* sqlite3expert.c:758:13: */
	var ap va_list
	_ = ap
	var zAppend uintptr = uintptr(0)
	var zRet uintptr = uintptr(0)
	var nIn int32
	if zIn != 0 {
		nIn = int32(libc.Xstrlen(tls, zIn))
	} else {
		nIn = 0
	}
	var nAppend int32 = 0
	ap = va
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		zAppend = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
		if zAppend != 0 {
			nAppend = int32(libc.Xstrlen(tls, zAppend))
			zRet = sqlite3.Xsqlite3_malloc(tls, ((nIn + nAppend) + 1))
		}
		if (zAppend != 0) && (zRet != 0) {
			if nIn != 0 {
				libc.Xmemcpy(tls, zRet, zIn, uint32(nIn))
			}
			libc.Xmemcpy(tls, (zRet + uintptr(nIn)), zAppend, (uint32(nAppend + 1)))
		} else {
			sqlite3.Xsqlite3_free(tls, zRet)
			zRet = uintptr(0)
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		}
		sqlite3.Xsqlite3_free(tls, zAppend)
		sqlite3.Xsqlite3_free(tls, zIn)
	}
	_ = ap
	return zRet
}

// Return true if zId must be quoted in order to use it as an SQL
// identifier, or false otherwise.
func idxIdentifierRequiresQuotes(tls *libc.TLS, zId uintptr) int32 { /* sqlite3expert.c:790:12: */
	var i int32
	for i = 0; *(*int8)(unsafe.Pointer(zId + uintptr(i))) != 0; i++ {
		if ((!(int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) == '_') &&
			!((int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= '0') && (int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= '9'))) &&
			!((int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= 'a') && (int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= 'z'))) &&
			!((int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= 'A') && (int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= 'Z')) {
			return 1
		}
	}
	return 0
}

// This function appends an index column definition suitable for constraint
// pCons to the string passed as zIn and returns the result.
func idxAppendColDefn(tls *libc.TLS, pRc uintptr, zIn uintptr, pTab uintptr, pCons uintptr) uintptr { /* sqlite3expert.c:808:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zRet uintptr = zIn
	var p uintptr = ((*IdxTable)(unsafe.Pointer(pTab)).FaCol + uintptr((*IdxConstraint)(unsafe.Pointer(pCons)).FiCol)*12)
	if zRet != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+90 /* ", " */, 0)
	}

	if idxIdentifierRequiresQuotes(tls, (*IdxColumn)(unsafe.Pointer(p)).FzName) != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+93 /* "%Q" */, libc.VaList(bp, (*IdxColumn)(unsafe.Pointer(p)).FzName))
	} else {
		zRet = idxAppendText(tls, pRc, zRet, ts /* "%s" */, libc.VaList(bp+8, (*IdxColumn)(unsafe.Pointer(p)).FzName))
	}

	if sqlite3.Xsqlite3_stricmp(tls, (*IdxColumn)(unsafe.Pointer(p)).FzColl, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl) != 0 {
		if idxIdentifierRequiresQuotes(tls, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl) != 0 {
			zRet = idxAppendText(tls, pRc, zRet, ts+96 /* " COLLATE %Q" */, libc.VaList(bp+16, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl))
		} else {
			zRet = idxAppendText(tls, pRc, zRet, ts+108 /* " COLLATE %s" */, libc.VaList(bp+24, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl))
		}
	}

	if (*IdxConstraint)(unsafe.Pointer(pCons)).FbDesc != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+120 /* " DESC" */, 0)
	}
	return zRet
}

// Search database dbm for an index compatible with the one idxCreateFromCons()
// would create from arguments pScan, pEq and pTail. If no error occurs and
// such an index is found, return non-zero. Or, if no such index is found,
// return zero.
//
// If an error occurs, set *pRc to an SQLite error code and return zero.
func idxFindCompatible(tls *libc.TLS, pRc uintptr, dbm uintptr, pScan uintptr, pEq uintptr, pTail uintptr) int32 { /* sqlite3expert.c:846:12: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var zTbl uintptr = (*IdxTable)(unsafe.Pointer((*IdxScan)(unsafe.Pointer(pScan)).FpTab)).FzName
	*(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)) = uintptr(0)
	var pIter uintptr
	var nEq int32 = 0 // Number of elements in pEq
	// var rc int32 at bp+24, 4

	// Count the elements in list pEq
	for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
		nEq++
	}

	*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxPrintfPrepareStmt(tls, dbm, bp+16 /* &pIdxList */, uintptr(0), ts+126 /* "PRAGMA index_lis..." */, libc.VaList(bp, zTbl))
	for (*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == SQLITE_OK) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */))) == SQLITE_ROW) {
		var bMatch int32 = 1
		var pT uintptr = pTail
		*(*uintptr)(unsafe.Pointer(bp + 20 /* pInfo */)) = uintptr(0)
		var zIdx uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)), 1)

		// Zero the IdxConstraint.bFlag values in the pEq list
		for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
			(*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag = 0
		}

		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxPrintfPrepareStmt(tls, dbm, bp+20 /* &pInfo */, uintptr(0), ts+147 /* "PRAGMA index_xIn..." */, libc.VaList(bp+8, zIdx))
		for (*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == SQLITE_OK) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pInfo */))) == SQLITE_ROW) {
			var iIdx int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pInfo */)), 0)
			var iCol int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pInfo */)), 1)
			var zColl uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pInfo */)), 4)

			if iIdx < nEq {
				for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
					if (*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag != 0 {
						continue
					}
					if (*IdxConstraint)(unsafe.Pointer(pIter)).FiCol != iCol {
						continue
					}
					if sqlite3.Xsqlite3_stricmp(tls, (*IdxConstraint)(unsafe.Pointer(pIter)).FzColl, zColl) != 0 {
						continue
					}
					(*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag = 1
					break
				}
				if pIter == uintptr(0) {
					bMatch = 0
					break
				}
			} else {
				if pT != 0 {
					if ((*IdxConstraint)(unsafe.Pointer(pT)).FiCol != iCol) || (sqlite3.Xsqlite3_stricmp(tls, (*IdxConstraint)(unsafe.Pointer(pT)).FzColl, zColl) != 0) {
						bMatch = 0
						break
					}
					pT = (*IdxConstraint)(unsafe.Pointer(pT)).FpLink
				}
			}
		}
		idxFinalize(tls, bp+24 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 20 /* pInfo */)))

		if (*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == SQLITE_OK) && (bMatch != 0) {
			sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)))
			return 1
		}
	}
	idxFinalize(tls, bp+24 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)))

	*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp + 24 /* rc */))
	return 0
}

func idxCreateFromCons(tls *libc.TLS, p uintptr, pScan uintptr, pEq uintptr, pTail uintptr) int32 { /* sqlite3expert.c:913:12: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var dbm uintptr = (*sqlite3expert)(unsafe.Pointer(p)).Fdbm
	*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
	if ((pEq != 0) || (pTail != 0)) && (0 == idxFindCompatible(tls, bp+40 /* &rc */, dbm, pScan, pEq, pTail)) {
		var pTab uintptr = (*IdxScan)(unsafe.Pointer(pScan)).FpTab
		var zCols uintptr = uintptr(0)
		var zIdx uintptr = uintptr(0)
		var pCons uintptr
		var h uint32 = uint32(0)
		var zFmt uintptr

		for pCons = pEq; pCons != 0; pCons = (*IdxConstraint)(unsafe.Pointer(pCons)).FpLink {
			zCols = idxAppendColDefn(tls, bp+40 /* &rc */, zCols, pTab, pCons)
		}
		for pCons = pTail; pCons != 0; pCons = (*IdxConstraint)(unsafe.Pointer(pCons)).FpLink {
			zCols = idxAppendColDefn(tls, bp+40 /* &rc */, zCols, pTab, pCons)
		}

		if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == SQLITE_OK {
			// Hash the list of columns to come up with a name for the index
			var zTable uintptr = (*IdxTable)(unsafe.Pointer((*IdxScan)(unsafe.Pointer(pScan)).FpTab)).FzName
			var zName uintptr // Index name
			var i int32
			for i = 0; *(*int8)(unsafe.Pointer(zCols + uintptr(i))) != 0; i++ {
				h = h + ((h << 3) + uint32(*(*int8)(unsafe.Pointer(zCols + uintptr(i)))))
			}
			zName = sqlite3.Xsqlite3_mprintf(tls, ts+169 /* "%s_idx_%08x" */, libc.VaList(bp, zTable, h))
			if zName == uintptr(0) {
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_NOMEM
			} else {
				if idxIdentifierRequiresQuotes(tls, zTable) != 0 {
					zFmt = ts + 181 /* "CREATE INDEX '%q..." */
				} else {
					zFmt = ts + 209 /* "CREATE INDEX %s ..." */
				}
				zIdx = sqlite3.Xsqlite3_mprintf(tls, zFmt, libc.VaList(bp+16, zName, zTable, zCols))
				if !(zIdx != 0) {
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_NOMEM
				} else {
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = sqlite3.Xsqlite3_exec(tls, dbm, zIdx, uintptr(0), uintptr(0), (*sqlite3expert)(unsafe.Pointer(p)).FpzErrmsg)
					idxHashAdd(tls, bp+40 /* &rc */, (p + 44 /* &.hIdx */), zName, zIdx)
				}
				sqlite3.Xsqlite3_free(tls, zName)
				sqlite3.Xsqlite3_free(tls, zIdx)
			}
		}

		sqlite3.Xsqlite3_free(tls, zCols)
	}
	return *(*int32)(unsafe.Pointer(bp + 40 /* rc */))
}

// Return true if list pList (linked by IdxConstraint.pLink) contains
// a constraint compatible with *p. Otherwise return false.
func idxFindConstraint(tls *libc.TLS, pList uintptr, p uintptr) int32 { /* sqlite3expert.c:974:12: */
	var pCmp uintptr
	for pCmp = pList; pCmp != 0; pCmp = (*IdxConstraint)(unsafe.Pointer(pCmp)).FpLink {
		if (*IdxConstraint)(unsafe.Pointer(p)).FiCol == (*IdxConstraint)(unsafe.Pointer(pCmp)).FiCol {
			return 1
		}
	}
	return 0
}

func idxCreateFromWhere(tls *libc.TLS, p uintptr, pScan uintptr, pTail uintptr) int32 { /* sqlite3expert.c:982:12: */
	var p1 uintptr = uintptr(0)
	var pCon uintptr
	var rc int32

	// Gather up all the == constraints.
	for pCon = (*IdxScan)(unsafe.Pointer(pScan)).FpEq; pCon != 0; pCon = (*IdxConstraint)(unsafe.Pointer(pCon)).FpNext {
		if !(idxFindConstraint(tls, p1, pCon) != 0) && !(idxFindConstraint(tls, pTail, pCon) != 0) {
			(*IdxConstraint)(unsafe.Pointer(pCon)).FpLink = p1
			p1 = pCon
		}
	}

	// Create an index using the == constraints collected above. And the
	// range constraint/ORDER BY terms passed in by the caller, if any.
	rc = idxCreateFromCons(tls, p, pScan, p1, pTail)

	// If no range/ORDER BY passed by the caller, create a version of the
	// index for each range constraint.
	if pTail == uintptr(0) {
		for pCon = (*IdxScan)(unsafe.Pointer(pScan)).FpRange; (rc == SQLITE_OK) && (pCon != 0); pCon = (*IdxConstraint)(unsafe.Pointer(pCon)).FpNext {

			if !(idxFindConstraint(tls, p1, pCon) != 0) && !(idxFindConstraint(tls, pTail, pCon) != 0) {
				rc = idxCreateFromCons(tls, p, pScan, p1, pCon)
			}
		}
	}

	return rc
}

// Create candidate indexes in database [dbm] based on the data in
// linked-list pScan.
func idxCreateCandidates(tls *libc.TLS, p uintptr) int32 { /* sqlite3expert.c:1021:12: */
	var rc int32 = SQLITE_OK
	var pIter uintptr

	for pIter = (*sqlite3expert)(unsafe.Pointer(p)).FpScan; (pIter != 0) && (rc == SQLITE_OK); pIter = (*IdxScan)(unsafe.Pointer(pIter)).FpNextScan {
		rc = idxCreateFromWhere(tls, p, pIter, uintptr(0))
		if (rc == SQLITE_OK) && ((*IdxScan)(unsafe.Pointer(pIter)).FpOrder != 0) {
			rc = idxCreateFromWhere(tls, p, pIter, (*IdxScan)(unsafe.Pointer(pIter)).FpOrder)
		}
	}

	return rc
}

// Free all elements of the linked list starting at pConstraint.
func idxConstraintFree(tls *libc.TLS, pConstraint uintptr) { /* sqlite3expert.c:1038:13: */
	var pNext uintptr
	var p uintptr

	for p = pConstraint; p != 0; p = pNext {
		pNext = (*IdxConstraint)(unsafe.Pointer(p)).FpNext
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Free all elements of the linked list starting from pScan up until pLast
// (pLast is not freed).
func idxScanFree(tls *libc.TLS, pScan uintptr, pLast uintptr) { /* sqlite3expert.c:1052:13: */
	var p uintptr
	var pNext uintptr
	for p = pScan; p != pLast; p = pNext {
		pNext = (*IdxScan)(unsafe.Pointer(p)).FpNextScan
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpOrder)
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpEq)
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpRange)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Free all elements of the linked list starting from pStatement up
// until pLast (pLast is not freed).
func idxStatementFree(tls *libc.TLS, pStatement uintptr, pLast uintptr) { /* sqlite3expert.c:1068:13: */
	var p uintptr
	var pNext uintptr
	for p = pStatement; p != pLast; p = pNext {
		pNext = (*IdxStatement)(unsafe.Pointer(p)).FpNext
		sqlite3.Xsqlite3_free(tls, (*IdxStatement)(unsafe.Pointer(p)).FzEQP)
		sqlite3.Xsqlite3_free(tls, (*IdxStatement)(unsafe.Pointer(p)).FzIdx)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Free the linked list of IdxTable objects starting at pTab.
func idxTableFree(tls *libc.TLS, pTab uintptr) { /* sqlite3expert.c:1082:13: */
	var pIter uintptr
	var pNext uintptr
	for pIter = pTab; pIter != 0; pIter = pNext {
		pNext = (*IdxTable)(unsafe.Pointer(pIter)).FpNext
		sqlite3.Xsqlite3_free(tls, pIter)
	}
}

// Free the linked list of IdxWrite objects starting at pTab.
func idxWriteFree(tls *libc.TLS, pTab uintptr) { /* sqlite3expert.c:1094:13: */
	var pIter uintptr
	var pNext uintptr
	for pIter = pTab; pIter != 0; pIter = pNext {
		pNext = (*IdxWrite)(unsafe.Pointer(pIter)).FpNext
		sqlite3.Xsqlite3_free(tls, pIter)
	}
}

// This function is called after candidate indexes have been created. It
// runs all the queries to see which indexes they prefer, and populates
// IdxStatement.zIdx and IdxStatement.zEQP with the results.
func idxFindIndexes(tls *libc.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1110:5: */
	bp := tls.Alloc(4128)
	defer tls.Free(4128)

	var pStmt uintptr
	var dbm uintptr
	// var rc int32 at bp+4124, 4

	// var hIdx IdxHash at bp+24, 4096

	var zSql uintptr
	var nIdx int32
	var zIdx uintptr
	// int iId = sqlite3_column_int(pExplain, 0);
	// int iParent = sqlite3_column_int(pExplain, 1);
	// int iNotUsed = sqlite3_column_int(pExplain, 2);
	var zDetail uintptr
	var nDetail int32
	var i int32
	var pEntry uintptr
	// var pExplain uintptr at bp+4120, 4
	dbm = (*sqlite3expert)(unsafe.Pointer(p)).Fdbm
	*(*int32)(unsafe.Pointer(bp + 4124 /* rc */)) = SQLITE_OK
	idxHashInit(tls, bp+24 /* &hIdx */)

	pStmt = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
__1:
	if !((*(*int32)(unsafe.Pointer(bp + 4124 /* rc */)) == SQLITE_OK) && (pStmt != 0)) {
		goto __3
	}
	*(*uintptr)(unsafe.Pointer(bp + 4120 /* pExplain */)) = uintptr(0)
	idxHashClear(tls, bp+24 /* &hIdx */)
	*(*int32)(unsafe.Pointer(bp + 4124 /* rc */)) = idxPrintfPrepareStmt(tls, dbm, bp+4120 /* &pExplain */, pzErr,
		ts+235 /* "EXPLAIN QUERY PL..." */, libc.VaList(bp, (*IdxStatement)(unsafe.Pointer(pStmt)).FzSql))
__4:
	if !((*(*int32)(unsafe.Pointer(bp + 4124 /* rc */)) == SQLITE_OK) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 4120 /* pExplain */))) == SQLITE_ROW)) {
		goto __5
	}
	// int iId = sqlite3_column_int(pExplain, 0);
	// int iParent = sqlite3_column_int(pExplain, 1);
	// int iNotUsed = sqlite3_column_int(pExplain, 2);
	zDetail = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 4120 /* pExplain */)), 3)

	if !(!(zDetail != 0)) {
		goto __6
	}
	goto __4
__6:
	;
	nDetail = int32(libc.Xstrlen(tls, zDetail))

	i = 0
__7:
	if !(i < nDetail) {
		goto __9
	}
	zIdx = uintptr(0)
	if !(((i + 13) < nDetail) && (libc.Xmemcmp(tls, (zDetail+uintptr(i)), ts+257 /* " USING INDEX " */, uint32(13)) == 0)) {
		goto __10
	}
	zIdx = (zDetail + uintptr((i + 13)))
	goto __11
__10:
	if !(((i + 22) < nDetail) &&
		(libc.Xmemcmp(tls, (zDetail+uintptr(i)), ts+271 /* " USING COVERING ..." */, uint32(22)) == 0)) {
		goto __12
	}
	zIdx = (zDetail + uintptr((i + 22)))
__12:
	;
__11:
	;
	if !(zIdx != 0) {
		goto __13
	}
	nIdx = 0
__14:
	if !((int32(*(*int8)(unsafe.Pointer(zIdx + uintptr(nIdx)))) != 0) && ((int32(*(*int8)(unsafe.Pointer(zIdx + uintptr(nIdx)))) != ' ') || (int32(*(*int8)(unsafe.Pointer(zIdx + uintptr((nIdx + 1))))) != '('))) {
		goto __15
	}
	nIdx++
	goto __14
__15:
	;
	zSql = idxHashSearch(tls, (p + 44 /* &.hIdx */), zIdx, nIdx)
	if !(zSql != 0) {
		goto __16
	}
	idxHashAdd(tls, bp+4124 /* &rc */, bp+24 /* &hIdx */, zSql, uintptr(0))
	if !(*(*int32)(unsafe.Pointer(bp + 4124 /* rc */)) != 0) {
		goto __17
	}
	goto find_indexes_out
__17:
	;
__16:
	;
	goto __9
__13:
	;
	goto __8
__8:
	i++
	goto __7
	goto __9
__9:
	;

	if !(int32(*(*int8)(unsafe.Pointer(zDetail))) != '-') {
		goto __18
	}
	(*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP = idxAppendText(tls, bp+4124 /* &rc */, (*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP, ts+294 /* "%s\n" */, libc.VaList(bp+8, zDetail))
__18:
	;
	goto __4
__5:
	;

	pEntry = (*IdxHash)(unsafe.Pointer(bp + 24 /* &hIdx */)).FpFirst
__19:
	if !(pEntry != 0) {
		goto __21
	}
	(*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx = idxAppendText(tls, bp+4124 /* &rc */, (*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx, ts+298 /* "%s;\n" */, libc.VaList(bp+16, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey))
	goto __20
__20:
	pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext
	goto __19
	goto __21
__21:
	;

	idxFinalize(tls, bp+4124 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 4120 /* pExplain */)))
	goto __2
__2:
	pStmt = (*IdxStatement)(unsafe.Pointer(pStmt)).FpNext
	goto __1
	goto __3
__3:
	;

find_indexes_out:
	idxHashClear(tls, bp+24 /* &hIdx */)
	return *(*int32)(unsafe.Pointer(bp + 4124 /* rc */))
}

func idxAuthCallback(tls *libc.TLS, pCtx uintptr, eOp int32, z3 uintptr, z4 uintptr, zDb uintptr, zTrigger uintptr) int32 { /* sqlite3expert.c:1180:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	_ = z4
	_ = zTrigger
	if ((eOp == SQLITE_INSERT) || (eOp == SQLITE_UPDATE)) || (eOp == SQLITE_DELETE) {
		if sqlite3.Xsqlite3_stricmp(tls, zDb, ts+85 /* "main" */) == 0 {
			var p uintptr = pCtx
			var pTab uintptr
			for pTab = (*sqlite3expert)(unsafe.Pointer(p)).FpTable; pTab != 0; pTab = (*IdxTable)(unsafe.Pointer(pTab)).FpNext {
				if 0 == sqlite3.Xsqlite3_stricmp(tls, z3, (*IdxTable)(unsafe.Pointer(pTab)).FzName) {
					break
				}
			}
			if pTab != 0 {
				var pWrite uintptr
				for pWrite = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite; pWrite != 0; pWrite = (*IdxWrite)(unsafe.Pointer(pWrite)).FpNext {
					if ((*IdxWrite)(unsafe.Pointer(pWrite)).FpTab == pTab) && ((*IdxWrite)(unsafe.Pointer(pWrite)).FeOp == eOp) {
						break
					}
				}
				if pWrite == uintptr(0) {
					pWrite = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(IdxWrite{})))
					if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
						(*IdxWrite)(unsafe.Pointer(pWrite)).FpTab = pTab
						(*IdxWrite)(unsafe.Pointer(pWrite)).FeOp = eOp
						(*IdxWrite)(unsafe.Pointer(pWrite)).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite
						(*sqlite3expert)(unsafe.Pointer(p)).FpWrite = pWrite
					}
				}
			}
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func idxProcessOneTrigger(tls *libc.TLS, p uintptr, pWrite uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1218:12: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var pTab uintptr = (*IdxWrite)(unsafe.Pointer(pWrite)).FpTab
	var zTab uintptr = (*IdxTable)(unsafe.Pointer(pTab)).FzName
	var zSql uintptr = ts + 303 /* "SELECT 'CREATE T..." */
	*(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 84 /* rc */)) = SQLITE_OK
	var zWrite uintptr = uintptr(0)

	// Create the table and its triggers in the temp schema
	*(*int32)(unsafe.Pointer(bp + 84 /* rc */)) = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, bp+80 /* &pSelect */, pzErr, zSql, libc.VaList(bp, zTab, zTab))
	for (*(*int32)(unsafe.Pointer(bp + 84 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)))) {
		var zCreate uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)), 0)
		*(*int32)(unsafe.Pointer(bp + 84 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zCreate, uintptr(0), uintptr(0), pzErr)
	}
	idxFinalize(tls, bp+84 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)))

	// Rename the table in the temp schema to zInt
	if *(*int32)(unsafe.Pointer(bp + 84 /* rc */)) == SQLITE_OK {
		var z uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+429 /* "ALTER TABLE temp..." */, libc.VaList(bp+16, zTab, zInt))
		if z == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 84 /* rc */)) = SQLITE_NOMEM
		} else {
			*(*int32)(unsafe.Pointer(bp + 84 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, z, uintptr(0), uintptr(0), pzErr)
			sqlite3.Xsqlite3_free(tls, z)
		}
	}

	switch (*IdxWrite)(unsafe.Pointer(pWrite)).FeOp {
	case SQLITE_INSERT:
		{
			var i int32
			zWrite = idxAppendText(tls, bp+84 /* &rc */, zWrite, ts+462 /* "INSERT INTO %Q V..." */, libc.VaList(bp+32, zInt))
			for i = 0; i < (*IdxTable)(unsafe.Pointer(pTab)).FnCol; i++ {
				zWrite = idxAppendText(tls, bp+84 /* &rc */, zWrite, ts+485 /* "%s?" */, libc.VaList(bp+40, func() uintptr {
					if i == 0 {
						return ts + 489 /* "" */
					}
					return ts + 90 /* ", " */
				}()))
			}
			zWrite = idxAppendText(tls, bp+84 /* &rc */, zWrite, ts+490 /* ")" */, 0)
			break

		}
	case SQLITE_UPDATE:
		{
			var i int32
			zWrite = idxAppendText(tls, bp+84 /* &rc */, zWrite, ts+492 /* "UPDATE %Q SET " */, libc.VaList(bp+48, zInt))
			for i = 0; i < (*IdxTable)(unsafe.Pointer(pTab)).FnCol; i++ {
				zWrite = idxAppendText(tls, bp+84 /* &rc */, zWrite, ts+507 /* "%s%Q=?" */, libc.VaList(bp+56, func() uintptr {
					if i == 0 {
						return ts + 489 /* "" */
					}
					return ts + 90 /* ", " */
				}(),
					(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pTab)).FaCol+uintptr(i)*12)).FzName))
			}
			break

		}
	default:
		{

			if *(*int32)(unsafe.Pointer(bp + 84 /* rc */)) == SQLITE_OK {
				zWrite = sqlite3.Xsqlite3_mprintf(tls, ts+514 /* "DELETE FROM %Q" */, libc.VaList(bp+72, zInt))
				if zWrite == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 84 /* rc */)) = SQLITE_NOMEM
				}
			}

		}
	}

	if *(*int32)(unsafe.Pointer(bp + 84 /* rc */)) == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(bp + 88 /* pX */)) = uintptr(0)
		*(*int32)(unsafe.Pointer(bp + 84 /* rc */)) = sqlite3.Xsqlite3_prepare_v2(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zWrite, -1, bp+88 /* &pX */, uintptr(0))
		idxFinalize(tls, bp+84 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 88 /* pX */)))
		if *(*int32)(unsafe.Pointer(bp + 84 /* rc */)) != SQLITE_OK {
			idxDatabaseError(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, pzErr)
		}
	}
	sqlite3.Xsqlite3_free(tls, zWrite)

	if *(*int32)(unsafe.Pointer(bp + 84 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 84 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zDrop, uintptr(0), uintptr(0), pzErr)
	}

	return *(*int32)(unsafe.Pointer(bp + 84 /* rc */))
}

var zInt uintptr = ts + 529  /* "t592690916721053..." */ /* sqlite3expert.c:1223:21 */
var zDrop uintptr = ts + 567 /* "DROP TABLE t5926..." */ /* sqlite3expert.c:1224:21 */

func idxProcessTriggers(tls *libc.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1300:12: */
	var rc int32 = SQLITE_OK
	var pEnd uintptr = uintptr(0)
	var pFirst uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite

	for (rc == SQLITE_OK) && (pFirst != pEnd) {
		var pIter uintptr
		for pIter = pFirst; (rc == SQLITE_OK) && (pIter != pEnd); pIter = (*IdxWrite)(unsafe.Pointer(pIter)).FpNext {
			rc = idxProcessOneTrigger(tls, p, pIter, pzErr)
		}
		pEnd = pFirst
		pFirst = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite
	}

	return rc
}

func idxCreateVtabSchema(tls *libc.TLS, p uintptr, pzErrmsg uintptr) int32 { /* sqlite3expert.c:1318:12: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = idxRegisterVtab(tls, p)
	*(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)) = uintptr(0)

	// For each table in the main db schema:
	//
	//   1) Add an entry to the p->pTable list, and
	//   2) Create the equivalent virtual table in dbv.
	*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, bp+40 /* &pSchema */, pzErrmsg,

		ts+616 /* "SELECT type, nam..." */)
	for (*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)))) {
		var zType uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)), 0)
		var zName uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)), 1)
		var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)), 2)

		if (int32(*(*int8)(unsafe.Pointer(zType))) == 'v') || (int32(*(*int8)(unsafe.Pointer(zType + 1))) == 'r') {
			*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zSql, uintptr(0), uintptr(0), pzErrmsg)
		} else {
			// var pTab uintptr at bp+44, 4

			*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = idxGetTableInfo(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, zName, bp+44 /* &pTab */, pzErrmsg)
			if *(*int32)(unsafe.Pointer(bp + 48 /* rc */)) == SQLITE_OK {
				var i int32
				var zInner uintptr = uintptr(0)
				var zOuter uintptr = uintptr(0)
				(*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44 /* pTab */)))).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpTable
				(*sqlite3expert)(unsafe.Pointer(p)).FpTable = *(*uintptr)(unsafe.Pointer(bp + 44 /* pTab */))

				// The statement the vtab will pass to sqlite3_declare_vtab()
				zInner = idxAppendText(tls, bp+48 /* &rc */, uintptr(0), ts+884 /* "CREATE TABLE x(" */, 0)
				for i = 0; i < (*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44 /* pTab */)))).FnCol; i++ {
					zInner = idxAppendText(tls, bp+48 /* &rc */, zInner, ts+900, /* "%s%Q COLLATE %s" */
						libc.VaList(bp, func() uintptr {
							if i == 0 {
								return ts + 489 /* "" */
							}
							return ts + 90 /* ", " */
						}(), (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44 /* pTab */)))).FaCol+uintptr(i)*12)).FzName, (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44 /* pTab */)))).FaCol+uintptr(i)*12)).FzColl))
				}
				zInner = idxAppendText(tls, bp+48 /* &rc */, zInner, ts+490 /* ")" */, 0)

				// The CVT statement to create the vtab
				zOuter = idxAppendText(tls, bp+48 /* &rc */, uintptr(0),
					ts+916 /* "CREATE VIRTUAL T..." */, libc.VaList(bp+24, zName, zInner))
				if *(*int32)(unsafe.Pointer(bp + 48 /* rc */)) == SQLITE_OK {
					*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zOuter, uintptr(0), uintptr(0), pzErrmsg)
				}
				sqlite3.Xsqlite3_free(tls, zInner)
				sqlite3.Xsqlite3_free(tls, zOuter)
			}
		}
	}
	idxFinalize(tls, bp+48 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)))
	return *(*int32)(unsafe.Pointer(bp + 48 /* rc */))
}

type IdxSampleCtx = struct {
	FiTarget int32
	_        [4]byte
	Ftarget  float64
	FnRow    float64
	FnRet    float64
} /* sqlite3expert.c:1378:1 */

func idxSampleFunc(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) { /* sqlite3expert.c:1385:13: */
	bp := tls.Alloc(2)
	defer tls.Free(2)

	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var bRet int32

	_ = argv

	if (*IdxSampleCtx)(unsafe.Pointer(p)).FnRow == 0.0 {
		bRet = 1
	} else {
		bRet = (libc.Bool32(((*IdxSampleCtx)(unsafe.Pointer(p)).FnRet / (*IdxSampleCtx)(unsafe.Pointer(p)).FnRow) <= (*IdxSampleCtx)(unsafe.Pointer(p)).Ftarget))
		if bRet == 0 {
			// var rnd uint16 at bp, 2

			sqlite3.Xsqlite3_randomness(tls, 2, bp /* &rnd */)
			bRet = (libc.Bool32((int32(*(*uint16)(unsafe.Pointer(bp /* rnd */))) % 100) <= (*IdxSampleCtx)(unsafe.Pointer(p)).FiTarget))
		}
	}

	sqlite3.Xsqlite3_result_int(tls, pCtx, bRet)
	*(*float64)(unsafe.Pointer(p + 16 /* &.nRow */)) += (1.0)
	*(*float64)(unsafe.Pointer(p + 24 /* &.nRet */)) += (float64(bRet))
}

type IdxRemCtx = struct {
	FnSlot int32
	_      [4]byte
	FaSlot [1]struct {
		FeType int32
		_      [4]byte
		FiVal  i64
		FrVal  float64
		FnByte int32
		Fn     int32
		Fz     uintptr
		_      [4]byte
	}
} /* sqlite3expert.c:1411:1 */

type IdxRemSlot = struct {
	FeType int32
	_      [4]byte
	FiVal  i64
	FrVal  float64
	FnByte int32
	Fn     int32
	Fz     uintptr
	_      [4]byte
} /* sqlite3expert.c:1411:1 */

// Implementation of scalar function rem().
func idxRemFunc(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) { /* sqlite3expert.c:1426:13: */
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var pSlot uintptr
	var iSlot int32

	iSlot = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))

	pSlot = ((p + 8 /* &.aSlot */) + uintptr(iSlot)*40)

	switch (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType {
	case SQLITE_NULL:
		// no-op
		break

	case SQLITE_INTEGER:
		sqlite3.Xsqlite3_result_int64(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).FiVal)
		break

	case SQLITE_FLOAT:
		sqlite3.Xsqlite3_result_double(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).FrVal)
		break

	case SQLITE_BLOB:
		sqlite3.Xsqlite3_result_blob(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn, libc.UintptrFromInt32(-1))
		break

	case SQLITE_TEXT:
		sqlite3.Xsqlite3_result_text(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn, libc.UintptrFromInt32(-1))
		break
	}

	(*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType = sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	switch (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType {
	case SQLITE_NULL:
		// no-op
		break

	case SQLITE_INTEGER:
		(*IdxRemSlot)(unsafe.Pointer(pSlot)).FiVal = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		break

	case SQLITE_FLOAT:
		(*IdxRemSlot)(unsafe.Pointer(pSlot)).FrVal = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		break

	case SQLITE_BLOB:
		fallthrough
	case SQLITE_TEXT:
		{
			var nByte int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
			if nByte > (*IdxRemSlot)(unsafe.Pointer(pSlot)).FnByte {
				var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, (nByte * 2))
				if zNew == uintptr(0) {
					sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
					return
				}
				(*IdxRemSlot)(unsafe.Pointer(pSlot)).FnByte = (nByte * 2)
				(*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz = zNew
			}
			(*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn = nByte
			if (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType == SQLITE_BLOB {
				libc.Xmemcpy(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))), uint32(nByte))
			} else {
				libc.Xmemcpy(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))), uint32(nByte))
			}
			break

		}
	}
}

func idxLargestIndex(tls *libc.TLS, db uintptr, pnMax uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1499:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = SQLITE_OK
	var zMax uintptr = ts + 957 /* "SELECT max(i.seq..." */
	*(*uintptr)(unsafe.Pointer(bp /* pMax */)) = uintptr(0)

	*(*int32)(unsafe.Pointer(pnMax)) = 0
	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPrepareStmt(tls, db, bp /* &pMax */, pzErr, zMax)
	if (*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pMax */)))) {
		*(*int32)(unsafe.Pointer(pnMax)) = (sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp /* pMax */)), 0) + 1)
	}
	idxFinalize(tls, bp+4 /* &rc */, *(*uintptr)(unsafe.Pointer(bp /* pMax */)))

	return *(*int32)(unsafe.Pointer(bp + 4 /* rc */))
}

func idxPopulateOneStat1(tls *libc.TLS, p uintptr, pIndexXInfo uintptr, pWriteStat uintptr, zTab uintptr, zIdx uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1519:12: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	var zCols uintptr = uintptr(0)
	var zOrder uintptr = uintptr(0)
	var zQuery uintptr = uintptr(0)
	var nCol int32 = 0
	var i int32
	*(*uintptr)(unsafe.Pointer(bp + 116 /* pQuery */)) = uintptr(0)
	var aStat uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = SQLITE_OK

	// Formulate the query text
	sqlite3.Xsqlite3_bind_text(tls, pIndexXInfo, 1, zIdx, -1, uintptr(0))
	for (SQLITE_OK == *(*int32)(unsafe.Pointer(bp + 112 /* rc */))) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pIndexXInfo)) {
		var zComma uintptr
		if zCols == uintptr(0) {
			zComma = ts + 489 /* "" */
		} else {
			zComma = ts + 90 /* ", " */
		}
		var zName uintptr = sqlite3.Xsqlite3_column_text(tls, pIndexXInfo, 0)
		var zColl uintptr = sqlite3.Xsqlite3_column_text(tls, pIndexXInfo, 1)
		zCols = idxAppendText(tls, bp+112 /* &rc */, zCols,
			ts+1094 /* "%sx.%Q IS rem(%d..." */, libc.VaList(bp, zComma, zName, nCol, zName, zColl))
		zOrder = idxAppendText(tls, bp+112 /* &rc */, zOrder, ts+1129 /* "%s%d" */, libc.VaList(bp+40, zComma, libc.PreIncInt32(&nCol, 1)))
	}
	sqlite3.Xsqlite3_reset(tls, pIndexXInfo)
	if *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == SQLITE_OK {
		if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
			zQuery = sqlite3.Xsqlite3_mprintf(tls,
				ts+1134 /* "SELECT %s FROM %..." */, libc.VaList(bp+56, zCols, zTab, zOrder))
		} else {
			zQuery = sqlite3.Xsqlite3_mprintf(tls,
				ts+1166 /* "SELECT %s FROM t..." */, libc.VaList(bp+80, zCols, zOrder))
		}
	}
	sqlite3.Xsqlite3_free(tls, zCols)
	sqlite3.Xsqlite3_free(tls, zOrder)

	// Formulate the query text
	if *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == SQLITE_OK {
		var dbrem uintptr = func() uintptr {
			if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
				return (*sqlite3expert)(unsafe.Pointer(p)).Fdb
			}
			return (*sqlite3expert)(unsafe.Pointer(p)).Fdbv
		}()
		*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = idxPrepareStmt(tls, dbrem, bp+116 /* &pQuery */, pzErr, zQuery)
	}
	sqlite3.Xsqlite3_free(tls, zQuery)

	if *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == SQLITE_OK {
		aStat = idxMalloc(tls, bp+112 /* &rc */, (int32(uint32(unsafe.Sizeof(int32(0))) * (uint32(nCol + 1)))))
	}
	if (*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 116 /* pQuery */)))) {
		var pEntry uintptr
		var zStat uintptr = uintptr(0)
		for i = 0; i <= nCol; i++ {
			*(*int32)(unsafe.Pointer(aStat + uintptr(i)*4)) = 1
		}
		for (*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 116 /* pQuery */)))) {
			*(*int32)(unsafe.Pointer(aStat))++
			for i = 0; i < nCol; i++ {
				if sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 116 /* pQuery */)), i) == 0 {
					break
				}
			}
			for ; i < nCol; i++ {
				*(*int32)(unsafe.Pointer(aStat + uintptr((i+1))*4))++
			}
		}

		if *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == SQLITE_OK {
			var s0 int32 = *(*int32)(unsafe.Pointer(aStat))
			zStat = sqlite3.Xsqlite3_mprintf(tls, ts+1238 /* "%d" */, libc.VaList(bp+96, s0))
			if zStat == uintptr(0) {
				*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = SQLITE_NOMEM
			}
			for i = 1; (*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == SQLITE_OK) && (i <= nCol); i++ {
				zStat = idxAppendText(tls, bp+112 /* &rc */, zStat, ts+1241 /* " %d" */, libc.VaList(bp+104, ((s0+(*(*int32)(unsafe.Pointer(aStat + uintptr(i)*4))/2)) / *(*int32)(unsafe.Pointer(aStat + uintptr(i)*4)))))
			}
		}

		if *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == SQLITE_OK {
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 1, zTab, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 2, zIdx, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 3, zStat, -1, uintptr(0))
			sqlite3.Xsqlite3_step(tls, pWriteStat)
			*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = sqlite3.Xsqlite3_reset(tls, pWriteStat)
		}

		pEntry = idxHashFind(tls, (p + 44 /* &.hIdx */), zIdx, int32(libc.Xstrlen(tls, zIdx)))
		if pEntry != 0 {

			(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2 = zStat
		} else {
			sqlite3.Xsqlite3_free(tls, zStat)
		}
	}
	sqlite3.Xsqlite3_free(tls, aStat)
	idxFinalize(tls, bp+112 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 116 /* pQuery */)))

	return *(*int32)(unsafe.Pointer(bp + 112 /* rc */))
}

func idxBuildSampleTable(tls *libc.TLS, p uintptr, zTab uintptr) int32 { /* sqlite3expert.c:1619:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	var zSql uintptr

	rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, ts+1245 /* "DROP TABLE IF EX..." */, uintptr(0), uintptr(0), uintptr(0))
	if rc != SQLITE_OK {
		return rc
	}

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+1309 /* "CREATE TABLE tem..." */, libc.VaList(bp, zTab))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	return rc
}

// This function is called as part of sqlite3_expert_analyze(). Candidate
// indexes have already been created in database sqlite3expert.dbm, this
// function populates sqlite_stat1 table in the same database.
//
// The stat1 data is generated by querying the
func idxPopulateStat1(tls *libc.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1643:12: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = SQLITE_OK
	*(*int32)(unsafe.Pointer(bp /* nMax */)) = 0
	var pCtx uintptr = uintptr(0)
	// var samplectx IdxSampleCtx at bp+8, 32

	var i int32
	var iPrev i64 = int64(-100000)
	*(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 44 /* pIndexXInfo */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 48 /* pWrite */)) = uintptr(0)

	var zAllIndex uintptr = ts + 1385   /* "SELECT s.rowid, ..." */
	var zIndexXInfo uintptr = ts + 1499 /* "SELECT name, col..." */
	var zWrite uintptr = ts + 1554      /* "INSERT INTO sqli..." */

	// If iSample==0, no sqlite_stat1 data is required.
	if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 0 {
		return SQLITE_OK
	}

	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxLargestIndex(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp /* &nMax */, pzErr)
	if (*(*int32)(unsafe.Pointer(bp /* nMax */)) <= 0) || (*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) != SQLITE_OK) {
		return *(*int32)(unsafe.Pointer(bp + 4 /* rc */))
	}

	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, ts+1595 /* "ANALYZE; PRAGMA ..." */, uintptr(0), uintptr(0), uintptr(0))

	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == SQLITE_OK {
		var nByte int32 = (int32(uint32(unsafe.Sizeof(IdxRemCtx{})) + (uint32(unsafe.Sizeof(IdxRemSlot{})) * uint32(*(*int32)(unsafe.Pointer(bp /* nMax */))))))
		pCtx = idxMalloc(tls, bp+4 /* &rc */, nByte)
	}

	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == SQLITE_OK {
		var dbrem uintptr = func() uintptr {
			if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
				return (*sqlite3expert)(unsafe.Pointer(p)).Fdb
			}
			return (*sqlite3expert)(unsafe.Pointer(p)).Fdbv
		}()
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_create_function(tls,
			dbrem, ts+1629 /* "rem" */, 2, SQLITE_UTF8, pCtx, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{idxRemFunc})), uintptr(0), uintptr(0))
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_create_function(tls,
			(*sqlite3expert)(unsafe.Pointer(p)).Fdb, ts+1633 /* "sample" */, 0, SQLITE_UTF8, bp+8 /* &samplectx */, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{idxSampleFunc})), uintptr(0), uintptr(0))
	}

	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == SQLITE_OK {
		(*IdxRemCtx)(unsafe.Pointer(pCtx)).FnSlot = (*(*int32)(unsafe.Pointer(bp /* nMax */)) + 1)
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+40 /* &pAllIndex */, pzErr, zAllIndex)
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+44 /* &pIndexXInfo */, pzErr, zIndexXInfo)
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+48 /* &pWrite */, pzErr, zWrite)
	}

	for (*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)))) {
		var iRowid i64 = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)), 0)
		var zTab uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)), 1)
		var zIdx uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)), 2)
		if ((*sqlite3expert)(unsafe.Pointer(p)).FiSample < 100) && (iPrev != iRowid) {
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).Ftarget = (float64((*sqlite3expert)(unsafe.Pointer(p)).FiSample) / 100.0)
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).FiTarget = (*sqlite3expert)(unsafe.Pointer(p)).FiSample
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).FnRow = 0.0
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).FnRet = 0.0
			*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxBuildSampleTable(tls, p, zTab)
			if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) != SQLITE_OK {
				break
			}
		}
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPopulateOneStat1(tls, p, *(*uintptr)(unsafe.Pointer(bp + 44 /* pIndexXInfo */)), *(*uintptr)(unsafe.Pointer(bp + 48 /* pWrite */)), zTab, zIdx, pzErr)
		iPrev = iRowid
	}
	if (*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == SQLITE_OK) && ((*sqlite3expert)(unsafe.Pointer(p)).FiSample < 100) {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv,
			ts+1245 /* "DROP TABLE IF EX..." */, uintptr(0), uintptr(0), uintptr(0))
	}

	idxFinalize(tls, bp+4 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)))
	idxFinalize(tls, bp+4 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 44 /* pIndexXInfo */)))
	idxFinalize(tls, bp+4 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 48 /* pWrite */)))

	if pCtx != 0 {
		for i = 0; i < (*IdxRemCtx)(unsafe.Pointer(pCtx)).FnSlot; i++ {
			sqlite3.Xsqlite3_free(tls, (*IdxRemSlot)(unsafe.Pointer((pCtx+8 /* &.aSlot */)+uintptr(i)*40)).Fz)
		}
		sqlite3.Xsqlite3_free(tls, pCtx)
	}

	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, ts+1640 /* "ANALYZE sqlite_s..." */, uintptr(0), uintptr(0), uintptr(0))
	}

	sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, ts+1245 /* "DROP TABLE IF EX..." */, uintptr(0), uintptr(0), uintptr(0))
	return *(*int32)(unsafe.Pointer(bp + 4 /* rc */))
}

// Allocate a new sqlite3expert object.
func sqlite3_expert_new(tls *libc.TLS, db uintptr, pzErrmsg uintptr) uintptr { /* sqlite3expert.c:1742:15: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = SQLITE_OK
	var pNew uintptr

	pNew = idxMalloc(tls, bp+16 /* &rc */, int32(unsafe.Sizeof(sqlite3expert{})))

	// Open two in-memory databases to work with. The "vtab database" (dbv)
	// will contain a virtual table corresponding to each real table in
	// the user database schema, and a copy of each view. It is used to
	// collect information regarding the WHERE, ORDER BY and other clauses
	// of the user's query.
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
		(*sqlite3expert)(unsafe.Pointer(pNew)).Fdb = db
		(*sqlite3expert)(unsafe.Pointer(pNew)).FiSample = 100
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_open(tls, ts+1662 /* ":memory:" */, (pNew + 12 /* &.dbv */))
	}
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_open(tls, ts+1662 /* ":memory:" */, (pNew + 8 /* &.dbm */))
		if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
			sqlite3.Xsqlite3_db_config(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbm, SQLITE_DBCONFIG_TRIGGER_EQP, libc.VaList(bp, 1, uintptr(0)))
		}
	}

	// Copy the entire schema of database [db] into [dbm].
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
		// var pSql uintptr at bp+20, 4

		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdb, bp+20 /* &pSql */, pzErrmsg,

			ts+1671 /* "SELECT sql FROM ..." */, 0)
		for (*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pSql */)))) {
			var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pSql */)), 0)
			*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbm, zSql, uintptr(0), uintptr(0), pzErrmsg)
		}
		idxFinalize(tls, bp+16 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 20 /* pSql */)))
	}

	// Create the vtab schema
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = idxCreateVtabSchema(tls, pNew, pzErrmsg)
	}

	// Register the auth callback with dbv
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
		sqlite3.Xsqlite3_set_authorizer(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbv, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr, uintptr) int32
		}{idxAuthCallback})), pNew)
	}

	// If an error has occurred, free the new object and reutrn NULL. Otherwise,
	// return the new sqlite3expert handle.
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) != SQLITE_OK {
		sqlite3_expert_destroy(tls, pNew)
		pNew = uintptr(0)
	}
	return pNew
}

// Configure an sqlite3expert object.
func sqlite3_expert_config(tls *libc.TLS, p uintptr, op int32, va uintptr) int32 { /* sqlite3expert.c:1803:5: */
	var rc int32 = SQLITE_OK
	var ap va_list
	_ = ap
	ap = va
	switch op {
	case EXPERT_CONFIG_SAMPLE:
		{
			var iVal int32 = int32(libc.VaInt32(&ap))
			if iVal < 0 {
				iVal = 0
			}
			if iVal > 100 {
				iVal = 100
			}
			(*sqlite3expert)(unsafe.Pointer(p)).FiSample = iVal
			break

		}
	default:
		rc = SQLITE_NOTFOUND
		break
	}

	_ = ap
	return rc
}

// Add an SQL statement to the analysis.
func sqlite3_expert_sql(tls *libc.TLS, p uintptr, zSql uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1827:5: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pScanOrig uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpScan
	var pStmtOrig uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
	*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = SQLITE_OK
	*(*uintptr)(unsafe.Pointer(bp + 4 /* zStmt */)) = zSql

	if (*sqlite3expert)(unsafe.Pointer(p)).FbRun != 0 {
		return SQLITE_MISUSE
	}

	for ((*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) == SQLITE_OK) && (*(*uintptr)(unsafe.Pointer(bp + 4 /* zStmt */)) != 0)) && (*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4 /* zStmt */)))) != 0) {
		*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0)
		*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = sqlite3.Xsqlite3_prepare_v2(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, *(*uintptr)(unsafe.Pointer(bp + 4 /* zStmt */)), -1, bp /* &pStmt */, bp+4 /* &zStmt */)
		if *(*int32)(unsafe.Pointer(bp + 8 /* rc */)) == SQLITE_OK {
			if *(*uintptr)(unsafe.Pointer(bp /* pStmt */)) != 0 {
				var pNew uintptr
				var z uintptr = sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
				var n int32 = int32(libc.Xstrlen(tls, z))
				pNew = idxMalloc(tls, bp+8 /* &rc */, (int32((uint32(unsafe.Sizeof(IdxStatement{})) + uint32(n)) + uint32(1))))
				if *(*int32)(unsafe.Pointer(bp + 8 /* rc */)) == SQLITE_OK {
					(*IdxStatement)(unsafe.Pointer(pNew)).FzSql = (pNew + 1*20)
					libc.Xmemcpy(tls, (*IdxStatement)(unsafe.Pointer(pNew)).FzSql, z, (uint32(n + 1)))
					(*IdxStatement)(unsafe.Pointer(pNew)).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
					if (*sqlite3expert)(unsafe.Pointer(p)).FpStatement != 0 {
						(*IdxStatement)(unsafe.Pointer(pNew)).FiId = ((*IdxStatement)(unsafe.Pointer((*sqlite3expert)(unsafe.Pointer(p)).FpStatement)).FiId + 1)
					}
					(*sqlite3expert)(unsafe.Pointer(p)).FpStatement = pNew
				}
				sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
			}
		} else {
			idxDatabaseError(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, pzErr)
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 8 /* rc */)) != SQLITE_OK {
		idxScanFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpScan, pScanOrig)
		idxStatementFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpStatement, pStmtOrig)
		(*sqlite3expert)(unsafe.Pointer(p)).FpScan = pScanOrig
		(*sqlite3expert)(unsafe.Pointer(p)).FpStatement = pStmtOrig
	}

	return *(*int32)(unsafe.Pointer(bp + 8 /* rc */))
}

func sqlite3_expert_analyze(tls *libc.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1872:5: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var rc int32 at bp+24, 4

	var pEntry uintptr

	// Do trigger processing to collect any extra IdxScan structures
	*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxProcessTriggers(tls, p, pzErr)

	// Create candidate indexes within the in-memory database file
	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxCreateCandidates(tls, p)
	}

	// Generate the stat1 data
	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxPopulateStat1(tls, p, pzErr)
	}

	// Formulate the EXPERT_REPORT_CANDIDATES text
	for pEntry = (*sqlite3expert)(unsafe.Pointer(p)).FhIdx.FpFirst; pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext {
		(*sqlite3expert)(unsafe.Pointer(p)).FzCandidates = idxAppendText(tls, bp+24 /* &rc */, (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates,
			ts+1770 /* "%s;%s%s\n" */, libc.VaList(bp, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal,
				func() uintptr {
					if (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2 != 0 {
						return ts + 1779 /* " -- stat1: " */
					}
					return ts + 489 /* "" */
				}(), (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2))
	}

	// Figure out which of the candidate indexes are preferred by the query
	// planner and report the results to the user.
	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxFindIndexes(tls, p, pzErr)
	}

	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == SQLITE_OK {
		(*sqlite3expert)(unsafe.Pointer(p)).FbRun = 1
	}
	return *(*int32)(unsafe.Pointer(bp + 24 /* rc */))
}

// Return the total number of statements that have been added to this
// sqlite3expert using sqlite3_expert_sql().
func sqlite3_expert_count(tls *libc.TLS, p uintptr) int32 { /* sqlite3expert.c:1913:5: */
	var nRet int32 = 0
	if (*sqlite3expert)(unsafe.Pointer(p)).FpStatement != 0 {
		nRet = ((*IdxStatement)(unsafe.Pointer((*sqlite3expert)(unsafe.Pointer(p)).FpStatement)).FiId + 1)
	}
	return nRet
}

// Return a component of the report.
func sqlite3_expert_report(tls *libc.TLS, p uintptr, iStmt int32, eReport int32) uintptr { /* sqlite3expert.c:1922:12: */
	var zRet uintptr = uintptr(0)
	var pStmt uintptr

	if (*sqlite3expert)(unsafe.Pointer(p)).FbRun == 0 {
		return uintptr(0)
	}
	for pStmt = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement; (pStmt != 0) && ((*IdxStatement)(unsafe.Pointer(pStmt)).FiId != iStmt); pStmt = (*IdxStatement)(unsafe.Pointer(pStmt)).FpNext {
	}
	switch eReport {
	case EXPERT_REPORT_SQL:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzSql
		}
		break
	case EXPERT_REPORT_INDEXES:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx
		}
		break
	case EXPERT_REPORT_PLAN:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP
		}
		break
	case EXPERT_REPORT_CANDIDATES:
		zRet = (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates
		break
	}
	return zRet
}

// Free an sqlite3expert object.
func sqlite3_expert_destroy(tls *libc.TLS, p uintptr) { /* sqlite3expert.c:1948:6: */
	if p != 0 {
		sqlite3.Xsqlite3_close(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm)
		sqlite3.Xsqlite3_close(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv)
		idxScanFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpScan, uintptr(0))
		idxStatementFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpStatement, uintptr(0))
		idxTableFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpTable)
		idxWriteFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpWrite)
		idxHashClear(tls, (p + 44 /* &.hIdx */))
		sqlite3.Xsqlite3_free(tls, (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

//----------------------------------------------------------------------------
// Support for functions with a variable number of arguments.
//
// The following TCL_VARARGS* macros are to support old extensions
// written for older versions of Tcl where the macros permitted
// support for the varargs.h system as well as stdarg.h .
//
// New code should just directly be written to use stdarg.h conventions.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Allow a part of Tcl's API to be explicitly marked as deprecated.
//
// Used to make TIP 330/336 generate moans even if people use the
// compatibility macros. Change your code, guys! We won't support you forever.

//----------------------------------------------------------------------------
// Macros used to declare a function to be exported by a DLL. Used by Windows,
// maps to no-op declarations on non-Windows systems. The default build on
// windows is for a DLL, which causes the DLLIMPORT and DLLEXPORT macros to be
// nonempty. To build a static library, the macro STATIC_BUILD should be
// defined.
//
// Note: when building static but linking dynamically to MSVCRT we must still
//       correctly decorate the C library imported function.  Use CRTIMPORT
//       for this purpose.  _DLL is defined by the compiler when linking to
//       MSVCRT.

// These macros are used to control whether functions are being declared for
// import or export. If a function is being declared while it is being built
// to be included in a shared library, then it should have the DLLEXPORT
// storage class. If is being declared for use by a module that is going to
// link against the shared library, then it should have the DLLIMPORT storage
// class. If the symbol is beind declared for a static build or for use from a
// stub library, then the storage class should be empty.
//
// The convention is that a macro called BUILD_xxxx, where xxxx is the name of
// a library we are building, is set on the compile line for sources that are
// to be placed in the library. When this macro is set, the storage class will
// be set to DLLEXPORT. At the end of the header file, the storage class will
// be reset to DLLIMPORT.

// The following _ANSI_ARGS_ macro is to support old extensions
// written for older versions of Tcl where it permitted support
// for compilers written in the pre-prototype era of C.
//
// New code should use prototypes.

// Definitions that allow this header file to be used either with or without
// ANSI C features.

// Make sure EXTERN isn't defined elsewhere.

//----------------------------------------------------------------------------
// The following code is copied from winnt.h. If we don't replicate it here,
// then <windows.h> can't be included after tcl.h, since tcl.h also defines
// VOID. This block is skipped under Cygwin and Mingw.

// Macro to use instead of "void" for arguments that must have type "void *"
// in ANSI C; maps them to type "char *" in non-ANSI systems.

// Miscellaneous declarations.

type ClientData = uintptr /* tcl.h:340:15 */

// Darwin specific configure overrides (to support fat compiles, where
// configure runs only once for multiple architectures):

// Define Tcl_WideInt to be a type that is (at least) 64-bits wide, and define
// Tcl_WideUInt to be the unsigned variant of that type (assuming that where
// we have one, we can have the other.)
//
// Also defines the following macros:
// TCL_WIDE_INT_IS_LONG - if wide ints are really longs (i.e. we're on a
//	LP64 system such as modern Solaris or Linux ... not including Win64)
// Tcl_WideAsLong - forgetful converter from wideInt to long.
// Tcl_LongAsWide - sign-extending converter from long to wideInt.
// Tcl_WideAsDouble - converter from wideInt to double.
// Tcl_DoubleAsWide - converter from double to wideInt.
//
// The following invariant should hold for any long value 'longVal':
//	longVal == Tcl_WideAsLong(Tcl_LongAsWide(longVal))
//
// Note on converting between Tcl_WideInt and strings. This implementation (in
// tclObj.c) depends on the function
// sprintf(...,"%" TCL_LL_MODIFIER "d",...).

type Tcl_WideInt = int64   /* tcl.h:415:28 */
type Tcl_WideUInt = uint64 /* tcl.h:416:36 */

// The next short section of defines are only done when not running on Windows
// or some other strange platform.

type stat = struct {
	Fst_dev     uint64
	F__pad1     uint16
	_           [2]byte
	F__st_ino   uint32
	Fst_mode    uint32
	Fst_nlink   uint32
	Fst_uid     uint32
	Fst_gid     uint32
	Fst_rdev    uint64
	F__pad2     uint16
	_           [6]byte
	Fst_size    int64
	Fst_blksize int32
	_           [4]byte
	Fst_blocks  int64
	Fst_atim    struct {
		Ftv_sec  int32
		Ftv_nsec int32
	}
	Fst_mtim struct {
		Ftv_sec  int32
		Ftv_nsec int32
	}
	Fst_ctim struct {
		Ftv_sec  int32
		Ftv_nsec int32
	}
	Fst_ino uint64
} /* stat.h:38:1 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp1 = struct {
	FresultDontUse    uintptr
	FfreeProcDontUse  uintptr
	FerrorLineDontUse int32
} /* tcl.h:493:9 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp = Tcl_Interp1 /* tcl.h:525:1 */

type Tcl_AsyncHandler = uintptr       /* tcl.h:527:34 */
type Tcl_Channel = uintptr            /* tcl.h:528:29 */
type Tcl_ChannelTypeVersion = uintptr /* tcl.h:529:40 */
type Tcl_Command = uintptr            /* tcl.h:530:29 */
type Tcl_Condition = uintptr          /* tcl.h:531:31 */
type Tcl_Dict = uintptr               /* tcl.h:532:26 */
type Tcl_EncodingState = uintptr      /* tcl.h:533:35 */
type Tcl_Encoding = uintptr           /* tcl.h:534:30 */
type Tcl_Event1 = struct {
	Fproc    uintptr
	FnextPtr uintptr
} /* tcl.h:535:9 */

type Tcl_Event = Tcl_Event1      /* tcl.h:535:26 */
type Tcl_InterpState = uintptr   /* tcl.h:536:33 */
type Tcl_LoadHandle = uintptr    /* tcl.h:537:32 */
type Tcl_Mutex = uintptr         /* tcl.h:538:27 */
type Tcl_Pid = uintptr           /* tcl.h:539:25 */
type Tcl_RegExp = uintptr        /* tcl.h:540:28 */
type Tcl_ThreadDataKey = uintptr /* tcl.h:541:35 */
type Tcl_ThreadId = uintptr      /* tcl.h:542:30 */
type Tcl_TimerToken = uintptr    /* tcl.h:543:32 */
type Tcl_Trace = uintptr         /* tcl.h:544:27 */
type Tcl_Var = uintptr           /* tcl.h:545:25 */
type Tcl_ZlibStream = uintptr    /* tcl.h:546:32 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices1 = struct {
	Fstart int32
	Fend   int32
} /* tcl.h:623:9 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices = Tcl_RegExpIndices1 /* tcl.h:628:3 */

type Tcl_RegExpInfo1 = struct {
	Fnsubs       int32
	Fmatches     uintptr
	FextendStart int32
	Freserved    int32
} /* tcl.h:630:9 */

type Tcl_RegExpInfo = Tcl_RegExpInfo1 /* tcl.h:637:3 */

// Picky compilers complain if this typdef doesn't appear before the struct's
// reference in tclDecls.h.

type Tcl_Stat_ = uintptr    /* tcl.h:644:21 */
type Tcl_OldStat_ = uintptr /* tcl.h:645:21 */

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

type Tcl_ValueType = uint32 /* tcl.h:692:3 */

type Tcl_Value1 = struct {
	Ftype        Tcl_ValueType
	FintValue    int32
	FdoubleValue float64
	FwideValue   Tcl_WideInt
} /* tcl.h:694:9 */

type Tcl_Value = Tcl_Value1 /* tcl.h:700:3 */

// Forward declaration of Tcl_Obj to prevent an error when the forward
// reference to Tcl_Obj is encountered in the function types declared below.

type Tcl_Obj1 = struct {
	FrefCount    int32
	Fbytes       uintptr
	Flength      int32
	FtypePtr     uintptr
	FinternalRep struct {
		_          [0]uint64
		FlongValue int32
		_          [4]byte
	}
} /* tcl.h:707:1 */

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType1 = struct {
	Fname             uintptr
	FfreeIntRepProc   uintptr
	FdupIntRepProc    uintptr
	FupdateStringProc uintptr
	FsetFromAnyProc   uintptr
} /* tcl.h:707:1 */

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType = Tcl_ObjType1 /* tcl.h:796:3 */

// One of the following structures exists for each object in the Tcl system.
// An object stores a value as either a string, some internal representation,
// or both.

type Tcl_Obj = Tcl_Obj1 /* tcl.h:843:3 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult1 = struct {
	Fresult       uintptr
	FfreeProc     uintptr
	FobjResultPtr uintptr
	FappendResult uintptr
	FappendAvl    int32
	FappendUsed   int32
	FresultSpace  [201]int8
	_             [3]byte
} /* tcl.h:864:9 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult = Tcl_SavedResult1 /* tcl.h:872:3 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace1 = struct {
	Fname       uintptr
	FfullName   uintptr
	FclientData ClientData
	FdeleteProc uintptr
	FparentPtr  uintptr
} /* tcl.h:881:9 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace = Tcl_Namespace1 /* tcl.h:897:3 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame1 = struct {
	FnsPtr   uintptr
	Fdummy1  int32
	Fdummy2  int32
	Fdummy3  uintptr
	Fdummy4  uintptr
	Fdummy5  uintptr
	Fdummy6  int32
	Fdummy7  uintptr
	Fdummy8  uintptr
	Fdummy9  int32
	Fdummy10 uintptr
	Fdummy11 uintptr
	Fdummy12 uintptr
	Fdummy13 uintptr
} /* tcl.h:922:9 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame = Tcl_CallFrame1 /* tcl.h:937:3 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo1 = struct {
	FisNativeObjectProc int32
	FobjProc            uintptr
	FobjClientData      ClientData
	Fproc               uintptr
	FclientData         ClientData
	FdeleteProc         uintptr
	FdeleteData         ClientData
	FnamespacePtr       uintptr
} /* tcl.h:954:9 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo = Tcl_CmdInfo1 /* tcl.h:973:3 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString1 = struct {
	Fstring      uintptr
	Flength      int32
	FspaceAvl    int32
	FstaticSpace [200]int8
} /* tcl.h:983:9 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString = Tcl_DString1 /* tcl.h:993:3 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType1 = struct {
	Fversion         int32
	Fflags           int32
	FhashKeyProc     uintptr
	FcompareKeysProc uintptr
	FallocEntryProc  uintptr
	FfreeEntryProc   uintptr
} /* tcl.h:1152:9 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType = Tcl_HashKeyType1 /* tcl.h:1152:32 */
type Tcl_HashTable1 = struct {
	Fbuckets       uintptr
	FstaticBuckets [4]uintptr
	FnumBuckets    int32
	FnumEntries    int32
	FrebuildSize   int32
	FdownShift     int32
	Fmask          int32
	FkeyType       int32
	FfindProc      uintptr
	FcreateProc    uintptr
	FtypePtr       uintptr
} /* tcl.h:1153:9 */

type Tcl_HashTable = Tcl_HashTable1 /* tcl.h:1153:30 */
type Tcl_HashEntry1 = struct {
	FnextPtr    uintptr
	FtablePtr   uintptr
	Fhash       uintptr
	FclientData ClientData
	Fkey        struct{ FoneWordValue uintptr }
} /* tcl.h:1153:9 */

type Tcl_HashEntry = Tcl_HashEntry1 /* tcl.h:1154:30 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch1 = struct {
	FtablePtr     uintptr
	FnextIndex    int32
	FnextEntryPtr uintptr
} /* tcl.h:1308:9 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch = Tcl_HashSearch1 /* tcl.h:1314:3 */

// Acceptable key types for hash tables:
//
// TCL_STRING_KEYS:		The keys are strings, they are copied into the
//				entry.
// TCL_ONE_WORD_KEYS:		The keys are pointers, the pointer is stored
//				in the entry.
// TCL_CUSTOM_TYPE_KEYS:	The keys are arbitrary types which are copied
//				into the entry.
// TCL_CUSTOM_PTR_KEYS:		The keys are pointers to arbitrary types, the
//				pointer is stored in the entry.
//
// While maintaining binary compatibility the above have to be distinct values
// as they are used to differentiate between old versions of the hash table
// which don't have a typePtr and new ones which do. Once binary compatibility
// is discarded in favour of making more wide spread changes TCL_STRING_KEYS
// can be the same as TCL_CUSTOM_TYPE_KEYS, and TCL_ONE_WORD_KEYS can be the
// same as TCL_CUSTOM_PTR_KEYS because they simply determine how the key is
// accessed from the entry and not the behaviour.

// Structure definition for information used to keep track of searches through
// dictionaries. These fields should not be accessed by code outside
// tclDictObj.c

type Tcl_DictSearch = struct {
	Fnext          uintptr
	Fepoch         int32
	FdictionaryPtr Tcl_Dict
} /* tcl.h:1354:3 */

// Positions to pass to Tcl_QueueEvent:

type Tcl_QueuePosition = uint32 /* tcl.h:1389:3 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time1 = struct {
	Fsec  int32
	Fusec int32
} /* tcl.h:1405:9 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time = Tcl_Time1 /* tcl.h:1408:3 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType1 = struct {
	FtypeName         uintptr
	Fversion          Tcl_ChannelTypeVersion
	FcloseProc        uintptr
	FinputProc        uintptr
	FoutputProc       uintptr
	FseekProc         uintptr
	FsetOptionProc    uintptr
	FgetOptionProc    uintptr
	FwatchProc        uintptr
	FgetHandleProc    uintptr
	Fclose2Proc       uintptr
	FblockModeProc    uintptr
	FflushProc        uintptr
	FhandlerProc      uintptr
	FwideSeekProc     uintptr
	FthreadActionProc uintptr
	FtruncateProc     uintptr
} /* tcl.h:1524:9 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType = Tcl_ChannelType1 /* tcl.h:1592:3 */

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

type Tcl_PathType = uint32 /* tcl.h:1613:3 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData1 = struct {
	Ftype       int32
	Fperm       int32
	FmacType    uintptr
	FmacCreator uintptr
} /* tcl.h:1620:9 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData = Tcl_GlobTypeData1 /* tcl.h:1625:3 */
// We have to declare the utime structure here.
type utimbuf = struct {
	Factime  int32
	Fmodtime int32
} /* utime.h:36:1 */

type Tcl_FSVersion = uintptr /* tcl.h:1700:31 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem1 = struct {
	FtypeName                 uintptr
	FstructureLength          int32
	Fversion                  Tcl_FSVersion
	FpathInFilesystemProc     uintptr
	FdupInternalRepProc       uintptr
	FfreeInternalRepProc      uintptr
	FinternalToNormalizedProc uintptr
	FcreateInternalRepProc    uintptr
	FnormalizePathProc        uintptr
	FfilesystemPathTypeProc   uintptr
	FfilesystemSeparatorProc  uintptr
	FstatProc                 uintptr
	FaccessProc               uintptr
	FopenFileChannelProc      uintptr
	FmatchInDirectoryProc     uintptr
	FutimeProc                uintptr
	FlinkProc                 uintptr
	FlistVolumesProc          uintptr
	FfileAttrStringsProc      uintptr
	FfileAttrsGetProc         uintptr
	FfileAttrsSetProc         uintptr
	FcreateDirectoryProc      uintptr
	FremoveDirectoryProc      uintptr
	FdeleteFileProc           uintptr
	FcopyFileProc             uintptr
	FrenameFileProc           uintptr
	FcopyDirectoryProc        uintptr
	FlstatProc                uintptr
	FloadFileProc             uintptr
	FgetCwdProc               uintptr
	FchdirProc                uintptr
} /* tcl.h:1726:9 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem = Tcl_Filesystem1 /* tcl.h:1873:3 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs1 = struct {
	FsetTimerProc          uintptr
	FwaitForEventProc      uintptr
	FcreateFileHandlerProc uintptr
	FdeleteFileHandlerProc uintptr
	FinitNotifierProc      uintptr
	FfinalizeNotifierProc  uintptr
	FalertNotifierProc     uintptr
	FserviceModeHookProc   uintptr
} /* tcl.h:1894:9 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs = Tcl_NotifierProcs1 /* tcl.h:1903:3 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token1 = struct {
	Ftype          int32
	Fstart         uintptr
	Fsize          int32
	FnumComponents int32
} /* tcl.h:1914:9 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token = Tcl_Token1 /* tcl.h:1924:3 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse1 = struct {
	FcommentStart    uintptr
	FcommentSize     int32
	FcommandStart    uintptr
	FcommandSize     int32
	FnumWords        int32
	FtokenPtr        uintptr
	FnumTokens       int32
	FtokensAvailable int32
	FerrorType       int32
	Fstring          uintptr
	Fend             uintptr
	Finterp          uintptr
	Fterm            uintptr
	Fincomplete      int32
	FstaticTokens    [20]Tcl_Token
} /* tcl.h:2030:9 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse = Tcl_Parse1 /* tcl.h:2083:3 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType1 = struct {
	FencodingName uintptr
	FtoUtfProc    uintptr
	FfromUtfProc  uintptr
	FfreeProc     uintptr
	FclientData   ClientData
	FnullSize     int32
} /* tcl.h:2091:9 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType = Tcl_EncodingType1 /* tcl.h:2111:3 */

// The following definitions are used as values for the conversion control
// flags argument when converting text from one character set to another:
//
// TCL_ENCODING_START -		Signifies that the source buffer is the first
//				block in a (potentially multi-block) input
//				stream. Tells the conversion function to reset
//				to an initial state and perform any
//				initialization that needs to occur before the
//				first byte is converted. If the source buffer
//				contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_END -		Signifies that the source buffer is the last
//				block in a (potentially multi-block) input
//				stream. Tells the conversion routine to
//				perform any finalization that needs to occur
//				after the last byte is converted and then to
//				reset to an initial state. If the source
//				buffer contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_STOPONERROR -	If set, then the converter will return
//				immediately upon encountering an invalid byte
//				sequence or a source character that has no
//				mapping in the target encoding. If clear, then
//				the converter will skip the problem,
//				substituting one or more "close" characters in
//				the destination buffer and then continue to
//				convert the source.
// TCL_ENCODING_NO_TERMINATE - 	If set, Tcl_ExternalToUtf will not append a
//				terminating NUL byte.  Knowing that it will
//				not need space to do so, it will fill all
//				dstLen bytes with encoded UTF-8 content, as
//				other circumstances permit.  If clear, the
//				default behavior is to reserve a byte in
//				the dst space for NUL termination, and to
//				append the NUL byte.
// TCL_ENCODING_CHAR_LIMIT -	If set and dstCharsPtr is not NULL, then
//				Tcl_ExternalToUtf takes the initial value
//				of *dstCharsPtr is taken as a limit of the
//				maximum number of chars to produce in the
//				encoded UTF-8 content.  Otherwise, the
//				number of chars produced is controlled only
//				by other limiting factors.

// The following definitions are the error codes returned by the conversion
// routines:
//
// TCL_OK -			All characters were converted.
// TCL_CONVERT_NOSPACE -	The output buffer would not have been large
//				enough for all of the converted data; as many
//				characters as could fit were converted though.
// TCL_CONVERT_MULTIBYTE -	The last few bytes in the source string were
//				the beginning of a multibyte sequence, but
//				more bytes were needed to complete this
//				sequence. A subsequent call to the conversion
//				routine should pass the beginning of this
//				unconverted sequence plus additional bytes
//				from the source stream to properly convert the
//				formerly split-up multibyte sequence.
// TCL_CONVERT_SYNTAX -		The source stream contained an invalid
//				character sequence. This may occur if the
//				input stream has been damaged or if the input
//				encoding method was misidentified. This error
//				is reported only if TCL_ENCODING_STOPONERROR
//				was specified.
// TCL_CONVERT_UNKNOWN -	The source string contained a character that
//				could not be represented in the target
//				encoding. This error is reported only if
//				TCL_ENCODING_STOPONERROR was specified.

// The maximum number of bytes that are necessary to represent a single
// Unicode character in UTF-8. The valid values should be 3, 4 or 6
// (or perhaps 1 if we want to support a non-unicode enabled core). If 3 or
// 4, then Tcl_UniChar must be 2-bytes in size (UCS-2) (the default). If 6,
// then Tcl_UniChar must be 4-bytes in size (UCS-4). At this time UCS-2 mode
// is the default and recommended mode. UCS-4 is experimental and not
// recommended. It works for the core, but most extensions expect UCS-2.

// This represents a Unicode character. Any changes to this should also be
// reflected in regcustom.h.

type Tcl_UniChar = uint16 /* tcl.h:2228:24 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config1 = struct {
	Fkey   uintptr
	Fvalue uintptr
} /* tcl.h:2237:9 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config = Tcl_Config1 /* tcl.h:2242:3 */
type mp_digit = uint32        /* tcl.h:2268:22 */

//----------------------------------------------------------------------------
// Definitions needed for Tcl_ParseArgvObj routines.
// Based on tkArgv.c.
// Modifications from the original are copyright (c) Sam Bromley 2006

type Tcl_ArgvInfo = struct {
	Ftype       int32
	FkeyStr     uintptr
	FsrcPtr     uintptr
	FdstPtr     uintptr
	FhelpStr    uintptr
	FclientData ClientData
} /* tcl.h:2289:3 */

type TclPlatStubs1 = struct {
	Fmagic int32
	Fhooks uintptr
} /* tclDecls.h:1821:11 */

type TclStubHooks = struct {
	FtclPlatStubs    uintptr
	FtclIntStubs     uintptr
	FtclIntPlatStubs uintptr
} /* tclDecls.h:1824:3 */

type TclStubs1 = struct {
	Fmagic                                  int32
	Fhooks                                  uintptr
	Ftcl_PkgProvideEx                       uintptr
	Ftcl_PkgRequireEx                       uintptr
	Ftcl_Panic                              uintptr
	Ftcl_Alloc                              uintptr
	Ftcl_Free                               uintptr
	Ftcl_Realloc                            uintptr
	Ftcl_DbCkalloc                          uintptr
	Ftcl_DbCkfree                           uintptr
	Ftcl_DbCkrealloc                        uintptr
	Ftcl_CreateFileHandler                  uintptr
	Ftcl_DeleteFileHandler                  uintptr
	Ftcl_SetTimer                           uintptr
	Ftcl_Sleep                              uintptr
	Ftcl_WaitForEvent                       uintptr
	Ftcl_AppendAllObjTypes                  uintptr
	Ftcl_AppendStringsToObj                 uintptr
	Ftcl_AppendToObj                        uintptr
	Ftcl_ConcatObj                          uintptr
	Ftcl_ConvertToType                      uintptr
	Ftcl_DbDecrRefCount                     uintptr
	Ftcl_DbIncrRefCount                     uintptr
	Ftcl_DbIsShared                         uintptr
	Ftcl_DbNewBooleanObj                    uintptr
	Ftcl_DbNewByteArrayObj                  uintptr
	Ftcl_DbNewDoubleObj                     uintptr
	Ftcl_DbNewListObj                       uintptr
	Ftcl_DbNewLongObj                       uintptr
	Ftcl_DbNewObj                           uintptr
	Ftcl_DbNewStringObj                     uintptr
	Ftcl_DuplicateObj                       uintptr
	FtclFreeObj                             uintptr
	Ftcl_GetBoolean                         uintptr
	Ftcl_GetBooleanFromObj                  uintptr
	Ftcl_GetByteArrayFromObj                uintptr
	Ftcl_GetDouble                          uintptr
	Ftcl_GetDoubleFromObj                   uintptr
	Ftcl_GetIndexFromObj                    uintptr
	Ftcl_GetInt                             uintptr
	Ftcl_GetIntFromObj                      uintptr
	Ftcl_GetLongFromObj                     uintptr
	Ftcl_GetObjType                         uintptr
	Ftcl_GetStringFromObj                   uintptr
	Ftcl_InvalidateStringRep                uintptr
	Ftcl_ListObjAppendList                  uintptr
	Ftcl_ListObjAppendElement               uintptr
	Ftcl_ListObjGetElements                 uintptr
	Ftcl_ListObjIndex                       uintptr
	Ftcl_ListObjLength                      uintptr
	Ftcl_ListObjReplace                     uintptr
	Ftcl_NewBooleanObj                      uintptr
	Ftcl_NewByteArrayObj                    uintptr
	Ftcl_NewDoubleObj                       uintptr
	Ftcl_NewIntObj                          uintptr
	Ftcl_NewListObj                         uintptr
	Ftcl_NewLongObj                         uintptr
	Ftcl_NewObj                             uintptr
	Ftcl_NewStringObj                       uintptr
	Ftcl_SetBooleanObj                      uintptr
	Ftcl_SetByteArrayLength                 uintptr
	Ftcl_SetByteArrayObj                    uintptr
	Ftcl_SetDoubleObj                       uintptr
	Ftcl_SetIntObj                          uintptr
	Ftcl_SetListObj                         uintptr
	Ftcl_SetLongObj                         uintptr
	Ftcl_SetObjLength                       uintptr
	Ftcl_SetStringObj                       uintptr
	Ftcl_AddErrorInfo                       uintptr
	Ftcl_AddObjErrorInfo                    uintptr
	Ftcl_AllowExceptions                    uintptr
	Ftcl_AppendElement                      uintptr
	Ftcl_AppendResult                       uintptr
	Ftcl_AsyncCreate                        uintptr
	Ftcl_AsyncDelete                        uintptr
	Ftcl_AsyncInvoke                        uintptr
	Ftcl_AsyncMark                          uintptr
	Ftcl_AsyncReady                         uintptr
	Ftcl_BackgroundError                    uintptr
	Ftcl_Backslash                          uintptr
	Ftcl_BadChannelOption                   uintptr
	Ftcl_CallWhenDeleted                    uintptr
	Ftcl_CancelIdleCall                     uintptr
	Ftcl_Close                              uintptr
	Ftcl_CommandComplete                    uintptr
	Ftcl_Concat                             uintptr
	Ftcl_ConvertElement                     uintptr
	Ftcl_ConvertCountedElement              uintptr
	Ftcl_CreateAlias                        uintptr
	Ftcl_CreateAliasObj                     uintptr
	Ftcl_CreateChannel                      uintptr
	Ftcl_CreateChannelHandler               uintptr
	Ftcl_CreateCloseHandler                 uintptr
	Ftcl_CreateCommand                      uintptr
	Ftcl_CreateEventSource                  uintptr
	Ftcl_CreateExitHandler                  uintptr
	Ftcl_CreateInterp                       uintptr
	Ftcl_CreateMathFunc                     uintptr
	Ftcl_CreateObjCommand                   uintptr
	Ftcl_CreateSlave                        uintptr
	Ftcl_CreateTimerHandler                 uintptr
	Ftcl_CreateTrace                        uintptr
	Ftcl_DeleteAssocData                    uintptr
	Ftcl_DeleteChannelHandler               uintptr
	Ftcl_DeleteCloseHandler                 uintptr
	Ftcl_DeleteCommand                      uintptr
	Ftcl_DeleteCommandFromToken             uintptr
	Ftcl_DeleteEvents                       uintptr
	Ftcl_DeleteEventSource                  uintptr
	Ftcl_DeleteExitHandler                  uintptr
	Ftcl_DeleteHashEntry                    uintptr
	Ftcl_DeleteHashTable                    uintptr
	Ftcl_DeleteInterp                       uintptr
	Ftcl_DetachPids                         uintptr
	Ftcl_DeleteTimerHandler                 uintptr
	Ftcl_DeleteTrace                        uintptr
	Ftcl_DontCallWhenDeleted                uintptr
	Ftcl_DoOneEvent                         uintptr
	Ftcl_DoWhenIdle                         uintptr
	Ftcl_DStringAppend                      uintptr
	Ftcl_DStringAppendElement               uintptr
	Ftcl_DStringEndSublist                  uintptr
	Ftcl_DStringFree                        uintptr
	Ftcl_DStringGetResult                   uintptr
	Ftcl_DStringInit                        uintptr
	Ftcl_DStringResult                      uintptr
	Ftcl_DStringSetLength                   uintptr
	Ftcl_DStringStartSublist                uintptr
	Ftcl_Eof                                uintptr
	Ftcl_ErrnoId                            uintptr
	Ftcl_ErrnoMsg                           uintptr
	Ftcl_Eval                               uintptr
	Ftcl_EvalFile                           uintptr
	Ftcl_EvalObj                            uintptr
	Ftcl_EventuallyFree                     uintptr
	Ftcl_Exit                               uintptr
	Ftcl_ExposeCommand                      uintptr
	Ftcl_ExprBoolean                        uintptr
	Ftcl_ExprBooleanObj                     uintptr
	Ftcl_ExprDouble                         uintptr
	Ftcl_ExprDoubleObj                      uintptr
	Ftcl_ExprLong                           uintptr
	Ftcl_ExprLongObj                        uintptr
	Ftcl_ExprObj                            uintptr
	Ftcl_ExprString                         uintptr
	Ftcl_Finalize                           uintptr
	Ftcl_FindExecutable                     uintptr
	Ftcl_FirstHashEntry                     uintptr
	Ftcl_Flush                              uintptr
	Ftcl_FreeResult                         uintptr
	Ftcl_GetAlias                           uintptr
	Ftcl_GetAliasObj                        uintptr
	Ftcl_GetAssocData                       uintptr
	Ftcl_GetChannel                         uintptr
	Ftcl_GetChannelBufferSize               uintptr
	Ftcl_GetChannelHandle                   uintptr
	Ftcl_GetChannelInstanceData             uintptr
	Ftcl_GetChannelMode                     uintptr
	Ftcl_GetChannelName                     uintptr
	Ftcl_GetChannelOption                   uintptr
	Ftcl_GetChannelType                     uintptr
	Ftcl_GetCommandInfo                     uintptr
	Ftcl_GetCommandName                     uintptr
	Ftcl_GetErrno                           uintptr
	Ftcl_GetHostName                        uintptr
	Ftcl_GetInterpPath                      uintptr
	Ftcl_GetMaster                          uintptr
	Ftcl_GetNameOfExecutable                uintptr
	Ftcl_GetObjResult                       uintptr
	Ftcl_GetOpenFile                        uintptr
	Ftcl_GetPathType                        uintptr
	Ftcl_Gets                               uintptr
	Ftcl_GetsObj                            uintptr
	Ftcl_GetServiceMode                     uintptr
	Ftcl_GetSlave                           uintptr
	Ftcl_GetStdChannel                      uintptr
	Ftcl_GetStringResult                    uintptr
	Ftcl_GetVar                             uintptr
	Ftcl_GetVar2                            uintptr
	Ftcl_GlobalEval                         uintptr
	Ftcl_GlobalEvalObj                      uintptr
	Ftcl_HideCommand                        uintptr
	Ftcl_Init                               uintptr
	Ftcl_InitHashTable                      uintptr
	Ftcl_InputBlocked                       uintptr
	Ftcl_InputBuffered                      uintptr
	Ftcl_InterpDeleted                      uintptr
	Ftcl_IsSafe                             uintptr
	Ftcl_JoinPath                           uintptr
	Ftcl_LinkVar                            uintptr
	Freserved188                            uintptr
	Ftcl_MakeFileChannel                    uintptr
	Ftcl_MakeSafe                           uintptr
	Ftcl_MakeTcpClientChannel               uintptr
	Ftcl_Merge                              uintptr
	Ftcl_NextHashEntry                      uintptr
	Ftcl_NotifyChannel                      uintptr
	Ftcl_ObjGetVar2                         uintptr
	Ftcl_ObjSetVar2                         uintptr
	Ftcl_OpenCommandChannel                 uintptr
	Ftcl_OpenFileChannel                    uintptr
	Ftcl_OpenTcpClient                      uintptr
	Ftcl_OpenTcpServer                      uintptr
	Ftcl_Preserve                           uintptr
	Ftcl_PrintDouble                        uintptr
	Ftcl_PutEnv                             uintptr
	Ftcl_PosixError                         uintptr
	Ftcl_QueueEvent                         uintptr
	Ftcl_Read                               uintptr
	Ftcl_ReapDetachedProcs                  uintptr
	Ftcl_RecordAndEval                      uintptr
	Ftcl_RecordAndEvalObj                   uintptr
	Ftcl_RegisterChannel                    uintptr
	Ftcl_RegisterObjType                    uintptr
	Ftcl_RegExpCompile                      uintptr
	Ftcl_RegExpExec                         uintptr
	Ftcl_RegExpMatch                        uintptr
	Ftcl_RegExpRange                        uintptr
	Ftcl_Release                            uintptr
	Ftcl_ResetResult                        uintptr
	Ftcl_ScanElement                        uintptr
	Ftcl_ScanCountedElement                 uintptr
	Ftcl_SeekOld                            uintptr
	Ftcl_ServiceAll                         uintptr
	Ftcl_ServiceEvent                       uintptr
	Ftcl_SetAssocData                       uintptr
	Ftcl_SetChannelBufferSize               uintptr
	Ftcl_SetChannelOption                   uintptr
	Ftcl_SetCommandInfo                     uintptr
	Ftcl_SetErrno                           uintptr
	Ftcl_SetErrorCode                       uintptr
	Ftcl_SetMaxBlockTime                    uintptr
	Ftcl_SetPanicProc                       uintptr
	Ftcl_SetRecursionLimit                  uintptr
	Ftcl_SetResult                          uintptr
	Ftcl_SetServiceMode                     uintptr
	Ftcl_SetObjErrorCode                    uintptr
	Ftcl_SetObjResult                       uintptr
	Ftcl_SetStdChannel                      uintptr
	Ftcl_SetVar                             uintptr
	Ftcl_SetVar2                            uintptr
	Ftcl_SignalId                           uintptr
	Ftcl_SignalMsg                          uintptr
	Ftcl_SourceRCFile                       uintptr
	Ftcl_SplitList                          uintptr
	Ftcl_SplitPath                          uintptr
	Ftcl_StaticPackage                      uintptr
	Ftcl_StringMatch                        uintptr
	Ftcl_TellOld                            uintptr
	Ftcl_TraceVar                           uintptr
	Ftcl_TraceVar2                          uintptr
	Ftcl_TranslateFileName                  uintptr
	Ftcl_Ungets                             uintptr
	Ftcl_UnlinkVar                          uintptr
	Ftcl_UnregisterChannel                  uintptr
	Ftcl_UnsetVar                           uintptr
	Ftcl_UnsetVar2                          uintptr
	Ftcl_UntraceVar                         uintptr
	Ftcl_UntraceVar2                        uintptr
	Ftcl_UpdateLinkedVar                    uintptr
	Ftcl_UpVar                              uintptr
	Ftcl_UpVar2                             uintptr
	Ftcl_VarEval                            uintptr
	Ftcl_VarTraceInfo                       uintptr
	Ftcl_VarTraceInfo2                      uintptr
	Ftcl_Write                              uintptr
	Ftcl_WrongNumArgs                       uintptr
	Ftcl_DumpActiveMemory                   uintptr
	Ftcl_ValidateAllMemory                  uintptr
	Ftcl_AppendResultVA                     uintptr
	Ftcl_AppendStringsToObjVA               uintptr
	Ftcl_HashStats                          uintptr
	Ftcl_ParseVar                           uintptr
	Ftcl_PkgPresent                         uintptr
	Ftcl_PkgPresentEx                       uintptr
	Ftcl_PkgProvide                         uintptr
	Ftcl_PkgRequire                         uintptr
	Ftcl_SetErrorCodeVA                     uintptr
	Ftcl_VarEvalVA                          uintptr
	Ftcl_WaitPid                            uintptr
	Ftcl_PanicVA                            uintptr
	Ftcl_GetVersion                         uintptr
	Ftcl_InitMemory                         uintptr
	Ftcl_StackChannel                       uintptr
	Ftcl_UnstackChannel                     uintptr
	Ftcl_GetStackedChannel                  uintptr
	Ftcl_SetMainLoop                        uintptr
	Freserved285                            uintptr
	Ftcl_AppendObjToObj                     uintptr
	Ftcl_CreateEncoding                     uintptr
	Ftcl_CreateThreadExitHandler            uintptr
	Ftcl_DeleteThreadExitHandler            uintptr
	Ftcl_DiscardResult                      uintptr
	Ftcl_EvalEx                             uintptr
	Ftcl_EvalObjv                           uintptr
	Ftcl_EvalObjEx                          uintptr
	Ftcl_ExitThread                         uintptr
	Ftcl_ExternalToUtf                      uintptr
	Ftcl_ExternalToUtfDString               uintptr
	Ftcl_FinalizeThread                     uintptr
	Ftcl_FinalizeNotifier                   uintptr
	Ftcl_FreeEncoding                       uintptr
	Ftcl_GetCurrentThread                   uintptr
	Ftcl_GetEncoding                        uintptr
	Ftcl_GetEncodingName                    uintptr
	Ftcl_GetEncodingNames                   uintptr
	Ftcl_GetIndexFromObjStruct              uintptr
	Ftcl_GetThreadData                      uintptr
	Ftcl_GetVar2Ex                          uintptr
	Ftcl_InitNotifier                       uintptr
	Ftcl_MutexLock                          uintptr
	Ftcl_MutexUnlock                        uintptr
	Ftcl_ConditionNotify                    uintptr
	Ftcl_ConditionWait                      uintptr
	Ftcl_NumUtfChars                        uintptr
	Ftcl_ReadChars                          uintptr
	Ftcl_RestoreResult                      uintptr
	Ftcl_SaveResult                         uintptr
	Ftcl_SetSystemEncoding                  uintptr
	Ftcl_SetVar2Ex                          uintptr
	Ftcl_ThreadAlert                        uintptr
	Ftcl_ThreadQueueEvent                   uintptr
	Ftcl_UniCharAtIndex                     uintptr
	Ftcl_UniCharToLower                     uintptr
	Ftcl_UniCharToTitle                     uintptr
	Ftcl_UniCharToUpper                     uintptr
	Ftcl_UniCharToUtf                       uintptr
	Ftcl_UtfAtIndex                         uintptr
	Ftcl_UtfCharComplete                    uintptr
	Ftcl_UtfBackslash                       uintptr
	Ftcl_UtfFindFirst                       uintptr
	Ftcl_UtfFindLast                        uintptr
	Ftcl_UtfNext                            uintptr
	Ftcl_UtfPrev                            uintptr
	Ftcl_UtfToExternal                      uintptr
	Ftcl_UtfToExternalDString               uintptr
	Ftcl_UtfToLower                         uintptr
	Ftcl_UtfToTitle                         uintptr
	Ftcl_UtfToUniChar                       uintptr
	Ftcl_UtfToUpper                         uintptr
	Ftcl_WriteChars                         uintptr
	Ftcl_WriteObj                           uintptr
	Ftcl_GetString                          uintptr
	Ftcl_GetDefaultEncodingDir              uintptr
	Ftcl_SetDefaultEncodingDir              uintptr
	Ftcl_AlertNotifier                      uintptr
	Ftcl_ServiceModeHook                    uintptr
	Ftcl_UniCharIsAlnum                     uintptr
	Ftcl_UniCharIsAlpha                     uintptr
	Ftcl_UniCharIsDigit                     uintptr
	Ftcl_UniCharIsLower                     uintptr
	Ftcl_UniCharIsSpace                     uintptr
	Ftcl_UniCharIsUpper                     uintptr
	Ftcl_UniCharIsWordChar                  uintptr
	Ftcl_UniCharLen                         uintptr
	Ftcl_UniCharNcmp                        uintptr
	Ftcl_UniCharToUtfDString                uintptr
	Ftcl_UtfToUniCharDString                uintptr
	Ftcl_GetRegExpFromObj                   uintptr
	Ftcl_EvalTokens                         uintptr
	Ftcl_FreeParse                          uintptr
	Ftcl_LogCommandInfo                     uintptr
	Ftcl_ParseBraces                        uintptr
	Ftcl_ParseCommand                       uintptr
	Ftcl_ParseExpr                          uintptr
	Ftcl_ParseQuotedString                  uintptr
	Ftcl_ParseVarName                       uintptr
	Ftcl_GetCwd                             uintptr
	Ftcl_Chdir                              uintptr
	Ftcl_Access                             uintptr
	Ftcl_Stat                               uintptr
	Ftcl_UtfNcmp                            uintptr
	Ftcl_UtfNcasecmp                        uintptr
	Ftcl_StringCaseMatch                    uintptr
	Ftcl_UniCharIsControl                   uintptr
	Ftcl_UniCharIsGraph                     uintptr
	Ftcl_UniCharIsPrint                     uintptr
	Ftcl_UniCharIsPunct                     uintptr
	Ftcl_RegExpExecObj                      uintptr
	Ftcl_RegExpGetInfo                      uintptr
	Ftcl_NewUnicodeObj                      uintptr
	Ftcl_SetUnicodeObj                      uintptr
	Ftcl_GetCharLength                      uintptr
	Ftcl_GetUniChar                         uintptr
	Ftcl_GetUnicode                         uintptr
	Ftcl_GetRange                           uintptr
	Ftcl_AppendUnicodeToObj                 uintptr
	Ftcl_RegExpMatchObj                     uintptr
	Ftcl_SetNotifier                        uintptr
	Ftcl_GetAllocMutex                      uintptr
	Ftcl_GetChannelNames                    uintptr
	Ftcl_GetChannelNamesEx                  uintptr
	Ftcl_ProcObjCmd                         uintptr
	Ftcl_ConditionFinalize                  uintptr
	Ftcl_MutexFinalize                      uintptr
	Ftcl_CreateThread                       uintptr
	Ftcl_ReadRaw                            uintptr
	Ftcl_WriteRaw                           uintptr
	Ftcl_GetTopChannel                      uintptr
	Ftcl_ChannelBuffered                    uintptr
	Ftcl_ChannelName                        uintptr
	Ftcl_ChannelVersion                     uintptr
	Ftcl_ChannelBlockModeProc               uintptr
	Ftcl_ChannelCloseProc                   uintptr
	Ftcl_ChannelClose2Proc                  uintptr
	Ftcl_ChannelInputProc                   uintptr
	Ftcl_ChannelOutputProc                  uintptr
	Ftcl_ChannelSeekProc                    uintptr
	Ftcl_ChannelSetOptionProc               uintptr
	Ftcl_ChannelGetOptionProc               uintptr
	Ftcl_ChannelWatchProc                   uintptr
	Ftcl_ChannelGetHandleProc               uintptr
	Ftcl_ChannelFlushProc                   uintptr
	Ftcl_ChannelHandlerProc                 uintptr
	Ftcl_JoinThread                         uintptr
	Ftcl_IsChannelShared                    uintptr
	Ftcl_IsChannelRegistered                uintptr
	Ftcl_CutChannel                         uintptr
	Ftcl_SpliceChannel                      uintptr
	Ftcl_ClearChannelHandlers               uintptr
	Ftcl_IsChannelExisting                  uintptr
	Ftcl_UniCharNcasecmp                    uintptr
	Ftcl_UniCharCaseMatch                   uintptr
	Ftcl_FindHashEntry                      uintptr
	Ftcl_CreateHashEntry                    uintptr
	Ftcl_InitCustomHashTable                uintptr
	Ftcl_InitObjHashTable                   uintptr
	Ftcl_CommandTraceInfo                   uintptr
	Ftcl_TraceCommand                       uintptr
	Ftcl_UntraceCommand                     uintptr
	Ftcl_AttemptAlloc                       uintptr
	Ftcl_AttemptDbCkalloc                   uintptr
	Ftcl_AttemptRealloc                     uintptr
	Ftcl_AttemptDbCkrealloc                 uintptr
	Ftcl_AttemptSetObjLength                uintptr
	Ftcl_GetChannelThread                   uintptr
	Ftcl_GetUnicodeFromObj                  uintptr
	Ftcl_GetMathFuncInfo                    uintptr
	Ftcl_ListMathFuncs                      uintptr
	Ftcl_SubstObj                           uintptr
	Ftcl_DetachChannel                      uintptr
	Ftcl_IsStandardChannel                  uintptr
	Ftcl_FSCopyFile                         uintptr
	Ftcl_FSCopyDirectory                    uintptr
	Ftcl_FSCreateDirectory                  uintptr
	Ftcl_FSDeleteFile                       uintptr
	Ftcl_FSLoadFile                         uintptr
	Ftcl_FSMatchInDirectory                 uintptr
	Ftcl_FSLink                             uintptr
	Ftcl_FSRemoveDirectory                  uintptr
	Ftcl_FSRenameFile                       uintptr
	Ftcl_FSLstat                            uintptr
	Ftcl_FSUtime                            uintptr
	Ftcl_FSFileAttrsGet                     uintptr
	Ftcl_FSFileAttrsSet                     uintptr
	Ftcl_FSFileAttrStrings                  uintptr
	Ftcl_FSStat                             uintptr
	Ftcl_FSAccess                           uintptr
	Ftcl_FSOpenFileChannel                  uintptr
	Ftcl_FSGetCwd                           uintptr
	Ftcl_FSChdir                            uintptr
	Ftcl_FSConvertToPathType                uintptr
	Ftcl_FSJoinPath                         uintptr
	Ftcl_FSSplitPath                        uintptr
	Ftcl_FSEqualPaths                       uintptr
	Ftcl_FSGetNormalizedPath                uintptr
	Ftcl_FSJoinToPath                       uintptr
	Ftcl_FSGetInternalRep                   uintptr
	Ftcl_FSGetTranslatedPath                uintptr
	Ftcl_FSEvalFile                         uintptr
	Ftcl_FSNewNativePath                    uintptr
	Ftcl_FSGetNativePath                    uintptr
	Ftcl_FSFileSystemInfo                   uintptr
	Ftcl_FSPathSeparator                    uintptr
	Ftcl_FSListVolumes                      uintptr
	Ftcl_FSRegister                         uintptr
	Ftcl_FSUnregister                       uintptr
	Ftcl_FSData                             uintptr
	Ftcl_FSGetTranslatedStringPath          uintptr
	Ftcl_FSGetFileSystemForPath             uintptr
	Ftcl_FSGetPathType                      uintptr
	Ftcl_OutputBuffered                     uintptr
	Ftcl_FSMountsChanged                    uintptr
	Ftcl_EvalTokensStandard                 uintptr
	Ftcl_GetTime                            uintptr
	Ftcl_CreateObjTrace                     uintptr
	Ftcl_GetCommandInfoFromToken            uintptr
	Ftcl_SetCommandInfoFromToken            uintptr
	Ftcl_DbNewWideIntObj                    uintptr
	Ftcl_GetWideIntFromObj                  uintptr
	Ftcl_NewWideIntObj                      uintptr
	Ftcl_SetWideIntObj                      uintptr
	Ftcl_AllocStatBuf                       uintptr
	Ftcl_Seek                               uintptr
	Ftcl_Tell                               uintptr
	Ftcl_ChannelWideSeekProc                uintptr
	Ftcl_DictObjPut                         uintptr
	Ftcl_DictObjGet                         uintptr
	Ftcl_DictObjRemove                      uintptr
	Ftcl_DictObjSize                        uintptr
	Ftcl_DictObjFirst                       uintptr
	Ftcl_DictObjNext                        uintptr
	Ftcl_DictObjDone                        uintptr
	Ftcl_DictObjPutKeyList                  uintptr
	Ftcl_DictObjRemoveKeyList               uintptr
	Ftcl_NewDictObj                         uintptr
	Ftcl_DbNewDictObj                       uintptr
	Ftcl_RegisterConfig                     uintptr
	Ftcl_CreateNamespace                    uintptr
	Ftcl_DeleteNamespace                    uintptr
	Ftcl_AppendExportList                   uintptr
	Ftcl_Export                             uintptr
	Ftcl_Import                             uintptr
	Ftcl_ForgetImport                       uintptr
	Ftcl_GetCurrentNamespace                uintptr
	Ftcl_GetGlobalNamespace                 uintptr
	Ftcl_FindNamespace                      uintptr
	Ftcl_FindCommand                        uintptr
	Ftcl_GetCommandFromObj                  uintptr
	Ftcl_GetCommandFullName                 uintptr
	Ftcl_FSEvalFileEx                       uintptr
	Ftcl_SetExitProc                        uintptr
	Ftcl_LimitAddHandler                    uintptr
	Ftcl_LimitRemoveHandler                 uintptr
	Ftcl_LimitReady                         uintptr
	Ftcl_LimitCheck                         uintptr
	Ftcl_LimitExceeded                      uintptr
	Ftcl_LimitSetCommands                   uintptr
	Ftcl_LimitSetTime                       uintptr
	Ftcl_LimitSetGranularity                uintptr
	Ftcl_LimitTypeEnabled                   uintptr
	Ftcl_LimitTypeExceeded                  uintptr
	Ftcl_LimitTypeSet                       uintptr
	Ftcl_LimitTypeReset                     uintptr
	Ftcl_LimitGetCommands                   uintptr
	Ftcl_LimitGetTime                       uintptr
	Ftcl_LimitGetGranularity                uintptr
	Ftcl_SaveInterpState                    uintptr
	Ftcl_RestoreInterpState                 uintptr
	Ftcl_DiscardInterpState                 uintptr
	Ftcl_SetReturnOptions                   uintptr
	Ftcl_GetReturnOptions                   uintptr
	Ftcl_IsEnsemble                         uintptr
	Ftcl_CreateEnsemble                     uintptr
	Ftcl_FindEnsemble                       uintptr
	Ftcl_SetEnsembleSubcommandList          uintptr
	Ftcl_SetEnsembleMappingDict             uintptr
	Ftcl_SetEnsembleUnknownHandler          uintptr
	Ftcl_SetEnsembleFlags                   uintptr
	Ftcl_GetEnsembleSubcommandList          uintptr
	Ftcl_GetEnsembleMappingDict             uintptr
	Ftcl_GetEnsembleUnknownHandler          uintptr
	Ftcl_GetEnsembleFlags                   uintptr
	Ftcl_GetEnsembleNamespace               uintptr
	Ftcl_SetTimeProc                        uintptr
	Ftcl_QueryTimeProc                      uintptr
	Ftcl_ChannelThreadActionProc            uintptr
	Ftcl_NewBignumObj                       uintptr
	Ftcl_DbNewBignumObj                     uintptr
	Ftcl_SetBignumObj                       uintptr
	Ftcl_GetBignumFromObj                   uintptr
	Ftcl_TakeBignumFromObj                  uintptr
	Ftcl_TruncateChannel                    uintptr
	Ftcl_ChannelTruncateProc                uintptr
	Ftcl_SetChannelErrorInterp              uintptr
	Ftcl_GetChannelErrorInterp              uintptr
	Ftcl_SetChannelError                    uintptr
	Ftcl_GetChannelError                    uintptr
	Ftcl_InitBignumFromDouble               uintptr
	Ftcl_GetNamespaceUnknownHandler         uintptr
	Ftcl_SetNamespaceUnknownHandler         uintptr
	Ftcl_GetEncodingFromObj                 uintptr
	Ftcl_GetEncodingSearchPath              uintptr
	Ftcl_SetEncodingSearchPath              uintptr
	Ftcl_GetEncodingNameFromEnvironment     uintptr
	Ftcl_PkgRequireProc                     uintptr
	Ftcl_AppendObjToErrorInfo               uintptr
	Ftcl_AppendLimitedToObj                 uintptr
	Ftcl_Format                             uintptr
	Ftcl_AppendFormatToObj                  uintptr
	Ftcl_ObjPrintf                          uintptr
	Ftcl_AppendPrintfToObj                  uintptr
	Ftcl_CancelEval                         uintptr
	Ftcl_Canceled                           uintptr
	Ftcl_CreatePipe                         uintptr
	Ftcl_NRCreateCommand                    uintptr
	Ftcl_NREvalObj                          uintptr
	Ftcl_NREvalObjv                         uintptr
	Ftcl_NRCmdSwap                          uintptr
	Ftcl_NRAddCallback                      uintptr
	Ftcl_NRCallObjProc                      uintptr
	Ftcl_GetFSDeviceFromStat                uintptr
	Ftcl_GetFSInodeFromStat                 uintptr
	Ftcl_GetModeFromStat                    uintptr
	Ftcl_GetLinkCountFromStat               uintptr
	Ftcl_GetUserIdFromStat                  uintptr
	Ftcl_GetGroupIdFromStat                 uintptr
	Ftcl_GetDeviceTypeFromStat              uintptr
	Ftcl_GetAccessTimeFromStat              uintptr
	Ftcl_GetModificationTimeFromStat        uintptr
	Ftcl_GetChangeTimeFromStat              uintptr
	Ftcl_GetSizeFromStat                    uintptr
	Ftcl_GetBlocksFromStat                  uintptr
	Ftcl_GetBlockSizeFromStat               uintptr
	Ftcl_SetEnsembleParameterList           uintptr
	Ftcl_GetEnsembleParameterList           uintptr
	Ftcl_ParseArgsObjv                      uintptr
	Ftcl_GetErrorLine                       uintptr
	Ftcl_SetErrorLine                       uintptr
	Ftcl_TransferResult                     uintptr
	Ftcl_InterpActive                       uintptr
	Ftcl_BackgroundException                uintptr
	Ftcl_ZlibDeflate                        uintptr
	Ftcl_ZlibInflate                        uintptr
	Ftcl_ZlibCRC32                          uintptr
	Ftcl_ZlibAdler32                        uintptr
	Ftcl_ZlibStreamInit                     uintptr
	Ftcl_ZlibStreamGetCommandName           uintptr
	Ftcl_ZlibStreamEof                      uintptr
	Ftcl_ZlibStreamChecksum                 uintptr
	Ftcl_ZlibStreamPut                      uintptr
	Ftcl_ZlibStreamGet                      uintptr
	Ftcl_ZlibStreamClose                    uintptr
	Ftcl_ZlibStreamReset                    uintptr
	Ftcl_SetStartupScript                   uintptr
	Ftcl_GetStartupScript                   uintptr
	Ftcl_CloseEx                            uintptr
	Ftcl_NRExprObj                          uintptr
	Ftcl_NRSubstObj                         uintptr
	Ftcl_LoadFile                           uintptr
	Ftcl_FindSymbol                         uintptr
	Ftcl_FSUnloadFile                       uintptr
	Ftcl_ZlibStreamSetCompressionDictionary uintptr
} /* tclDecls.h:1826:9 */

type TclStubs = TclStubs1 /* tclDecls.h:2485:3 */

// !END!: Do not edit above this line.

// Deprecated Tcl procedures:

// Include platform specific public function declarations that are accessible
// via the stubs table. Make all TclOO symbols MODULE_SCOPE (which only
// has effect on building it as a shared library). See ticket [3010352].

// tclPlatDecls.h --
//
//	Declarations of platform specific Tcl APIs.
//
// Copyright (c) 1998-1999 by Scriptics Corporation.
// All rights reserved.

// WARNING: This file is automatically generated by the tools/genStubs.tcl
// script.  Any modifications to the function declarations below should be made
// in the generic/tcl.decls script.

// TCHAR is needed here for win32, so if it is not defined yet do it here.
// This way, we don't need to include <tchar.h> just for one define.

// !BEGIN!: Do not edit below this line.

// Exported function declarations:

type TclPlatStubs = TclPlatStubs1 /* tclPlatDecls.h:86:3 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Extract an sqlite3* db handle from the object passed as the second
// argument. If successful, set *pDb to point to the db handle and return
// TCL_OK. Otherwise, return TCL_ERROR.
func dbHandleFromObj(tls *libc.TLS, interp uintptr, pObj uintptr, pDb uintptr) int32 { /* test_expert.c:36:12: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var info Tcl_CmdInfo at bp+24, 32

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, pObj), bp+24 /* &info */) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1791 /* "no such handle: " */, tcl.XTcl_GetString(tls, pObj), 0))
		return TCL_ERROR
	}

	*(*uintptr)(unsafe.Pointer(pDb)) = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24 /* &info */)).FobjClientData))
	return TCL_OK
}

// Tclcmd:  $expert sql SQL
//          $expert analyze
//          $expert count
//          $expert report STMT EREPORT
//          $expert destroy
func testExpertCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_expert.c:55:26: */
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var pExpert uintptr = clientData
	*(*[6]Subcmd)(unsafe.Pointer(bp /* aSub */)) = [6]Subcmd{
		{FzSub: ts + 1808 /* "sql" */, FnArg: 1, FzMsg: ts + 1812 /* "TABLE" */},           // 0
		{FzSub: ts + 1818 /* "analyze" */, FzMsg: ts + 489 /* "" */},                       // 1
		{FzSub: ts + 1826 /* "count" */, FzMsg: ts + 489 /* "" */},                         // 2
		{FzSub: ts + 1832 /* "report" */, FnArg: 2, FzMsg: ts + 1839 /* "STMT EREPORT" */}, // 3
		{FzSub: ts + 1852 /* "destroy" */, FzMsg: ts + 489 /* "" */},                       // 4
		{},
	}
	// var iSub int32 at bp+72, 4

	var rc int32 = TCL_OK
	*(*uintptr)(unsafe.Pointer(bp + 76 /* zErr */)) = uintptr(0)

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1860 /* "SUBCOMMAND ..." */)
		return TCL_ERROR
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &aSub[0] */, int32(unsafe.Sizeof(Subcmd{})), ts+1875 /* "sub-command" */, 0, bp+72 /* &iSub */)
	if rc != TCL_OK {
		return rc
	}
	if objc != (2 + (*Subcmd)(unsafe.Pointer(bp /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 72 /* iSub */)))*12)).FnArg) {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*Subcmd)(unsafe.Pointer(bp /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 72 /* iSub */)))*12)).FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp + 72 /* iSub */)) {
	case 0:
		{ // sql
			var zArg uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			rc = sqlite3_expert_sql(tls, pExpert, zArg, bp+76 /* &zErr */)
			break

		}

	case 1:
		{ // analyze
			rc = sqlite3_expert_analyze(tls, pExpert, bp+76 /* &zErr */)
			break

		}

	case 2:
		{ // count
			var n int32 = sqlite3_expert_count(tls, pExpert)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, n))
			break

		}

	case 3:
		{ // report
			*(*[5]uintptr)(unsafe.Pointer(bp + 84 /* aEnum */)) = [5]uintptr{
				ts + 1808 /* "sql" */, ts + 1887 /* "indexes" */, ts + 1895 /* "plan" */, ts + 1900 /* "candidates" */, uintptr(0),
			}
			// var iEnum int32 at bp+104, 4

			// var iStmt int32 at bp+80, 4

			var zReport uintptr

			if (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+80 /* &iStmt */) != 0) ||
				(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+84 /* &aEnum[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+1832 /* "report" */, 0, bp+104 /* &iEnum */) != 0) {
				return TCL_ERROR
			}

			zReport = sqlite3_expert_report(tls, pExpert, *(*int32)(unsafe.Pointer(bp + 80 /* iStmt */)), (1 + *(*int32)(unsafe.Pointer(bp + 104 /* iEnum */))))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zReport, -1))
			break

		}

	default: // destroy

		tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
		break
	}

	if rc != TCL_OK {
		if *(*uintptr)(unsafe.Pointer(bp + 76 /* zErr */)) != 0 {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 76 /* zErr */)), -1))
		} else {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		}
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 76 /* zErr */)))
	return rc
}

type Subcmd = struct {
	FzSub uintptr
	FnArg int32
	FzMsg uintptr
} /* test_expert.c:62:3 */

func testExpertDel(tls *libc.TLS, clientData uintptr) { /* test_expert.c:150:27: */
	var pExpert uintptr = clientData
	sqlite3_expert_destroy(tls, pExpert)
}

// sqlite3_expert_new DB
func test_sqlite3_expert_new(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_expert.c:158:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var db uintptr at bp+40, 4

	var zCmd uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 44 /* zErr */)) = uintptr(0)
	var pExpert uintptr
	var rc int32 = TCL_OK

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if dbHandleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+40 /* &db */) != 0 {
		return TCL_ERROR
	}

	zCmd = sqlite3.Xsqlite3_mprintf(tls, ts+1914 /* "sqlite3expert%d" */, libc.VaList(bp, libc.PreIncInt32(&iCmd, 1)))
	if zCmd == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+8, ts+1930 /* "out of memory" */, uintptr(0)))
		return TCL_ERROR
	}

	pExpert = sqlite3_expert_new(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* db */)), bp+44 /* &zErr */)
	if pExpert == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(bp + 44 /* zErr */)), uintptr(0)))
		rc = TCL_ERROR
	} else {
		var p uintptr = pExpert
		tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{testExpertCmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testExpertDel})))
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zCmd, -1))
	}

	sqlite3.Xsqlite3_free(tls, zCmd)
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 44 /* zErr */)))
	return rc
}

var iCmd int32 = 0 /* test_expert.c:164:14 */

func TestExpert_Init(tls *libc.TLS, interp uintptr) int32 { /* test_expert.c:202:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*[1]struct {
		FzCmd  uintptr
		FxProc uintptr
	})(unsafe.Pointer(bp /* aCmd */)) = [1]struct {
		FzCmd  uintptr
		FxProc uintptr
	}{
		{FzCmd: ts + 1944 /* "sqlite3_expert_n..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3_expert_new}))},
	}
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof([1]struct {
		FzCmd  uintptr
		FxProc uintptr
	}{})) / uint32(unsafe.Sizeof(struct {
		FzCmd  uintptr
		FxProc uintptr
	}{}))); i++ {
		var p uintptr = (bp /* &aCmd */ + uintptr(i)*8)
		tcl.XTcl_CreateObjCommand(tls, interp, (*struct {
			FzCmd  uintptr
			FxProc uintptr
		})(unsafe.Pointer(p)).FzCmd, (*struct {
			FzCmd  uintptr
			FxProc uintptr
		})(unsafe.Pointer(p)).FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

// 2011 Jan 27
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// This file is not part of the production FTS code. It is only used for
// testing. It contains a virtual table implementation that provides direct
// access to the full-text index of an FTS table.

// 2009 Nov 12
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//

// FTS3/FTS4 require virtual tables

// FTS4 is really an extension for FTS3.  It is enabled using the
// SQLITE_ENABLE_FTS3 macro.  But to avoid confusion we also all
// the SQLITE_ENABLE_FTS4 macro to serve as an alisse for SQLITE_ENABLE_FTS3.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// Decode a pointer to an sqlite3 object.
func f5tDbPointer(tls *libc.TLS, interp uintptr, pObj uintptr, ppDb uintptr) int32 { /* fts5_tcl.c:54:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var p uintptr
	// var cmdInfo Tcl_CmdInfo at bp, 32

	var z uintptr = tcl.XTcl_GetString(tls, pObj)
	if tcl.XTcl_GetCommandInfo(tls, interp, z, bp /* &cmdInfo */) != 0 {
		p = (*Tcl_CmdInfo)(unsafe.Pointer(bp /* &cmdInfo */)).FobjClientData
		*(*uintptr)(unsafe.Pointer(ppDb)) = (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb
		return TCL_OK
	}
	return TCL_ERROR
}

// End of code that accesses the SqliteDb struct.
//

func f5tResultToErrorCode(tls *libc.TLS, zRes uintptr) int32 { /* fts5_tcl.c:69:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*[4]ErrorCode)(unsafe.Pointer(bp /* aErr */)) = [4]ErrorCode{
		{Frc: SQLITE_DONE, FzError: ts + 1963 /* "SQLITE_DONE" */},
		{Frc: SQLITE_ERROR, FzError: ts + 1975 /* "SQLITE_ERROR" */},
		{FzError: ts + 1988 /* "SQLITE_OK" */},
		{FzError: ts + 489 /* "" */},
	}
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof([4]ErrorCode{})) / uint32(unsafe.Sizeof(ErrorCode{}))); i++ {
		if 0 == sqlite3.Xsqlite3_stricmp(tls, zRes, (*ErrorCode)(unsafe.Pointer(bp /* &aErr */ +uintptr(i)*8)).FzError) {
			return (*ErrorCode)(unsafe.Pointer(bp /* &aErr */ + uintptr(i)*8)).Frc
		}
	}

	return SQLITE_ERROR
}

type ErrorCode = struct {
	Frc     int32
	FzError uintptr
} /* fts5_tcl.c:70:3 */

func f5tDbAndApi(tls *libc.TLS, interp uintptr, pObj uintptr, ppDb uintptr, ppApi uintptr) int32 { /* fts5_tcl.c:90:26: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	*(*uintptr)(unsafe.Pointer(bp + 48 /* db */)) = uintptr(0)
	var rc int32 = f5tDbPointer(tls, interp, pObj, bp+48 /* &db */)
	if rc != TCL_OK {
		return TCL_ERROR
	} else {
		*(*uintptr)(unsafe.Pointer(bp + 52 /* pStmt */)) = uintptr(0)
		*(*uintptr)(unsafe.Pointer(bp + 56 /* pApi */)) = uintptr(0)

		rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), ts+1998 /* "SELECT fts5(?1)" */, -1, bp+52 /* &pStmt */, uintptr(0))
		if rc != SQLITE_OK {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2014 /* "error: " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */))), 0))
			return TCL_ERROR
		}
		sqlite3.Xsqlite3_bind_pointer(tls, *(*uintptr)(unsafe.Pointer(bp + 52 /* pStmt */)), 1, bp+56 /* &pApi */, ts+2022 /* "fts5_api_ptr" */, uintptr(0))
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 52 /* pStmt */)))

		if sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 52 /* pStmt */))) != SQLITE_OK {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+2014 /* "error: " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */))), 0))
			return TCL_ERROR
		}

		*(*uintptr)(unsafe.Pointer(ppDb)) = *(*uintptr)(unsafe.Pointer(bp + 48 /* db */))
		*(*uintptr)(unsafe.Pointer(ppApi)) = *(*uintptr)(unsafe.Pointer(bp + 56 /* pApi */))
	}

	return TCL_OK
}

type F5tFunction1 = struct {
	Finterp  uintptr
	FpScript uintptr
} /* fts5_tcl.c:124:9 */

type F5tFunction = F5tFunction1 /* fts5_tcl.c:124:28 */

type F5tApi1 = struct {
	FpApi uintptr
	FpFts uintptr
} /* fts5_tcl.c:130:9 */

type F5tApi = F5tApi1 /* fts5_tcl.c:130:23 */

// An object of this type is used with the xSetAuxdata() and xGetAuxdata()
// API test wrappers. The tcl interface allows a single tcl value to be
// saved using xSetAuxdata(). Instead of simply storing a pointer to the
// tcl object, the code in this file wraps it in an sqlite3_malloc'd
// instance of the following struct so that if the destructor is not
// correctly invoked it will be reported as an SQLite memory leak.
type F5tAuxData1 = struct{ FpObj uintptr } /* fts5_tcl.c:144:9 */

// An object of this type is used with the xSetAuxdata() and xGetAuxdata()
// API test wrappers. The tcl interface allows a single tcl value to be
// saved using xSetAuxdata(). Instead of simply storing a pointer to the
// tcl object, the code in this file wraps it in an sqlite3_malloc'd
// instance of the following struct so that if the destructor is not
// correctly invoked it will be reported as an SQLite memory leak.
type F5tAuxData = F5tAuxData1 /* fts5_tcl.c:144:27 */

func xTokenizeCb(tls *libc.TLS, pCtx uintptr, tflags int32, zToken uintptr, nToken int32, iStart int32, iEnd int32) int32 { /* fts5_tcl.c:149:12: */
	var p uintptr = pCtx
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, (*F5tFunction)(unsafe.Pointer(p)).FpScript)
	var rc int32

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zToken, nToken))
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewIntObj(tls, iStart))
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewIntObj(tls, iEnd))

	rc = tcl.XTcl_EvalObjEx(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if rc == TCL_OK {
		rc = f5tResultToErrorCode(tls, tcl.XTcl_GetStringResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp))
	}

	return rc
}

func xQueryPhraseCb(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr) int32 { /* fts5_tcl.c:175:12: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var p uintptr = pCtx
	var pEval uintptr
	var rc int32
	// var zCmd [64]int8 at bp+8, 64

	// var sApi F5tApi at bp+72, 8

	(*F5tApi)(unsafe.Pointer(bp + 72 /* &sApi */)).FpApi = pApi
	(*F5tApi)(unsafe.Pointer(bp + 72 /* &sApi */)).FpFts = pFts
	libc.Xsprintf(tls, bp+8 /* &zCmd[0] */, ts+2035 /* "f5t_2_%lld" */, libc.VaList(bp, libc.PostIncInt64(&iCmd1, 1)))
	tcl.XTcl_CreateObjCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8 /* &zCmd[0] */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{xF5tApi})), bp+72 /* &sApi */, uintptr(0))

	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tFunction)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, bp+8 /* &zCmd[0] */, -1))
	rc = tcl.XTcl_EvalObjEx(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_DeleteCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8 /* &zCmd[0] */)

	if rc == TCL_OK {
		rc = f5tResultToErrorCode(tls, tcl.XTcl_GetStringResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp))
	}

	return rc
}

var iCmd1 sqlite3_int64 = int64(0) /* fts5_tcl.c:181:24 */

func xSetAuxdataDestructor(tls *libc.TLS, p uintptr) { /* fts5_tcl.c:207:13: */
	var pData uintptr = p
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*F5tAuxData)(unsafe.Pointer(pData)).FpObj
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, pData)
}

//      api sub-command...
//
// Description...
func xF5tApi(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:218:26: */
	bp := tls.Alloc(404)
	defer tls.Free(404)

	*(*[19]Sub)(unsafe.Pointer(bp + 32 /* aSub */)) = [19]Sub{
		{FzName: ts + 2046 /* "xColumnCount" */, FzMsg: ts + 489 /* "" */},                                      //  0
		{FzName: ts + 2059 /* "xRowCount" */, FzMsg: ts + 489 /* "" */},                                         //  1
		{FzName: ts + 2069 /* "xColumnTotalSize" */, FnArg: 1, FzMsg: ts + 2086 /* "COL" */},                    //  2
		{FzName: ts + 2090 /* "xTokenize" */, FnArg: 2, FzMsg: ts + 2100 /* "TEXT SCRIPT" */},                   //  3
		{FzName: ts + 2112 /* "xPhraseCount" */, FzMsg: ts + 489 /* "" */},                                      //  4
		{FzName: ts + 2125 /* "xPhraseSize" */, FnArg: 1, FzMsg: ts + 2137 /* "PHRASE" */},                      //  5
		{FzName: ts + 2144 /* "xInstCount" */, FzMsg: ts + 489 /* "" */},                                        //  6
		{FzName: ts + 2155 /* "xInst" */, FnArg: 1, FzMsg: ts + 2161 /* "IDX" */},                               //  7
		{FzName: ts + 2165 /* "xRowid" */, FzMsg: ts + 489 /* "" */},                                            //  8
		{FzName: ts + 2172 /* "xColumnText" */, FnArg: 1, FzMsg: ts + 2086 /* "COL" */},                         //  9
		{FzName: ts + 2184 /* "xColumnSize" */, FnArg: 1, FzMsg: ts + 2086 /* "COL" */},                         // 10
		{FzName: ts + 2196 /* "xQueryPhrase" */, FnArg: 2, FzMsg: ts + 2209 /* "PHRASE SCRIPT" */},              // 11
		{FzName: ts + 2223 /* "xSetAuxdata" */, FnArg: 1, FzMsg: ts + 2235 /* "VALUE" */},                       // 12
		{FzName: ts + 2241 /* "xGetAuxdata" */, FnArg: 1, FzMsg: ts + 2253 /* "CLEAR" */},                       // 13
		{FzName: ts + 2259 /* "xSetAuxdataInt" */, FnArg: 1, FzMsg: ts + 2274 /* "INTEGER" */},                  // 14
		{FzName: ts + 2282 /* "xGetAuxdataInt" */, FnArg: 1, FzMsg: ts + 2253 /* "CLEAR" */},                    // 15
		{FzName: ts + 2297 /* "xPhraseForeach" */, FnArg: 4, FzMsg: ts + 2312 /* "IPHRASE COLVAR O..." */},      // 16
		{FzName: ts + 2341 /* "xPhraseColumnFor..." */, FnArg: 3, FzMsg: ts + 2362 /* "IPHRASE COLVAR S..." */}, // 17
		{},
	}
	var rc int32
	*(*int32)(unsafe.Pointer(bp + 260 /* iSub */)) = 0
	var p uintptr = clientData

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2384 /* "SUB-COMMAND" */)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+32 /* &aSub[0] */, int32(unsafe.Sizeof(Sub{})), ts+2384 /* "SUB-COMMAND" */, 0, bp+260 /* &iSub */)
	if rc != TCL_OK {
		return rc
	}
	if (*Sub)(unsafe.Pointer(bp+32 /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 260 /* iSub */)))*12)).FnArg != (objc - 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, (*Sub)(unsafe.Pointer(bp+32 /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 260 /* iSub */)))*12)).FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp + 260 /* iSub */)) {
	case 0:
		{
			var nCol int32
			nCol = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 8 /* &.xColumnCount */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nCol))
			}
			break

		}
	case 1:
		{
			// var nRow sqlite3_int64 at bp+264, 8

			rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 12 /* &.xRowCount */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+264 /* &nRow */)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 264 /* nRow */))))
			}
			break

		}
	case 2:
		{
			// var iCol int32 at bp+272, 4

			// var nSize sqlite3_int64 at bp+280, 8

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+272 /* &iCol */) != 0 {
				return TCL_ERROR
			}
			rc = (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 16 /* &.xColumnTotalSize */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 272 /* iCol */)), bp+280 /* &nSize */)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 280 /* nSize */))))
			}
			break

		}
	case 3:
		{
			// var nText int32 at bp+288, 4

			var zText uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+288 /* &nText */)
			// var ctx F5tFunction at bp+292, 8

			(*F5tFunction)(unsafe.Pointer(bp + 292 /* &ctx */)).Finterp = interp
			(*F5tFunction)(unsafe.Pointer(bp + 292 /* &ctx */)).FpScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))
			rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 20 /* &.xTokenize */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, zText, *(*int32)(unsafe.Pointer(bp + 288 /* nText */)), bp+292 /* &ctx */, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
			}{xTokenizeCb})))
			if rc == SQLITE_OK {
				tcl.XTcl_ResetResult(tls, interp)
			}
			return rc

		}
	case 4:
		{
			var nPhrase int32
			nPhrase = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 24 /* &.xPhraseCount */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nPhrase))
			}
			break

		}
	case 5:
		{
			// var iPhrase int32 at bp+300, 4

			var sz int32
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+300 /* &iPhrase */) != 0 {
				return TCL_ERROR
			}
			sz = (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 28 /* &.xPhraseSize */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 300 /* iPhrase */)))
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sz))
			}
			break

		}
	case 6:
		{
			// var nInst int32 at bp+304, 4

			rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 32 /* &.xInstCount */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+304 /* &nInst */)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 304 /* nInst */))))
			}
			break

		}
	case 7:
		{
			// var iIdx int32 at bp+308, 4

			// var ip int32 at bp+312, 4

			// var ic int32 at bp+316, 4

			// var io int32 at bp+320, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+308 /* &iIdx */) != 0 {
				return TCL_ERROR
			}
			rc = (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 36 /* &.xInst */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 308 /* iIdx */)), bp+312 /* &ip */, bp+316 /* &ic */, bp+320 /* &io */)
			if rc == SQLITE_OK {
				var pList uintptr = tcl.XTcl_NewObj(tls)
				tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 312 /* ip */))))
				tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 316 /* ic */))))
				tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 320 /* io */))))
				tcl.XTcl_SetObjResult(tls, interp, pList)
			}
			break

		}
	case 8:
		{
			var iRowid sqlite3_int64 = (*(*func(*libc.TLS, uintptr) sqlite3_int64)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 40 /* &.xRowid */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, iRowid))
			break

		}
	case 9:
		{
			*(*uintptr)(unsafe.Pointer(bp + 328 /* z */)) = uintptr(0)
			*(*int32)(unsafe.Pointer(bp + 332 /* n */)) = 0
			// var iCol int32 at bp+324, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+324 /* &iCol */) != 0 {
				return TCL_ERROR
			}
			rc = (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 44 /* &.xColumnText */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 324 /* iCol */)), bp+328 /* &z */, bp+332 /* &n */)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 328 /* z */)), *(*int32)(unsafe.Pointer(bp + 332 /* n */))))
			}
			break

		}
	case 10:
		{
			*(*int32)(unsafe.Pointer(bp + 340 /* n */)) = 0
			// var iCol int32 at bp+336, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+336 /* &iCol */) != 0 {
				return TCL_ERROR
			}
			rc = (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 48 /* &.xColumnSize */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 336 /* iCol */)), bp+340 /* &n */)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 340 /* n */))))
			}
			break

		}
	case 11:
		{
			// var iPhrase int32 at bp+344, 4

			// var ctx F5tFunction at bp+348, 8

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+344 /* &iPhrase */) != 0 {
				return TCL_ERROR
			}
			(*F5tFunction)(unsafe.Pointer(bp + 348 /* &ctx */)).Finterp = interp
			(*F5tFunction)(unsafe.Pointer(bp + 348 /* &ctx */)).FpScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))
			rc = (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 52 /* &.xQueryPhrase */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 344 /* iPhrase */)), bp+348 /* &ctx */, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{xQueryPhraseCb})))
			if rc == SQLITE_OK {
				tcl.XTcl_ResetResult(tls, interp)
			}
			break

		}
	case 12:
		{
			var pData uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(F5tAuxData{})))
			if pData == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930 /* "out of memory" */, 0))
				return TCL_ERROR
			}
			(*F5tAuxData)(unsafe.Pointer(pData)).FpObj = *(*uintptr)(unsafe.Pointer(objv + 2*4))
			(*Tcl_Obj)(unsafe.Pointer((*F5tAuxData)(unsafe.Pointer(pData)).FpObj)).FrefCount++
			rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 56 /* &.xSetAuxdata */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, pData, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{xSetAuxdataDestructor})))
			break

		}
	case 13:
		{
			var pData uintptr
			// var bClear int32 at bp+356, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+356 /* &bClear */) != 0 {
				return TCL_ERROR
			}
			pData = (*(*func(*libc.TLS, uintptr, int32) uintptr)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 60 /* &.xGetAuxdata */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 356 /* bClear */)))
			if pData == uintptr(0) {
				tcl.XTcl_ResetResult(tls, interp)
			} else {
				tcl.XTcl_SetObjResult(tls, interp, (*F5tAuxData)(unsafe.Pointer(pData)).FpObj)
				if *(*int32)(unsafe.Pointer(bp + 356 /* bClear */)) != 0 {
					xSetAuxdataDestructor(tls, pData)
				}
			}
			break

		}

	// These two - xSetAuxdataInt and xGetAuxdataInt - are similar to the
	// xSetAuxdata and xGetAuxdata methods implemented above. The difference
	// is that they may only save an integer value as auxiliary data, and
	// do not specify a destructor function.
	case 14:
		{
			// var iVal int32 at bp+360, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+360 /* &iVal */) != 0 {
				return TCL_ERROR
			}
			rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 56 /* &.xSetAuxdata */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, (uintptr(0) + uintptr(*(*int32)(unsafe.Pointer(bp + 360 /* iVal */)))), uintptr(0))
			break

		}
	case 15:
		{
			var iVal int32
			// var bClear int32 at bp+364, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+364 /* &bClear */) != 0 {
				return TCL_ERROR
			}
			iVal = ((int32((*(*func(*libc.TLS, uintptr, int32) uintptr)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 60 /* &.xGetAuxdata */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 364 /* bClear */)))) - int32(uintptr(0))) / 1)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iVal))
			break

		}

	case 16:
		{
			// var iPhrase int32 at bp+368, 4

			// var iCol int32 at bp+380, 4

			// var iOff int32 at bp+384, 4

			var zColvar uintptr
			var zOffvar uintptr
			var pScript uintptr = *(*uintptr)(unsafe.Pointer(objv + 5*4))
			// var iter Fts5PhraseIter at bp+372, 8

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+368 /* &iPhrase */) != 0 {
				return TCL_ERROR
			}
			zColvar = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
			zOffvar = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))

			rc = (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 64 /* &.xPhraseFirst */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 368 /* iPhrase */)), bp+372 /* &iter */, bp+380 /* &iCol */, bp+384 /* &iOff */)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, sqlite3.Xsqlite3ErrName(tls, rc), 0))
				return TCL_ERROR
			}
			for ; *(*int32)(unsafe.Pointer(bp + 380 /* iCol */)) >= 0; (*(*func(*libc.TLS, uintptr, uintptr, uintptr, uintptr))(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 68 /* &.xPhraseNext */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+372 /* &iter */, bp+380 /* &iCol */, bp+384 /* &iOff */) {
				tcl.XTcl_SetVar2Ex(tls, interp, zColvar, uintptr(0), tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 380 /* iCol */))), 0)
				tcl.XTcl_SetVar2Ex(tls, interp, zOffvar, uintptr(0), tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 384 /* iOff */))), 0)
				rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
				if rc == TCL_CONTINUE {
					rc = TCL_OK
				}
				if rc != TCL_OK {
					if rc == TCL_BREAK {
						rc = TCL_OK
					}
					break
				}
			}

			break

		}

	case 17:
		{
			// var iPhrase int32 at bp+388, 4

			// var iCol int32 at bp+400, 4

			var zColvar uintptr
			var pScript uintptr = *(*uintptr)(unsafe.Pointer(objv + 4*4))
			// var iter Fts5PhraseIter at bp+392, 8

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+388 /* &iPhrase */) != 0 {
				return TCL_ERROR
			}
			zColvar = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))

			rc = (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 72 /* &.xPhraseFirstColumn */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 388 /* iPhrase */)), bp+392 /* &iter */, bp+400 /* &iCol */)
			if rc != SQLITE_OK {
				tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
				return TCL_ERROR
			}
			for ; *(*int32)(unsafe.Pointer(bp + 400 /* iCol */)) >= 0; (*(*func(*libc.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer(((*F5tApi)(unsafe.Pointer(p)).FpApi + 76 /* &.xPhraseNextColumn */))))(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+392 /* &iter */, bp+400 /* &iCol */) {
				tcl.XTcl_SetVar2Ex(tls, interp, zColvar, uintptr(0), tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 400 /* iCol */))), 0)
				rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
				if rc == TCL_CONTINUE {
					rc = TCL_OK
				}
				if rc != TCL_OK {
					if rc == TCL_BREAK {
						rc = TCL_OK
					}
					break
				}
			}

			break

		}

	default:

		break
	}

	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}

	return TCL_OK
}

type Sub = struct {
	FzName uintptr
	FnArg  int32
	FzMsg  uintptr
} /* fts5_tcl.c:224:3 */

func xF5tFunction(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr, nVal int32, apVal uintptr) { /* fts5_tcl.c:517:13: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var p uintptr = (*(*func(*libc.TLS, uintptr) uintptr)(unsafe.Pointer((pApi + 4 /* &.xUserData */))))(tls, pFts)
	var pEval uintptr // Script to evaluate
	var i int32
	var rc int32
	// var zCmd [64]int8 at bp+8, 64

	// var sApi F5tApi at bp+72, 8

	(*F5tApi)(unsafe.Pointer(bp + 72 /* &sApi */)).FpApi = pApi
	(*F5tApi)(unsafe.Pointer(bp + 72 /* &sApi */)).FpFts = pFts

	libc.Xsprintf(tls, bp+8 /* &zCmd[0] */, ts+2396 /* "f5t_%lld" */, libc.VaList(bp, libc.PostIncInt64(&iCmd2, 1)))
	tcl.XTcl_CreateObjCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8 /* &zCmd[0] */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{xF5tApi})), bp+72 /* &sApi */, uintptr(0))
	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tFunction)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, bp+8 /* &zCmd[0] */, -1))

	for i = 0; i < nVal; i++ {
		var pObj uintptr = uintptr(0)
		switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))) {
		case SQLITE_TEXT:
			pObj = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))), -1)
			break
		case SQLITE_BLOB:
			pObj = tcl.XTcl_NewByteArrayObj(tls,
				sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))), sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))))
			break
		case SQLITE_INTEGER:
			pObj = tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))))
			break
		case SQLITE_FLOAT:
			pObj = tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))))
			break
		default:
			pObj = tcl.XTcl_NewObj(tls)
			break
		}
		tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, pObj)
	}

	rc = tcl.XTcl_EvalObjEx(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, TCL_GLOBAL_ONLY)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_DeleteCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8 /* &zCmd[0] */)

	if rc != TCL_OK {
		sqlite3.Xsqlite3_result_error(tls, pCtx, tcl.XTcl_GetStringResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp), -1)
	} else {
		var pVar uintptr = tcl.XTcl_GetObjResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp)
		// var n int32 at bp+80, 4

		var zType uintptr = func() uintptr {
			if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
				return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
			}
			return ts + 489 /* "" */
		}()
		var c int8 = *(*int8)(unsafe.Pointer(zType))
		if ((int32(c) == 'b') && (libc.Xstrcmp(tls, zType, ts+2405 /* "bytearray" */) == 0)) && ((*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0)) {
			// Only return a BLOB type if the Tcl variable is a bytearray and
			// has no string representation.
			var data uintptr = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+80 /* &n */)
			sqlite3.Xsqlite3_result_blob(tls, pCtx, data, *(*int32)(unsafe.Pointer(bp + 80 /* n */)), libc.UintptrFromInt32(-1))
		} else if (int32(c) == 'b') && (libc.Xstrcmp(tls, zType, ts+2415 /* "boolean" */) == 0) {
			tcl.XTcl_GetIntFromObj(tls, uintptr(0), pVar, bp+80 /* &n */)
			sqlite3.Xsqlite3_result_int(tls, pCtx, *(*int32)(unsafe.Pointer(bp + 80 /* n */)))
		} else if (int32(c) == 'd') && (libc.Xstrcmp(tls, zType, ts+2423 /* "double" */) == 0) {
			// var r float64 at bp+88, 8

			tcl.XTcl_GetDoubleFromObj(tls, uintptr(0), pVar, bp+88 /* &r */)
			sqlite3.Xsqlite3_result_double(tls, pCtx, *(*float64)(unsafe.Pointer(bp + 88 /* r */)))
		} else if ((int32(c) == 'w') && (libc.Xstrcmp(tls, zType, ts+2430 /* "wideInt" */) == 0)) || ((int32(c) == 'i') && (libc.Xstrcmp(tls, zType, ts+2438 /* "int" */) == 0)) {
			// var v Tcl_WideInt at bp+96, 8

			tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), pVar, bp+96 /* &v */)
			sqlite3.Xsqlite3_result_int64(tls, pCtx, *(*Tcl_WideInt)(unsafe.Pointer(bp + 96 /* v */)))
		} else {
			var data uintptr = tcl.XTcl_GetStringFromObj(tls, pVar, bp+80 /* &n */)
			sqlite3.Xsqlite3_result_text(tls, pCtx, data, *(*int32)(unsafe.Pointer(bp + 80 /* n */)), libc.UintptrFromInt32(-1))
		}
	}
}

var iCmd2 sqlite3_int64 = int64(0) /* fts5_tcl.c:529:24 */

func xF5tDestroy(tls *libc.TLS, pCtx uintptr) { /* fts5_tcl.c:600:13: */
	var p uintptr = pCtx
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*F5tFunction)(unsafe.Pointer(p)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, p)
}

//      sqlite3_fts5_create_function DB NAME SCRIPT
//
// Description...
func f5tCreateFunction(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:611:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zName uintptr
	var pScript uintptr
	*(*uintptr)(unsafe.Pointer(bp + 24 /* db */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 28 /* pApi */)) = uintptr(0)
	var pCtx uintptr = uintptr(0)
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2442 /* "DB NAME SCRIPT" */)
		return TCL_ERROR
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+24 /* &db */, bp+28 /* &pApi */) != 0 {
		return TCL_ERROR
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))
	pCtx = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tFunction{})))
	(*F5tFunction)(unsafe.Pointer(pCtx)).Finterp = interp
	(*F5tFunction)(unsafe.Pointer(pCtx)).FpScript = pScript
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++

	rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, fts5_extension_function, uintptr) int32)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(bp + 28 /* pApi */)) + 12 /* &.xCreateFunction */))))(tls,
		*(*uintptr)(unsafe.Pointer(bp + 28 /* pApi */)), zName, pCtx, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr)
		}{xF5tFunction})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{xF5tDestroy})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2014 /* "error: " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */))), 0))
		return TCL_ERROR
	}

	return TCL_OK
}

type F5tTokenizeCtx1 = struct {
	FpRet   uintptr
	FbSubst int32
	FzInput uintptr
} /* fts5_tcl.c:648:9 */

type F5tTokenizeCtx = F5tTokenizeCtx1 /* fts5_tcl.c:648:31 */

func xTokenizeCb2(tls *libc.TLS, pCtx uintptr, tflags int32, zToken uintptr, nToken int32, iStart int32, iEnd int32) int32 { /* fts5_tcl.c:655:12: */
	var p uintptr = pCtx
	if (*F5tTokenizeCtx)(unsafe.Pointer(p)).FbSubst != 0 {
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewStringObj(tls, zToken, nToken))
		tcl.XTcl_ListObjAppendElement(tls,
			uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewStringObj(tls, ((*F5tTokenizeCtx)(unsafe.Pointer(p)).FzInput+uintptr(iStart)), (iEnd-iStart)))
	} else {
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewStringObj(tls, zToken, nToken))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewIntObj(tls, iStart))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewIntObj(tls, iEnd))
	}
	return SQLITE_OK
}

//      sqlite3_fts5_tokenize DB TOKENIZER TEXT
//
// Description...
func f5tTokenize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:681:26: */
	bp := tls.Alloc(148)
	defer tls.Free(148)

	var zText uintptr
	// var nText int32 at bp+112, 4

	*(*uintptr)(unsafe.Pointer(bp + 96 /* db */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 100 /* pApi */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 132 /* pTok */)) = uintptr(0)
	// var tokenizer fts5_tokenizer at bp+120, 12

	var pRet uintptr = uintptr(0)
	// var pUserdata uintptr at bp+116, 4

	var rc int32
	// var nArg int32 at bp+104, 4

	// var azArg uintptr at bp+108, 4

	// var ctx F5tTokenizeCtx at bp+136, 12

	if (objc != 4) && (objc != 5) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2457 /* "?-subst? DB NAME..." */)
		return TCL_ERROR
	}
	if objc == 5 {
		var zOpt uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
		if libc.Xstrcmp(tls, ts+2479 /* "-subst" */, zOpt) != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2486 /* "unrecognized opt..." */, zOpt, 0))
			return TCL_ERROR
		}
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-3))*4)), bp+96 /* &db */, bp+100 /* &pApi */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_SplitList(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-2))*4))), bp+104 /* &nArg */, bp+108 /* &azArg */) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 104 /* nArg */)) == 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+2508 /* "no such tokenize..." */, 0))
		tcl.XTcl_Free(tls, *(*uintptr)(unsafe.Pointer(bp + 108 /* azArg */)))
		return TCL_ERROR
	}
	zText = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*4)), bp+112 /* &nText */)

	rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(bp + 100 /* pApi */)) + 8 /* &.xFindTokenizer */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 100 /* pApi */)), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 108 /* azArg */)))), bp+116 /* &pUserdata */, bp+120 /* &tokenizer */)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+2508 /* "no such tokenize..." */, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 108 /* azArg */)))), 0))
		return TCL_ERROR
	}

	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((bp + 120 /* &tokenizer */ /* &.xCreate */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 116 /* pUserdata */)), (*(*uintptr)(unsafe.Pointer(bp + 108 /* azArg */)) + 1*4), (*(*int32)(unsafe.Pointer(bp + 104 /* nArg */)) - 1), bp+132 /* &pTok */)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, ts+2528 /* "error in tokeniz..." */, 0))
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
	(*F5tTokenizeCtx)(unsafe.Pointer(bp + 136 /* &ctx */)).FbSubst = (libc.Bool32(objc == 5))
	(*F5tTokenizeCtx)(unsafe.Pointer(bp + 136 /* &ctx */)).FpRet = pRet
	(*F5tTokenizeCtx)(unsafe.Pointer(bp + 136 /* &ctx */)).FzInput = zText
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((bp + 120 /* &tokenizer */ + 8 /* &.xTokenize */))))(tls,
		*(*uintptr)(unsafe.Pointer(bp + 132 /* pTok */)), bp+136 /* &ctx */, FTS5_TOKENIZE_DOCUMENT, zText, *(*int32)(unsafe.Pointer(bp + 112 /* nText */)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
		}{xTokenizeCb2})))
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((bp + 120 /* &tokenizer */ + 4 /* &.xDelete */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 132 /* pTok */)))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+80, ts+2557 /* "error in tokeniz..." */, 0))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pRet
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		return TCL_ERROR
	}

	tcl.XTcl_Free(tls, *(*uintptr)(unsafe.Pointer(bp + 108 /* azArg */)))
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pRet
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return TCL_OK
}

// ************************************************************************
//
// Start of tokenizer wrapper.

type F5tTokenizerContext1 = struct {
	FpCtx   uintptr
	FxToken uintptr
} /* fts5_tcl.c:761:9 */

// ************************************************************************
//
// Start of tokenizer wrapper.

type F5tTokenizerContext = F5tTokenizerContext1 /* fts5_tcl.c:761:36 */
type F5tTokenizerModule1 = struct {
	Finterp   uintptr
	FpScript  uintptr
	FpContext uintptr
} /* fts5_tcl.c:763:9 */

type F5tTokenizerModule = F5tTokenizerModule1 /* fts5_tcl.c:763:35 */
type F5tTokenizerInstance1 = struct {
	Finterp   uintptr
	FpScript  uintptr
	FpContext uintptr
} /* fts5_tcl.c:764:9 */

type F5tTokenizerInstance = F5tTokenizerInstance1 /* fts5_tcl.c:764:37 */

func f5tTokenizerCreate(tls *libc.TLS, pCtx uintptr, azArg uintptr, nArg int32, ppOut uintptr) int32 { /* fts5_tcl.c:783:12: */
	var pMod uintptr = pCtx
	var pEval uintptr
	var rc int32 = TCL_OK
	var i int32

	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	for i = 0; (rc == TCL_OK) && (i < nArg); i++ {
		var pObj uintptr = tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4)), -1)
		rc = tcl.XTcl_ListObjAppendElement(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp, pEval, pObj)
	}

	if rc == TCL_OK {
		rc = tcl.XTcl_EvalObjEx(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp, pEval, TCL_GLOBAL_ONLY)
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	if rc == TCL_OK {
		var pInst uintptr
		pInst = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tTokenizerInstance{})))
		libc.Xmemset(tls, pInst, 0, uint32(unsafe.Sizeof(F5tTokenizerInstance{})))
		(*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp = (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp
		(*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript = tcl.XTcl_GetObjResult(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp)
		(*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext = (*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpContext
		(*Tcl_Obj)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript)).FrefCount++
		*(*uintptr)(unsafe.Pointer(ppOut)) = pInst
	}

	return rc
}

func f5tTokenizerDelete(tls *libc.TLS, p uintptr) { /* fts5_tcl.c:821:13: */
	var pInst uintptr = p
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, pInst)
}

func f5tTokenizerTokenize(tls *libc.TLS, p uintptr, pCtx uintptr, flags int32, pText uintptr, nText int32, xToken uintptr) int32 { /* fts5_tcl.c:827:12: */
	var pInst uintptr = p
	var pOldCtx uintptr
	var xOldToken uintptr
	var pEval uintptr
	var rc int32
	var zFlags uintptr

	pOldCtx = (*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FpCtx
	xOldToken = (*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FxToken

	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FpCtx = pCtx
	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FxToken = xToken

	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	switch flags {
	case FTS5_TOKENIZE_DOCUMENT:
		zFlags = ts + 2588 /* "document" */
		break
	case FTS5_TOKENIZE_AUX:
		zFlags = ts + 2597 /* "aux" */
		break
	case FTS5_TOKENIZE_QUERY:
		zFlags = ts + 2601 /* "query" */
		break
	case (FTS5_TOKENIZE_PREFIX | FTS5_TOKENIZE_QUERY):
		zFlags = ts + 2607 /* "prefixquery" */
		break
	default:

		zFlags = ts + 2619 /* "invalid" */
		break
	}

	tcl.XTcl_ListObjAppendElement(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zFlags, -1))
	tcl.XTcl_ListObjAppendElement(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, pText, nText))
	rc = tcl.XTcl_EvalObjEx(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp, pEval, TCL_GLOBAL_ONLY)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FpCtx = pOldCtx
	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FxToken = xOldToken
	return rc
}

// sqlite3_fts5_token ?-colocated? TEXT START END
func f5tTokenizerReturn(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:887:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var p uintptr
	// var iStart int32 at bp+24, 4

	// var iEnd int32 at bp+28, 4

	// var nToken int32 at bp+20, 4

	var tflags int32
	var zToken uintptr
	var rc int32
	// var nArg int32 at bp+16, 4

	var zArg uintptr
	p = clientData
	tflags = 0

	if !(objc == 5) {
		goto __1
	}
	zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16 /* &nArg */)
	if !(((*(*int32)(unsafe.Pointer(bp + 16 /* nArg */)) <= 10) && (*(*int32)(unsafe.Pointer(bp + 16 /* nArg */)) >= 2)) && (libc.Xmemcmp(tls, ts+2627 /* "-colocated" */, zArg, uint32(*(*int32)(unsafe.Pointer(bp + 16 /* nArg */)))) == 0)) {
		goto __3
	}
	tflags = tflags | (FTS5_TOKEN_COLOCATED)
	goto __4
__3:
	goto usage
__4:
	;
	goto __2
__1:
	if !(objc != 4) {
		goto __5
	}
	goto usage
__5:
	;
__2:
	;

	zToken = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-3))*4)), bp+20 /* &nToken */)
	if !((tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-2))*4)), bp+24 /* &iStart */) != 0) ||
		(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*4)), bp+28 /* &iEnd */) != 0)) {
		goto __6
	}
	return TCL_ERROR
__6:
	;

	if !((*F5tTokenizerContext)(unsafe.Pointer(p)).FxToken == uintptr(0)) {
		goto __7
	}
	tcl.XTcl_AppendResult(tls, interp,
		libc.VaList(bp, ts+2638 /* "sqlite3_fts5_tok..." */, 0))
	return TCL_ERROR
__7:
	;

	rc = (*(*func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32)(unsafe.Pointer((p + 4 /* &.xToken */))))(tls, (*F5tTokenizerContext)(unsafe.Pointer(p)).FpCtx, tflags, zToken, *(*int32)(unsafe.Pointer(bp + 20 /* nToken */)), *(*int32)(unsafe.Pointer(bp + 24 /* iStart */)), *(*int32)(unsafe.Pointer(bp + 28 /* iEnd */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	if rc == SQLITE_OK {
		return TCL_OK
	}
	return TCL_ERROR

usage:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2696 /* "?-colocated? TEX..." */)
	return TCL_ERROR
}

func f5tDelTokenizer(tls *libc.TLS, pCtx uintptr) { /* fts5_tcl.c:936:13: */
	var pMod uintptr = pCtx
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, pMod)
}

//      sqlite3_fts5_create_tokenizer DB NAME SCRIPT
//
// Register a tokenizer named NAME implemented by script SCRIPT. When
// a tokenizer instance is created (fts5_tokenizer.xCreate), any tokenizer
// arguments are appended to SCRIPT and the result executed.
//
// The value returned by (SCRIPT + args) is itself a tcl script. This
// script - call it SCRIPT2 - is executed to tokenize text using the
// tokenizer instance "returned" by SCRIPT. Specifically, to tokenize
// text SCRIPT2 is invoked with a single argument appended to it - the
// text to tokenize.
//
// SCRIPT2 should invoke the [sqlite3_fts5_token] command once for each
// token within the tokenized text.
func f5tCreateTokenizer(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:958:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var pContext uintptr = clientData
	// var db uintptr at bp+16, 4

	// var pApi uintptr at bp+20, 4

	var zName uintptr
	var pScript uintptr
	// var t fts5_tokenizer at bp+24, 12

	var pMod uintptr
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2442 /* "DB NAME SCRIPT" */)
		return TCL_ERROR
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16 /* &db */, bp+20 /* &pApi */) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))

	(*fts5_tokenizer)(unsafe.Pointer(bp + 24 /* &t */)).FxCreate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{f5tTokenizerCreate}))
	(*fts5_tokenizer)(unsafe.Pointer(bp + 24 /* &t */)).FxTokenize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	}{f5tTokenizerTokenize}))
	(*fts5_tokenizer)(unsafe.Pointer(bp + 24 /* &t */)).FxDelete = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{f5tTokenizerDelete}))

	pMod = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tTokenizerModule{})))
	(*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp = interp
	(*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpScript = pScript
	(*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpContext = pContext
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(bp + 20 /* pApi */)) + 4 /* &.xCreateTokenizer */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pApi */)), zName, pMod, bp+24 /* &t */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{f5tDelTokenizer})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2724 /* "error in fts5_ap..." */, 0))
		return TCL_ERROR
	}

	return TCL_OK
}

func xF5tFree(tls *libc.TLS, clientData ClientData) { /* fts5_tcl.c:1001:27: */
	tcl.XTcl_Free(tls, clientData)
}

//      sqlite3_fts5_may_be_corrupt BOOLEAN
//
// Set or clear the global "may-be-corrupt" flag. Return the old value.
func f5tMayBeCorrupt(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:1010:26: */
	return TCL_OK
}

func f5t_fts5HashKey(tls *libc.TLS, nSlot int32, p uintptr, n int32) uint32 { /* fts5_tcl.c:1035:21: */
	var i int32
	var h uint32 = uint32(13)
	for i = (n - 1); i >= 0; i-- {
		h = (((h << 3) ^ h) ^ uint32(*(*int8)(unsafe.Pointer(p + uintptr(i)))))
	}
	return (h % uint32(nSlot))
}

func f5tTokenHash(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:1044:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	// var n int32 at bp+4, 4

	var iVal uint32
	// var nSlot int32 at bp, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2761 /* "NSLOT TOKEN" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &nSlot */) != 0 {
		return TCL_ERROR
	}
	z = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &n */)

	iVal = f5t_fts5HashKey(tls, *(*int32)(unsafe.Pointer(bp /* nSlot */)), z, *(*int32)(unsafe.Pointer(bp + 4 /* n */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(iVal)))
	return TCL_OK
}

func f5tRegisterMatchinfo(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:1069:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp /* db */)) = uintptr(0)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if f5tDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &db */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3Fts5TestRegisterMatchinfo(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

func f5tRegisterTok(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:1094:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp /* db */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 4 /* pApi */)) = uintptr(0)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &db */, bp+4 /* &pApi */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3Fts5TestRegisterTok(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*uintptr)(unsafe.Pointer(bp + 4 /* pApi */)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

// Entry point.
func Fts5tcl_Init(tls *libc.TLS, interp uintptr) int32 { /* fts5_tcl.c:1123:5: */
	var i int32
	var pContext uintptr

	pContext = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tTokenizerContext{})))
	libc.Xmemset(tls, pContext, 0, uint32(unsafe.Sizeof(F5tTokenizerContext{})))

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aCmd)) / uint32(unsafe.Sizeof(struct {
		FzName        uintptr
		FxProc        uintptr
		FbTokenizeCtx int32
	}{}))); i++ {
		var p uintptr = (uintptr(unsafe.Pointer(&aCmd)) + uintptr(i)*12)
		var pCtx uintptr = uintptr(0)
		if (*struct {
			FzName        uintptr
			FxProc        uintptr
			FbTokenizeCtx int32
		})(unsafe.Pointer(p)).FbTokenizeCtx != 0 {
			pCtx = pContext
		}
		tcl.XTcl_CreateObjCommand(tls, interp, (*struct {
			FzName        uintptr
			FxProc        uintptr
			FbTokenizeCtx int32
		})(unsafe.Pointer(p)).FzName, (*struct {
			FzName        uintptr
			FxProc        uintptr
			FbTokenizeCtx int32
		})(unsafe.Pointer(p)).FxProc, pCtx, func() uintptr {
			if i != 0 {
				return uintptr(0)
			}
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{xF5tFree}))
		}())
	}

	return TCL_OK
}

var aCmd = [8]struct {
	FzName        uintptr
	FxProc        uintptr
	FbTokenizeCtx int32
}{
	{FzName: ts + 2773 /* "sqlite3_fts5_cre..." */, FxProc: 0, FbTokenizeCtx: 1},
	{FzName: ts + 2803 /* "sqlite3_fts5_tok..." */, FxProc: 0, FbTokenizeCtx: 1},
	{FzName: ts + 2822 /* "sqlite3_fts5_tok..." */, FxProc: 0},
	{FzName: ts + 2844 /* "sqlite3_fts5_cre..." */, FxProc: 0},
	{FzName: ts + 2873 /* "sqlite3_fts5_may..." */, FxProc: 0},
	{FzName: ts + 2901 /* "sqlite3_fts5_tok..." */, FxProc: 0},
	{FzName: ts + 2925 /* "sqlite3_fts5_reg..." */, FxProc: 0},
	{FzName: ts + 2957 /* "sqlite3_fts5_reg..." */, FxProc: 0},
} /* fts5_tcl.c:1128:5 */

type Fts5MatchinfoCtx1 = struct {
	FnCol    int32
	FnPhrase int32
	FzArg    uintptr
	FnRet    int32
	FaRet    uintptr
} /* fts5_test_mi.c:50:9 */

type Fts5MatchinfoCtx = Fts5MatchinfoCtx1 /* fts5_test_mi.c:50:33 */

type u32 = uint32 /* fts5_test_mi.c:53:22 */

// Return a pointer to the fts5_api pointer for database connection db.
// If an error occurs, return NULL and leave an error in the database
// handle (accessible using sqlite3_errcode()/errmsg()).
func fts5_api_from_db(tls *libc.TLS, db uintptr, ppApi uintptr) int32 { /* fts5_test_mi.c:71:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0)
	var rc int32

	*(*uintptr)(unsafe.Pointer(ppApi)) = uintptr(0)
	rc = sqlite3.Xsqlite3_prepare(tls, db, ts+1998 /* "SELECT fts5(?1)" */, -1, bp /* &pStmt */, uintptr(0))
	if rc == SQLITE_OK {
		sqlite3.Xsqlite3_bind_pointer(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 1, ppApi, ts+2022 /* "fts5_api_ptr" */, uintptr(0))
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
		rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
	}

	return rc
}

// Argument f should be a flag accepted by matchinfo() (a valid character
// in the string passed as the second argument). If it is not, -1 is
// returned. Otherwise, if f is a valid matchinfo flag, the value returned
// is the number of 32-bit integers added to the output array if the
// table has nCol columns and the query nPhrase phrases.
func fts5MatchinfoFlagsize(tls *libc.TLS, nCol int32, nPhrase int32, f int8) int32 { /* fts5_test_mi.c:94:12: */
	var ret int32 = -1
	switch int32(f) {
	case 'p':
		ret = 1
		break
	case 'c':
		ret = 1
		break
	case 'x':
		ret = ((3 * nCol) * nPhrase)
		break
	case 'y':
		ret = (nCol * nPhrase)
		break
	case 'b':
		ret = (((nCol + 31) / 32) * nPhrase)
		break
	case 'n':
		ret = 1
		break
	case 'a':
		ret = nCol
		break
	case 'l':
		ret = nCol
		break
	case 's':
		ret = nCol
		break
	}
	return ret
}

func fts5MatchinfoIter(tls *libc.TLS, pApi uintptr, pFts uintptr, p uintptr, x uintptr) int32 { /* fts5_test_mi.c:110:12: */
	var i int32
	var n int32 = 0
	var rc int32 = SQLITE_OK
	var f int8
	for i = 0; libc.AssignInt8(&f, *(*int8)(unsafe.Pointer((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg + uintptr(i)))) != 0; i++ {
		rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int8, uintptr) int32)(unsafe.Pointer(&x)))(tls, pApi, pFts, p, f, ((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet + uintptr(n)*4))
		if rc != SQLITE_OK {
			break
		}
		n = n + (fts5MatchinfoFlagsize(tls, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase, f))
	}
	return rc
}

func fts5MatchinfoXCb(tls *libc.TLS, pApi uintptr, pFts uintptr, pUserData uintptr) int32 { /* fts5_test_mi.c:128:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var iter Fts5PhraseIter at bp, 8

	// var iCol int32 at bp+8, 4

	// var iOff int32 at bp+12, 4

	var aOut uintptr = pUserData
	var iPrev int32 = -1

	for (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 64 /* &.xPhraseFirst */))))(tls, pFts, 0, bp /* &iter */, bp+8 /* &iCol */, bp+12 /* &iOff */); *(*int32)(unsafe.Pointer(bp + 8 /* iCol */)) >= 0; (*(*func(*libc.TLS, uintptr, uintptr, uintptr, uintptr))(unsafe.Pointer((pApi + 68 /* &.xPhraseNext */))))(tls, pFts, bp /* &iter */, bp+8 /* &iCol */, bp+12 /* &iOff */) {
		*(*u32)(unsafe.Pointer(aOut + uintptr(((*(*int32)(unsafe.Pointer(bp + 8 /* iCol */))*3)+1))*4))++
		if *(*int32)(unsafe.Pointer(bp + 8 /* iCol */)) != iPrev {
			*(*u32)(unsafe.Pointer(aOut + uintptr(((*(*int32)(unsafe.Pointer(bp + 8 /* iCol */))*3)+2))*4))++
		}
		iPrev = *(*int32)(unsafe.Pointer(bp + 8 /* iCol */))
	}

	return SQLITE_OK
}

func fts5MatchinfoGlobalCb(tls *libc.TLS, pApi uintptr, pFts uintptr, p uintptr, f int8, aOut uintptr) int32 { /* fts5_test_mi.c:150:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	switch int32(f) {
	case 'p':
		*(*u32)(unsafe.Pointer(aOut)) = u32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase)
		break

	case 'c':
		*(*u32)(unsafe.Pointer(aOut)) = u32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol)
		break

	case 'x':
		{
			var i int32
			for i = 0; (i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase) && (rc == SQLITE_OK); i++ {
				var pPtr uintptr = (aOut + uintptr(((i*(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol)*3))*4)
				rc = (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 52 /* &.xQueryPhrase */))))(tls, pFts, i, pPtr, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr) int32
				}{fts5MatchinfoXCb})))
			}
			break

		}

	case 'n':
		{
			// var nRow sqlite3_int64 at bp, 8

			rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 12 /* &.xRowCount */))))(tls, pFts, bp /* &nRow */)
			*(*u32)(unsafe.Pointer(aOut)) = u32(*(*sqlite3_int64)(unsafe.Pointer(bp /* nRow */)))
			break

		}

	case 'a':
		{
			*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* nRow */)) = int64(0)
			rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 12 /* &.xRowCount */))))(tls, pFts, bp+8 /* &nRow */)
			if *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* nRow */)) == int64(0) {
				libc.Xmemset(tls, aOut, 0, (uint32(unsafe.Sizeof(u32(0))) * uint32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol)))
			} else {
				var i int32
				for i = 0; (rc == SQLITE_OK) && (i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol); i++ {
					// var nToken sqlite3_int64 at bp+16, 8

					rc = (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((pApi + 16 /* &.xColumnTotalSize */))))(tls, pFts, i, bp+16 /* &nToken */)
					if rc == SQLITE_OK {
						*(*u32)(unsafe.Pointer(aOut + uintptr(i)*4)) = (u32(((int64(2) * *(*sqlite3_int64)(unsafe.Pointer(bp + 16 /* nToken */))) + *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* nRow */))) / (int64(2) * *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* nRow */)))))
					}
				}
			}
			break

		}

	}
	return rc
}

func fts5MatchinfoLocalCb(tls *libc.TLS, pApi uintptr, pFts uintptr, p uintptr, f int8, aOut uintptr) int32 { /* fts5_test_mi.c:205:12: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var i int32
	var rc int32 = SQLITE_OK

	switch int32(f) {
	case 'b':
		{
			var iPhrase int32
			var nInt int32 = ((((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol + 31) / 32) * (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase)
			for i = 0; i < nInt; i++ {
				*(*u32)(unsafe.Pointer(aOut + uintptr(i)*4)) = u32(0)
			}

			for iPhrase = 0; iPhrase < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase; iPhrase++ {
				// var iter Fts5PhraseIter at bp, 8

				// var iCol int32 at bp+8, 4

				for (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 72 /* &.xPhraseFirstColumn */))))(tls, pFts, iPhrase, bp /* &iter */, bp+8 /* &iCol */); *(*int32)(unsafe.Pointer(bp + 8 /* iCol */)) >= 0; (*(*func(*libc.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((pApi + 76 /* &.xPhraseNextColumn */))))(tls, pFts, bp /* &iter */, bp+8 /* &iCol */) {
					*(*u32)(unsafe.Pointer(aOut + uintptr(((iPhrase*(((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol+31)/32))+(*(*int32)(unsafe.Pointer(bp + 8 /* iCol */))/32)))*4)) |= (u32(u32(1)) << (*(*int32)(unsafe.Pointer(bp + 8 /* iCol */)) % 32))
				}
			}

			break

		}

	case 'x':
		fallthrough
	case 'y':
		{
			var nMul int32 = func() int32 {
				if int32(f) == 'x' {
					return 3
				}
				return 1
			}()
			var iPhrase int32

			for i = 0; i < ((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol * (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase); i++ {
				*(*u32)(unsafe.Pointer(aOut + uintptr((i*nMul))*4)) = u32(0)
			}

			for iPhrase = 0; iPhrase < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase; iPhrase++ {
				// var iter Fts5PhraseIter at bp+12, 8

				// var iOff int32 at bp+24, 4

				// var iCol int32 at bp+20, 4

				for (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 64 /* &.xPhraseFirst */))))(tls, pFts, iPhrase, bp+12 /* &iter */, bp+20 /* &iCol */, bp+24 /* &iOff */); *(*int32)(unsafe.Pointer(bp + 24 /* iOff */)) >= 0; (*(*func(*libc.TLS, uintptr, uintptr, uintptr, uintptr))(unsafe.Pointer((pApi + 68 /* &.xPhraseNext */))))(tls, pFts, bp+12 /* &iter */, bp+20 /* &iCol */, bp+24 /* &iOff */) {
					*(*u32)(unsafe.Pointer(aOut + uintptr((nMul*(*(*int32)(unsafe.Pointer(bp + 20 /* iCol */))+(iPhrase*(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol))))*4))++
				}
			}

			break

		}

	case 'l':
		{
			for i = 0; (rc == SQLITE_OK) && (i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol); i++ {
				// var nToken int32 at bp+28, 4

				rc = (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((pApi + 48 /* &.xColumnSize */))))(tls, pFts, i, bp+28 /* &nToken */)
				*(*u32)(unsafe.Pointer(aOut + uintptr(i)*4)) = u32(*(*int32)(unsafe.Pointer(bp + 28 /* nToken */)))
			}
			break

		}

	case 's':
		{
			// var nInst int32 at bp+32, 4

			libc.Xmemset(tls, aOut, 0, (uint32(unsafe.Sizeof(u32(0))) * uint32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol)))

			rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 32 /* &.xInstCount */))))(tls, pFts, bp+32 /* &nInst */)
			for i = 0; (rc == SQLITE_OK) && (i < *(*int32)(unsafe.Pointer(bp + 32 /* nInst */))); i++ {
				// var iPhrase int32 at bp+36, 4

				// var iOff int32 at bp+44, 4

				*(*int32)(unsafe.Pointer(bp + 40 /* iCol */)) = 0
				var iNextPhrase int32
				var iNextOff int32
				var nSeq u32 = u32(1)
				var j int32

				rc = (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 36 /* &.xInst */))))(tls, pFts, i, bp+36 /* &iPhrase */, bp+40 /* &iCol */, bp+44 /* &iOff */)
				iNextPhrase = (*(*int32)(unsafe.Pointer(bp + 36 /* iPhrase */)) + 1)
				iNextOff = (*(*int32)(unsafe.Pointer(bp + 44 /* iOff */)) + (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer((pApi + 28 /* &.xPhraseSize */))))(tls, pFts, 0))
				for j = (i + 1); (rc == SQLITE_OK) && (j < *(*int32)(unsafe.Pointer(bp + 32 /* nInst */))); j++ {
					// var ip int32 at bp+48, 4

					// var ic int32 at bp+52, 4

					// var io int32 at bp+56, 4

					rc = (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 36 /* &.xInst */))))(tls, pFts, j, bp+48 /* &ip */, bp+52 /* &ic */, bp+56 /* &io */)
					if (*(*int32)(unsafe.Pointer(bp + 52 /* ic */)) != *(*int32)(unsafe.Pointer(bp + 40 /* iCol */))) || (*(*int32)(unsafe.Pointer(bp + 56 /* io */)) > iNextOff) {
						break
					}
					if (*(*int32)(unsafe.Pointer(bp + 48 /* ip */)) == iNextPhrase) && (*(*int32)(unsafe.Pointer(bp + 56 /* io */)) == iNextOff) {
						nSeq++
						iNextPhrase = (*(*int32)(unsafe.Pointer(bp + 48 /* ip */)) + 1)
						iNextOff = (*(*int32)(unsafe.Pointer(bp + 56 /* io */)) + (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer((pApi + 28 /* &.xPhraseSize */))))(tls, pFts, *(*int32)(unsafe.Pointer(bp + 48 /* ip */))))
					}
				}

				if nSeq > *(*u32)(unsafe.Pointer(aOut + uintptr(*(*int32)(unsafe.Pointer(bp + 40 /* iCol */)))*4)) {
					*(*u32)(unsafe.Pointer(aOut + uintptr(*(*int32)(unsafe.Pointer(bp + 40 /* iCol */)))*4)) = nSeq
				}
			}

			break

		}
	}
	return rc
}

func fts5MatchinfoNew(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr, zArg uintptr) uintptr { /* fts5_test_mi.c:301:25: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var nCol int32
	var nPhrase int32
	var i int32
	var nInt int32
	var nByte sqlite3_int64
	var rc int32

	nCol = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((pApi + 8 /* &.xColumnCount */))))(tls, pFts)
	nPhrase = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((pApi + 24 /* &.xPhraseCount */))))(tls, pFts)

	nInt = 0
	for i = 0; *(*int8)(unsafe.Pointer(zArg + uintptr(i))) != 0; i++ {
		var n int32 = fts5MatchinfoFlagsize(tls, nCol, nPhrase, *(*int8)(unsafe.Pointer(zArg + uintptr(i))))
		if n < 0 {
			var zErr uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+2992 /* "unrecognized mat..." */, libc.VaList(bp, int32(*(*int8)(unsafe.Pointer(zArg + uintptr(i))))))
			sqlite3.Xsqlite3_result_error(tls, pCtx, zErr, -1)
			sqlite3.Xsqlite3_free(tls, zErr)
			return uintptr(0)
		}
		nInt = nInt + (n)
	}

	nByte = (sqlite3_int64((uint32(unsafe.Sizeof(Fts5MatchinfoCtx{})) + // The struct itself
		(uint32(unsafe.Sizeof(u32(0))) * uint32(nInt))) + // The p->aRet[] array
		(uint32(i + 1)))) // The p->zArg string
	p = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
	if p == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		return uintptr(0)
	}
	libc.Xmemset(tls, p, 0, uint32(nByte))

	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol = nCol
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase = nPhrase
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet = (p + 1*20)
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnRet = nInt
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg = ((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet + uintptr(nInt)*4)
	libc.Xmemcpy(tls, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg, zArg, uint32(i))

	rc = fts5MatchinfoIter(tls, pApi, pFts, p, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int8, uintptr) int32
	}{fts5MatchinfoGlobalCb})))
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
		sqlite3.Xsqlite3_free(tls, p)
		p = uintptr(0)
	}

	return p
}

func fts5MatchinfoFunc(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr, nVal int32, apVal uintptr) { /* fts5_test_mi.c:357:13: */
	var zArg uintptr
	var p uintptr
	var rc int32 = SQLITE_OK

	if nVal > 0 {
		zArg = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	} else {
		zArg = ts + 3024 /* "pcx" */
	}

	p = (*(*func(*libc.TLS, uintptr, int32) uintptr)(unsafe.Pointer((pApi + 60 /* &.xGetAuxdata */))))(tls, pFts, 0)
	if (p == uintptr(0)) || (sqlite3.Xsqlite3_stricmp(tls, zArg, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg) != 0) {
		p = fts5MatchinfoNew(tls, pApi, pFts, pCtx, zArg)
		if p == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 56 /* &.xSetAuxdata */))))(tls, pFts, p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		}
	}

	if rc == SQLITE_OK {
		rc = fts5MatchinfoIter(tls, pApi, pFts, p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int8, uintptr) int32
		}{fts5MatchinfoLocalCb})))
	}
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
	} else {
		// No errors has occured, so return a copy of the array of integers.
		var nByte int32 = (int32(uint32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnRet) * uint32(unsafe.Sizeof(u32(0)))))
		sqlite3.Xsqlite3_result_blob(tls, pCtx, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet, nByte, libc.UintptrFromInt32(-1))
	}
}

func sqlite3Fts5TestRegisterMatchinfo(tls *libc.TLS, db uintptr) int32 { /* fts5_test_mi.c:396:5: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32 // Return code
	// var pApi uintptr at bp, 4
	// FTS5 API functions

	// Extract the FTS5 API pointer from the database handle. The
	// fts5_api_from_db() function above is copied verbatim from the
	// FTS5 documentation. Refer there for details.
	rc = fts5_api_from_db(tls, db, bp /* &pApi */)
	if rc != SQLITE_OK {
		return rc
	}

	/* If fts5_api_from_db() returns NULL, then either FTS5 is not registered
	 ** with this database handle, or an error (OOM perhaps?) has occurred.
	 **
	 ** Also check that the fts5_api object is version 2 or newer.
	 */
	if (*(*uintptr)(unsafe.Pointer(bp /* pApi */)) == uintptr(0)) || ((*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* pApi */)))).FiVersion < 2) {
		return SQLITE_ERROR
	}

	// Register the implementation of matchinfo()
	rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, fts5_extension_function, uintptr) int32)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(bp /* pApi */)) + 12 /* &.xCreateFunction */))))(tls, *(*uintptr)(unsafe.Pointer(bp /* pApi */)), ts+3028 /* "matchinfo" */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr)
	}{fts5MatchinfoFunc})), uintptr(0))

	return rc
}

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

type Fts5tokTable1 = struct {
	Fbase sqlite3_vtab
	Ftok  fts5_tokenizer
	FpTok uintptr
} /* fts5_test_tok.c:47:9 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

type Fts5tokTable = Fts5tokTable1 /* fts5_test_tok.c:47:29 */
type Fts5tokCursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FiRowid int32
	FzInput uintptr
	FnRow   int32
	FaRow   uintptr
} /* fts5_test_tok.c:48:9 */

type Fts5tokCursor = Fts5tokCursor1 /* fts5_test_tok.c:48:30 */
type Fts5tokRow1 = struct {
	FzToken uintptr
	FiStart int32
	FiEnd   int32
	FiPos   int32
} /* fts5_test_tok.c:48:9 */

type Fts5tokRow = Fts5tokRow1 /* fts5_test_tok.c:49:27 */

func fts5tokDequote(tls *libc.TLS, z uintptr) { /* fts5_test_tok.c:81:13: */
	var q int8 = *(*int8)(unsafe.Pointer(z))

	if (((int32(q) == '[') || (int32(q) == '\'')) || (int32(q) == '"')) || (int32(q) == '`') {
		var iIn int32 = 1
		var iOut int32 = 0
		if int32(q) == '[' {
			q = int8(']')
		}

		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr((iIn + 1))))) != int32(q) {
					// Character iIn was the close quote.
					iIn++
					break
				} else {
					// Character iIn and iIn+1 form an escaped quote character. Skip
					// the input cursor past both and copy a single quote character
					// to the output buffer.
					iIn = iIn + (2)
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = q
				}
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
			}
		}

		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

// The second argument, argv[], is an array of pointers to nul-terminated
// strings. This function makes a copy of the array and strings into a
// single block of memory. It then dequotes any of the strings that appear
// to be quoted.
//
// If successful, output parameter *pazDequote is set to point at the
// array of dequoted strings and SQLITE_OK is returned. The caller is
// responsible for eventually calling sqlite3_free() to free the array
// in this case. Or, if an error occurs, an SQLite error code is returned.
// The final value of *pazDequote is undefined in this case.
func fts5tokDequoteArray(tls *libc.TLS, argc int32, argv uintptr, pazDequote uintptr) int32 { /* fts5_test_tok.c:123:12: */
	var rc int32 = SQLITE_OK // Return code
	if argc == 0 {
		*(*uintptr)(unsafe.Pointer(pazDequote)) = uintptr(0)
	} else {
		var i int32
		var nByte int32 = 0
		var azDequote uintptr

		for i = 0; i < argc; i++ {
			nByte = nByte + (int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))) + size_t(1)))
		}

		*(*uintptr)(unsafe.Pointer(pazDequote)) = libc.AssignUintptr(&azDequote, sqlite3.Xsqlite3_malloc64(tls, (uint64((uint32(unsafe.Sizeof(uintptr(0)))*uint32(argc))+uint32(nByte)))))
		if azDequote == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			var pSpace uintptr = (azDequote + uintptr(argc)*4)
			for i = 0; i < argc; i++ {
				var n int32 = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
				*(*uintptr)(unsafe.Pointer(azDequote + uintptr(i)*4)) = pSpace
				libc.Xmemcpy(tls, pSpace, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), (uint32(n + 1)))
				fts5tokDequote(tls, pSpace)
				pSpace += (uintptr(n + 1))
			}
		}
	}

	return rc
}

// Schema of the tokenizer table.

// This function does all the work for both the xConnect and xCreate methods.
// These tables have no persistent representation of their own, so xConnect
// and xCreate are identical operations.
//
//   argv[0]: module name
//   argv[1]: database name
//   argv[2]: table name
//   argv[3]: first argument (tokenizer name)
func fts5tokConnectMethod(tls *libc.TLS, db uintptr, pCtx uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* fts5_test_tok.c:173:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pApi uintptr = pCtx
	var pTab uintptr = uintptr(0)
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp /* azDequote */)) = uintptr(0)
	var nDequote int32 = 0

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+3038 /* "CREATE TABLE x(i..." */)

	if rc == SQLITE_OK {
		nDequote = (argc - 3)
		rc = fts5tokDequoteArray(tls, nDequote, (argv + 3*4), bp /* &azDequote */)
	}

	if rc == SQLITE_OK {
		pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Fts5tokTable{})))
		if pTab == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pTab, 0, uint32(unsafe.Sizeof(Fts5tokTable{})))
		}
	}

	if rc == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(bp + 4 /* pTokCtx */)) = uintptr(0)
		var zModule uintptr = uintptr(0)
		if nDequote > 0 {
			zModule = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* azDequote */))))
		}

		rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((pApi + 8 /* &.xFindTokenizer */))))(tls, pApi, zModule, bp+4 /* &pTokCtx */, (pTab + 12 /* &.tok */))
		if rc == SQLITE_OK {
			var azArg uintptr = func() uintptr {
				if nDequote > 1 {
					return (*(*uintptr)(unsafe.Pointer(bp /* azDequote */)) + 1*4)
				}
				return uintptr(0)
			}()
			var nArg int32
			if nDequote > 0 {
				nArg = (nDequote - 1)
			} else {
				nArg = 0
			}
			rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pTab + 12 /* &.tok */ /* &.xCreate */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 4 /* pTokCtx */)), azArg, nArg, (pTab + 24 /* &.pTok */))
		}
	}

	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, pTab)
		pTab = uintptr(0)
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp /* azDequote */)))
	return rc
}

// This function does the work for both the xDisconnect and xDestroy methods.
// These tables have no persistent representation of their own, so xDisconnect
// and xDestroy are identical operations.
func fts5tokDisconnectMethod(tls *libc.TLS, pVtab uintptr) int32 { /* fts5_test_tok.c:235:12: */
	var pTab uintptr = pVtab
	if (*Fts5tokTable)(unsafe.Pointer(pTab)).FpTok != 0 {
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((pTab + 12 /* &.tok */ + 4 /* &.xDelete */))))(tls, (*Fts5tokTable)(unsafe.Pointer(pTab)).FpTok)
	}
	sqlite3.Xsqlite3_free(tls, pTab)
	return SQLITE_OK
}

// xBestIndex - Analyze a WHERE and ORDER BY clause.
func fts5tokBestIndexMethod(tls *libc.TLS, pVTab uintptr, pInfo uintptr) int32 { /* fts5_test_tok.c:247:12: */
	var i int32

	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pInfo)).FnConstraint; i++ {
		if (((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraint+uintptr(i)*12)).Fusable != 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraint+uintptr(i)*12)).FiColumn == 0)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraint+uintptr(i)*12)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			(*sqlite3_index_info)(unsafe.Pointer(pInfo)).FidxNum = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			(*sqlite3_index_info)(unsafe.Pointer(pInfo)).FestimatedCost = float64(1)
			return SQLITE_OK
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pInfo)).FidxNum = 0

	return SQLITE_OK
}

// xOpen - Open a cursor.
func fts5tokOpenMethod(tls *libc.TLS, pVTab uintptr, ppCsr uintptr) int32 { /* fts5_test_tok.c:275:12: */
	var pCsr uintptr

	pCsr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Fts5tokCursor{})))
	if pCsr == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCsr, 0, uint32(unsafe.Sizeof(Fts5tokCursor{})))

	*(*uintptr)(unsafe.Pointer(ppCsr)) = pCsr
	return SQLITE_OK
}

// Reset the tokenizer cursor passed as the only argument. As if it had
// just been returned by fts5tokOpenMethod().
func fts5tokResetCursor(tls *libc.TLS, pCsr uintptr) { /* fts5_test_tok.c:292:13: */
	var i int32
	for i = 0; i < (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow; i++ {
		sqlite3.Xsqlite3_free(tls, (*Fts5tokRow)(unsafe.Pointer((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow+uintptr(i)*16)).FzToken)
	}
	sqlite3.Xsqlite3_free(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput)
	sqlite3.Xsqlite3_free(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput = uintptr(0)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow = uintptr(0)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow = 0
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid = 0
}

// xClose - Close a cursor.
func fts5tokCloseMethod(tls *libc.TLS, pCursor uintptr) int32 { /* fts5_test_tok.c:308:12: */
	var pCsr uintptr = pCursor
	fts5tokResetCursor(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

// xNext - Advance the cursor to the next row, if any.
func fts5tokNextMethod(tls *libc.TLS, pCursor uintptr) int32 { /* fts5_test_tok.c:318:12: */
	var pCsr uintptr = pCursor
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid++
	return SQLITE_OK
}

func fts5tokCb(tls *libc.TLS, pCtx uintptr, tflags int32, pToken uintptr, nToken int32, iStart int32, iEnd int32) int32 { /* fts5_test_tok.c:324:12: */
	var pCsr uintptr = pCtx
	var pRow uintptr

	if ((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow & ((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow - 1)) == 0 {
		var nNew int32
		if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow != 0 {
			nNew = ((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow * 2)
		} else {
			nNew = 32
		}
		var aNew uintptr
		aNew = sqlite3.Xsqlite3_realloc64(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow, (uint64(uint32(nNew) * uint32(unsafe.Sizeof(Fts5tokRow{})))))
		if aNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, (aNew + uintptr((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow)*16), 0, (uint32(unsafe.Sizeof(Fts5tokRow{})) * (uint32(nNew - (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow))))
		(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow = aNew
	}

	pRow = ((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow + uintptr((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow)*16)
	(*Fts5tokRow)(unsafe.Pointer(pRow)).FiStart = iStart
	(*Fts5tokRow)(unsafe.Pointer(pRow)).FiEnd = iEnd
	if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow != 0 {
		(*Fts5tokRow)(unsafe.Pointer(pRow)).FiPos = ((*Fts5tokRow)(unsafe.Pointer(pRow+libc.UintptrFromInt32(-1)*16)).FiPos + (func() int32 {
			if (tflags & FTS5_TOKEN_COLOCATED) != 0 {
				return 0
			}
			return 1
		}()))
	}
	(*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken = sqlite3.Xsqlite3_malloc(tls, (nToken + 1))
	if (*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemcpy(tls, (*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken, pToken, uint32(nToken))
	*(*int8)(unsafe.Pointer((*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken + uintptr(nToken))) = int8(0)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow++

	return SQLITE_OK
}

// xFilter - Initialize a cursor to point at the start of its data.
func fts5tokFilterMethod(tls *libc.TLS, pCursor uintptr, idxNum int32, idxStr uintptr, nVal int32, apVal uintptr) int32 { /* fts5_test_tok.c:362:12: */
	var rc int32 = SQLITE_ERROR
	var pCsr uintptr = pCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab

	fts5tokResetCursor(tls, pCsr)
	if idxNum == 1 {
		var zByte uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
		var nByte int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal)))
		(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput = sqlite3.Xsqlite3_malloc(tls, (nByte + 1))
		if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			if nByte > 0 {
				libc.Xmemcpy(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput, zByte, uint32(nByte))
			}
			*(*int8)(unsafe.Pointer((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput + uintptr(nByte))) = int8(0)
			rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((pTab + 12 /* &.tok */ + 8 /* &.xTokenize */))))(tls,
				(*Fts5tokTable)(unsafe.Pointer(pTab)).FpTok, pCsr, 0, zByte, nByte, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
				}{fts5tokCb})))
		}
	}

	if rc != SQLITE_OK {
		return rc
	}
	return fts5tokNextMethod(tls, pCursor)
}

// xEof - Return true if the cursor is at EOF, or false otherwise.
func fts5tokEofMethod(tls *libc.TLS, pCursor uintptr) int32 { /* fts5_test_tok.c:396:12: */
	var pCsr uintptr = pCursor
	return (libc.Bool32((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid > (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow))
}

// xColumn - Return a column value.
func fts5tokColumnMethod(tls *libc.TLS, pCursor uintptr, pCtx uintptr, iCol int32) int32 { /* fts5_test_tok.c:404:12: */
	var pCsr uintptr = pCursor
	var pRow uintptr = ((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow + uintptr(((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid-1))*16)

	// CREATE TABLE x(input, token, start, end, position)
	switch iCol {
	case 0:
		sqlite3.Xsqlite3_result_text(tls, pCtx, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput, -1, libc.UintptrFromInt32(-1))
		break
	case 1:
		sqlite3.Xsqlite3_result_text(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken, -1, libc.UintptrFromInt32(-1))
		break
	case 2:
		sqlite3.Xsqlite3_result_int(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FiStart)
		break
	case 3:
		sqlite3.Xsqlite3_result_int(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FiEnd)
		break
	default:

		sqlite3.Xsqlite3_result_int(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FiPos)
		break
	}
	return SQLITE_OK
}

// xRowid - Return the current rowid for the cursor.
func fts5tokRowidMethod(tls *libc.TLS, pCursor uintptr, pRowid uintptr) int32 { /* fts5_test_tok.c:437:12: */
	var pCsr uintptr = pCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3_int64((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid)
	return SQLITE_OK
}

// Register the fts5tok module with database connection db. Return SQLITE_OK
// if successful or an error code if sqlite3_create_module() fails.
func sqlite3Fts5TestRegisterTok(tls *libc.TLS, db uintptr, pApi uintptr) int32 { /* fts5_test_tok.c:450:5: */
	var rc int32 // Return code

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+3096 /* "fts5tokenize" */, uintptr(unsafe.Pointer(&fts5tok_module)), pApi)
	return rc
}

var fts5tok_module = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen
	FxClose:      0, // xClose
	FxFilter:     0, // xFilter
	FxNext:       0, // xNext
	FxEof:        0, // xEof
	FxColumn:     0, // xColumn
	FxRowid:      0, // xShadowName
} /* fts5_test_tok.c:451:31 */

// CAPI3REF: Loadable Extension Thunk
//
// A pointer to the opaque sqlite3_api_routines structure is passed as
// the third parameter to entry points of [loadable extensions].  This
// structure must be typedefed in order to work around compiler warnings
// on some platforms.
type sqlite3_api_routines = sqlite3_api_routines1 /* sqlite3.h:1216:37 */

// This is the function signature used for all extension entry points.  It
// is also defined in the file "loadext.c".
type sqlite3_loadext_entry = uintptr /* sqlite3ext.h:346:13 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// The append mark at the end of the database is:
//
//     Start-Of-SQLite3-NNNNNNNN
//     123456789 123456789 12345
//
// The NNNNNNNN represents a 64-bit big-endian unsigned integer which is
// the offset to page 1, and also the length of the prefix content.

// Maximum size of the combined prefix + database + append-mark.  This
// must be less than 0x40000000 to avoid locking issues on Windows.

// Try to align the database to an even multiple of APND_ROUNDUP bytes.

// Forward declaration of objects used by this utility
type ApndVfs = sqlite3_vfs1 /* appendvfs.c:85:28 */
type ApndFile1 = struct {
	Fbase   sqlite3_file
	_       [4]byte
	FiPgOne sqlite3_int64
	FiMark  sqlite3_int64
} /* appendvfs.c:86:9 */

type ApndFile = ApndFile1 /* appendvfs.c:86:25 */

var apnd_vfs = sqlite3_vfs{
	FiVersion:          3,         // szOsFile (set when registered)
	FmxPathname:        1024,      // pNext
	FzName:             ts + 3109, /* "apndvfs" */ /* pAppData (set when registered) */
	FxOpen:             0,         // xOpen
	FxDelete:           0,         // xDelete
	FxAccess:           0,         // xAccess
	FxFullPathname:     0,         // xFullPathname
	FxDlOpen:           0,         // xDlOpen
	FxDlError:          0,         // xDlError
	FxDlSym:            0,         // xDlSym
	FxDlClose:          0,         // xDlClose
	FxRandomness:       0,         // xRandomness
	FxSleep:            0,         // xSleep
	FxCurrentTime:      0,         // xCurrentTime
	FxGetLastError:     0,         // xGetLastError
	FxCurrentTimeInt64: 0,         // xCurrentTimeInt64
	FxSetSystemCall:    0,         // xSetSystemCall
	FxGetSystemCall:    0,         // xGetSystemCall
	FxNextSystemCall:   0,         // xNextSystemCall
} /* appendvfs.c:177:20 */

var apnd_io_methods = sqlite3_io_methods{
	FiVersion:               3, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
	FxFetch:                 0, // xFetch
	FxUnfetch:               0, // xUnfetch
} /* appendvfs.c:202:33 */

// Close an apnd-file.
func apndClose(tls *libc.TLS, pFile uintptr) int32 { /* appendvfs.c:227:12: */
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 4 /* &.xClose */))))(tls, pFile)
}

// Read data from an apnd-file.
func apndRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* appendvfs.c:235:12: */
	var paf uintptr = pFile
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 8 /* &.xRead */))))(tls, pFile, zBuf, iAmt, ((*ApndFile)(unsafe.Pointer(paf)).FiPgOne + iOfst))
}

// Add the append-mark onto what should become the end of the file.
//  If and only if this succeeds, internal ApndFile.iMark is updated.
//  Parameter iWriteEnd is the appendvfs-relative offset of the new mark.
func apndWriteMark(tls *libc.TLS, paf uintptr, pFile uintptr, iWriteEnd sqlite_int64) int32 { /* appendvfs.c:251:12: */
	bp := tls.Alloc(25)
	defer tls.Free(25)

	var iPgOne sqlite_int64 = (*ApndFile)(unsafe.Pointer(paf)).FiPgOne
	// var a [25]uint8 at bp, 25

	var i int32 = APND_MARK_FOS_SZ
	var rc int32

	libc.Xmemcpy(tls, bp /* &a[0] */, ts+3117 /* "Start-Of-SQLite3..." */, uint32(APND_MARK_PREFIX_SZ))
	for libc.PreDecInt32(&i, 1) >= 0 {
		*(*uint8)(unsafe.Pointer(bp /* &a[0] */ + uintptr((APND_MARK_PREFIX_SZ + i)))) = (uint8(iPgOne & int64(0xff)))
		iPgOne >>= 8
	}
	iWriteEnd = iWriteEnd + ((*ApndFile)(unsafe.Pointer(paf)).FiPgOne)
	if SQLITE_OK == (libc.AssignInt32(&rc, (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 12 /* &.xWrite */))))(tls, pFile, bp /* &a[0] */, (APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ), iWriteEnd))) {
		(*ApndFile)(unsafe.Pointer(paf)).FiMark = iWriteEnd
	}
	return rc
}

// Write data to an apnd-file.
func apndWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* appendvfs.c:277:12: */
	var paf uintptr = pFile
	var iWriteEnd sqlite_int64 = (iOfst + sqlite_int64(iAmt))
	if iWriteEnd >= (int64(0x40000000)) {
		return SQLITE_FULL
	}
	pFile = ((pFile) + uintptr(1)*24)
	// If append-mark is absent or will be overwritten, write it.
	if ((*ApndFile)(unsafe.Pointer(paf)).FiMark < int64(0)) || (((*ApndFile)(unsafe.Pointer(paf)).FiPgOne + iWriteEnd) > (*ApndFile)(unsafe.Pointer(paf)).FiMark) {
		var rc int32 = apndWriteMark(tls, paf, pFile, iWriteEnd)
		if SQLITE_OK != rc {
			return rc
		}
	}
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 12 /* &.xWrite */))))(tls, pFile, zBuf, iAmt, ((*ApndFile)(unsafe.Pointer(paf)).FiPgOne + iOfst))
}

// Truncate an apnd-file.
func apndTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* appendvfs.c:298:12: */
	var paf uintptr = pFile
	pFile = ((pFile) + uintptr(1)*24)
	// The append mark goes out first so truncate failure does not lose it.
	if SQLITE_OK != apndWriteMark(tls, paf, pFile, size) {
		return SQLITE_IOERR
	}
	// Truncate underlying file just past append mark
	return (*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 16 /* &.xTruncate */))))(tls, pFile, ((*ApndFile)(unsafe.Pointer(paf)).FiMark + (int64(APND_MARK_PREFIX_SZ + APND_MARK_FOS_SZ))))
}

// Sync an apnd-file.
func apndSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* appendvfs.c:310:12: */
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 20 /* &.xSync */))))(tls, pFile, flags)
}

// Return the current file-size of an apnd-file.
// If the append mark is not yet there, the file-size is 0.
func apndFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* appendvfs.c:319:12: */
	var paf uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = func() int64 {
		if (*ApndFile)(unsafe.Pointer(paf)).FiMark >= int64(0) {
			return ((*ApndFile)(unsafe.Pointer(paf)).FiMark - (*ApndFile)(unsafe.Pointer(paf)).FiPgOne)
		}
		return int64(0)
	}()
	return SQLITE_OK
}

// Lock an apnd-file.
func apndLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* appendvfs.c:328:12: */
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 28 /* &.xLock */))))(tls, pFile, eLock)
}

// Unlock an apnd-file.
func apndUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* appendvfs.c:336:12: */
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 32 /* &.xUnlock */))))(tls, pFile, eLock)
}

// Check if another file-handle holds a RESERVED lock on an apnd-file.
func apndCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* appendvfs.c:344:12: */
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 36 /* &.xCheckReservedLock */))))(tls, pFile, pResOut)
}

// File control method. For custom operations on an apnd-file.
func apndFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* appendvfs.c:352:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var paf uintptr = pFile
	var rc int32
	pFile = ((pFile) + uintptr(1)*24)
	if op == SQLITE_FCNTL_SIZE_HINT {
		*(*sqlite3_int64)(unsafe.Pointer(pArg)) += ((*ApndFile)(unsafe.Pointer(paf)).FiPgOne)
	}
	rc = (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 40 /* &.xFileControl */))))(tls, pFile, op, pArg)
	if (rc == SQLITE_OK) && (op == SQLITE_FCNTL_VFSNAME) {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+3135 /* "apnd(%lld)/%z" */, libc.VaList(bp, (*ApndFile)(unsafe.Pointer(paf)).FiPgOne, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

// Return the sector-size in bytes for an apnd-file.
func apndSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* appendvfs.c:367:12: */
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 44 /* &.xSectorSize */))))(tls, pFile)
}

// Return the device characteristic flags supported by an apnd-file.
func apndDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* appendvfs.c:375:12: */
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 48 /* &.xDeviceCharacteristics */))))(tls, pFile)
}

// Create a shared memory file mapping
func apndShmMap(tls *libc.TLS, pFile uintptr, iPg int32, pgsz int32, bExtend int32, pp uintptr) int32 { /* appendvfs.c:381:12: */
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 52 /* &.xShmMap */))))(tls, pFile, iPg, pgsz, bExtend, libc.AtomicLoadUintptr(&pp))
}

// Perform locking on a shared-memory segment
func apndShmLock(tls *libc.TLS, pFile uintptr, offset int32, n int32, flags int32) int32 { /* appendvfs.c:393:12: */
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 56 /* &.xShmLock */))))(tls, pFile, offset, n, flags)
}

// Memory barrier operation on shared memory
func apndShmBarrier(tls *libc.TLS, pFile uintptr) { /* appendvfs.c:399:13: */
	pFile = ((pFile) + uintptr(1)*24)
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 60 /* &.xShmBarrier */))))(tls, pFile)
}

// Unmap a shared memory segment
func apndShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 { /* appendvfs.c:405:12: */
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 64 /* &.xShmUnmap */))))(tls, pFile, deleteFlag)
}

// Fetch a page of a memory-mapped file
func apndFetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, iAmt int32, pp uintptr) int32 { /* appendvfs.c:411:12: */
	var p uintptr = pFile
	if ((*ApndFile)(unsafe.Pointer(p)).FiMark < int64(0)) || ((iOfst + sqlite3_int64(iAmt)) > (*ApndFile)(unsafe.Pointer(p)).FiMark) {
		return SQLITE_IOERR // Cannot read what is not yet there.
	}
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 68 /* &.xFetch */))))(tls, pFile, (iOfst + (*ApndFile)(unsafe.Pointer(p)).FiPgOne), iAmt, pp)
}

// Release a memory-mapped page
func apndUnfetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, pPage uintptr) int32 { /* appendvfs.c:426:12: */
	var p uintptr = pFile
	pFile = ((pFile) + uintptr(1)*24)
	return (*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 72 /* &.xUnfetch */))))(tls, pFile, (iOfst + (*ApndFile)(unsafe.Pointer(p)).FiPgOne), pPage)
}

// Try to read the append-mark off the end of a file.  Return the
// start of the appended database if the append-mark is present.
// If there is no valid append-mark, return -1;
//
// An append-mark is only valid if the NNNNNNNN start-of-database offset
// indicates that the appended database contains at least one page.  The
// start-of-database value must be a multiple of 512.
func apndReadMark(tls *libc.TLS, sz sqlite3_int64, pFile uintptr) sqlite3_int64 { /* appendvfs.c:441:22: */
	bp := tls.Alloc(25)
	defer tls.Free(25)

	var rc int32
	var i int32
	var iMark sqlite3_int64
	var msbs int32 = (8 * (APND_MARK_FOS_SZ - 1))
	// var a [25]uint8 at bp, 25

	if (int64(APND_MARK_PREFIX_SZ + APND_MARK_FOS_SZ)) != (sz & int64(0x1ff)) {
		return int64(-1)
	}
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 8 /* &.xRead */))))(tls, pFile, bp /* &a[0] */, (APND_MARK_PREFIX_SZ + APND_MARK_FOS_SZ), (sz - (int64(APND_MARK_PREFIX_SZ + APND_MARK_FOS_SZ))))
	if rc != 0 {
		return int64(-1)
	}
	if libc.Xmemcmp(tls, bp /* &a[0] */, ts+3117 /* "Start-Of-SQLite3..." */, uint32(APND_MARK_PREFIX_SZ)) != 0 {
		return int64(-1)
	}
	iMark = ((sqlite3_int64(int32(*(*uint8)(unsafe.Pointer(bp /* &a[0] */ + 17))) & 0x7f)) << msbs)
	for i = 1; i < 8; i++ {
		msbs = msbs - (8)
		iMark = iMark | (sqlite3_int64(*(*uint8)(unsafe.Pointer(bp /* &a[0] */ + uintptr((APND_MARK_PREFIX_SZ + i))))) << msbs)
	}
	if iMark > ((sz - (int64(APND_MARK_PREFIX_SZ + APND_MARK_FOS_SZ))) - int64(512)) {
		return int64(-1)
	}
	if (iMark & int64(0x1ff)) != 0 {
		return int64(-1)
	}
	return iMark
}

var apvfsSqliteHdr = *(*[16]int8)(unsafe.Pointer(ts + 3149 /* "SQLite format 3" */)) /* appendvfs.c:461:19 */

// Check to see if the file is an appendvfs SQLite database file.
// Return true iff it is such. Parameter sz is the file's size.
func apndIsAppendvfsDatabase(tls *libc.TLS, sz sqlite3_int64, pFile uintptr) int32 { /* appendvfs.c:466:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	// var zHdr [16]int8 at bp, 16

	var iMark sqlite3_int64 = apndReadMark(tls, sz, pFile)
	if iMark >= int64(0) {
		// If file has the correct end-marker, the expected odd size, and the
		// SQLite DB type marker where the end-marker puts it, then it
		// is an appendvfs database.
		rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 8 /* &.xRead */))))(tls, pFile, bp /* &zHdr[0] */, int32(unsafe.Sizeof([16]int8{})), iMark)
		if (((SQLITE_OK == rc) &&
			(libc.Xmemcmp(tls, bp /* &zHdr[0] */, uintptr(unsafe.Pointer(&apvfsSqliteHdr)), uint32(unsafe.Sizeof([16]int8{}))) == 0)) &&
			((sz & int64(0x1ff)) == (int64(APND_MARK_PREFIX_SZ + APND_MARK_FOS_SZ)))) &&
			(sz >= (int64(512 + (APND_MARK_PREFIX_SZ + APND_MARK_FOS_SZ)))) {
			return 1 // It's an appendvfs database
		}
	}
	return 0
}

// Check to see if the file is an ordinary SQLite database file.
// Return true iff so. Parameter sz is the file's size.
func apndIsOrdinaryDatabaseFile(tls *libc.TLS, sz sqlite3_int64, pFile uintptr) int32 { /* appendvfs.c:491:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var zHdr [16]int8 at bp, 16

	if (((apndIsAppendvfsDatabase(tls, sz, pFile) != 0) || // rule 2
		((sz & int64(0x1ff)) != int64(0))) ||
		(SQLITE_OK != (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 8 /* &.xRead */))))(tls, pFile, bp /* &zHdr[0] */, int32(unsafe.Sizeof([16]int8{})), int64(0)))) ||
		(libc.Xmemcmp(tls, bp /* &zHdr[0] */, uintptr(unsafe.Pointer(&apvfsSqliteHdr)), uint32(unsafe.Sizeof([16]int8{}))) != 0) {
		return 0
	} else {
		return 1
	}
	return int32(0)
}

// Open an apnd file handle.
func apndOpen(tls *libc.TLS, pApndVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* appendvfs.c:507:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pApndFile uintptr = pFile
	var pBaseFile uintptr = ((pFile) + uintptr(1)*24)
	var pBaseVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pApndVfs)).FpAppData
	var rc int32
	*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)) = int64(0)
	if (flags & SQLITE_OPEN_MAIN_DB) == 0 {
		// The appendvfs is not to be used for transient or temporary databases.
		// Just use the base VFS open to initialize the given file object and
		// open the underlying file. (Appendvfs is then unused for this file.)
		return (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pBaseVfs + 24 /* &.xOpen */))))(tls, pBaseVfs, zName, pFile, flags, pOutFlags)
	}
	libc.Xmemset(tls, pApndFile, 0, uint32(unsafe.Sizeof(ApndFile{})))
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&apnd_io_methods))
	(*ApndFile)(unsafe.Pointer(pApndFile)).FiMark = int64(-1) // Append mark not yet written

	rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pBaseVfs + 24 /* &.xOpen */))))(tls, pBaseVfs, zName, pBaseFile, flags, pOutFlags)
	if rc == SQLITE_OK {
		rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pBaseFile)).FpMethods + 24 /* &.xFileSize */))))(tls, pBaseFile, bp /* &sz */)
		if rc != 0 {
			(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pBaseFile)).FpMethods + 4 /* &.xClose */))))(tls, pBaseFile)
		}
	}
	if rc != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
		return rc
	}
	if apndIsOrdinaryDatabaseFile(tls, *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)), pBaseFile) != 0 {
		// The file being opened appears to be just an ordinary DB. Copy
		// the base dispatch-table so this instance mimics the base VFS.
		libc.Xmemmove(tls, pApndFile, pBaseFile, uint32((*sqlite3_vfs)(unsafe.Pointer(pBaseVfs)).FszOsFile))
		return SQLITE_OK
	}
	(*ApndFile)(unsafe.Pointer(pApndFile)).FiPgOne = apndReadMark(tls, *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)), pFile)
	if (*ApndFile)(unsafe.Pointer(pApndFile)).FiPgOne >= int64(0) {
		(*ApndFile)(unsafe.Pointer(pApndFile)).FiMark = (*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)) - (int64(APND_MARK_PREFIX_SZ + APND_MARK_FOS_SZ))) // Append mark found
		return SQLITE_OK
	}
	if (flags & SQLITE_OPEN_CREATE) == 0 {
		(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pBaseFile)).FpMethods + 4 /* &.xClose */))))(tls, pBaseFile)
		rc = SQLITE_CANTOPEN
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
	} else {
		// Round newly added appendvfs location to #define'd page boundary.
		// Note that nothing has yet been written to the underlying file.
		// The append mark will be written along with first content write.
		// Until then, paf->iMark value indicates it is not yet written.
		(*ApndFile)(unsafe.Pointer(pApndFile)).FiPgOne = (((*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */))) + (int64(APND_ROUNDUP - 1))) & libc.CplInt64((int64(APND_ROUNDUP - 1))))
	}
	return rc
}

// Delete an apnd file.
// For an appendvfs, this could mean delete the appendvfs portion,
// leaving the appendee as it was before it gained an appendvfs.
// For now, this code deletes the underlying file too.
func apndDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* appendvfs.c:574:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 28 /* &.xDelete */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, dirSync)
}

// All other VFS methods are pass-thrus.
func apndAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* appendvfs.c:581:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 32 /* &.xAccess */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, flags, pResOut)
}

func apndFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* appendvfs.c:589:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 36 /* &.xFullPathname */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, nOut, zOut)
}

func apndDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr { /* appendvfs.c:597:13: */
	return (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 40 /* &.xDlOpen */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath)
}

func apndDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* appendvfs.c:600:13: */
	(*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 44 /* &.xDlError */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zErrMsg)
}

func apndDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr { /* appendvfs.c:603:13: */
	return (*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 48 /* &.xDlSym */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, p, zSym)
}

func apndDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) { /* appendvfs.c:606:13: */
	(*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 52 /* &.xDlClose */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pHandle)
}

func apndRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* appendvfs.c:609:12: */
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 56 /* &.xRandomness */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zBufOut)
}

func apndSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* appendvfs.c:612:12: */
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 60 /* &.xSleep */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nMicro)
}

func apndCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* appendvfs.c:615:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 64 /* &.xCurrentTime */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pTimeOut)
}

func apndGetLastError(tls *libc.TLS, pVfs uintptr, a int32, b uintptr) int32 { /* appendvfs.c:618:12: */
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 68 /* &.xGetLastError */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, a, b)
}

func apndCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, p uintptr) int32 { /* appendvfs.c:621:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 72 /* &.xCurrentTimeInt64 */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, p)
}

func apndSetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr, pCall sqlite3_syscall_ptr) int32 { /* appendvfs.c:624:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 76 /* &.xSetSystemCall */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName, pCall)
}

func apndGetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) sqlite3_syscall_ptr { /* appendvfs.c:631:28: */
	return (*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 80 /* &.xGetSystemCall */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

func apndNextSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) uintptr { /* appendvfs.c:637:19: */
	return (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 84 /* &.xNextSystemCall */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

// This routine is called when the extension is loaded.
// Register the new VFS.
func sqlite3_appendvfs_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* appendvfs.c:649:5: */
	var rc int32 = SQLITE_OK
	var pOrig uintptr
	_ = pApi

	_ = pzErrMsg
	_ = db
	pOrig = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if pOrig == uintptr(0) {
		return SQLITE_ERROR
	}
	apnd_vfs.FiVersion = (*sqlite3_vfs)(unsafe.Pointer(pOrig)).FiVersion
	apnd_vfs.FpAppData = pOrig
	apnd_vfs.FszOsFile = (int32(uint32((*sqlite3_vfs)(unsafe.Pointer(pOrig)).FszOsFile) + uint32(unsafe.Sizeof(ApndFile{}))))
	rc = sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&apnd_vfs)), 0)
	if rc == SQLITE_OK {
		rc = (SQLITE_OK | (int32(1) << 8))
	}
	return rc
}

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//    which causes a conflict if the include order is reversed.

type idtype_t = uint32 /* waitflags.h:57:3 */
// Definitions of status bits for `wait' et al.
//    Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Everything extant so far uses these same bits.

// If WIFEXITED(STATUS), the low-order 8 bits of the status.

// If WIFSIGNALED(STATUS), the terminating signal.

// If WIFSTOPPED(STATUS), the signal that stopped the child.

// Nonzero if STATUS indicates normal termination.

// Nonzero if STATUS indicates termination by a signal.

// Nonzero if STATUS indicates the child is stopped.

// Nonzero if STATUS indicates the child continued after a stop.  We only
//    define this if <bits/waitflags.h> provides the WCONTINUED flag bit.

// Nonzero if STATUS indicates the child dumped core.

// Macros for constructing status values.

// Define the macros <sys/wait.h> also would define this way.

// _FloatN API tests for enablement.
// Macros to control TS 18661-3 glibc features.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the IEEE 754 binary128 format, and this glibc
//    includes corresponding *f128 interfaces for it.

// Defined to 1 if __HAVE_FLOAT128 is 1 and the type is ABI-distinct
//    from the default float, double and long double types in this glibc.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for _Float64x, and this
//    glibc includes corresponding *f64x interfaces for it.

// Defined to 1 if __HAVE_FLOAT64X is 1 and _Float64x has the format
//    of long double.  Otherwise, if __HAVE_FLOAT64X is 1, _Float64x has
//    the format of _Float128, which must be different from that of long
//    double.

// Defined to concatenate the literal suffix to be used with _Float128
//    types, if __HAVE_FLOAT128 is 1.
//    E.g.: #define __f128(x) x##f128.

// Defined to a complex binary128 type if __HAVE_FLOAT128 is 1.
//    E.g.: #define __CFLOAT128 _Complex _Float128.

// Macros to control TS 18661-3 glibc features where the same
//    definitions are appropriate for all platforms.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Properties of long double type.
//    Copyright (C) 2016-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This header is included by <sys/cdefs.h>.
//
//    If long double is ABI-compatible with double, it should define
//    __NO_LONG_DOUBLE_MATH to 1; otherwise, it should leave
//    __NO_LONG_DOUBLE_MATH undefined.
//
//    If this build of the GNU C Library supports both long double
//    ABI-compatible with double and some other long double format not
//    ABI-compatible with double, it should define
//    __LONG_DOUBLE_MATH_OPTIONAL to 1; otherwise, it should leave
//    __LONG_DOUBLE_MATH_OPTIONAL undefined.
//
//    If __NO_LONG_DOUBLE_MATH is already defined, this header must not
//    define anything; this is needed to work with the definition of
//    __NO_LONG_DOUBLE_MATH in nldbl-compat.h.

// In the default version of this header, long double is
//    ABI-compatible with double.

// This header should be included at the bottom of each bits/floatn.h.
//    It defines the following macros for each _FloatN and _FloatNx type,
//    where the same definitions, or definitions based only on the macros
//    in bits/floatn.h, are appropriate for all glibc configurations.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for this type, and this
//    glibc includes corresponding *fN or *fNx interfaces for it.

// Defined to 1 if the corresponding __HAVE_<type> macro is 1 and the
//    type is the first with its format in the sequence of (the default
//    choices for) float, double, long double, _Float16, _Float32,
//    _Float64, _Float128, _Float32x, _Float64x, _Float128x for this
//    glibc; that is, if functions present once per floating-point format
//    rather than once per type are present for this type.
//
//    All configurations supported by glibc have _Float32 the same format
//    as float, _Float64 and _Float32x the same format as double, the
//    _Float64x the same format as either long double or _Float128.  No
//    configurations support _Float128x or, as of GCC 7, have compiler
//    support for a type meeting the requirements for _Float128x.

// Defined to 1 if the corresponding _FloatN type is not binary compatible
//    with the corresponding ISO C type in the current compilation unit as
//    opposed to __HAVE_DISTINCT_FLOATN, which indicates the default types built
//    in glibc.

// Defined to 1 if any _FloatN or _FloatNx types that are not
//    ABI-distinct are however distinct types at the C language level (so
//    for the purposes of __builtin_types_compatible_p and _Generic).

// Defined to concatenate the literal suffix to be used with _FloatN
//    or _FloatNx types, if __HAVE_<type> is 1.  The corresponding
//    literal suffixes exist since GCC 7, for C only.

// Defined to a complex type if __HAVE_<type> is 1.

// The remaining of this file provides support for older compilers.

// If double, long double and _Float64 all have the same set of
//    values, TS 18661-3 requires the usual arithmetic conversions on
//    long double and _Float64 to produce _Float64.  For this to be the
//    case when building with a compiler without a distinct _Float64
//    type, _Float64 must be a typedef for long double, not for
//    double.

// Returned by `div'.
type div_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:62:5 */

// Returned by `ldiv'.
type ldiv_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:70:5 */

// Returned by `lldiv'.
type lldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:80:5 */

type u_char = uint8                     /* types.h:33:18 */
type u_short = uint16                   /* types.h:34:19 */
type u_int = uint32                     /* types.h:35:17 */
type u_long = uint32                    /* types.h:36:18 */
type quad_t = int64                     /* types.h:37:18 */
type u_quad_t = uint64                  /* types.h:38:20 */
type fsid_t = struct{ F__val [2]int32 } /* types.h:39:18 */
type loff_t = int64                     /* types.h:42:18 */

type ino_t = uint64 /* types.h:49:19 */

type dev_t = uint64 /* types.h:59:17 */

type gid_t = uint32 /* types.h:64:17 */

type mode_t = uint32 /* types.h:69:18 */

type nlink_t = uint32 /* types.h:74:19 */

type uid_t = uint32 /* types.h:79:17 */

type pid_t = int32 /* types.h:97:17 */

type id_t = uint32 /* types.h:103:16 */

type daddr_t = int32   /* types.h:114:19 */
type caddr_t = uintptr /* types.h:115:19 */

type key_t = int32 /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type clock_t = int32 /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type clockid_t = int32 /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type time_t = int32 /* time_t.h:7:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type timer_t = uintptr /* timer_t.h:7:19 */

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Old compatibility names for C types.
type ulong = uint32  /* types.h:148:27 */
type ushort = uint16 /* types.h:149:28 */
type uint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type int8_t = int8   /* stdint-intn.h:24:18 */
type int16_t = int16 /* stdint-intn.h:25:19 */
type int32_t = int32 /* stdint-intn.h:26:19 */
type int64_t = int64 /* stdint-intn.h:27:19 */

// For GCC 2.7 and later, we can use specific type-size attributes.

type u_int8_t = uint32  /* types.h:177:1 */
type u_int16_t = uint32 /* types.h:178:1 */
type u_int32_t = uint32 /* types.h:179:1 */
type u_int64_t = uint32 /* types.h:180:1 */

type register_t = int32 /* types.h:182:13 */

// A set of signals to be blocked, unblocked, or waited for.
type sigset_t = struct{ F__val [32]uint32 } /* sigset_t.h:7:20 */

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//    microsecond but also has a range of years.
type timeval = struct {
	Ftv_sec  int32
	Ftv_usec int32
} /* struct_timeval.h:8:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//    has nanoseconds instead of microseconds.
type timespec = struct {
	Ftv_sec  int32
	Ftv_nsec int32
} /* struct_timespec.h:9:1 */

type suseconds_t = int32 /* select.h:43:23 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set = struct{ F__fds_bits [32]int32 } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type fd_mask = int32 /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type blksize_t = int32 /* types.h:202:21 */

// Types from the Large File Support interface.
type blkcnt_t = int64    /* types.h:222:22 */ // Type to count number of disk blocks.
type fsblkcnt_t = uint64 /* types.h:226:24 */ // Type to count file system blocks.
type fsfilcnt_t = uint64 /* types.h:230:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    Also, the following macros must be define for internal pthread_mutex_t
//    struct definitions (struct __pthread_mutex_s):
//
//    __PTHREAD_COMPAT_PADDING_MID   - any additional members after 'kind'
// 				    and before '__spin' (for 64 bits) or
// 				    '__nusers' (for 32 bits).
//    __PTHREAD_COMPAT_PADDING_END   - any additional members at the end of
// 				    the internal structure.
//    __PTHREAD_MUTEX_LOCK_ELISION   - 1 if the architecture supports lock
// 				    elision or 0 otherwise.
//    __PTHREAD_MUTEX_NUSERS_AFTER_KIND - control where to put __nusers.  The
// 				       preferred value for new architectures
// 				       is 0.
//    __PTHREAD_MUTEX_USE_UNION      - control whether internal __spins and
// 				    __list will be place inside a union for
// 				    linuxthreads compatibility.
// 				    The preferred value for new architectures
// 				    is 0.
//
//    For a new port the preferred values for the required defines are:
//
//    #define __PTHREAD_COMPAT_PADDING_MID
//    #define __PTHREAD_COMPAT_PADDING_END
//    #define __PTHREAD_MUTEX_LOCK_ELISION         0
//    #define __PTHREAD_MUTEX_NUSERS_AFTER_KIND    0
//    #define __PTHREAD_MUTEX_USE_UNION            0
//
//    __PTHREAD_MUTEX_LOCK_ELISION can be set to 1 if the hardware plans to
//    eventually support lock elision using transactional memory.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.
//
//    And finally the internal pthread_rwlock_t (struct __pthread_rwlock_arch_t)
//    must be defined.
//
// Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library.  If not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Data structure for mutex handling.

type __pthread_rwlock_arch_t = struct {
	F__readers       uint32
	F__writers       uint32
	F__wrphase_futex uint32
	F__writers_futex uint32
	F__pad3          uint32
	F__pad4          uint32
	F__flags         uint8
	F__shared        uint8
	F__pad1          uint8
	F__pad2          uint8
	F__cur_writer    int32
} /* pthreadtypes-arch.h:43:1 */

// Common definition of pthread_mutex_t.

type __pthread_internal_slist = struct{ F__next uintptr } /* thread-shared-types.h:88:9 */

// Lock elision support.
// Mutex __spins initializer used by PTHREAD_MUTEX_INITIALIZER.

type __pthread_mutex_s = struct {
	F__lock   int32
	F__count  uint32
	F__owner  int32
	F__kind   int32
	F__nusers uint32
	F__20     struct{ F__spins int32 }
} /* thread-shared-types.h:118:1 */

// Common definition of pthread_cond_t.

type __pthread_cond_s = struct {
	F__0            struct{ F__wseq uint64 }
	F__8            struct{ F__g1_start uint64 }
	F__g_refs       [2]uint32
	F__g_size       [2]uint32
	F__g1_orig_size uint32
	F__wrefs        uint32
	F__g_signals    [2]uint32
} /* thread-shared-types.h:171:1 */

// Thread identifiers.  The structure of the attribute type is not
//    exposed on purpose.
type pthread_t = uint32 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//    type is not exposed on purpose.
type pthread_mutexattr_t = struct {
	_       [0]uint32
	F__size [4]int8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//    the attribute type is not exposed on purpose.
type pthread_condattr_t = struct {
	_       [0]uint32
	F__size [4]int8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type pthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type pthread_once_t = int32 /* pthreadtypes.h:53:30 */

type pthread_attr_t1 = struct {
	_       [0]uint32
	F__size [36]int8
} /* pthreadtypes.h:56:1 */

type pthread_attr_t = pthread_attr_t1 /* pthreadtypes.h:62:30 */

type pthread_mutex_t = struct{ F__data __pthread_mutex_s } /* pthreadtypes.h:72:3 */

type pthread_cond_t = struct{ F__data __pthread_cond_s } /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//    structure of the attribute type is deliberately not exposed.
type pthread_rwlock_t = struct{ F__data __pthread_rwlock_arch_t } /* pthreadtypes.h:91:3 */

type pthread_rwlockattr_t = struct {
	_       [0]uint32
	F__size [8]int8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type pthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//    deliberately not exposed.
type pthread_barrier_t = struct {
	_       [0]uint32
	F__size [20]int8
} /* pthreadtypes.h:112:3 */

type pthread_barrierattr_t = struct {
	_       [0]uint32
	F__size [4]int8
} /* pthreadtypes.h:118:3 */

// Reentrant versions of the `random' family of functions.
//    These functions all use the following data structure to contain
//    state, rather than global state variables.

type random_data = struct {
	Ffptr      uintptr
	Frptr      uintptr
	Fstate     uintptr
	Frand_type int32
	Frand_deg  int32
	Frand_sep  int32
	Fend_ptr   uintptr
} /* stdlib.h:423:1 */

// Data structure for communication with thread safe versions.  This
//    type is to be regarded as opaque.  It's only exported because users
//    have to allocate objects of this type.
type drand48_data = struct {
	F__x     [3]uint16
	F__old_x [3]uint16
	F__c     uint16
	F__init  uint16
	F__a     uint64
} /* stdlib.h:490:1 */

// Forward declaration of objects used by this implementation
type amatch_vtab1 = struct {
	Fbase       sqlite3_vtab
	FzClassName uintptr
	FzDb        uintptr
	FzSelf      uintptr
	FzCostTab   uintptr
	FzVocabTab  uintptr
	FzVocabWord uintptr
	FzVocabLang uintptr
	FpRule      uintptr
	FrIns       amatch_cost
	FrDel       amatch_cost
	FrSub       amatch_cost
	Fdb         uintptr
	FpVCheck    uintptr
	FnCursor    int32
} /* amatch.c:172:9 */

// Forward declaration of objects used by this implementation
type amatch_vtab = amatch_vtab1 /* amatch.c:172:28 */
type amatch_cursor1 = struct {
	Fbase      sqlite3_vtab_cursor
	_          [4]byte
	FiRowid    sqlite3_int64
	FiLang     amatch_langid
	FrLimit    amatch_cost
	FnBuf      int32
	FoomErr    int32
	FnWord     int32
	FzBuf      uintptr
	FzInput    uintptr
	FpVtab     uintptr
	FpAllWords uintptr
	FpCurrent  uintptr
	FpCost     uintptr
	FpWord     uintptr
} /* amatch.c:173:9 */

type amatch_cursor = amatch_cursor1 /* amatch.c:173:30 */
type amatch_rule1 = struct {
	FpNext uintptr
	FzFrom uintptr
	FrCost amatch_cost
	FiLang amatch_langid
	FnFrom amatch_len
	FnTo   amatch_len
	FzTo   [4]int8
	_      [2]byte
} /* amatch.c:172:9 */

type amatch_rule = amatch_rule1 /* amatch.c:174:28 */
type amatch_word1 = struct {
	FpNext  uintptr
	FsCost  amatch_avl
	FsWord  amatch_avl
	FrCost  amatch_cost
	FiSeq   int32
	FzCost  [10]int8
	FnMatch int16
	FzWord  [4]int8
} /* amatch.c:173:9 */

type amatch_word = amatch_word1 /* amatch.c:175:28 */
type amatch_avl1 = struct {
	FpWord     uintptr
	FzKey      uintptr
	FpBefore   uintptr
	FpAfter    uintptr
	FpUp       uintptr
	Fheight    int16
	Fimbalance int16
} /* amatch.c:173:9 */

type amatch_avl = amatch_avl1 /* amatch.c:176:27 */

// Recompute the amatch_avl.height and amatch_avl.imbalance fields for p.
// Assume that the children of p have correct heights.
func amatchAvlRecomputeHeight(tls *libc.TLS, p uintptr) { /* amatch.c:199:13: */
	var hBefore int16
	if (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
		hBefore = (*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(p)).FpBefore)).Fheight
	} else {
		hBefore = int16(0)
	}
	var hAfter int16
	if (*amatch_avl)(unsafe.Pointer(p)).FpAfter != 0 {
		hAfter = (*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(p)).FpAfter)).Fheight
	} else {
		hAfter = int16(0)
	}
	(*amatch_avl)(unsafe.Pointer(p)).Fimbalance = (int16(int32(hBefore) - int32(hAfter))) // -: pAfter higher.  +: pBefore higher
	(*amatch_avl)(unsafe.Pointer(p)).Fheight = (int16((func() int32 {
		if int32(hBefore) > int32(hAfter) {
			return int32(hBefore)
		}
		return int32(hAfter)
	}()) + 1))
}

//     P                B
//    / \              / **   B   Z    ==>     X   P
//  / \                  / ** X   Y                Y   Z
//
func amatchAvlRotateBefore(tls *libc.TLS, pP uintptr) uintptr { /* amatch.c:214:19: */
	var pB uintptr = (*amatch_avl)(unsafe.Pointer(pP)).FpBefore
	var pY uintptr = (*amatch_avl)(unsafe.Pointer(pB)).FpAfter
	(*amatch_avl)(unsafe.Pointer(pB)).FpUp = (*amatch_avl)(unsafe.Pointer(pP)).FpUp
	(*amatch_avl)(unsafe.Pointer(pB)).FpAfter = pP
	(*amatch_avl)(unsafe.Pointer(pP)).FpUp = pB
	(*amatch_avl)(unsafe.Pointer(pP)).FpBefore = pY
	if pY != 0 {
		(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	amatchAvlRecomputeHeight(tls, pP)
	amatchAvlRecomputeHeight(tls, pB)
	return pB
}

//     P                A
//    / \              / **   X   A    ==>     P   Z
//      / \          / **     Y   Z        X   Y
//
func amatchAvlRotateAfter(tls *libc.TLS, pP uintptr) uintptr { /* amatch.c:235:19: */
	var pA uintptr = (*amatch_avl)(unsafe.Pointer(pP)).FpAfter
	var pY uintptr = (*amatch_avl)(unsafe.Pointer(pA)).FpBefore
	(*amatch_avl)(unsafe.Pointer(pA)).FpUp = (*amatch_avl)(unsafe.Pointer(pP)).FpUp
	(*amatch_avl)(unsafe.Pointer(pA)).FpBefore = pP
	(*amatch_avl)(unsafe.Pointer(pP)).FpUp = pA
	(*amatch_avl)(unsafe.Pointer(pP)).FpAfter = pY
	if pY != 0 {
		(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	amatchAvlRecomputeHeight(tls, pP)
	amatchAvlRecomputeHeight(tls, pA)
	return pA
}

// Return a pointer to the pBefore or pAfter pointer in the parent
// of p that points to p.  Or if p is the root node, return pp.
func amatchAvlFromPtr(tls *libc.TLS, p uintptr, pp uintptr) uintptr { /* amatch.c:252:19: */
	var pUp uintptr = (*amatch_avl)(unsafe.Pointer(p)).FpUp
	if pUp == uintptr(0) {
		return pp
	}
	if (*amatch_avl)(unsafe.Pointer(pUp)).FpAfter == p {
		return (pUp + 12 /* &.pAfter */)
	}
	return (pUp + 8 /* &.pBefore */)
}

// Rebalance all nodes starting with p and working up to the root.
// Return the new root.
func amatchAvlBalance(tls *libc.TLS, p uintptr) uintptr { /* amatch.c:263:19: */
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*uintptr)(unsafe.Pointer(bp)) = p

	var pTop uintptr = *(*uintptr)(unsafe.Pointer(bp /* p */))
	var pp uintptr
	for *(*uintptr)(unsafe.Pointer(bp /* p */)) != 0 {
		amatchAvlRecomputeHeight(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)))
		if int32((*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fimbalance) >= 2 {
			var pB uintptr = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore
			if int32((*amatch_avl)(unsafe.Pointer(pB)).Fimbalance) < 0 {
				(*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore = amatchAvlRotateAfter(tls, pB)
			}
			pp = amatchAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = libc.AssignPtrUintptr(pp, amatchAvlRotateBefore(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		} else if int32((*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fimbalance) <= (-2) {
			var pA uintptr = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter
			if int32((*amatch_avl)(unsafe.Pointer(pA)).Fimbalance) > 0 {
				(*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter = amatchAvlRotateBefore(tls, pA)
			}
			pp = amatchAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = libc.AssignPtrUintptr(pp, amatchAvlRotateAfter(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		}
		pTop = *(*uintptr)(unsafe.Pointer(bp /* p */))
		*(*uintptr)(unsafe.Pointer(bp /* p */)) = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpUp
	}
	return pTop
}

// Search the tree rooted at p for an entry with zKey.  Return a pointer
// to the entry or return NULL.
func amatchAvlSearch(tls *libc.TLS, p uintptr, zKey uintptr) uintptr { /* amatch.c:288:19: */
	var c int32
	for (p != 0) && ((libc.AssignInt32(&c, libc.Xstrcmp(tls, zKey, (*amatch_avl)(unsafe.Pointer(p)).FzKey))) != 0) {
		if c < 0 {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
		} else {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpAfter
		}
	}
	return p
}

// Find the first node (the one with the smallest key).
func amatchAvlFirst(tls *libc.TLS, p uintptr) uintptr { /* amatch.c:298:19: */
	if p != 0 {
		for (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
		}
	}
	return p
}

// Insert a new node pNew.  Return NULL on success.  If the key is not
// unique, then do not perform the insert but instead leave pNew unchanged
// and return a pointer to an existing node with the same key.
func amatchAvlInsert(tls *libc.TLS, ppHead uintptr, pNew uintptr) uintptr { /* amatch.c:356:19: */
	var c int32
	var p uintptr = *(*uintptr)(unsafe.Pointer(ppHead))
	if p == uintptr(0) {
		p = pNew
		(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = uintptr(0)
	} else {
		for p != 0 {
			c = libc.Xstrcmp(tls, (*amatch_avl)(unsafe.Pointer(pNew)).FzKey, (*amatch_avl)(unsafe.Pointer(p)).FzKey)
			if c < 0 {
				if (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
					p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
				} else {
					(*amatch_avl)(unsafe.Pointer(p)).FpBefore = pNew
					(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else if c > 0 {
				if (*amatch_avl)(unsafe.Pointer(p)).FpAfter != 0 {
					p = (*amatch_avl)(unsafe.Pointer(p)).FpAfter
				} else {
					(*amatch_avl)(unsafe.Pointer(p)).FpAfter = pNew
					(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else {
				return p
			}
		}
	}
	(*amatch_avl)(unsafe.Pointer(pNew)).FpBefore = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pNew)).FpAfter = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pNew)).Fheight = int16(1)
	(*amatch_avl)(unsafe.Pointer(pNew)).Fimbalance = int16(0)
	*(*uintptr)(unsafe.Pointer(ppHead)) = amatchAvlBalance(tls, p)
	// assert( amatchAvlIntegrity(*ppHead) );
	// assert( amatchAvlIntegrity2(*ppHead) );
	return uintptr(0)
}

// Remove node pOld from the tree.  pOld must be an element of the tree or
// the AVL tree will become corrupt.
func amatchAvlRemove(tls *libc.TLS, ppHead uintptr, pOld uintptr) { /* amatch.c:399:13: */
	var ppParent uintptr
	var pBalance uintptr = uintptr(0)
	// assert( amatchAvlSearch(*ppHead, pOld->zKey)==pOld );
	ppParent = amatchAvlFromPtr(tls, pOld, ppHead)
	if ((*amatch_avl)(unsafe.Pointer(pOld)).FpBefore == uintptr(0)) && ((*amatch_avl)(unsafe.Pointer(pOld)).FpAfter == uintptr(0)) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = uintptr(0)
		pBalance = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	} else if ((*amatch_avl)(unsafe.Pointer(pOld)).FpBefore != 0) && ((*amatch_avl)(unsafe.Pointer(pOld)).FpAfter != 0) {
		var pX uintptr
		var pY uintptr
		pX = amatchAvlFirst(tls, (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter)
		*(*uintptr)(unsafe.Pointer(amatchAvlFromPtr(tls, pX, uintptr(0)))) = (*amatch_avl)(unsafe.Pointer(pX)).FpAfter
		if (*amatch_avl)(unsafe.Pointer(pX)).FpAfter != 0 {
			(*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(pX)).FpAfter)).FpUp = (*amatch_avl)(unsafe.Pointer(pX)).FpUp
		}
		pBalance = (*amatch_avl)(unsafe.Pointer(pX)).FpUp
		(*amatch_avl)(unsafe.Pointer(pX)).FpAfter = (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter
		if (*amatch_avl)(unsafe.Pointer(pX)).FpAfter != 0 {
			(*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(pX)).FpAfter)).FpUp = pX
		} else {

			pBalance = pX
		}
		(*amatch_avl)(unsafe.Pointer(pX)).FpBefore = libc.AssignUintptr(&pY, (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore)
		if pY != 0 {
			(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pX
		}
		(*amatch_avl)(unsafe.Pointer(pX)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
		*(*uintptr)(unsafe.Pointer(ppParent)) = pX
	} else if (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = libc.AssignUintptr(&pBalance, (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter)
		(*amatch_avl)(unsafe.Pointer(pBalance)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	} else if (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = libc.AssignUintptr(&pBalance, (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore)
		(*amatch_avl)(unsafe.Pointer(pBalance)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	}
	*(*uintptr)(unsafe.Pointer(ppHead)) = amatchAvlBalance(tls, pBalance)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpUp = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpBefore = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpAfter = uintptr(0)
	// assert( amatchAvlIntegrity(*ppHead) );
	// assert( amatchAvlIntegrity2(*ppHead) );
}

//
// End of the AVL Tree implementation
//

// Various types.
//
// amatch_cost is the "cost" of an edit operation.
//
// amatch_len is the length of a matching string.
//
// amatch_langid is an ruleset identifier.
type amatch_cost = int32   /* amatch.c:452:13 */
type amatch_len = int8     /* amatch.c:453:21 */
type amatch_langid = int32 /* amatch.c:454:13 */

// The two input rule lists are both sorted in order of increasing
// cost.  Merge them together into a single list, sorted by cost, and
// return a pointer to the head of that list.
func amatchMergeRules(tls *libc.TLS, pA uintptr, pB uintptr) uintptr { /* amatch.c:534:20: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var head amatch_rule at bp, 24

	var pTail uintptr

	pTail = bp /* &head */
	for (pA != 0) && (pB != 0) {
		if (*amatch_rule)(unsafe.Pointer(pA)).FrCost <= (*amatch_rule)(unsafe.Pointer(pB)).FrCost {
			(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*amatch_rule)(unsafe.Pointer(pA)).FpNext
		} else {
			(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*amatch_rule)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*amatch_rule)(unsafe.Pointer(bp /* &head */)).FpNext
}

// Statement pStmt currently points to a row in the amatch data table. This
// function allocates and populates a amatch_rule structure according to
// the content of the row.
//
// If successful, *ppRule is set to point to the new object and SQLITE_OK
// is returned. Otherwise, *ppRule is zeroed, *pzErr may be set to point
// to an error message and an SQLite error code returned.
func amatchLoadOneRule(tls *libc.TLS, p uintptr, pStmt uintptr, ppRule uintptr, pzErr uintptr) int32 { /* amatch.c:567:12: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var iLang sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
	var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 2)
	var rCost amatch_cost = sqlite3.Xsqlite3_column_int(tls, pStmt, 3)

	var rc int32 = SQLITE_OK       // Return code
	var nFrom int32                // Size of string zFrom, in bytes
	var nTo int32                  // Size of string zTo, in bytes
	var pRule uintptr = uintptr(0) // New rule object to return

	if zFrom == uintptr(0) {
		zFrom = ts + 489 /* "" */
	}
	if zTo == uintptr(0) {
		zTo = ts + 489 /* "" */
	}
	nFrom = int32(libc.Xstrlen(tls, zFrom))
	nTo = int32(libc.Xstrlen(tls, zTo))

	// Silently ignore null transformations
	if libc.Xstrcmp(tls, zFrom, zTo) == 0 {
		if (int32(*(*int8)(unsafe.Pointer(zFrom))) == '?') && (int32(*(*int8)(unsafe.Pointer(zFrom + 1))) == 0) {
			if ((*amatch_vtab)(unsafe.Pointer(p)).FrSub == 0) || ((*amatch_vtab)(unsafe.Pointer(p)).FrSub > rCost) {
				(*amatch_vtab)(unsafe.Pointer(p)).FrSub = rCost
			}
		}
		*(*uintptr)(unsafe.Pointer(ppRule)) = uintptr(0)
		return SQLITE_OK
	}

	if (rCost <= 0) || (rCost > AMATCH_MX_COST) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3165, /* "%s: cost must be..." */
			libc.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, AMATCH_MX_COST))
		rc = SQLITE_ERROR
	} else if (nFrom > AMATCH_MX_LENGTH) || (nTo > AMATCH_MX_LENGTH) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3199, /* "%s: maximum stri..." */
			libc.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, AMATCH_MX_LENGTH))
		rc = SQLITE_ERROR
	} else if (iLang < int64(0)) || (iLang > int64(AMATCH_MX_LANGID)) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3231, /* "%s: iLang must b..." */
			libc.VaList(bp+32, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, AMATCH_MX_LANGID))
		rc = SQLITE_ERROR
	} else if (libc.Xstrcmp(tls, zFrom, ts+489 /* "" */) == 0) && (libc.Xstrcmp(tls, zTo, ts+3266 /* "?" */) == 0) {
		if ((*amatch_vtab)(unsafe.Pointer(p)).FrIns == 0) || ((*amatch_vtab)(unsafe.Pointer(p)).FrIns > rCost) {
			(*amatch_vtab)(unsafe.Pointer(p)).FrIns = rCost
		}
	} else if (libc.Xstrcmp(tls, zFrom, ts+3266 /* "?" */) == 0) && (libc.Xstrcmp(tls, zTo, ts+489 /* "" */) == 0) {
		if ((*amatch_vtab)(unsafe.Pointer(p)).FrDel == 0) || ((*amatch_vtab)(unsafe.Pointer(p)).FrDel > rCost) {
			(*amatch_vtab)(unsafe.Pointer(p)).FrDel = rCost
		}
	} else {
		pRule = sqlite3.Xsqlite3_malloc64(tls, (uint64((uint32(unsafe.Sizeof(amatch_rule{})) + uint32(nFrom)) + uint32(nTo))))
		if pRule == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pRule, 0, uint32(unsafe.Sizeof(amatch_rule{})))
			(*amatch_rule)(unsafe.Pointer(pRule)).FzFrom = ((pRule + 18 /* &.zTo */) + uintptr((nTo + 1)))
			(*amatch_rule)(unsafe.Pointer(pRule)).FnFrom = amatch_len(nFrom)
			libc.Xmemcpy(tls, (*amatch_rule)(unsafe.Pointer(pRule)).FzFrom, zFrom, (uint32(nFrom + 1)))
			libc.Xmemcpy(tls, pRule+18 /* &.zTo */, zTo, (uint32(nTo + 1)))
			(*amatch_rule)(unsafe.Pointer(pRule)).FnTo = amatch_len(nTo)
			(*amatch_rule)(unsafe.Pointer(pRule)).FrCost = rCost
			(*amatch_rule)(unsafe.Pointer(pRule)).FiLang = int32(iLang)
		}
	}

	*(*uintptr)(unsafe.Pointer(ppRule)) = pRule
	return rc
}

// Free all the content in the edit-cost-table
func amatchFreeRules(tls *libc.TLS, p uintptr) { /* amatch.c:644:13: */
	for (*amatch_vtab)(unsafe.Pointer(p)).FpRule != 0 {
		var pRule uintptr = (*amatch_vtab)(unsafe.Pointer(p)).FpRule
		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = (*amatch_rule)(unsafe.Pointer(pRule)).FpNext
		sqlite3.Xsqlite3_free(tls, pRule)
	}
	(*amatch_vtab)(unsafe.Pointer(p)).FpRule = uintptr(0)
}

// Load the content of the amatch data table into memory.
func amatchLoadRules(tls *libc.TLS, db uintptr, p uintptr, pzErr uintptr) int32 { /* amatch.c:656:12: */
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var rc int32 = SQLITE_OK // Return code
	var zSql uintptr         // SELECT used to read from rules table
	var pHead uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+3268 /* "SELECT * FROM %Q..." */, libc.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzDb, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab))
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var rc2 int32 // finalize() return code
		*(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+56 /* &pStmt */, uintptr(0))
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3288 /* "%s: %s" */, libc.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, sqlite3.Xsqlite3_errmsg(tls, db)))
		} else if sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */))) != 4 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3295, /* "%s: %s has %d co..." */
				libc.VaList(bp+32, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))))
			rc = SQLITE_ERROR
		} else {
			for (rc == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))) {
				*(*uintptr)(unsafe.Pointer(bp + 60 /* pRule */)) = uintptr(0)
				rc = amatchLoadOneRule(tls, p, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)), bp+60 /* &pRule */, pzErr)
				if *(*uintptr)(unsafe.Pointer(bp + 60 /* pRule */)) != 0 {
					(*amatch_rule)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 60 /* pRule */)))).FpNext = pHead
					pHead = *(*uintptr)(unsafe.Pointer(bp + 60 /* pRule */))
				}
			}
		}
		rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))
		if rc == SQLITE_OK {
			rc = rc2
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	// All rules are now in a singly linked list starting at pHead. This
	// block sorts them by cost and then sets amatch_vtab.pRule to point to
	// point to the head of the sorted list.
	if rc == SQLITE_OK {
		var i uint32
		var pX uintptr
		// var a [15]uintptr at bp+64, 60

		for i = uint32(0); i < (uint32(unsafe.Sizeof([15]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0)))); i++ {
			*(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)) = uintptr(0)
		}
		for (libc.AssignUintptr(&pX, pHead)) != uintptr(0) {
			pHead = (*amatch_rule)(unsafe.Pointer(pX)).FpNext
			(*amatch_rule)(unsafe.Pointer(pX)).FpNext = uintptr(0)
			for i = uint32(0); (*(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)) != 0) && (i < ((uint32(unsafe.Sizeof([15]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0)))) - uint32(1))); i++ {
				pX = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)), pX)
				*(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)) = uintptr(0)
			}
			*(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)) = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)), pX)
		}
		pX = *(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */))
		i = uint32(1)
		for ; i < (uint32(unsafe.Sizeof([15]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0)))); i++ {
			pX = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)), pX)
		}
		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = amatchMergeRules(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpRule, pX)
	} else {
		// An error has occurred. Setting p->pRule to point to the head of the
		// allocated list ensures that the list will be cleaned up in this case.

		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = pHead
	}

	return rc
}

// This function converts an SQL quoted string into an unquoted string
// and returns a pointer to a buffer allocated using sqlite3_malloc()
// containing the result. The caller should eventually free this buffer
// using sqlite3_free.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func amatchDequote(tls *libc.TLS, zIn uintptr) uintptr { /* amatch.c:740:13: */
	var nIn sqlite3_int64 // Size of input string, in bytes
	var zOut uintptr      // Output (dequoted) string

	nIn = sqlite3_int64(libc.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, (uint64(nIn + int64(1))))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn)) // Quote character (if any )

		if (((int32(q) != '[') && (int32(q) != '\'')) && (int32(q) != '"')) && (int32(q) != '`') {
			libc.Xmemcpy(tls, zOut, zIn, (size_t(nIn + int64(1))))
		} else {
			var iOut int32 = 0 // Index of next byte to write to output
			var iIn int32      // Index of next byte to read from input

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}

	}
	return zOut
}

// Deallocate the pVCheck prepared statement.
func amatchVCheckClear(tls *libc.TLS, p uintptr) { /* amatch.c:769:13: */
	if (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
		(*amatch_vtab)(unsafe.Pointer(p)).FpVCheck = uintptr(0)
	}
}

// Deallocate an amatch_vtab object
func amatchFree(tls *libc.TLS, p uintptr) { /* amatch.c:779:13: */
	if p != 0 {
		amatchFreeRules(tls, p)
		amatchVCheckClear(tls, p)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzDb)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf)
		libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(amatch_vtab{})))
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// xDisconnect/xDestroy method for the amatch module.
func amatchDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* amatch.c:798:12: */
	var p uintptr = pVtab

	amatchFree(tls, p)
	return SQLITE_OK
}

// Check to see if the argument is of the form:
//
//       KEY = VALUE
//
// If it is, return a pointer to the first character of VALUE.
// If not, return NULL.  Spaces around the = are ignored.
func amatchValueOfKey(tls *libc.TLS, zKey uintptr, zStr uintptr) uintptr { /* amatch.c:813:19: */
	var nKey int32 = int32(libc.Xstrlen(tls, zKey))
	var nStr int32 = int32(libc.Xstrlen(tls, zStr))
	var i int32
	if nStr < (nKey + 1) {
		return uintptr(0)
	}
	if libc.Xmemcmp(tls, zStr, zKey, uint32(nKey)) != 0 {
		return uintptr(0)
	}
	for i = nKey; (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))))*2))) & int32(_ISspace)) != 0; i++ {
	}
	if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) != '=' {
		return uintptr(0)
	}
	i++
	for (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))))*2))) & int32(_ISspace)) != 0 {
		i++
	}
	return (zStr + uintptr(i))
}

// xConnect/xCreate method for the amatch module. Arguments are:
//
//   argv[0]    -> module name  ("approximate_match")
//   argv[1]    -> database name
//   argv[2]    -> table name
//   argv[3...] -> arguments
func amatchConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* amatch.c:834:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32     // Return code
	var pNew uintptr // New virtual table
	var zModule uintptr
	var zDb uintptr
	var zVal uintptr
	var i int32
	rc = SQLITE_OK
	pNew = uintptr(0)
	zModule = *(*uintptr)(unsafe.Pointer(argv))
	zDb = *(*uintptr)(unsafe.Pointer(argv + 1*4))

	_ = pAux
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(amatch_vtab{})))
	if !(pNew == uintptr(0)) {
		goto __1
	}
	return SQLITE_NOMEM
__1:
	;
	rc = SQLITE_NOMEM
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(amatch_vtab{})))
	(*amatch_vtab)(unsafe.Pointer(pNew)).Fdb = db
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzClassName = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zModule))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzClassName == uintptr(0)) {
		goto __2
	}
	goto amatchConnectError
__2:
	;
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzDb = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, zDb))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzDb == uintptr(0)) {
		goto __3
	}
	goto amatchConnectError
__3:
	;
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzSelf = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzSelf == uintptr(0)) {
		goto __4
	}
	goto amatchConnectError
__4:
	;
	i = 3
__5:
	if !(i < argc) {
		goto __7
	}
	zVal = amatchValueOfKey(tls, ts+3329 /* "vocabulary_table" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __8
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab == uintptr(0)) {
		goto __9
	}
	goto amatchConnectError
__9:
	;
	goto __6
__8:
	;
	zVal = amatchValueOfKey(tls, ts+3346 /* "vocabulary_word" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __10
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord == uintptr(0)) {
		goto __11
	}
	goto amatchConnectError
__11:
	;
	goto __6
__10:
	;
	zVal = amatchValueOfKey(tls, ts+3362 /* "vocabulary_langu..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __12
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang == uintptr(0)) {
		goto __13
	}
	goto amatchConnectError
__13:
	;
	goto __6
__12:
	;
	zVal = amatchValueOfKey(tls, ts+3382 /* "edit_distances" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __14
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab == uintptr(0)) {
		goto __15
	}
	goto amatchConnectError
__15:
	;
	goto __6
__14:
	;
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3397 /* "unrecognized arg..." */, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
	amatchFree(tls, pNew)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	return SQLITE_ERROR
	goto __6
__6:
	i++
	goto __5
	goto __7
__7:
	;
	rc = SQLITE_OK
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab == uintptr(0)) {
		goto __16
	}
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3426 /* "no edit_distance..." */, 0)
	rc = SQLITE_ERROR
	goto __17
__16:
	rc = amatchLoadRules(tls, db, pNew, pzErr)
__17:
	;
	if !(rc == SQLITE_OK) {
		goto __18
	}
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,

		ts+3460 /* "CREATE TABLE x(w..." */)
__18:
	;
	if !(rc != SQLITE_OK) {
		goto __19
	}
	amatchFree(tls, pNew)
__19:
	;
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pNew /* &.base */)
	return rc

amatchConnectError:
	amatchFree(tls, pNew)
	return rc
}

// Open a new amatch cursor.
func amatchOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* amatch.c:928:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(amatch_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(amatch_cursor{})))
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	(*amatch_vtab)(unsafe.Pointer(p)).FnCursor++
	return SQLITE_OK
}

// Free up all the memory allocated by a cursor.  Set it rLimit to 0
// to indicate that it is at EOF.
func amatchClearCursor(tls *libc.TLS, pCur uintptr) { /* amatch.c:944:13: */
	var pWord uintptr
	var pNextWord uintptr
	for pWord = (*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords; pWord != 0; pWord = pNextWord {
		pNextWord = (*amatch_word)(unsafe.Pointer(pWord)).FpNext
		sqlite3.Xsqlite3_free(tls, pWord)
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzInput)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzInput = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = 0
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCost = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpWord = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit = 1000000
	(*amatch_cursor)(unsafe.Pointer(pCur)).FiLang = 0
	(*amatch_cursor)(unsafe.Pointer(pCur)).FnWord = 0
}

// Close a amatch cursor.
func amatchClose(tls *libc.TLS, cur uintptr) int32 { /* amatch.c:967:12: */
	var pCur uintptr = cur
	amatchClearCursor(tls, pCur)
	(*amatch_vtab)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Render a 24-bit unsigned integer as a 4-byte base-64 number.
func amatchEncodeInt(tls *libc.TLS, x int32, z uintptr) { /* amatch.c:978:13: */
	*(*int8)(unsafe.Pointer(z)) = a[((x >> 18) & 0x3f)]
	*(*int8)(unsafe.Pointer(z + 1)) = a[((x >> 12) & 0x3f)]
	*(*int8)(unsafe.Pointer(z + 2)) = a[((x >> 6) & 0x3f)]
	*(*int8)(unsafe.Pointer(z + 3)) = a[(x & 0x3f)]
}

var a = *(*[65]int8)(unsafe.Pointer(ts + 3527 /* "0123456789ABCDEF..." */)) /* amatch.c:979:21 */

// Write the zCost[] field for a amatch_word object
func amatchWriteCost(tls *libc.TLS, pWord uintptr) { /* amatch.c:996:13: */
	amatchEncodeInt(tls, (*amatch_word)(unsafe.Pointer(pWord)).FrCost, pWord+60 /* &.zCost */)
	amatchEncodeInt(tls, (*amatch_word)(unsafe.Pointer(pWord)).FiSeq, ((pWord + 60 /* &.zCost */) + uintptr(4)))
	*(*int8)(unsafe.Pointer((pWord + 60 /* &.zCost */) + 8)) = int8(0)
}

// Circumvent compiler warnings about the use of strcpy() by supplying
// our own implementation.
func amatchStrcpy(tls *libc.TLS, dest uintptr, src uintptr) { /* amatch.c:1005:13: */
	for (int32(libc.AssignPtrInt8(libc.PostIncUintptr(&dest, 1), *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&src, 1)))))) != 0 {
	}
}

func amatchStrcat(tls *libc.TLS, dest uintptr, src uintptr) { /* amatch.c:1008:13: */
	for *(*int8)(unsafe.Pointer(dest)) != 0 {
		dest++
	}
	amatchStrcpy(tls, dest, src)
}

// Add a new amatch_word object to the queue.
//
// If a prior amatch_word object with the same zWord, and nMatch
// already exists, update its rCost (if the new rCost is less) but
// otherwise leave it unchanged.  Do not add a duplicate.
//
// Do nothing if the cost exceeds threshold.
func amatchAddWord(tls *libc.TLS, pCur uintptr, rCost amatch_cost, nMatch int32, zWordBase uintptr, zWordTail uintptr) { /* amatch.c:1022:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pWord uintptr
	var pNode uintptr
	var pOther uintptr
	_ = pOther
	var nBase int32
	var nTail int32
	// var zBuf [4]int8 at bp, 4

	if rCost > (*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit {
		return
	}
	nBase = int32(libc.Xstrlen(tls, zWordBase))
	nTail = int32(libc.Xstrlen(tls, zWordTail))
	if ((nBase + nTail) + 3) > (*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = ((nBase + nTail) + 100)
		(*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf = sqlite3.Xsqlite3_realloc(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf, (*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf)
		if (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf == uintptr(0) {
			(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = 0
			return
		}
	}
	amatchEncodeInt(tls, nMatch, bp /* &zBuf[0] */)
	libc.Xmemcpy(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf, (bp /* &zBuf[0] */ + uintptr(2)), uint32(2))
	libc.Xmemcpy(tls, ((*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf + uintptr(2)), zWordBase, uint32(nBase))
	libc.Xmemcpy(tls, (((*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf + uintptr(2)) + uintptr(nBase)), zWordTail, (uint32(nTail + 1)))
	pNode = amatchAvlSearch(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FpWord, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	if pNode != 0 {
		pWord = (*amatch_avl)(unsafe.Pointer(pNode)).FpWord
		if (*amatch_word)(unsafe.Pointer(pWord)).FrCost > rCost {
			amatchAvlRemove(tls, (pCur + 56 /* &.pCost */), (pWord + 4 /* &.sCost */))
			(*amatch_word)(unsafe.Pointer(pWord)).FrCost = rCost
			amatchWriteCost(tls, pWord)
			pOther = amatchAvlInsert(tls, (pCur + 56 /* &.pCost */), (pWord + 4 /* &.sCost */))
			_ = pOther
		}
		return
	}
	pWord = sqlite3.Xsqlite3_malloc64(tls, (uint64(((uint32(unsafe.Sizeof(amatch_word{})) + uint32(nBase)) + uint32(nTail)) - uint32(1))))
	if pWord == uintptr(0) {
		return
	}
	libc.Xmemset(tls, pWord, 0, uint32(unsafe.Sizeof(amatch_word{})))
	(*amatch_word)(unsafe.Pointer(pWord)).FrCost = rCost
	(*amatch_word)(unsafe.Pointer(pWord)).FiSeq = libc.PostIncInt32(&(*amatch_cursor)(unsafe.Pointer(pCur)).FnWord, 1)
	amatchWriteCost(tls, pWord)
	(*amatch_word)(unsafe.Pointer(pWord)).FnMatch = int16(nMatch)
	(*amatch_word)(unsafe.Pointer(pWord)).FpNext = (*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords = pWord
	(*amatch_word)(unsafe.Pointer(pWord)).FsCost.FzKey = pWord + 60 /* &.zCost */
	(*amatch_word)(unsafe.Pointer(pWord)).FsCost.FpWord = pWord
	pOther = amatchAvlInsert(tls, (pCur + 56 /* &.pCost */), (pWord + 4 /* &.sCost */))
	_ = pOther
	(*amatch_word)(unsafe.Pointer(pWord)).FsWord.FzKey = pWord + 72 /* &.zWord */
	(*amatch_word)(unsafe.Pointer(pWord)).FsWord.FpWord = pWord
	amatchStrcpy(tls, pWord+72 /* &.zWord */, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	pOther = amatchAvlInsert(tls, (pCur + 60 /* &.pWord */), (pWord + 28 /* &.sWord */))
	_ = pOther
}

// Advance a cursor to its next row of output
func amatchNext(tls *libc.TLS, cur uintptr) int32 { /* amatch.c:1102:12: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var pCur uintptr = cur
	var pWord uintptr = uintptr(0)
	var pNode uintptr
	var isMatch int32 = 0
	var p uintptr = (*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab
	var nWord int32
	var rc int32
	var i int32
	var zW uintptr
	var pRule uintptr
	var zBuf uintptr = uintptr(0)
	var nBuf int8 = int8(0)
	// var zNext [8]int8 at bp+64, 8

	// var zNextIn [8]int8 at bp+72, 8

	var nNextIn int32

	if (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck == uintptr(0) {
		var zSql uintptr
		if ((*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang != 0) && (*(*int8)(unsafe.Pointer((*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang)) != 0) {
			zSql = sqlite3.Xsqlite3_mprintf(tls,
				ts+3592, /* "SELECT \"%w\" FROM..." */

				libc.VaList(bp, ts+3614, /* " WHERE \"%w\">=?1 ..." */
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab,
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang))
		} else {
			zSql = sqlite3.Xsqlite3_mprintf(tls,

				ts+3653, /* "SELECT \"%w\" FROM..." */
				libc.VaList(bp+40, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab,
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord))
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*amatch_vtab)(unsafe.Pointer(p)).Fdb, zSql, -1, (p + 60 /* &.pVCheck */), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != 0 {
			return rc
		}
	}
	sqlite3.Xsqlite3_bind_int(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 2, (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang)

	for ok := true; ok; ok = !(isMatch != 0) {
		pNode = amatchAvlFirst(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FpCost)
		if pNode == uintptr(0) {
			pWord = uintptr(0)
			break
		}
		pWord = (*amatch_avl)(unsafe.Pointer(pNode)).FpWord
		amatchAvlRemove(tls, (pCur + 56 /* &.pCost */), (pWord + 4 /* &.sCost */))

		nWord = int32(libc.Xstrlen(tls, ((pWord + 72 /* &.zWord */) + uintptr(2))))
		if (nWord + 20) > int32(nBuf) {
			nBuf = (int8(nWord + 100))
			zBuf = sqlite3.Xsqlite3_realloc(tls, zBuf, int32(nBuf))
			if zBuf == uintptr(0) {
				return SQLITE_NOMEM
			}
		}
		amatchStrcpy(tls, zBuf, ((pWord + 72 /* &.zWord */) + uintptr(2)))
		*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */)) = int8(0)
		*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */)) = *(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)))
		if *(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */)) != 0 {
			for i = 1; (i <= 4) && ((int32(*(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr((int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + i))))) & 0xc0) == 0x80); i++ {
				*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(i))) = *(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr((int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + i))))
			}
			*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(i))) = int8(0)
			nNextIn = i
		} else {
			nNextIn = 0
		}

		if (*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */)) != 0) && (int32(*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */))) != '*') {
			sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			amatchStrcat(tls, zBuf, bp+72 /* &zNextIn[0] */)
			sqlite3.Xsqlite3_bind_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 1, zBuf, (nWord + nNextIn), uintptr(0))
			rc = sqlite3.Xsqlite3_step(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			if rc == SQLITE_ROW {
				zW = sqlite3.Xsqlite3_column_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 0)
				if libc.Xstrncmp(tls, zBuf, zW, (uint32(nWord+nNextIn))) == 0 {
					amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost, (int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + nNextIn), zBuf, ts+489 /* "" */)
				}
			}
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
		}

		for 1 != 0 {
			amatchStrcpy(tls, (zBuf + uintptr(nWord)), bp+64 /* &zNext[0] */)
			sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			sqlite3.Xsqlite3_bind_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 1, zBuf, -1, libc.UintptrFromInt32(-1))
			rc = sqlite3.Xsqlite3_step(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			if rc != SQLITE_ROW {
				break
			}
			zW = sqlite3.Xsqlite3_column_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 0)
			amatchStrcpy(tls, (zBuf + uintptr(nWord)), bp+64 /* &zNext[0] */)
			if libc.Xstrncmp(tls, zW, zBuf, uint32(nWord)) != 0 {
				break
			}
			if ((int32(*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */))) == '*') && (int32(*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + 1))) == 0)) ||
				((int32(*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */))) == 0) && (int32(*(*int8)(unsafe.Pointer(zW + uintptr(nWord)))) == 0)) {
				isMatch = 1
				*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */)) = int8(0)
				nNextIn = 0
				break
			}
			*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */)) = *(*int8)(unsafe.Pointer(zW + uintptr(nWord)))
			for i = 1; (i <= 4) && ((int32(*(*int8)(unsafe.Pointer(zW + uintptr((nWord + i))))) & 0xc0) == 0x80); i++ {
				*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr(i))) = *(*int8)(unsafe.Pointer(zW + uintptr((nWord + i))))
			}
			*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr(i))) = int8(0)
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
			if (*amatch_vtab)(unsafe.Pointer(p)).FrIns > 0 {
				amatchAddWord(tls, pCur, ((*amatch_word)(unsafe.Pointer(pWord)).FrCost + (*amatch_vtab)(unsafe.Pointer(p)).FrIns), int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch),
					zBuf, bp+64 /* &zNext[0] */)
			}
			if (*amatch_vtab)(unsafe.Pointer(p)).FrSub > 0 {
				amatchAddWord(tls, pCur, ((*amatch_word)(unsafe.Pointer(pWord)).FrCost + (*amatch_vtab)(unsafe.Pointer(p)).FrSub), (int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + nNextIn),
					zBuf, bp+64 /* &zNext[0] */)
			}
			if ((*amatch_vtab)(unsafe.Pointer(p)).FrIns < 0) && ((*amatch_vtab)(unsafe.Pointer(p)).FrSub < 0) {
				break
			}
			*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr((i - 1))))++ // FIX ME
		}
		sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)

		if (*amatch_vtab)(unsafe.Pointer(p)).FrDel > 0 {
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
			amatchAddWord(tls, pCur, ((*amatch_word)(unsafe.Pointer(pWord)).FrCost + (*amatch_vtab)(unsafe.Pointer(p)).FrDel), (int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + nNextIn),
				zBuf, ts+489 /* "" */)
		}

		for pRule = (*amatch_vtab)(unsafe.Pointer(p)).FpRule; pRule != 0; pRule = (*amatch_rule)(unsafe.Pointer(pRule)).FpNext {
			if (*amatch_rule)(unsafe.Pointer(pRule)).FiLang != (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang {
				continue
			}
			if libc.Xstrncmp(tls, (*amatch_rule)(unsafe.Pointer(pRule)).FzFrom, ((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput+uintptr((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)), uint32((*amatch_rule)(unsafe.Pointer(pRule)).FnFrom)) == 0 {
				amatchAddWord(tls, pCur, ((*amatch_word)(unsafe.Pointer(pWord)).FrCost + (*amatch_rule)(unsafe.Pointer(pRule)).FrCost),
					(int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + int32((*amatch_rule)(unsafe.Pointer(pRule)).FnFrom)), ((pWord + 72 /* &.zWord */) + uintptr(2)), pRule+18 /* &.zTo */)
			}
		}
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent = pWord
	sqlite3.Xsqlite3_free(tls, zBuf)
	return SQLITE_OK
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any amatchColumn, amatchRowid, or amatchEof call.
func amatchFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* amatch.c:1251:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	var zWord uintptr = ts + 3701 /* "*" */
	var idx int32

	amatchClearCursor(tls, pCur)
	idx = 0
	if (idxNum & 1) != 0 {
		zWord = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		idx++
	}
	if (idxNum & 2) != 0 {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*4)))
		idx++
	}
	if (idxNum & 4) != 0 {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FiLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*4)))
		idx++
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzInput = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zWord))
	if (*amatch_cursor)(unsafe.Pointer(pCur)).FzInput == uintptr(0) {
		return SQLITE_NOMEM
	}
	amatchAddWord(tls, pCur, 0, 0, ts+489 /* "" */, ts+489 /* "" */)
	amatchNext(tls, pVtabCursor)

	return SQLITE_OK
}

// Only the word and distance columns have values.  All other columns
// return NULL
func amatchColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* amatch.c:1286:12: */
	var pCur uintptr = cur
	switch i {
	case AMATCH_COL_WORD:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (((*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent + 72 /* &.zWord */) + uintptr(2)), -1, uintptr(0))
			break

		}
	case AMATCH_COL_DISTANCE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_word)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent)).FrCost)
			break

		}
	case AMATCH_COL_LANGUAGE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang)
			break

		}
	case AMATCH_COL_NWORD:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_cursor)(unsafe.Pointer(pCur)).FnWord)
			break

		}
	default:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break

		}
	}
	return SQLITE_OK
}

// The rowid.
func amatchRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* amatch.c:1316:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*amatch_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// EOF indicator
func amatchEof(tls *libc.TLS, cur uintptr) int32 { /* amatch.c:1325:12: */
	var pCur uintptr = cur
	return (libc.Bool32((*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent == uintptr(0)))
}

// Search for terms of these forms:
//
//   (A)    word MATCH $str
//   (B1)   distance < $value
//   (B2)   distance <= $value
//   (C)    language == $language
//
// The distance< and distance<= are both treated as distance<=.
// The query plan number is a bit vector:
//
//   bit 1:   Term of the form (A) found
//   bit 2:   Term like (B1) or (B2) found
//   bit 3:   Term like (C) found
//
// If bit-1 is set, $str is always in filter.argv[0].  If bit-2 is set
// then $value is in filter.argv[0] if bit-1 is clear and is in
// filter.argv[1] if bit-1 is set.  If bit-3 is set, then $ruleid is
// in filter.argv[0] if bit-1 and bit-2 are both zero, is in
// filter.argv[1] if exactly one of bit-1 and bit-2 are set, and is in
// filter.argv[2] if both bit-1 and bit-2 are set.
func amatchBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* amatch.c:1352:12: */
	var iPlan int32 = 0
	var iDistTerm int32 = -1
	var iLangTerm int32 = -1
	var i int32
	var pConstraint uintptr

	_ = tab
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if (((iPlan & 1) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH) {
			iPlan = iPlan | (1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}
		if (((iPlan & 2) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 1)) &&
			((int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT) ||
				(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE)) {
			iPlan = iPlan | (2)
			iDistTerm = i
		}
		if (((iPlan & 4) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 2)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | (4)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			iLangTerm = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (iPlan & 2) != 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = (1 + (libc.Bool32((iPlan & 1) != 0)))
	}
	if (iPlan & 4) != 0 {
		var idx int32 = 1
		if (iPlan & 1) != 0 {
			idx++
		}
		if (iPlan & 2) != 0 {
			idx++
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).FargvIndex = idx
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) &&
		((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == 1)) &&
		(int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0) {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10000)

	return SQLITE_OK
}

// The xUpdate() method.
//
// This implementation disallows DELETE and UPDATE.  The only thing
// allowed is INSERT into the "command" column.
func amatchUpdate(tls *libc.TLS, pVTab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 { /* amatch.c:1418:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr = pVTab
	var zCmd uintptr
	_ = pRowid
	if argc == 1 {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+3703, /* "DELETE from %s i..." */
			libc.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return SQLITE_ERROR
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) != SQLITE_NULL {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+3733, /* "UPDATE of %s is ..." */
			libc.VaList(bp+8, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return SQLITE_ERROR
	}
	if ((sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4))) != SQLITE_NULL) ||
		(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4))) != SQLITE_NULL)) ||
		(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4))) != SQLITE_NULL) {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
			ts+3761 /* "INSERT INTO %s a..." */, libc.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return SQLITE_ERROR
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 5*4)))
	if zCmd == uintptr(0) {
		return SQLITE_OK
	}

	return SQLITE_OK
}

// A virtual table module that implements the "approximate_match".
var amatchModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRowid - read data
	FxUpdate:     0, // xShadowName
} /* amatch.c:1454:23 */

// Register the amatch virtual table
func sqlite3_amatch_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* amatch.c:1489:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Not used
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+3810 /* "approximate_matc..." */, uintptr(unsafe.Pointer(&amatchModule)), uintptr(0))
	return rc
}

// Allowed values for the mFlags parameter to sqlite3_carray_bind().
// Must exactly match the definitions in carray.h.

// Names of allowed datatypes
var azType = [4]uintptr{ts + 3828 /* "int32" */, ts + 3834 /* "int64" */, ts + 2423 /* "double" */, ts + 3840 /* "char*" */} /* carray.c:73:19 */

// Structure used to hold the sqlite3_carray_bind() information
type carray_bind1 = struct {
	FaData  uintptr
	FnData  int32
	FmFlags int32
	FxDel   uintptr
} /* carray.c:78:9 */

// Structure used to hold the sqlite3_carray_bind() information
type carray_bind = carray_bind1 /* carray.c:78:28 */

// carray_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type carray_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	_       [4]byte
	FiRowid sqlite3_int64
	FpPtr   uintptr
	_       [4]byte
	FiCnt   sqlite3_int64
	FeType  uint8
	_       [7]byte
} /* carray.c:91:9 */

// carray_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type carray_cursor = carray_cursor1 /* carray.c:91:30 */

// The carrayConnect() method is invoked to create a new
// carray_vtab that describes the carray virtual table.
//
// Think of this routine as the constructor for carray_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the carray_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against carray will look like.
func carrayConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* carray.c:113:12: */
	var pNew uintptr
	var rc int32

	// Column numbers

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+3846 /* "CREATE TABLE x(v..." */)
	if rc == SQLITE_OK {
		pNew = libc.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(sqlite3_vtab{})))
	}
	return rc
}

// This method is the destructor for carray_cursor objects.
func carrayDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* carray.c:142:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// Constructor for a new carray_cursor object.
func carrayOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* carray.c:150:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(carray_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(carray_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Destructor for a carray_cursor.
func carrayClose(tls *libc.TLS, cur uintptr) int32 { /* carray.c:162:12: */
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

// Advance a carray_cursor to its next row of output.
func carrayNext(tls *libc.TLS, cur uintptr) int32 { /* carray.c:171:12: */
	var pCur uintptr = cur
	(*carray_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return SQLITE_OK
}

// Return values of columns for the row at which the carray_cursor
// is currently pointing.
func carrayColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* carray.c:181:12: */
	var pCur uintptr = cur
	var x sqlite3_int64 = int64(0)
	switch i {
	case CARRAY_COLUMN_POINTER:
		return SQLITE_OK
	case CARRAY_COLUMN_COUNT:
		x = (*carray_cursor)(unsafe.Pointer(pCur)).FiCnt
		break
	case CARRAY_COLUMN_CTYPE:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, azType[(*carray_cursor)(unsafe.Pointer(pCur)).FeType], -1, uintptr(0))
			return SQLITE_OK

		}
	default:
		{
			switch int32((*carray_cursor)(unsafe.Pointer(pCur)).FeType) {
			case CARRAY_INT32:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_int(tls, ctx, *(*int32)(unsafe.Pointer(p + uintptr(((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1)))*4)))
					return SQLITE_OK

				}
			case CARRAY_INT64:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_int64(tls, ctx, *(*sqlite3_int64)(unsafe.Pointer(p + uintptr(((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1)))*8)))
					return SQLITE_OK

				}
			case CARRAY_DOUBLE:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_double(tls, ctx, *(*float64)(unsafe.Pointer(p + uintptr(((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1)))*8)))
					return SQLITE_OK

				}
			case CARRAY_TEXT:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_text(tls, ctx, *(*uintptr)(unsafe.Pointer(p + uintptr(((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1)))*4)), -1, libc.UintptrFromInt32(-1))
					return SQLITE_OK

				}
			}

		}
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, x)
	return SQLITE_OK
}

// Return the rowid for the current row.  In this implementation, the
// rowid is the same as the output value.
func carrayRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* carray.c:228:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*carray_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func carrayEof(tls *libc.TLS, cur uintptr) int32 { /* carray.c:238:12: */
	var pCur uintptr = cur
	return (libc.Bool32((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid > (*carray_cursor)(unsafe.Pointer(pCur)).FiCnt))
}

// This method is called to "rewind" the carray_cursor object back
// to the first row of output.
func carrayFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* carray.c:247:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = uintptr(0)
	(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = int64(0)
	switch idxNum {
	case 1:
		{
			var pBind uintptr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv)), ts+3909 /* "carray-bind" */)
			if pBind == uintptr(0) {
				break
			}
			(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = (*carray_bind)(unsafe.Pointer(pBind)).FaData
			(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = sqlite3_int64((*carray_bind)(unsafe.Pointer(pBind)).FnData)
			(*carray_cursor)(unsafe.Pointer(pCur)).FeType = (uint8((*carray_bind)(unsafe.Pointer(pBind)).FmFlags & 0x03))
			break

		}
	case 2:
		fallthrough
	case 3:
		{
			(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv)), ts+3921 /* "carray" */)
			(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = func() int64 {
				if (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr != 0 {
					return sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
				}
				return int64(0)
			}()
			if idxNum < 3 {
				(*carray_cursor)(unsafe.Pointer(pCur)).FeType = uint8(CARRAY_INT32)
			} else {
				var i uint8
				var zType uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
				for i = uint8(0); uint32(i) < (uint32(unsafe.Sizeof(azType)) / uint32(unsafe.Sizeof(uintptr(0)))); i++ {
					if sqlite3.Xsqlite3_stricmp(tls, zType, azType[i]) == 0 {
						break
					}
				}
				if uint32(i) >= (uint32(unsafe.Sizeof(azType)) / uint32(unsafe.Sizeof(uintptr(0)))) {
					(*sqlite3_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
						ts+3928 /* "unknown datatype..." */, libc.VaList(bp, zType))
					return SQLITE_ERROR
				} else {
					(*carray_cursor)(unsafe.Pointer(pCur)).FeType = i
				}
			}
			break

		}
	}
	(*carray_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
	return SQLITE_OK
}

// SQLite will invoke this method one or more times while planning a query
// that uses the carray virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
//
// In this implementation idxNum is used to represent the
// query plan.  idxStr is unused.
//
// idxNum is:
//
//    1    If only the pointer= constraint exists.  In this case, the
//         parameter must be bound using sqlite3_carray_bind().
//
//    2    if the pointer= and count= constraints exist.
//
//    3    if the ctype= constraint also exists.
//
// idxNum is 0 otherwise and carray becomes an empty table.
func carrayBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* carray.c:311:12: */
	var i int32             // Loop over constraints
	var ptrIdx int32 = -1   // Index of the pointer= constraint, or -1 if none
	var cntIdx int32 = -1   // Index of the count= constraint, or -1 if none
	var ctypeIdx int32 = -1 // Index of the ctype= constraint, or -1 if none

	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) != SQLITE_INDEX_CONSTRAINT_EQ {
			goto __2
		}
		switch (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn {
		case CARRAY_COLUMN_POINTER:
			ptrIdx = i
			break
		case CARRAY_COLUMN_COUNT:
			cntIdx = i
			break
		case CARRAY_COLUMN_CTYPE:
			ctypeIdx = i
			break
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if ptrIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ptrIdx)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ptrIdx)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(100)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
		if cntIdx >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(cntIdx)*8)).FargvIndex = 2
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(cntIdx)*8)).Fomit = uint8(1)
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 2
			if ctypeIdx >= 0 {
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ctypeIdx)*8)).FargvIndex = 3
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ctypeIdx)*8)).Fomit = uint8(1)
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 3
			}
		}
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(2147483647)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(2147483647)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
	}
	return SQLITE_OK
}

// This following structure defines all the methods for the
// carray virtual table.
var carrayModule = sqlite3_module{ // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* carray.c:365:23 */

// Destructor for the carray_bind object
func carrayBindDel(tls *libc.TLS, pPtr uintptr) { /* carray.c:391:13: */
	var p uintptr = pPtr
	if (*carray_bind)(unsafe.Pointer(p)).FxDel != (uintptr(0)) {
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((p + 12 /* &.xDel */))))(tls, (*carray_bind)(unsafe.Pointer(p)).FaData)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

// Invoke this interface in order to bind to the single-argument
// version of CARRAY().
func sqlite3_carray_bind(tls *libc.TLS, pStmt uintptr, idx int32, aData uintptr, nData int32, mFlags int32, xDestroy uintptr) int32 { /* carray.c:406:5: */
	var pNew uintptr
	var i int32
	pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(carray_bind{})))
	if pNew == uintptr(0) {
		if (xDestroy != (uintptr(0))) && (xDestroy != (libc.UintptrFromInt32(-1))) {
			(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&xDestroy)))(tls, aData)
		}
		return SQLITE_NOMEM
	}
	(*carray_bind)(unsafe.Pointer(pNew)).FnData = nData
	(*carray_bind)(unsafe.Pointer(pNew)).FmFlags = mFlags
	if xDestroy == (libc.UintptrFromInt32(-1)) {
		var sz sqlite3_int64 = sqlite3_int64(nData)
		switch mFlags & 0x03 {
		case CARRAY_INT32:
			sz = sz * (int64(4))
			break
			fallthrough
		case CARRAY_INT64:
			sz = sz * (int64(8))
			break
			fallthrough
		case CARRAY_DOUBLE:
			sz = sz * (int64(8))
			break
			fallthrough
		case CARRAY_TEXT:
			sz = sz * (sqlite3_int64(unsafe.Sizeof(uintptr(0))))
			break
		}
		if (mFlags & 0x03) == CARRAY_TEXT {
			for i = 0; i < nData; i++ {
				var z uintptr = *(*uintptr)(unsafe.Pointer((aData) + uintptr(i)*4))
				if z != 0 {
					sz = sz + (sqlite3_int64(libc.Xstrlen(tls, z) + size_t(1)))
				}
			}
		}
		(*carray_bind)(unsafe.Pointer(pNew)).FaData = sqlite3.Xsqlite3_malloc64(tls, uint64(sz))
		if (*carray_bind)(unsafe.Pointer(pNew)).FaData == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, pNew)
			return SQLITE_NOMEM
		}
		if (mFlags & 0x03) == CARRAY_TEXT {
			var az uintptr = (*carray_bind)(unsafe.Pointer(pNew)).FaData
			var z uintptr = (az + uintptr(nData)*4)
			for i = 0; i < nData; i++ {
				var zData uintptr = *(*uintptr)(unsafe.Pointer((aData) + uintptr(i)*4))
				var n sqlite3_int64
				if zData == uintptr(0) {
					*(*uintptr)(unsafe.Pointer(az + uintptr(i)*4)) = uintptr(0)
					continue
				}
				*(*uintptr)(unsafe.Pointer(az + uintptr(i)*4)) = z
				n = sqlite3_int64(libc.Xstrlen(tls, zData))
				libc.Xmemcpy(tls, z, zData, (uint32(n + int64(1))))
				z += (uintptr(n + int64(1)))
			}
		} else {
			libc.Xmemcpy(tls, (*carray_bind)(unsafe.Pointer(pNew)).FaData, aData, (uint32(sz * sqlite3_int64(nData))))
		}
		(*carray_bind)(unsafe.Pointer(pNew)).FxDel = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free}))
	} else {
		(*carray_bind)(unsafe.Pointer(pNew)).FaData = aData
		(*carray_bind)(unsafe.Pointer(pNew)).FxDel = xDestroy
	}
	return sqlite3.Xsqlite3_bind_pointer(tls, pStmt, idx, pNew, ts+3909 /* "carray-bind" */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{carrayBindDel})))
}

// For testing purpose in the TCL test harness, we need a method for
// setting the pointer value.  The inttoptr(X) SQL function accomplishes
// this.  Tcl script will bind an integer to X and the inttoptr() SQL
// function will use sqlite3_result_pointer() to convert that integer into
// a pointer.
//
// This is for testing on TCL only.
func inttoptrFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* carray.c:481:13: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	// var p uintptr at bp, 4

	// var i64 sqlite3_int64 at bp+8, 8

	*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* i64 */)) = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if uint32(unsafe.Sizeof(sqlite3_int64(0))) == uint32(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, bp /* &p */, bp+8 /* &i64 */, uint32(unsafe.Sizeof(uintptr(0))))
	} else {
		*(*int32)(unsafe.Pointer(bp + 16 /* i32 */)) = (int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* i64 */)) & int64(0xffffffff)))
		libc.Xmemcpy(tls, bp /* &p */, bp+16 /* &i32 */, uint32(unsafe.Sizeof(uintptr(0))))
	}
	sqlite3.Xsqlite3_result_pointer(tls, context, *(*uintptr)(unsafe.Pointer(bp /* p */)), ts+3921 /* "carray" */, uintptr(0))
}

func sqlite3_carray_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* carray.c:504:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+3921 /* "carray" */, uintptr(unsafe.Pointer(&carrayModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+3949 /* "inttoptr" */, 1, SQLITE_UTF8, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{inttoptrFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// Forward declaration of objects used by this utility
type CksmVfs = sqlite3_vfs1 /* cksumvfs.c:176:28 */
type CksmFile1 = struct {
	Fbase        sqlite3_file
	FzFName      uintptr
	FcomputeCksm int8
	FverifyCksm  int8
	FisWal       int8
	FinCkpt      int8
	FpPartner    uintptr
} /* cksumvfs.c:177:9 */

type CksmFile = CksmFile1 /* cksumvfs.c:177:25 */

// Useful datatype abbreviations
type u8 = uint8 /* cksumvfs.c:183:25 */

var cksm_vfs = sqlite3_vfs{
	FiVersion:          3,         // szOsFile (set when registered)
	FmxPathname:        1024,      // pNext
	FzName:             ts + 3958, /* "cksmvfs" */ /* pAppData (set when registered) */
	FxOpen:             0,         // xOpen
	FxDelete:           0,         // xDelete
	FxAccess:           0,         // xAccess
	FxFullPathname:     0,         // xFullPathname
	FxDlOpen:           0,         // xDlOpen
	FxDlError:          0,         // xDlError
	FxDlSym:            0,         // xDlSym
	FxDlClose:          0,         // xDlClose
	FxRandomness:       0,         // xRandomness
	FxSleep:            0,         // xSleep
	FxCurrentTime:      0,         // xCurrentTime
	FxGetLastError:     0,         // xGetLastError
	FxCurrentTimeInt64: 0,         // xCurrentTimeInt64
	FxSetSystemCall:    0,         // xSetSystemCall
	FxGetSystemCall:    0,         // xGetSystemCall
	FxNextSystemCall:   0,         // xNextSystemCall
} /* cksumvfs.c:247:20 */

var cksm_io_methods = sqlite3_io_methods{
	FiVersion:               3, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
	FxFetch:                 0, // xFetch
	FxUnfetch:               0, // xUnfetch
} /* cksumvfs.c:272:33 */

// Do byte swapping on a unsigned 32-bit integer

// Compute a checksum on a buffer
func cksmCompute(tls *libc.TLS, a uintptr, nByte int32, aOut uintptr) { /* cksumvfs.c:301:13: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*u32)(unsafe.Pointer(bp + 4 /* s1 */)) = u32(0)
	*(*u32)(unsafe.Pointer(bp + 8 /* s2 */)) = u32(0)
	var aData uintptr = a
	var aEnd uintptr = (a + uintptr(nByte))
	*(*u32)(unsafe.Pointer(bp /* x */)) = u32(1)

	if 1 == int32(*(*u8)(unsafe.Pointer(bp /* &x */))) {
		// Little-endian
		for ok := true; ok; ok = (aData < aEnd) {
			*(*u32)(unsafe.Pointer(bp + 4 /* s1 */)) += (*(*u32)(unsafe.Pointer(libc.PostIncUintptr(&aData, 4))) + *(*u32)(unsafe.Pointer(bp + 8 /* s2 */)))
			*(*u32)(unsafe.Pointer(bp + 8 /* s2 */)) += (*(*u32)(unsafe.Pointer(libc.PostIncUintptr(&aData, 4))) + *(*u32)(unsafe.Pointer(bp + 4 /* s1 */)))
		}
	} else {
		// Big-endian
		for ok1 := true; ok1; ok1 = (aData < aEnd) {
			*(*u32)(unsafe.Pointer(bp + 4 /* s1 */)) += (((((((*(*u32)(unsafe.Pointer(aData))) & u32(0x000000FF)) << 24) + (((*(*u32)(unsafe.Pointer(aData))) & u32(0x0000FF00)) << 8)) + (((*(*u32)(unsafe.Pointer(aData))) & u32(0x00FF0000)) >> 8)) + (((*(*u32)(unsafe.Pointer(aData))) & 0xFF000000) >> 24)) + *(*u32)(unsafe.Pointer(bp + 8 /* s2 */)))
			*(*u32)(unsafe.Pointer(bp + 8 /* s2 */)) += (((((((*(*u32)(unsafe.Pointer(aData + 1*4))) & u32(0x000000FF)) << 24) + (((*(*u32)(unsafe.Pointer(aData + 1*4))) & u32(0x0000FF00)) << 8)) + (((*(*u32)(unsafe.Pointer(aData + 1*4))) & u32(0x00FF0000)) >> 8)) + (((*(*u32)(unsafe.Pointer(aData + 1*4))) & 0xFF000000) >> 24)) + *(*u32)(unsafe.Pointer(bp + 4 /* s1 */)))
			aData += 4 * (uintptr(2))
		}
		*(*u32)(unsafe.Pointer(bp + 4 /* s1 */)) = ((((((*(*u32)(unsafe.Pointer(bp + 4 /* s1 */))) & u32(0x000000FF)) << 24) + (((*(*u32)(unsafe.Pointer(bp + 4 /* s1 */))) & u32(0x0000FF00)) << 8)) + (((*(*u32)(unsafe.Pointer(bp + 4 /* s1 */))) & u32(0x00FF0000)) >> 8)) + (((*(*u32)(unsafe.Pointer(bp + 4 /* s1 */))) & 0xFF000000) >> 24))
		*(*u32)(unsafe.Pointer(bp + 8 /* s2 */)) = ((((((*(*u32)(unsafe.Pointer(bp + 8 /* s2 */))) & u32(0x000000FF)) << 24) + (((*(*u32)(unsafe.Pointer(bp + 8 /* s2 */))) & u32(0x0000FF00)) << 8)) + (((*(*u32)(unsafe.Pointer(bp + 8 /* s2 */))) & u32(0x00FF0000)) >> 8)) + (((*(*u32)(unsafe.Pointer(bp + 8 /* s2 */))) & 0xFF000000) >> 24))
	}
	libc.Xmemcpy(tls, aOut, bp+4 /* &s1 */, uint32(4))
	libc.Xmemcpy(tls, (aOut + uintptr(4)), bp+8 /* &s2 */, uint32(4))
}

// SQL function:    verify_checksum(BLOB)
//
// Return 0 or 1 if the checksum is invalid or valid.  Or return
// NULL if the input is not a BLOB that is the right size for a
// database page.
func cksmVerifyFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* cksumvfs.c:342:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var nByte int32
	var data uintptr
	// var cksum [8]u8 at bp, 8

	data = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if data == uintptr(0) {
		return
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) != SQLITE_BLOB {
		return
	}
	nByte = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if ((nByte < 512) || (nByte > 65536)) || ((nByte & (nByte - 1)) != 0) {
		return
	}
	cksmCompute(tls, data, (nByte - 8), bp /* &cksum[0] */)
	sqlite3.Xsqlite3_result_int(tls, context, (libc.Bool32(libc.Xmemcmp(tls, ((data+uintptr(nByte))-uintptr(8)), bp /* &cksum[0] */, uint32(8)) == 0)))
}

// Close a cksm-file.
func cksmClose(tls *libc.TLS, pFile uintptr) int32 { /* cksumvfs.c:397:12: */
	var p uintptr = pFile
	if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {

		(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FpPartner = uintptr(0)
		(*CksmFile)(unsafe.Pointer(p)).FpPartner = uintptr(0)
	}
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 4 /* &.xClose */))))(tls, pFile)
}

// Set the computeCkSm and verifyCksm flags, if they need to be
// changed.
func cksmSetFlags(tls *libc.TLS, p uintptr, hasCorrectReserveSize int32) { /* cksumvfs.c:412:13: */
	if hasCorrectReserveSize != int32((*CksmFile)(unsafe.Pointer(p)).FcomputeCksm) {
		(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm = libc.AssignPtrInt8(p+9 /* &.verifyCksm */, int8(hasCorrectReserveSize))
		if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {
			(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FverifyCksm = int8(hasCorrectReserveSize)
			(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FcomputeCksm = int8(hasCorrectReserveSize)
		}
	}
}

// Read data from a cksm-file.
func cksmRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* cksumvfs.c:425:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	var p uintptr = pFile
	pFile = ((pFile) + uintptr(1)*16)
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 8 /* &.xRead */))))(tls, pFile, zBuf, iAmt, iOfst)
	if rc == SQLITE_OK {
		if ((iOfst == int64(0)) && (iAmt >= 100)) && ((libc.Xmemcmp(tls, zBuf, ts+3149 /* "SQLite format 3" */, uint32(16)) == 0) || (libc.Xmemcmp(tls, zBuf, ts+3966 /* "ZV-" */, uint32(3)) == 0)) {
			var d uintptr = zBuf
			var hasCorrectReserveSize int8 = (int8(libc.Bool32(int32(*(*u8)(unsafe.Pointer(d + 20))) == 8)))
			cksmSetFlags(tls, p, int32(hasCorrectReserveSize))
		}
		// Verify the checksum if
		//    (1) the size indicates that we are dealing with a complete
		//        database page
		//    (2) checksum verification is enabled
		//    (3) we are not in the middle of checkpoint
		if ((iAmt >= 512) && // (1)
			((*CksmFile)(unsafe.Pointer(p)).FverifyCksm != 0)) && // (2)
			!(int32((*CksmFile)(unsafe.Pointer(p)).FinCkpt) != 0) {
			// var cksum [8]u8 at bp+16, 8

			cksmCompute(tls, zBuf, (iAmt - 8), bp+16 /* &cksum[0] */)
			if libc.Xmemcmp(tls, ((zBuf+uintptr(iAmt))-uintptr(8)), bp+16 /* &cksum[0] */, uint32(8)) != 0 {
				sqlite3.Xsqlite3_log(tls, (SQLITE_IOERR | (int32(32) << 8)),
					ts+3970, /* "checksum fault o..." */
					libc.VaList(bp, iOfst, (*CksmFile)(unsafe.Pointer(p)).FzFName))
				rc = (SQLITE_IOERR | (int32(32) << 8))
			}
		}
	}
	return rc
}

// Write data to a cksm-file.
func cksmWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* cksumvfs.c:469:12: */
	var p uintptr = pFile
	pFile = ((pFile) + uintptr(1)*16)
	if ((iOfst == int64(0)) && (iAmt >= 100)) && ((libc.Xmemcmp(tls, zBuf, ts+3149 /* "SQLite format 3" */, uint32(16)) == 0) || (libc.Xmemcmp(tls, zBuf, ts+3966 /* "ZV-" */, uint32(3)) == 0)) {
		var d uintptr = zBuf
		var hasCorrectReserveSize int8 = (int8(libc.Bool32(int32(*(*u8)(unsafe.Pointer(d + 20))) == 8)))
		cksmSetFlags(tls, p, int32(hasCorrectReserveSize))
	}
	// If the write size is appropriate for a database page and if
	// checksums where ever enabled, then it will be safe to compute
	// the checksums.  The reserve byte size might have increased, but
	// it will never decrease.  And because it cannot decrease, the
	// checksum will not overwrite anything.
	if ((iAmt >= 512) &&
		((*CksmFile)(unsafe.Pointer(p)).FcomputeCksm != 0)) &&
		!(int32((*CksmFile)(unsafe.Pointer(p)).FinCkpt) != 0) {
		cksmCompute(tls, zBuf, (iAmt - 8), (((zBuf) + uintptr(iAmt)) - uintptr(8)))
	}
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 12 /* &.xWrite */))))(tls, pFile, zBuf, iAmt, iOfst)
}

// Truncate a cksm-file.
func cksmTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* cksumvfs.c:502:12: */
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 16 /* &.xTruncate */))))(tls, pFile, size)
}

// Sync a cksm-file.
func cksmSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* cksumvfs.c:510:12: */
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 20 /* &.xSync */))))(tls, pFile, flags)
}

// Return the current file-size of a cksm-file.
func cksmFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* cksumvfs.c:518:12: */
	var p uintptr = pFile
	pFile = ((p) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 24 /* &.xFileSize */))))(tls, pFile, pSize)
}

// Lock a cksm-file.
func cksmLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* cksumvfs.c:527:12: */
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 28 /* &.xLock */))))(tls, pFile, eLock)
}

// Unlock a cksm-file.
func cksmUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* cksumvfs.c:535:12: */
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 32 /* &.xUnlock */))))(tls, pFile, eLock)
}

// Check if another file-handle holds a RESERVED lock on a cksm-file.
func cksmCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* cksumvfs.c:543:12: */
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 36 /* &.xCheckReservedLock */))))(tls, pFile, pResOut)
}

// File control method. For custom operations on a cksm-file.
func cksmFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* cksumvfs.c:551:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	var p uintptr = pFile
	pFile = ((pFile) + uintptr(1)*16)
	if op == SQLITE_FCNTL_PRAGMA {
		var azArg uintptr = pArg

		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(azArg + 1*4)), ts+4005 /* "checksum_verific..." */) == 0 {
			var zArg uintptr = *(*uintptr)(unsafe.Pointer(azArg + 2*4))
			if zArg != uintptr(0) {
				if ((((int32(*(*int8)(unsafe.Pointer(zArg))) >= '1') && (int32(*(*int8)(unsafe.Pointer(zArg))) <= '9')) ||
					(sqlite3.Xsqlite3_strlike(tls, ts+4027 /* "enable%" */, zArg, uint32(0)) == 0)) ||
					(sqlite3.Xsqlite3_stricmp(tls, ts+4035 /* "yes" */, zArg) == 0)) ||
					(sqlite3.Xsqlite3_stricmp(tls, ts+4039 /* "on" */, zArg) == 0) {
					(*CksmFile)(unsafe.Pointer(p)).FverifyCksm = (*CksmFile)(unsafe.Pointer(p)).FcomputeCksm
				} else {
					(*CksmFile)(unsafe.Pointer(p)).FverifyCksm = int8(0)
				}
				if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {
					(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FverifyCksm = (*CksmFile)(unsafe.Pointer(p)).FverifyCksm
				}
			}
			*(*uintptr)(unsafe.Pointer(azArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+1238 /* "%d" */, libc.VaList(bp, int32((*CksmFile)(unsafe.Pointer(p)).FverifyCksm)))
			return SQLITE_OK
		} else if (((*CksmFile)(unsafe.Pointer(p)).FcomputeCksm != 0) && (*(*uintptr)(unsafe.Pointer(azArg + 2*4)) != uintptr(0))) &&
			(sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(azArg + 1*4)), ts+4042 /* "page_size" */) == 0) {
			// Do not allow page size changes on a checksum database
			return SQLITE_OK
		}
	} else if (op == SQLITE_FCNTL_CKPT_START) || (op == SQLITE_FCNTL_CKPT_DONE) {
		(*CksmFile)(unsafe.Pointer(p)).FinCkpt = (int8(libc.Bool32(op == SQLITE_FCNTL_CKPT_START)))
		if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {
			(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FinCkpt = (*CksmFile)(unsafe.Pointer(p)).FinCkpt
		}
	} else if op == SQLITE_FCNTL_CKSM_FILE {
		// This VFS needs to obtain a pointer to the corresponding database
		// file handle from within xOpen() calls to open wal files. To do this,
		// it uses the sqlite3_database_file_object() API to obtain a pointer
		// to the file-handle used by SQLite to access the db file. This is
		// fine if cksmvfs happens to be the top-level VFS, but not if there
		// are one or more wrapper VFS. To handle this case, this file-control
		// is used to extract the cksmvfs file-handle from any wrapper file
		// handle.
		var ppFile uintptr = pArg
		*(*uintptr)(unsafe.Pointer(ppFile)) = p
		return SQLITE_OK
	}
	rc = (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 40 /* &.xFileControl */))))(tls, pFile, op, pArg)
	if (rc == SQLITE_OK) && (op == SQLITE_FCNTL_VFSNAME) {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+4052 /* "cksm/%z" */, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

// Return the sector-size in bytes for a cksm-file.
func cksmSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* cksumvfs.c:605:12: */
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 44 /* &.xSectorSize */))))(tls, pFile)
}

// Return the device characteristic flags supported by a cksm-file.
func cksmDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* cksumvfs.c:613:12: */
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 48 /* &.xDeviceCharacteristics */))))(tls, pFile)
}

// Create a shared memory file mapping
func cksmShmMap(tls *libc.TLS, pFile uintptr, iPg int32, pgsz int32, bExtend int32, pp uintptr) int32 { /* cksumvfs.c:619:12: */
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 52 /* &.xShmMap */))))(tls, pFile, iPg, pgsz, bExtend, libc.AtomicLoadUintptr(&pp))
}

// Perform locking on a shared-memory segment
func cksmShmLock(tls *libc.TLS, pFile uintptr, offset int32, n int32, flags int32) int32 { /* cksumvfs.c:631:12: */
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 56 /* &.xShmLock */))))(tls, pFile, offset, n, flags)
}

// Memory barrier operation on shared memory
func cksmShmBarrier(tls *libc.TLS, pFile uintptr) { /* cksumvfs.c:637:13: */
	pFile = ((pFile) + uintptr(1)*16)
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 60 /* &.xShmBarrier */))))(tls, pFile)
}

// Unmap a shared memory segment
func cksmShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 { /* cksumvfs.c:643:12: */
	pFile = ((pFile) + uintptr(1)*16)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 64 /* &.xShmUnmap */))))(tls, pFile, deleteFlag)
}

// Fetch a page of a memory-mapped file
func cksmFetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, iAmt int32, pp uintptr) int32 { /* cksumvfs.c:649:12: */
	var p uintptr = pFile
	if (*CksmFile)(unsafe.Pointer(p)).FcomputeCksm != 0 {
		*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
		return SQLITE_OK
	}
	pFile = ((pFile) + uintptr(1)*16)
	if ((*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FiVersion > 2) && ((*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFetch != 0) {
		return (*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 68 /* &.xFetch */))))(tls, pFile, iOfst, iAmt, pp)
	}
	*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
	return SQLITE_OK
}

// Release a memory-mapped page
func cksmUnfetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, pPage uintptr) int32 { /* cksumvfs.c:669:12: */
	pFile = ((pFile) + uintptr(1)*16)
	if ((*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FiVersion > 2) && ((*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnfetch != 0) {
		return (*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods + 72 /* &.xUnfetch */))))(tls, pFile, iOfst, pPage)
	}
	return SQLITE_OK
}

// Open a cksm file handle.
func cksmOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* cksumvfs.c:680:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	var pSubFile uintptr
	var pSubVfs uintptr
	var rc int32
	// var pDb uintptr at bp, 4

	pSubVfs = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if !((flags & (SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_WAL)) == 0) {
		goto __1
	}
	return (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pSubVfs + 24 /* &.xOpen */))))(tls, pSubVfs, zName, pFile, flags, pOutFlags)
__1:
	;
	p = pFile
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(CksmFile{})))
	pSubFile = ((pFile) + uintptr(1)*16)
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&cksm_io_methods))
	rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pSubVfs + 24 /* &.xOpen */))))(tls, pSubVfs, zName, pSubFile, flags, pOutFlags)
	if !(rc != 0) {
		goto __2
	}
	goto cksm_open_done
__2:
	;
	if !((flags & SQLITE_OPEN_WAL) != 0) {
		goto __3
	}
	*(*uintptr)(unsafe.Pointer(bp /* pDb */)) = sqlite3.Xsqlite3_database_file_object(tls, zName)
	rc = (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* pDb */)))).FpMethods + 40 /* &.xFileControl */))))(tls, *(*uintptr)(unsafe.Pointer(bp /* pDb */)), SQLITE_FCNTL_CKSM_FILE, bp /* &pDb */)

	(*CksmFile)(unsafe.Pointer(p)).FpPartner = *(*uintptr)(unsafe.Pointer(bp /* pDb */))

	(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FpPartner = p
	(*CksmFile)(unsafe.Pointer(p)).FisWal = int8(1)
	(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm = (*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FcomputeCksm
	goto __4
__3:
	(*CksmFile)(unsafe.Pointer(p)).FisWal = int8(0)
	(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm = int8(0)
__4:
	;
	(*CksmFile)(unsafe.Pointer(p)).FzFName = zName
cksm_open_done:
	if !(rc != 0) {
		goto __5
	}
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
__5:
	;
	return rc
}

// All other VFS methods are pass-thrus.
func cksmDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* cksumvfs.c:723:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 28 /* &.xDelete */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, dirSync)
}

func cksmAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* cksumvfs.c:726:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 32 /* &.xAccess */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, flags, pResOut)
}

func cksmFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* cksumvfs.c:734:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 36 /* &.xFullPathname */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, nOut, zOut)
}

func cksmDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr { /* cksumvfs.c:742:13: */
	return (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 40 /* &.xDlOpen */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath)
}

func cksmDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* cksumvfs.c:745:13: */
	(*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 44 /* &.xDlError */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zErrMsg)
}

func cksmDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr { /* cksumvfs.c:748:13: */
	return (*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 48 /* &.xDlSym */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, p, zSym)
}

func cksmDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) { /* cksumvfs.c:751:13: */
	(*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 52 /* &.xDlClose */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pHandle)
}

func cksmRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* cksumvfs.c:754:12: */
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 56 /* &.xRandomness */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zBufOut)
}

func cksmSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* cksumvfs.c:757:12: */
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 60 /* &.xSleep */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nMicro)
}

func cksmCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* cksumvfs.c:760:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 64 /* &.xCurrentTime */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pTimeOut)
}

func cksmGetLastError(tls *libc.TLS, pVfs uintptr, a int32, b uintptr) int32 { /* cksumvfs.c:763:12: */
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 68 /* &.xGetLastError */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, a, b)
}

func cksmCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, p uintptr) int32 { /* cksumvfs.c:766:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pOrig uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	var rc int32

	if (*sqlite3_vfs)(unsafe.Pointer(pOrig)).FxCurrentTimeInt64 != 0 {
		rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pOrig + 72 /* &.xCurrentTimeInt64 */))))(tls, pOrig, p)
	} else {
		// var r float64 at bp, 8

		rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pOrig + 64 /* &.xCurrentTime */))))(tls, pOrig, bp /* &r */)
		*(*sqlite3_int64)(unsafe.Pointer(p)) = (sqlite3_int64(*(*float64)(unsafe.Pointer(bp /* r */)) * 86400000.0))
	}
	return rc
}

func cksmSetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr, pCall sqlite3_syscall_ptr) int32 { /* cksumvfs.c:779:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 76 /* &.xSetSystemCall */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName, pCall)
}

func cksmGetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) sqlite3_syscall_ptr { /* cksumvfs.c:786:28: */
	return (*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 80 /* &.xGetSystemCall */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

func cksmNextSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) uintptr { /* cksumvfs.c:792:19: */
	return (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData + 84 /* &.xNextSystemCall */))))(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

// Register the verify_checksum() SQL function.
func cksmRegisterFunc(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* cksumvfs.c:798:12: */
	var rc int32
	if db == uintptr(0) {
		return SQLITE_OK
	}
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4060 /* "verify_checksum" */, 1,
		((SQLITE_UTF8 | SQLITE_INNOCUOUS) | SQLITE_DETERMINISTIC),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{cksmVerifyFunc})), uintptr(0), uintptr(0))
	return rc
}

// Register the cksum VFS as the default VFS for the system.
// Also make arrangements to automatically register the "verify_checksum()"
// SQL function on each new database connection.
func cksmRegisterVfs(tls *libc.TLS) int32 { /* cksumvfs.c:821:12: */
	var rc int32 = SQLITE_OK
	var pOrig uintptr
	if sqlite3.Xsqlite3_vfs_find(tls, ts+3958 /* "cksmvfs" */) != uintptr(0) {
		return SQLITE_OK
	}
	pOrig = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if pOrig == uintptr(0) {
		return SQLITE_ERROR
	}
	cksm_vfs.FiVersion = (*sqlite3_vfs)(unsafe.Pointer(pOrig)).FiVersion
	cksm_vfs.FpAppData = pOrig
	cksm_vfs.FszOsFile = (int32(uint32((*sqlite3_vfs)(unsafe.Pointer(pOrig)).FszOsFile) + uint32(unsafe.Sizeof(CksmFile{}))))
	rc = sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&cksm_vfs)), 1)
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		}{cksmRegisterFunc})))
	}
	return rc
}

// This variant of the initializer runs when the extension is
// statically linked.
func sqlite3_register_cksumvfs(tls *libc.TLS, NotUsed uintptr) int32 { /* cksumvfs.c:841:5: */
	_ = NotUsed
	return cksmRegisterVfs(tls)
}

func sqlite3_unregister_cksumvfs(tls *libc.TLS) int32 { /* cksumvfs.c:845:5: */
	if sqlite3.Xsqlite3_vfs_find(tls, ts+3958 /* "cksmvfs" */) != 0 {
		sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&cksm_vfs)))
		sqlite3.Xsqlite3_cancel_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		}{cksmRegisterFunc})))
	}
	return SQLITE_OK
}

// Forward declaration of objects used by this implementation
type closure_vtab1 = struct {
	Fbase          sqlite3_vtab
	FzDb           uintptr
	FzSelf         uintptr
	FzTableName    uintptr
	FzIdColumn     uintptr
	FzParentColumn uintptr
	Fdb            uintptr
	FnCursor       int32
} /* closure.c:156:9 */

// Forward declaration of objects used by this implementation
type closure_vtab = closure_vtab1 /* closure.c:156:29 */
type closure_cursor1 = struct {
	Fbase          sqlite3_vtab_cursor
	FpVtab         uintptr
	FzTableName    uintptr
	FzIdColumn     uintptr
	FzParentColumn uintptr
	FpCurrent      uintptr
	FpClosure      uintptr
} /* closure.c:157:9 */

type closure_cursor = closure_cursor1 /* closure.c:157:31 */
type closure_queue1 = struct {
	FpFirst uintptr
	FpLast  uintptr
} /* closure.c:158:9 */

type closure_queue = closure_queue1 /* closure.c:158:30 */
type closure_avl1 = struct {
	Fid          sqlite3_int64
	FiGeneration int32
	FpList       uintptr
	FpBefore     uintptr
	FpAfter      uintptr
	FpUp         uintptr
	Fheight      int16
	Fimbalance   int16
} /* closure.c:157:9 */

type closure_avl = closure_avl1 /* closure.c:159:28 */

// Recompute the closure_avl.height and closure_avl.imbalance fields for p.
// Assume that the children of p have correct heights.
func closureAvlRecomputeHeight(tls *libc.TLS, p uintptr) { /* closure.c:182:13: */
	var hBefore int16
	if (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
		hBefore = (*closure_avl)(unsafe.Pointer((*closure_avl)(unsafe.Pointer(p)).FpBefore)).Fheight
	} else {
		hBefore = int16(0)
	}
	var hAfter int16
	if (*closure_avl)(unsafe.Pointer(p)).FpAfter != 0 {
		hAfter = (*closure_avl)(unsafe.Pointer((*closure_avl)(unsafe.Pointer(p)).FpAfter)).Fheight
	} else {
		hAfter = int16(0)
	}
	(*closure_avl)(unsafe.Pointer(p)).Fimbalance = (int16(int32(hBefore) - int32(hAfter))) // -: pAfter higher.  +: pBefore higher
	(*closure_avl)(unsafe.Pointer(p)).Fheight = (int16((func() int32 {
		if int32(hBefore) > int32(hAfter) {
			return int32(hBefore)
		}
		return int32(hAfter)
	}()) + 1))
}

//     P                B
//    / \              / **   B   Z    ==>     X   P
//  / \                  / ** X   Y                Y   Z
//
func closureAvlRotateBefore(tls *libc.TLS, pP uintptr) uintptr { /* closure.c:197:20: */
	var pB uintptr = (*closure_avl)(unsafe.Pointer(pP)).FpBefore
	var pY uintptr = (*closure_avl)(unsafe.Pointer(pB)).FpAfter
	(*closure_avl)(unsafe.Pointer(pB)).FpUp = (*closure_avl)(unsafe.Pointer(pP)).FpUp
	(*closure_avl)(unsafe.Pointer(pB)).FpAfter = pP
	(*closure_avl)(unsafe.Pointer(pP)).FpUp = pB
	(*closure_avl)(unsafe.Pointer(pP)).FpBefore = pY
	if pY != 0 {
		(*closure_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	closureAvlRecomputeHeight(tls, pP)
	closureAvlRecomputeHeight(tls, pB)
	return pB
}

//     P                A
//    / \              / **   X   A    ==>     P   Z
//      / \          / **     Y   Z        X   Y
//
func closureAvlRotateAfter(tls *libc.TLS, pP uintptr) uintptr { /* closure.c:218:20: */
	var pA uintptr = (*closure_avl)(unsafe.Pointer(pP)).FpAfter
	var pY uintptr = (*closure_avl)(unsafe.Pointer(pA)).FpBefore
	(*closure_avl)(unsafe.Pointer(pA)).FpUp = (*closure_avl)(unsafe.Pointer(pP)).FpUp
	(*closure_avl)(unsafe.Pointer(pA)).FpBefore = pP
	(*closure_avl)(unsafe.Pointer(pP)).FpUp = pA
	(*closure_avl)(unsafe.Pointer(pP)).FpAfter = pY
	if pY != 0 {
		(*closure_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	closureAvlRecomputeHeight(tls, pP)
	closureAvlRecomputeHeight(tls, pA)
	return pA
}

// Return a pointer to the pBefore or pAfter pointer in the parent
// of p that points to p.  Or if p is the root node, return pp.
func closureAvlFromPtr(tls *libc.TLS, p uintptr, pp uintptr) uintptr { /* closure.c:235:20: */
	var pUp uintptr = (*closure_avl)(unsafe.Pointer(p)).FpUp
	if pUp == uintptr(0) {
		return pp
	}
	if (*closure_avl)(unsafe.Pointer(pUp)).FpAfter == p {
		return (pUp + 20 /* &.pAfter */)
	}
	return (pUp + 16 /* &.pBefore */)
}

// Rebalance all nodes starting with p and working up to the root.
// Return the new root.
func closureAvlBalance(tls *libc.TLS, p uintptr) uintptr { /* closure.c:246:20: */
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*uintptr)(unsafe.Pointer(bp)) = p

	var pTop uintptr = *(*uintptr)(unsafe.Pointer(bp /* p */))
	var pp uintptr
	for *(*uintptr)(unsafe.Pointer(bp /* p */)) != 0 {
		closureAvlRecomputeHeight(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)))
		if int32((*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fimbalance) >= 2 {
			var pB uintptr = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore
			if int32((*closure_avl)(unsafe.Pointer(pB)).Fimbalance) < 0 {
				(*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore = closureAvlRotateAfter(tls, pB)
			}
			pp = closureAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = libc.AssignPtrUintptr(pp, closureAvlRotateBefore(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		} else if int32((*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fimbalance) <= (-2) {
			var pA uintptr = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter
			if int32((*closure_avl)(unsafe.Pointer(pA)).Fimbalance) > 0 {
				(*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter = closureAvlRotateBefore(tls, pA)
			}
			pp = closureAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = libc.AssignPtrUintptr(pp, closureAvlRotateAfter(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		}
		pTop = *(*uintptr)(unsafe.Pointer(bp /* p */))
		*(*uintptr)(unsafe.Pointer(bp /* p */)) = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpUp
	}
	return pTop
}

// Search the tree rooted at p for an entry with id.  Return a pointer
// to the entry or return NULL.
func closureAvlSearch(tls *libc.TLS, p uintptr, id sqlite3_int64) uintptr { /* closure.c:271:20: */
	for (p != 0) && (id != (*closure_avl)(unsafe.Pointer(p)).Fid) {
		if id < (*closure_avl)(unsafe.Pointer(p)).Fid {
			p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
		} else {
			p = (*closure_avl)(unsafe.Pointer(p)).FpAfter
		}
	}
	return p
}

// Find the first node (the one with the smallest key).
func closureAvlFirst(tls *libc.TLS, p uintptr) uintptr { /* closure.c:280:20: */
	if p != 0 {
		for (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
			p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
		}
	}
	return p
}

// Return the node with the next larger key after p.
func closureAvlNext(tls *libc.TLS, p uintptr) uintptr { /* closure.c:287:13: */
	var pPrev uintptr = uintptr(0)
	for (p != 0) && ((*closure_avl)(unsafe.Pointer(p)).FpAfter == pPrev) {
		pPrev = p
		p = (*closure_avl)(unsafe.Pointer(p)).FpUp
	}
	if (p != 0) && (pPrev == uintptr(0)) {
		p = closureAvlFirst(tls, (*closure_avl)(unsafe.Pointer(p)).FpAfter)
	}
	return p
}

// Insert a new node pNew.  Return NULL on success.  If the key is not
// unique, then do not perform the insert but instead leave pNew unchanged
// and return a pointer to an existing node with the same key.
func closureAvlInsert(tls *libc.TLS, ppHead uintptr, pNew uintptr) uintptr { /* closure.c:303:20: */
	var p uintptr = *(*uintptr)(unsafe.Pointer(ppHead))
	if p == uintptr(0) {
		p = pNew
		(*closure_avl)(unsafe.Pointer(pNew)).FpUp = uintptr(0)
	} else {
		for p != 0 {
			if (*closure_avl)(unsafe.Pointer(pNew)).Fid < (*closure_avl)(unsafe.Pointer(p)).Fid {
				if (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
					p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
				} else {
					(*closure_avl)(unsafe.Pointer(p)).FpBefore = pNew
					(*closure_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else if (*closure_avl)(unsafe.Pointer(pNew)).Fid > (*closure_avl)(unsafe.Pointer(p)).Fid {
				if (*closure_avl)(unsafe.Pointer(p)).FpAfter != 0 {
					p = (*closure_avl)(unsafe.Pointer(p)).FpAfter
				} else {
					(*closure_avl)(unsafe.Pointer(p)).FpAfter = pNew
					(*closure_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else {
				return p
			}
		}
	}
	(*closure_avl)(unsafe.Pointer(pNew)).FpBefore = uintptr(0)
	(*closure_avl)(unsafe.Pointer(pNew)).FpAfter = uintptr(0)
	(*closure_avl)(unsafe.Pointer(pNew)).Fheight = int16(1)
	(*closure_avl)(unsafe.Pointer(pNew)).Fimbalance = int16(0)
	*(*uintptr)(unsafe.Pointer(ppHead)) = closureAvlBalance(tls, p)
	return uintptr(0)
}

// Walk the tree can call xDestroy on each node
func closureAvlDestroy(tls *libc.TLS, p uintptr, xDestroy uintptr) { /* closure.c:344:13: */
	if p != 0 {
		closureAvlDestroy(tls, (*closure_avl)(unsafe.Pointer(p)).FpBefore, xDestroy)
		closureAvlDestroy(tls, (*closure_avl)(unsafe.Pointer(p)).FpAfter, xDestroy)
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&xDestroy)))(tls, p)
	}
}

// Add a node to the end of the queue
func queuePush(tls *libc.TLS, pQueue uintptr, pNode uintptr) { /* closure.c:389:13: */
	(*closure_avl)(unsafe.Pointer(pNode)).FpList = uintptr(0)
	if (*closure_queue)(unsafe.Pointer(pQueue)).FpLast != 0 {
		(*closure_avl)(unsafe.Pointer((*closure_queue)(unsafe.Pointer(pQueue)).FpLast)).FpList = pNode
	} else {
		(*closure_queue)(unsafe.Pointer(pQueue)).FpFirst = pNode
	}
	(*closure_queue)(unsafe.Pointer(pQueue)).FpLast = pNode
}

// Extract the oldest element (the front element) from the queue.
func queuePull(tls *libc.TLS, pQueue uintptr) uintptr { /* closure.c:402:20: */
	var p uintptr = (*closure_queue)(unsafe.Pointer(pQueue)).FpFirst
	if p != 0 {
		(*closure_queue)(unsafe.Pointer(pQueue)).FpFirst = (*closure_avl)(unsafe.Pointer(p)).FpList
		if (*closure_queue)(unsafe.Pointer(pQueue)).FpFirst == uintptr(0) {
			(*closure_queue)(unsafe.Pointer(pQueue)).FpLast = uintptr(0)
		}
	}
	return p
}

// This function converts an SQL quoted string into an unquoted string
// and returns a pointer to a buffer allocated using sqlite3_malloc()
// containing the result. The caller should eventually free this buffer
// using sqlite3_free.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func closureDequote(tls *libc.TLS, zIn uintptr) uintptr { /* closure.c:424:13: */
	var nIn sqlite3_int64 // Size of input string, in bytes
	var zOut uintptr      // Output (dequoted) string

	nIn = sqlite3_int64(libc.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, (uint64(nIn + int64(1))))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn)) // Quote character (if any )

		if (((int32(q) != '[') && (int32(q) != '\'')) && (int32(q) != '"')) && (int32(q) != '`') {
			libc.Xmemcpy(tls, zOut, zIn, (size_t(nIn + int64(1))))
		} else {
			var iOut int32 = 0 // Index of next byte to write to output
			var iIn int32      // Index of next byte to read from input

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}

	}
	return zOut
}

// Deallocate an closure_vtab object
func closureFree(tls *libc.TLS, p uintptr) { /* closure.c:453:13: */
	if p != 0 {
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzDb)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzSelf)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzTableName)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzIdColumn)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzParentColumn)
		libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(closure_vtab{})))
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// xDisconnect/xDestroy method for the closure module.
func closureDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* closure.c:468:12: */
	var p uintptr = pVtab

	closureFree(tls, p)
	return SQLITE_OK
}

// Check to see if the argument is of the form:
//
//       KEY = VALUE
//
// If it is, return a pointer to the first character of VALUE.
// If not, return NULL.  Spaces around the = are ignored.
func closureValueOfKey(tls *libc.TLS, zKey uintptr, zStr uintptr) uintptr { /* closure.c:483:19: */
	var nKey int32 = int32(libc.Xstrlen(tls, zKey))
	var nStr int32 = int32(libc.Xstrlen(tls, zStr))
	var i int32
	if nStr < (nKey + 1) {
		return uintptr(0)
	}
	if libc.Xmemcmp(tls, zStr, zKey, uint32(nKey)) != 0 {
		return uintptr(0)
	}
	for i = nKey; (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))))*2))) & int32(_ISspace)) != 0; i++ {
	}
	if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) != '=' {
		return uintptr(0)
	}
	i++
	for (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))))*2))) & int32(_ISspace)) != 0 {
		i++
	}
	return (zStr + uintptr(i))
}

// xConnect/xCreate method for the closure module. Arguments are:
//
//   argv[0]    -> module name  ("transitive_closure")
//   argv[1]    -> database name
//   argv[2]    -> table name
//   argv[3...] -> arguments
func closureConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* closure.c:504:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32     // Return code
	var pNew uintptr // New virtual table
	var zDb uintptr
	var zVal uintptr
	var i int32
	rc = SQLITE_OK
	pNew = uintptr(0)
	zDb = *(*uintptr)(unsafe.Pointer(argv + 1*4))

	_ = pAux
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_vtab{})))
	if !(pNew == uintptr(0)) {
		goto __1
	}
	return SQLITE_NOMEM
__1:
	;
	rc = SQLITE_NOMEM
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(closure_vtab{})))
	(*closure_vtab)(unsafe.Pointer(pNew)).Fdb = db
	(*closure_vtab)(unsafe.Pointer(pNew)).FzDb = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zDb))
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzDb == uintptr(0)) {
		goto __2
	}
	goto closureConnectError
__2:
	;
	(*closure_vtab)(unsafe.Pointer(pNew)).FzSelf = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzSelf == uintptr(0)) {
		goto __3
	}
	goto closureConnectError
__3:
	;
	i = 3
__4:
	if !(i < argc) {
		goto __6
	}
	zVal = closureValueOfKey(tls, ts+4076 /* "tablename" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __7
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzTableName)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzTableName = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzTableName == uintptr(0)) {
		goto __8
	}
	goto closureConnectError
__8:
	;
	goto __5
__7:
	;
	zVal = closureValueOfKey(tls, ts+4086 /* "idcolumn" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __9
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn == uintptr(0)) {
		goto __10
	}
	goto closureConnectError
__10:
	;
	goto __5
__9:
	;
	zVal = closureValueOfKey(tls, ts+4095 /* "parentcolumn" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __11
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn == uintptr(0)) {
		goto __12
	}
	goto closureConnectError
__12:
	;
	goto __5
__11:
	;
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3397 /* "unrecognized arg..." */, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
	closureFree(tls, pNew)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	return SQLITE_ERROR
	goto __5
__5:
	i++
	goto __4
	goto __6
__6:
	;
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,

		ts+4108 /* "CREATE TABLE x(i..." */)
	if !(rc != SQLITE_OK) {
		goto __13
	}
	closureFree(tls, pNew)
__13:
	;
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pNew /* &.base */)
	return rc

closureConnectError:
	closureFree(tls, pNew)
	return rc
}

// Open a new closure cursor.
func closureOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* closure.c:579:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(closure_cursor{})))
	(*closure_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	(*closure_vtab)(unsafe.Pointer(p)).FnCursor++
	return SQLITE_OK
}

// Free up all the memory allocated by a cursor.  Set it rLimit to 0
// to indicate that it is at EOF.
func closureClearCursor(tls *libc.TLS, pCur uintptr) { /* closure.c:595:13: */
	closureAvlDestroy(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName)
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn)
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzTableName = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FpClosure = uintptr(0)
}

// Close a closure cursor.
func closureClose(tls *libc.TLS, cur uintptr) int32 { /* closure.c:610:12: */
	var pCur uintptr = cur
	closureClearCursor(tls, pCur)
	(*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Advance a cursor to its next row of output
func closureNext(tls *libc.TLS, cur uintptr) int32 { /* closure.c:621:12: */
	var pCur uintptr = cur
	(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = closureAvlNext(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)
	return SQLITE_OK
}

// Allocate and insert a node
func closureInsertNode(tls *libc.TLS, pQueue uintptr, pCur uintptr, id sqlite3_int64, iGeneration int32) int32 { /* closure.c:630:12: */
	var pNew uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_avl{})))
	if pNew == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(closure_avl{})))
	(*closure_avl)(unsafe.Pointer(pNew)).Fid = id
	(*closure_avl)(unsafe.Pointer(pNew)).FiGeneration = iGeneration
	closureAvlInsert(tls, (pCur + 24 /* &.pClosure */), pNew)
	queuePush(tls, pQueue, pNew)
	return SQLITE_OK
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any closureColumn, closureRowid, or closureEof call.
//
// This routine actually computes the closure.
//
// See the comment at the beginning of closureBestIndex() for a
// description of the meaning of idxNum.  The idxStr parameter is
// not used.
func closureFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* closure.c:657:12: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var pCur uintptr = pVtabCursor
	var pVtab uintptr = (*closure_cursor)(unsafe.Pointer(pCur)).FpVtab
	var iRoot sqlite3_int64
	var mxGen int32 = 999999999
	var zSql uintptr
	// var pStmt uintptr at bp+80, 4

	var pAvl uintptr
	var rc int32 = SQLITE_OK
	var zTableName uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzTableName
	var zIdColumn uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzIdColumn
	var zParentColumn uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzParentColumn
	// var sQueue closure_queue at bp+72, 8

	_ = idxStr // Unused parameter
	_ = argc   // Unused parameter
	closureClearCursor(tls, pCur)
	libc.Xmemset(tls, bp+72 /* &sQueue */, 0, uint32(unsafe.Sizeof(closure_queue{})))
	if (idxNum & 1) == 0 {
		// No root=$root in the WHERE clause.  Return an empty set
		return SQLITE_OK
	}
	iRoot = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if (idxNum & 0x000f0) != 0 {
		mxGen = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(((idxNum>>4)&0x0f))*4)))
		if (idxNum & 0x00002) != 0 {
			mxGen--
		}
	}
	if (idxNum & 0x00f00) != 0 {
		zTableName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(((idxNum>>8)&0x0f))*4)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zTableName))
	}
	if (idxNum & 0x0f000) != 0 {
		zIdColumn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(((idxNum>>12)&0x0f))*4)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, zIdColumn))
	}
	if (idxNum & 0x0f0000) != 0 {
		zParentColumn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(((idxNum>>16)&0x0f))*4)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, zParentColumn))
	}

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+4198, /* "SELECT \"%w\".\"%w\"..." */
		libc.VaList(bp+24, zTableName, zIdColumn, zTableName, zTableName, zParentColumn))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, bp+80 /* &pStmt */, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != 0 {
			sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fbase.FzErrMsg)
			(*closure_vtab)(unsafe.Pointer(pVtab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+64, sqlite3.Xsqlite3_errmsg(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fdb)))
			return rc
		}
	}
	if rc == SQLITE_OK {
		rc = closureInsertNode(tls, bp+72 /* &sQueue */, pCur, iRoot, 0)
	}
	for (libc.AssignUintptr(&pAvl, queuePull(tls, bp+72 /* &sQueue */))) != uintptr(0) {
		if (*closure_avl)(unsafe.Pointer(pAvl)).FiGeneration >= mxGen {
			continue
		}
		sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), 1, (*closure_avl)(unsafe.Pointer(pAvl)).Fid)
		for (rc == SQLITE_OK) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */))) == SQLITE_ROW) {
			if sqlite3.Xsqlite3_column_type(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), 0) == SQLITE_INTEGER {
				var iNew sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), 0)
				if closureAvlSearch(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure, iNew) == uintptr(0) {
					rc = closureInsertNode(tls, bp+72 /* &sQueue */, pCur, iNew, ((*closure_avl)(unsafe.Pointer(pAvl)).FiGeneration + 1))
				}
			}
		}
		sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)))
	}
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)))
	if rc == SQLITE_OK {
		(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = closureAvlFirst(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure)
	}

	return rc
}

// Only the word and distance columns have values.  All other columns
// return NULL
func closureColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* closure.c:743:12: */
	var pCur uintptr = cur
	switch i {
	case CLOSURE_COL_ID:
		{
			sqlite3.Xsqlite3_result_int64(tls, ctx, (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).Fid)
			break

		}
	case CLOSURE_COL_DEPTH:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).FiGeneration)
			break

		}
	case CLOSURE_COL_ROOT:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break

		}
	case CLOSURE_COL_TABLENAME:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzTableName
				}(),
				-1, libc.UintptrFromInt32(-1))
			break

		}
	case CLOSURE_COL_IDCOLUMN:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzIdColumn
				}(),
				-1, libc.UintptrFromInt32(-1))
			break

		}
	case CLOSURE_COL_PARENTCOLUMN:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzParentColumn
				}(),
				-1, libc.UintptrFromInt32(-1))
			break

		}
	}
	return SQLITE_OK
}

// The rowid.  For the closure table, this is the same as the "id" column.
func closureRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* closure.c:783:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).Fid
	return SQLITE_OK
}

// EOF indicator
func closureEof(tls *libc.TLS, cur uintptr) int32 { /* closure.c:792:12: */
	var pCur uintptr = cur
	return (libc.Bool32((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent == uintptr(0)))
}

// Search for terms of these forms:
//
//   (A)    root = $root
//   (B1)   depth < $depth
//   (B2)   depth <= $depth
//   (B3)   depth = $depth
//   (C)    tablename = $tablename
//   (D)    idcolumn = $idcolumn
//   (E)    parentcolumn = $parentcolumn
//
//
//
//   idxNum       meaning
//   ----------   ------------------------------------------------------
//   0x00000001   Term of the form (A) found
//   0x00000002   The term of bit-2 is like (B1)
//   0x000000f0   Index in filter.argv[] of $depth.  0 if not used.
//   0x00000f00   Index in filter.argv[] of $tablename.  0 if not used.
//   0x0000f000   Index in filter.argv[] of $idcolumn.  0 if not used
//   0x000f0000   Index in filter.argv[] of $parentcolumn.  0 if not used.
//
// There must be a term of type (A).  If there is not, then the index type
// is 0 and the query will return an empty set.
func closureBestIndex(tls *libc.TLS, pTab uintptr, pIdxInfo uintptr) int32 { /* closure.c:822:12: */
	var iPlan int32 = 0
	var i int32
	var idx int32 = 1
	var pConstraint uintptr
	var pVtab uintptr = pTab
	var rCost float64 = 10000000.0

	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if (((iPlan & 1) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_ROOT)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | (1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / (100.0)
		}
		if (((iPlan & 0x0000f0) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_DEPTH)) &&
			(((int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT) ||
				(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE)) ||
				(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ)) {
			iPlan = iPlan | (idx << 4)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT {
				iPlan = iPlan | (0x000002)
			}
			rCost = rCost / (5.0)
		}
		if (((iPlan & 0x000f00) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_TABLENAME)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | (idx << 8)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / (5.0)
		}
		if (((iPlan & 0x00f000) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_IDCOLUMN)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | (idx << 12)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}
		if (((iPlan & 0x0f0000) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_PARENTCOLUMN)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | (idx << 16)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if ((((*closure_vtab)(unsafe.Pointer(pVtab)).FzTableName == uintptr(0)) && ((iPlan & 0x000f00) == 0)) ||
		(((*closure_vtab)(unsafe.Pointer(pVtab)).FzIdColumn == uintptr(0)) && ((iPlan & 0x00f000) == 0))) ||
		(((*closure_vtab)(unsafe.Pointer(pVtab)).FzParentColumn == uintptr(0)) && ((iPlan & 0x0f0000) == 0)) {
		// All of tablename, idcolumn, and parentcolumn must be specified
		// in either the CREATE VIRTUAL TABLE or in the WHERE clause constraints
		// or else the result is an empty set.
		iPlan = 0
	}
	if (iPlan & 1) == 0 {
		// If there is no usable "root=?" term, then set the index-type to 0.
		// Also clear any argvIndex variables already set. This is necessary
		// to prevent the core from throwing an "xBestIndex malfunction error"
		// error (because the argvIndex values are not contiguously assigned
		// starting from 1).
		rCost = rCost * (1e30)
		i = 0
	__4:
		if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
			goto __6
		}
		{
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 0

		}
		goto __5
	__5:
		i++
		pConstraint += 12
		goto __4
		goto __6
	__6:
		;
		iPlan = 0
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) &&
		((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == CLOSURE_COL_ID)) &&
		(int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0) {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = rCost

	return SQLITE_OK
}

// A virtual table module that implements the "transitive_closure".
var closureModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xShadowName
} /* closure.c:918:23 */

// Register the closure virtual table
func sqlite3_closure_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* closure.c:953:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4244 /* "transitive_closu..." */, uintptr(unsafe.Pointer(&closureModule)), uintptr(0))
	return rc
}

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// A macro to hint to the compiler that a function should not be
// inlined.

// Max size of the error message in a CsvReader

// Size of the CsvReader input buffer

// A context object used when read a CSV file.
type CsvReader1 = struct {
	Fin        uintptr
	Fz         uintptr
	Fn         int32
	FnAlloc    int32
	FnLine     int32
	FbNotFirst int32
	FcTerm     int32
	FiIn       size_t
	FnIn       size_t
	FzIn       uintptr
	FzErr      [200]int8
} /* csv.c:73:9 */

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// A macro to hint to the compiler that a function should not be
// inlined.

// Max size of the error message in a CsvReader

// Size of the CsvReader input buffer

// A context object used when read a CSV file.
type CsvReader = CsvReader1 /* csv.c:73:26 */

// Initialize a CsvReader object
func csv_reader_init(tls *libc.TLS, p uintptr) { /* csv.c:89:13: */
	(*CsvReader)(unsafe.Pointer(p)).Fin = uintptr(0)
	(*CsvReader)(unsafe.Pointer(p)).Fz = uintptr(0)
	(*CsvReader)(unsafe.Pointer(p)).Fn = 0
	(*CsvReader)(unsafe.Pointer(p)).FnAlloc = 0
	(*CsvReader)(unsafe.Pointer(p)).FnLine = 0
	(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 0
	(*CsvReader)(unsafe.Pointer(p)).FnIn = size_t(0)
	(*CsvReader)(unsafe.Pointer(p)).FzIn = uintptr(0)
	*(*int8)(unsafe.Pointer((p + 40 /* &.zErr */))) = int8(0)
}

// Close and reset a CsvReader object
func csv_reader_reset(tls *libc.TLS, p uintptr) { /* csv.c:102:13: */
	if (*CsvReader)(unsafe.Pointer(p)).Fin != 0 {
		libc.Xfclose(tls, (*CsvReader)(unsafe.Pointer(p)).Fin)
		sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn)
	}
	sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).Fz)
	csv_reader_init(tls, p)
}

// Report an error on a CsvReader
func csv_errmsg(tls *libc.TLS, p uintptr, zFormat uintptr, va uintptr) { /* csv.c:112:13: */
	var ap va_list
	_ = ap
	ap = va
	sqlite3.Xsqlite3_vsnprintf(tls, CSV_MXERR, p+40 /* &.zErr */, zFormat, ap)
	_ = ap
}

// Open the file associated with a CsvReader
// Return the number of errors.
func csv_reader_open(tls *libc.TLS, p uintptr, zFilename uintptr, zData uintptr) int32 { /* csv.c:122:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if zFilename != 0 {
		(*CsvReader)(unsafe.Pointer(p)).FzIn = sqlite3.Xsqlite3_malloc(tls, CSV_INBUFSZ)
		if (*CsvReader)(unsafe.Pointer(p)).FzIn == uintptr(0) {
			csv_errmsg(tls, p, ts+1930 /* "out of memory" */, 0)
			return 1
		}
		(*CsvReader)(unsafe.Pointer(p)).Fin = libc.Xfopen(tls, zFilename, ts+4263 /* "rb" */)
		if (*CsvReader)(unsafe.Pointer(p)).Fin == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn)
			csv_reader_reset(tls, p)
			csv_errmsg(tls, p, ts+4266 /* "cannot open '%s'..." */, libc.VaList(bp, zFilename))
			return 1
		}
	} else {

		(*CsvReader)(unsafe.Pointer(p)).FzIn = zData
		(*CsvReader)(unsafe.Pointer(p)).FnIn = libc.Xstrlen(tls, zData)
	}
	return 0
}

// The input buffer has overflowed.  Refill the input buffer, then
// return the next character
func csv_getc_refill(tls *libc.TLS, p uintptr) int32 { /* csv.c:151:25: */
	var got size_t

	// Only called on an empty input buffer
	// Only called if reading froma file

	got = libc.Xfread(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn, uint32(1), uint32(CSV_INBUFSZ), (*CsvReader)(unsafe.Pointer(p)).Fin)
	if got == size_t(0) {
		return -1
	}
	(*CsvReader)(unsafe.Pointer(p)).FnIn = got
	(*CsvReader)(unsafe.Pointer(p)).FiIn = size_t(1)
	return int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).FzIn)))
}

// Return the next character of input.  Return EOF at end of input.
func csv_getc(tls *libc.TLS, p uintptr) int32 { /* csv.c:165:12: */
	if (*CsvReader)(unsafe.Pointer(p)).FiIn >= (*CsvReader)(unsafe.Pointer(p)).FnIn {
		if (*CsvReader)(unsafe.Pointer(p)).Fin != uintptr(0) {
			return csv_getc_refill(tls, p)
		}
		return -1
	}
	return int32(*(*uint8)(unsafe.Pointer(((*CsvReader)(unsafe.Pointer(p)).FzIn) + uintptr(libc.PostIncUint32(&(*CsvReader)(unsafe.Pointer(p)).FiIn, 1)))))
}

// Increase the size of p->z and append character c to the end.
// Return 0 on success and non-zero if there is an OOM error
func csv_resize_and_append(tls *libc.TLS, p uintptr, c int8) int32 { /* csv.c:175:25: */
	var zNew uintptr
	var nNew int32 = (((*CsvReader)(unsafe.Pointer(p)).FnAlloc * 2) + 100)
	zNew = sqlite3.Xsqlite3_realloc64(tls, (*CsvReader)(unsafe.Pointer(p)).Fz, uint64(nNew))
	if zNew != 0 {
		(*CsvReader)(unsafe.Pointer(p)).Fz = zNew
		(*CsvReader)(unsafe.Pointer(p)).FnAlloc = nNew
		*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*CsvReader)(unsafe.Pointer(p)).Fn, 1)))) = c
		return 0
	} else {
		csv_errmsg(tls, p, ts+1930 /* "out of memory" */, 0)
		return 1
	}
	return int32(0)
}

// Append a single character to the CsvReader.z[] array.
// Return 0 on success and non-zero if there is an OOM error
func csv_append(tls *libc.TLS, p uintptr, c int8) int32 { /* csv.c:192:12: */
	if (*CsvReader)(unsafe.Pointer(p)).Fn >= ((*CsvReader)(unsafe.Pointer(p)).FnAlloc - 1) {
		return csv_resize_and_append(tls, p, c)
	}
	*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*CsvReader)(unsafe.Pointer(p)).Fn, 1)))) = c
	return 0
}

// Read a single field of CSV text.  Compatible with rfc4180 and extended
// with the option of having a separator other than ",".
//
//   +  Input comes from p->in.
//   +  Store results in p->z of length p->n.  Space to hold p->z comes
//      from sqlite3_malloc64().
//   +  Keep track of the line number in p->nLine.
//   +  Store the character that terminates the field in p->cTerm.  Store
//      EOF on end-of-file.
//
// Return 0 at EOF or on OOM.  On EOF, the p->cTerm character will have
// been set to EOF.
func csv_read_one_field(tls *libc.TLS, p uintptr) uintptr { /* csv.c:211:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var c int32
	(*CsvReader)(unsafe.Pointer(p)).Fn = 0
	c = csv_getc(tls, p)
	if c == (-1) {
		(*CsvReader)(unsafe.Pointer(p)).FcTerm = -1
		return uintptr(0)
	}
	if c == '"' {
		var pc int32
		var ppc int32
		var startLine int32 = (*CsvReader)(unsafe.Pointer(p)).FnLine
		pc = libc.AssignInt32(&ppc, 0)
		for 1 != 0 {
			c = csv_getc(tls, p)
			if (c <= '"') || (pc == '"') {
				if c == '\n' {
					(*CsvReader)(unsafe.Pointer(p)).FnLine++
				}
				if c == '"' {
					if pc == '"' {
						pc = 0
						continue
					}
				}
				if ((((c == ',') && (pc == '"')) ||
					((c == '\n') && (pc == '"'))) ||
					(((c == '\n') && (pc == '\r')) && (ppc == '"'))) ||
					((c == (-1)) && (pc == '"')) {
					for ok := true; ok; ok = (int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr((*CsvReader)(unsafe.Pointer(p)).Fn)))) != '"') {
						(*CsvReader)(unsafe.Pointer(p)).Fn--
					}
					(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
					break
				}
				if (pc == '"') && (c != '\r') {
					csv_errmsg(tls, p, ts+4295 /* "line %d: unescap..." */, libc.VaList(bp, (*CsvReader)(unsafe.Pointer(p)).FnLine, '"'))
					break
				}
				if c == (-1) {
					csv_errmsg(tls, p, ts+4327, /* "line %d: untermi..." */
						libc.VaList(bp+16, startLine, '"'))
					(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
					break
				}
			}
			if csv_append(tls, p, int8(c)) != 0 {
				return uintptr(0)
			}
			ppc = pc
			pc = c
		}
	} else {
		// If this is the first field being parsed and it begins with the
		// UTF-8 BOM  (0xEF BB BF) then skip the BOM
		if ((c & 0xff) == 0xef) && ((*CsvReader)(unsafe.Pointer(p)).FbNotFirst == 0) {
			csv_append(tls, p, int8(c))
			c = csv_getc(tls, p)
			if (c & 0xff) == 0xbb {
				csv_append(tls, p, int8(c))
				c = csv_getc(tls, p)
				if (c & 0xff) == 0xbf {
					(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 1
					(*CsvReader)(unsafe.Pointer(p)).Fn = 0
					return csv_read_one_field(tls, p)
				}
			}
		}
		for (c > ',') || (((c != (-1)) && (c != ',')) && (c != '\n')) {
			if csv_append(tls, p, int8(c)) != 0 {
				return uintptr(0)
			}
			c = csv_getc(tls, p)
		}
		if c == '\n' {
			(*CsvReader)(unsafe.Pointer(p)).FnLine++
			if ((*CsvReader)(unsafe.Pointer(p)).Fn > 0) && (int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr(((*CsvReader)(unsafe.Pointer(p)).Fn - 1))))) == '\r') {
				(*CsvReader)(unsafe.Pointer(p)).Fn--
			}
		}
		(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
	}
	if (*CsvReader)(unsafe.Pointer(p)).Fz != 0 {
		*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr((*CsvReader)(unsafe.Pointer(p)).Fn))) = int8(0)
	}
	(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 1
	return (*CsvReader)(unsafe.Pointer(p)).Fz
}

// An instance of the CSV virtual table
type CsvTable1 = struct {
	Fbase      sqlite3_vtab
	FzFilename uintptr
	FzData     uintptr
	FiStart    int32
	FnCol      int32
	FtstFlags  uint32
} /* csv.c:307:9 */

// An instance of the CSV virtual table
type CsvTable = CsvTable1 /* csv.c:314:3 */

// Allowed values for tstFlags

// A cursor for the CSV virtual table
type CsvCursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	Frdr    CsvReader
	FazVal  uintptr
	FaLen   uintptr
	_       [4]byte
	FiRowid sqlite3_int64
} /* csv.c:320:9 */

// Allowed values for tstFlags

// A cursor for the CSV virtual table
type CsvCursor = CsvCursor1 /* csv.c:326:3 */

// Transfer error message text from a reader into a CsvTable
func csv_xfer_error(tls *libc.TLS, pTab uintptr, pRdr uintptr) { /* csv.c:329:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(pTab)).Fbase.FzErrMsg)
	(*CsvTable)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, pRdr+40 /* &.zErr */))
}

// This method is the destructor fo a CsvTable object.
func csvtabDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* csv.c:337:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(p)).FzFilename)
	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(p)).FzData)
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

// Skip leading whitespace.  Return a pointer to the first non-whitespace
// character, or to the zero terminator if the string has only whitespace
func csv_skip_whitespace(tls *libc.TLS, z uintptr) uintptr { /* csv.c:347:19: */
	for (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(z)))))*2))) & int32(_ISspace)) != 0 {
		z++
	}
	return z
}

// Remove trailing whitespace from the end of string z[]
func csv_trim_whitespace(tls *libc.TLS, z uintptr) { /* csv.c:353:13: */
	var n size_t = libc.Xstrlen(tls, z)
	for (n > size_t(0)) && ((int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(n))))))*2))) & int32(_ISspace)) != 0) {
		n--
	}
	*(*int8)(unsafe.Pointer(z + uintptr(n))) = int8(0)
}

// Dequote the string
func csv_dequote(tls *libc.TLS, z uintptr) { /* csv.c:360:13: */
	var j int32
	var cQuote int8 = *(*int8)(unsafe.Pointer(z))
	var i size_t
	var n size_t

	if (int32(cQuote) != '\'') && (int32(cQuote) != '"') {
		return
	}
	n = libc.Xstrlen(tls, z)
	if (n < size_t(2)) || (int32(*(*int8)(unsafe.Pointer(z + uintptr((n - size_t(1)))))) != int32(*(*int8)(unsafe.Pointer(z)))) {
		return
	}
	i = size_t(1)
	j = 0
	for ; i < (n - size_t(1)); i++ {
		if (int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == int32(cQuote)) && (int32(*(*int8)(unsafe.Pointer(z + uintptr((i + size_t(1)))))) == int32(cQuote)) {
			i++
		}
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(i)))
	}
	*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)
}

// Check to see if the string is of the form:  "TAG = VALUE" with optional
// whitespace before and around tokens.  If it is, return a pointer to the
// first character of VALUE.  If it is not, return NULL.
func csv_parameter(tls *libc.TLS, zTag uintptr, nTag int32, z uintptr) uintptr { /* csv.c:379:19: */
	z = csv_skip_whitespace(tls, z)
	if libc.Xstrncmp(tls, zTag, z, uint32(nTag)) != 0 {
		return uintptr(0)
	}
	z = csv_skip_whitespace(tls, (z + uintptr(nTag)))
	if int32(*(*int8)(unsafe.Pointer(z))) != '=' {
		return uintptr(0)
	}
	return csv_skip_whitespace(tls, (z + uintptr(1)))
}

// Decode a parameter that requires a dequoted string.
//
// Return 1 if the parameter is seen, or 0 if not.  1 is returned
// even if there is an error.  If an error occurs, then an error message
// is left in p->zErr.  If there are no errors, p->zErr[0]==0.
func csv_string_parameter(tls *libc.TLS, p uintptr, zParam uintptr, zArg uintptr, pzVal uintptr) int32 { /* csv.c:393:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var zValue uintptr
	zValue = csv_parameter(tls, zParam, int32(libc.Xstrlen(tls, zParam)), zArg)
	if zValue == uintptr(0) {
		return 0
	}
	*(*int8)(unsafe.Pointer((p + 40 /* &.zErr */))) = int8(0)
	if *(*uintptr)(unsafe.Pointer(pzVal)) != 0 {
		csv_errmsg(tls, p, ts+4366 /* "more than one '%..." */, libc.VaList(bp, zParam))
		return 1
	}
	*(*uintptr)(unsafe.Pointer(pzVal)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, zValue))
	if *(*uintptr)(unsafe.Pointer(pzVal)) == uintptr(0) {
		csv_errmsg(tls, p, ts+1930 /* "out of memory" */, 0)
		return 1
	}
	csv_trim_whitespace(tls, *(*uintptr)(unsafe.Pointer(pzVal)))
	csv_dequote(tls, *(*uintptr)(unsafe.Pointer(pzVal)))
	return 1
}

// Return 0 if the argument is false and 1 if it is true.  Return -1 if
// we cannot really tell.
func csv_boolean(tls *libc.TLS, z uintptr) int32 { /* csv.c:421:12: */
	if (((sqlite3.Xsqlite3_stricmp(tls, ts+4035 /* "yes" */, z) == 0) ||
		(sqlite3.Xsqlite3_stricmp(tls, ts+4039 /* "on" */, z) == 0)) ||
		(sqlite3.Xsqlite3_stricmp(tls, ts+4395 /* "true" */, z) == 0)) ||
		((int32(*(*int8)(unsafe.Pointer(z))) == '1') && (int32(*(*int8)(unsafe.Pointer(z + 1))) == 0)) {
		return 1
	}
	if (((sqlite3.Xsqlite3_stricmp(tls, ts+4400 /* "no" */, z) == 0) ||
		(sqlite3.Xsqlite3_stricmp(tls, ts+4403 /* "off" */, z) == 0)) ||
		(sqlite3.Xsqlite3_stricmp(tls, ts+4407 /* "false" */, z) == 0)) ||
		((int32(*(*int8)(unsafe.Pointer(z))) == '0') && (int32(*(*int8)(unsafe.Pointer(z + 1))) == 0)) {
		return 0
	}
	return -1
}

// Check to see if the string is of the form:  "TAG = BOOLEAN" or just "TAG".
// If it is, set *pValue to be the value of the boolean ("true" if there is
// not "= BOOLEAN" component) and return non-zero.  If the input string
// does not begin with TAG, return zero.
func csv_boolean_parameter(tls *libc.TLS, zTag uintptr, nTag int32, z uintptr, pValue uintptr) int32 { /* csv.c:444:12: */
	var b int32
	z = csv_skip_whitespace(tls, z)
	if libc.Xstrncmp(tls, zTag, z, uint32(nTag)) != 0 {
		return 0
	}
	z = csv_skip_whitespace(tls, (z + uintptr(nTag)))
	if int32(*(*int8)(unsafe.Pointer(z))) == 0 {
		*(*int32)(unsafe.Pointer(pValue)) = 1
		return 1
	}
	if int32(*(*int8)(unsafe.Pointer(z))) != '=' {
		return 0
	}
	z = csv_skip_whitespace(tls, (z + uintptr(1)))
	b = csv_boolean(tls, z)
	if b >= 0 {
		*(*int32)(unsafe.Pointer(pValue)) = b
		return 1
	}
	return 0
}

// Parameters:
//    filename=FILENAME          Name of file containing CSV content
//    data=TEXT                  Direct CSV content.
//    schema=SCHEMA              Alternative CSV schema.
//    header=YES|NO              First row of CSV defines the names of
//                               columns if "yes".  Default "no".
//    columns=N                  Assume the CSV file contains N columns.
//
// Only available if compiled with SQLITE_TEST:
//
//    testflags=N                Bitmask of test flags.  Optional
//
// If schema= is omitted, then the columns are named "c0", "c1", "c2",
// and so forth.  If columns=N is omitted, then the file is opened and
// the number of columns in the first row is counted to determine the
// column count.  If header=YES, then the first row is skipped.
func csvtabConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* csv.c:486:12: */
	bp := tls.Alloc(336)
	defer tls.Free(336)

	var pNew uintptr  // The CsvTable object to construct
	var bHeader int32 // header= flags.  -1 means not seen yet
	var rc int32      // Result code from this routine
	var i int32
	var j int32        // Loop counters
	var tstFlags int32 // Value for testflags=N parameter
	// var b int32 at bp+332, 4
	// Value of a boolean parameter
	var nCol int32 // Value of the columns= parameter
	// var sRdr CsvReader at bp+80, 240

	// var azPValue [3]uintptr at bp+320, 12

	var z uintptr
	var zValue uintptr
	var z1 uintptr
	var pStr uintptr
	var zSep uintptr
	var iCol int32
	pNew = uintptr(0)
	bHeader = -1
	rc = SQLITE_OK
	tstFlags = 0
	nCol = -99 // Parameter values

	libc.Xmemset(tls, bp+80 /* &sRdr */, 0, uint32(unsafe.Sizeof(CsvReader{})))
	libc.Xmemset(tls, bp+320 /* &azPValue[0] */, 0, uint32(unsafe.Sizeof([3]uintptr{})))
	i = 3
__1:
	if !(i < argc) {
		goto __3
	}
	z = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))
	j = 0
__4:
	if !(uint32(j) < (uint32(unsafe.Sizeof(azParam)) / uint32(unsafe.Sizeof(uintptr(0))))) {
		goto __6
	}
	if !(csv_string_parameter(tls, bp+80 /* &sRdr */, azParam[j], z, (bp+320 /* &azPValue */ +uintptr(j)*4)) != 0) {
		goto __7
	}
	goto __6
__7:
	;
	goto __5
__5:
	j++
	goto __4
	goto __6
__6:
	;
	if !(uint32(j) < (uint32(unsafe.Sizeof(azParam)) / uint32(unsafe.Sizeof(uintptr(0))))) {
		goto __8
	}
	if !(*(*int8)(unsafe.Pointer((bp + 80 /* &sRdr */ + 40 /* &.zErr */))) != 0) {
		goto __10
	}
	goto csvtab_connect_error
__10:
	;
	goto __9
__8:
	if !(csv_boolean_parameter(tls, ts+4413 /* "header" */, 6, z, bp+332 /* &b */) != 0) {
		goto __11
	}
	if !(bHeader >= 0) {
		goto __13
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4420 /* "more than one 'h..." */, 0)
	goto csvtab_connect_error
__13:
	;
	bHeader = *(*int32)(unsafe.Pointer(bp + 332 /* b */))
	goto __12
__11:
	if !((libc.AssignUintptr(&zValue, csv_parameter(tls, ts+4453 /* "testflags" */, 9, z))) != uintptr(0)) {
		goto __14
	}
	tstFlags = int32(uint32(libc.Xatoi(tls, zValue)))
	goto __15
__14:
	if !((libc.AssignUintptr(&zValue, csv_parameter(tls, ts+4463 /* "columns" */, 7, z))) != uintptr(0)) {
		goto __16
	}
	if !(nCol > 0) {
		goto __18
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4471 /* "more than one 'c..." */, 0)
	goto csvtab_connect_error
__18:
	;
	nCol = libc.Xatoi(tls, zValue)
	if !(nCol <= 0) {
		goto __19
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4505 /* "column= value mu..." */, 0)
	goto csvtab_connect_error
__19:
	;
	goto __17
__16:

	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4536 /* "bad parameter: '..." */, libc.VaList(bp, z))
	goto csvtab_connect_error
__17:
	;
__15:
	;
__12:
	;
__9:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	if !((libc.Bool32((*(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */))) == uintptr(0))) == (libc.Bool32((*(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + 1*4))) == uintptr(0)))) {
		goto __20
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4556 /* "must specify eit..." */, 0)
	goto csvtab_connect_error
__20:
	;

	if !(((nCol <= 0) || (bHeader == 1)) &&
		(csv_reader_open(tls, bp+80 /* &sRdr */, *(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */)), *(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + 1*4))) != 0)) {
		goto __21
	}
	goto csvtab_connect_error
__21:
	;
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(CsvTable{})))
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	if !(pNew == uintptr(0)) {
		goto __22
	}
	goto csvtab_connect_oom
__22:
	;
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(CsvTable{})))
	if !((*(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + 2*4))) == uintptr(0)) {
		goto __23
	}
	pStr = sqlite3.Xsqlite3_str_new(tls, uintptr(0))
	zSep = ts + 489 /* "" */
	iCol = 0
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+884 /* "CREATE TABLE x(" */, 0)
	if !((nCol < 0) && (bHeader < 1)) {
		goto __25
	}
	nCol = 0
__26:
	csv_read_one_field(tls, bp+80 /* &sRdr */)
	nCol++
	goto __27
__27:
	if (*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).FcTerm == ',' {
		goto __26
	}
	goto __28
__28:
	;
__25:
	;
	if !((nCol > 0) && (bHeader < 1)) {
		goto __29
	}
	iCol = 0
__31:
	if !(iCol < nCol) {
		goto __33
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+4608 /* "%sc%d TEXT" */, libc.VaList(bp+8, zSep, iCol))
	zSep = ts + 4619 /* "," */
	goto __32
__32:
	iCol++
	goto __31
	goto __33
__33:
	;
	goto __30
__29:
__34:
	z1 = csv_read_one_field(tls, bp+80 /* &sRdr */)
	if !(((nCol > 0) && (iCol < nCol)) || ((nCol < 0) && (bHeader != 0))) {
		goto __37
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+4621 /* "%s\"%w\" TEXT" */, libc.VaList(bp+24, zSep, z1))
	zSep = ts + 4619 /* "," */
	iCol++
__37:
	;
	goto __35
__35:
	if (*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).FcTerm == ',' {
		goto __34
	}
	goto __36
__36:
	;
	if !(nCol < 0) {
		goto __38
	}
	nCol = iCol
	goto __39
__38:
__40:
	if !(iCol < nCol) {
		goto __41
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+4608 /* "%sc%d TEXT" */, libc.VaList(bp+40, zSep, libc.PreIncInt32(&iCol, 1)))
	zSep = ts + 4619 /* "," */
	goto __40
__41:
	;
__39:
	;
__30:
	;
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol = nCol
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+490 /* ")" */, 0)
	(*(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + 2*4))) = sqlite3.Xsqlite3_str_finish(tls, pStr)
	if !((*(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + 2*4))) == uintptr(0)) {
		goto __42
	}
	goto csvtab_connect_oom
__42:
	;
	goto __24
__23:
	if !(nCol < 0) {
		goto __43
	}
__45:
	csv_read_one_field(tls, bp+80 /* &sRdr */)
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol++
	goto __46
__46:
	if (*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).FcTerm == ',' {
		goto __45
	}
	goto __47
__47:
	;
	goto __44
__43:
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol = nCol
__44:
	;
__24:
	;
	(*CsvTable)(unsafe.Pointer(pNew)).FzFilename = *(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */))
	(*(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */))) = uintptr(0)
	(*CsvTable)(unsafe.Pointer(pNew)).FzData = *(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + 1*4))
	(*(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + 1*4))) = uintptr(0)
	(*CsvTable)(unsafe.Pointer(pNew)).FtstFlags = uint32(tstFlags)
	if !(bHeader != 1) {
		goto __48
	}
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = 0
	goto __49
__48:
	if !((*CsvTable)(unsafe.Pointer(pNew)).FzData != 0) {
		goto __50
	}
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = int32(int32((*CsvReader)(unsafe.Pointer(bp + 80 /* &sRdr */)).FiIn))
	goto __51
__50:
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = int32((int32((uint32(libc.Xftell(tls, (*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).Fin)) - uint32((*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).FnIn)) + uint32((*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).FiIn))))
__51:
	;
__49:
	;
	csv_reader_reset(tls, bp+80 /* &sRdr */)
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db, *(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + 2*4)))
	if !(rc != 0) {
		goto __52
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4633 /* "bad schema: '%s'..." */, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + 2*4)), sqlite3.Xsqlite3_errmsg(tls, db)))
	goto csvtab_connect_error
__52:
	;
	i = 0
__53:
	if !(uint32(i) < (uint32(unsafe.Sizeof([3]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0))))) {
		goto __55
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + uintptr(i)*4)))
	goto __54
__54:
	i++
	goto __53
	goto __55
__55:
	;
	// Rationale for DIRECTONLY:
	// An attacker who controls a database schema could use this vtab
	// to exfiltrate sensitive data from other files in the filesystem.
	// And, recommended practice is to put all CSV virtual tables in the
	// TEMP namespace, so they should still be usable from within TEMP
	// views, so there shouldn't be a serious loss of functionality by
	// prohibiting the use of this vtab from persistent triggers and views.
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_DIRECTONLY, 0)
	return SQLITE_OK

csvtab_connect_oom:
	rc = SQLITE_NOMEM
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+1930 /* "out of memory" */, 0)

csvtab_connect_error:
	if !(pNew != 0) {
		goto __56
	}
	csvtabDisconnect(tls, (pNew /* &.base */))
__56:
	;
	i = 0
__57:
	if !(uint32(i) < (uint32(unsafe.Sizeof([3]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0))))) {
		goto __59
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 320 /* &azPValue[0] */ + uintptr(i)*4)))
	goto __58
__58:
	i++
	goto __57
	goto __59
__59:
	;
	if !(*(*int8)(unsafe.Pointer((bp + 80 /* &sRdr */ + 40 /* &.zErr */))) != 0) {
		goto __60
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(pzErr)))
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+72, bp+80 /* &sRdr */ +40 /* &.zErr */))
__60:
	;
	csv_reader_reset(tls, bp+80 /* &sRdr */)
	if !(rc == SQLITE_OK) {
		goto __61
	}
	rc = SQLITE_ERROR
__61:
	;
	return rc
}

var azParam = [3]uintptr{
	ts + 4655 /* "filename" */, ts + 4664 /* "data" */, ts + 4669, /* "schema" */
} /* csv.c:504:21 */

// Reset the current row content held by a CsvCursor.
func csvtabCursorRowReset(tls *libc.TLS, pCur uintptr) { /* csv.c:667:13: */
	var pTab uintptr = (*CsvCursor)(unsafe.Pointer(pCur)).Fbase.FpVtab
	var i int32
	for i = 0; i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)))
		*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)) = uintptr(0)
		*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = 0
	}
}

// The xConnect and xCreate methods do the same thing, but they must be
// different so that the virtual table is not an eponymous virtual table.
func csvtabCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* csv.c:681:12: */
	return csvtabConnect(tls, db, pAux, argc, argv, ppVtab, pzErr)
}

// Destructor for a CsvCursor.
func csvtabClose(tls *libc.TLS, cur uintptr) int32 { /* csv.c:694:12: */
	var pCur uintptr = cur
	csvtabCursorRowReset(tls, pCur)
	csv_reader_reset(tls, (pCur + 4 /* &.rdr */))
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

// Constructor for a new CsvTable cursor object.
func csvtabOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* csv.c:705:12: */
	var pTab uintptr = p
	var pCur uintptr
	var nByte size_t
	nByte = (uint32(unsafe.Sizeof(CsvCursor{})) + ((uint32(unsafe.Sizeof(uintptr(0))) + uint32(unsafe.Sizeof(int32(0)))) * uint32((*CsvTable)(unsafe.Pointer(pTab)).FnCol)))
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, nByte)
	(*CsvCursor)(unsafe.Pointer(pCur)).FazVal = (pCur + 1*264)
	(*CsvCursor)(unsafe.Pointer(pCur)).FaLen = ((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr((*CsvTable)(unsafe.Pointer(pTab)).FnCol)*4)
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	if csv_reader_open(tls, (pCur+4 /* &.rdr */), (*CsvTable)(unsafe.Pointer(pTab)).FzFilename, (*CsvTable)(unsafe.Pointer(pTab)).FzData) != 0 {
		csv_xfer_error(tls, pTab, (pCur + 4 /* &.rdr */))
		return SQLITE_ERROR
	}
	return SQLITE_OK
}

// Advance a CsvCursor to its next row of input.
// Set the EOF marker if we reach the end of input.
func csvtabNext(tls *libc.TLS, cur uintptr) int32 { /* csv.c:728:12: */
	var pCur uintptr = cur
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	var i int32 = 0
	var z uintptr
	for ok := true; ok; ok = ((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FcTerm == ',') {
		z = csv_read_one_field(tls, (pCur + 4 /* &.rdr */))
		if z == uintptr(0) {
			break
		}
		if i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol {
			if *(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) < ((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn + 1) {
				var zNew uintptr = sqlite3.Xsqlite3_realloc64(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)), (uint64((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn + 1)))
				if zNew == uintptr(0) {
					csv_errmsg(tls, (pCur + 4 /* &.rdr */), ts+1930 /* "out of memory" */, 0)
					csv_xfer_error(tls, pTab, (pCur + 4 /* &.rdr */))
					break
				}
				*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)) = zNew
				*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = ((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn + 1)
			}
			libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)), z, (uint32((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn + 1)))
			i++
		}
	}
	if (z == uintptr(0)) || (((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FcTerm == (-1)) && (i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol)) {
		(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid = int64(-1)
	} else {
		(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid++
		for i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol {
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)))
			*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)) = uintptr(0)
			*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = 0
			i++
		}
	}
	return SQLITE_OK
}

// Return values of columns for the row at which the CsvCursor
// is currently pointing.
func csvtabColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* csv.c:771:12: */
	var pCur uintptr = cur
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	if ((i >= 0) && (i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol)) && (*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)) != uintptr(0)) {
		sqlite3.Xsqlite3_result_text(tls, ctx, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)), -1, libc.UintptrFromInt32(-1))
	}
	return SQLITE_OK
}

// Return the rowid for the current row.
func csvtabRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* csv.c:787:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*CsvCursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func csvtabEof(tls *libc.TLS, cur uintptr) int32 { /* csv.c:797:12: */
	var pCur uintptr = cur
	return (libc.Bool32((*CsvCursor)(unsafe.Pointer(pCur)).FiRowid < int64(0)))
}

// Only a full table scan is supported.  So xFilter simply rewinds to
// the beginning.
func csvtabFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* csv.c:806:12: */
	var pCur uintptr = pVtabCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid = int64(0)
	if (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fin == uintptr(0) {

		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FiIn = size_t((*CsvTable)(unsafe.Pointer(pTab)).FiStart)
	} else {
		libc.Xfseek(tls, (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fin, (*CsvTable)(unsafe.Pointer(pTab)).FiStart, SEEK_SET)
		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FiIn = size_t(0)
		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FnIn = size_t(0)
	}
	return csvtabNext(tls, pVtabCursor)
}

// Only a forward full table scan is supported.  xBestIndex is mostly
// a no-op.  If CSVTEST_FIDX is set, then the presence of equality
// constraints lowers the estimated cost, which is fiction, but is useful
// for testing certain kinds of virtual table behavior.
func csvtabBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* csv.c:833:12: */
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1000000)
	if ((*CsvTable)(unsafe.Pointer((tab))).FtstFlags & uint32(CSVTEST_FIDX)) != uint32(0) {
		// The usual (and sensible) case is to always do a full table scan.
		// The code in this branch only runs when testflags=1.  This code
		// generates an artifical and unrealistic plan which is useful
		// for testing virtual table logic but is not helpful to real applications.
		//
		// Any ==, LIKE, or GLOB constraint is marked as usable by the virtual
		// table (even though it is not) and the cost of running the virtual table
		// is reduced from 1 million to just 10.  The constraints are *not* marked
		// as omittable, however, so the query planner should still generate a
		// plan that gives a correct answer, even if they plan is not optimal.
		var i int32
		var nConst int32 = 0
		for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
			var op uint8
			if int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(i)*12)).Fusable) == 0 {
				continue
			}
			op = (*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)).Fop
			if ((int32(op) == SQLITE_INDEX_CONSTRAINT_EQ) ||
				(int32(op) == SQLITE_INDEX_CONSTRAINT_LIKE)) ||
				(int32(op) == SQLITE_INDEX_CONSTRAINT_GLOB) {
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10)
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(nConst)*8)).FargvIndex = (nConst + 1)
				nConst++
			}
		}
	}
	return SQLITE_OK
}

var CsvModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* csv.c:872:23 */

// For virtual table testing, make a version of the CSV virtual table
// available that has an xUpdate function.  But the xUpdate always returns
// SQLITE_READONLY since the CSV file is not really writable.
func csvtabUpdate(tls *libc.TLS, p uintptr, n int32, v uintptr, x uintptr) int32 { /* csv.c:901:12: */
	return SQLITE_READONLY
}

var CsvModuleFauxWrite = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRowid - read data
	FxUpdate:     0, // xRename
} /* csv.c:904:23 */

// This routine is called when the extension is loaded.  The new
// CSV virtual table module is registered with the calling database
// connection.
func sqlite3_csv_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* csv.c:939:5: */
	var rc int32
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4676 /* "csv" */, uintptr(unsafe.Pointer(&CsvModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4680 /* "csv_wr" */, uintptr(unsafe.Pointer(&CsvModuleFauxWrite)), uintptr(0))
	}
	return rc
}

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Mark a function parameter as unused, to suppress nuisance compiler
// warnings.

// A decimal object
type Decimal1 = struct {
	Fsign   int8
	Foom    int8
	FisNull int8
	FisInit int8
	FnDigit int32
	FnFrac  int32
	Fa      uintptr
} /* decimal.c:32:9 */

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Mark a function parameter as unused, to suppress nuisance compiler
// warnings.

// A decimal object
type Decimal = Decimal1 /* decimal.c:32:24 */

// Release memory held by a Decimal, but do not free the object itself.
func decimal_clear(tls *libc.TLS, p uintptr) { /* decimal.c:46:13: */
	sqlite3.Xsqlite3_free(tls, (*Decimal)(unsafe.Pointer(p)).Fa)
}

// Destroy a Decimal object
func decimal_free(tls *libc.TLS, p uintptr) { /* decimal.c:53:13: */
	if p != 0 {
		decimal_clear(tls, p)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Allocate a new Decimal object.  Initialize it to the number given
// by the input string.
func decimal_new(tls *libc.TLS, pCtx uintptr, pIn uintptr, nAlt int32, zAlt uintptr) uintptr { /* decimal.c:64:16: */
	var p uintptr
	var n int32
	var i int32
	var zIn uintptr
	var iExp int32
	var j int32
	var neg int32
	var c int8
	var nExtra int32
	iExp = 0
	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Decimal{})))
	if !(p == uintptr(0)) {
		goto __1
	}
	goto new_no_mem
__1:
	;
	(*Decimal)(unsafe.Pointer(p)).Fsign = int8(0)
	(*Decimal)(unsafe.Pointer(p)).Foom = int8(0)
	(*Decimal)(unsafe.Pointer(p)).FisInit = int8(1)
	(*Decimal)(unsafe.Pointer(p)).FisNull = int8(0)
	(*Decimal)(unsafe.Pointer(p)).FnDigit = 0
	(*Decimal)(unsafe.Pointer(p)).FnFrac = 0
	if !(zAlt != 0) {
		goto __2
	}
	n = nAlt
	zIn = zAlt
	goto __3
__2:
	if !(sqlite3.Xsqlite3_value_type(tls, pIn) == SQLITE_NULL) {
		goto __4
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = uintptr(0)
	(*Decimal)(unsafe.Pointer(p)).FisNull = int8(1)
	return p
__4:
	;
	n = sqlite3.Xsqlite3_value_bytes(tls, pIn)
	zIn = sqlite3.Xsqlite3_value_text(tls, pIn)
__3:
	;
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_malloc64(tls, (uint64(n + 1)))
	if !((*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0)) {
		goto __5
	}
	goto new_no_mem
__5:
	;
	i = 0
__6:
	if !((int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls)))) + uintptr(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))))*2))) & int32(_ISspace)) != 0) {
		goto __8
	}
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))) == '-') {
		goto __9
	}
	(*Decimal)(unsafe.Pointer(p)).Fsign = int8(1)
	i++
	goto __10
__9:
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))) == '+') {
		goto __11
	}
	i++
__11:
	;
__10:
	;
__12:
	if !((i < n) && (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))) == '0')) {
		goto __13
	}
	i++
	goto __12
__13:
	;
__14:
	if !(i < n) {
		goto __15
	}
	c = int8(*(*uint8)(unsafe.Pointer(zIn + uintptr(i))))
	if !((int32(c) >= '0') && (int32(c) <= '9')) {
		goto __16
	}
	*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(libc.PostIncInt32(&(*Decimal)(unsafe.Pointer(p)).FnDigit, 1)))) = (int8(int32(c) - '0'))
	goto __17
__16:
	if !(int32(c) == '.') {
		goto __18
	}
	(*Decimal)(unsafe.Pointer(p)).FnFrac = ((*Decimal)(unsafe.Pointer(p)).FnDigit + 1)
	goto __19
__18:
	if !((int32(c) == 'e') || (int32(c) == 'E')) {
		goto __20
	}
	j = (i + 1)
	neg = 0
	if !(j >= n) {
		goto __21
	}
	goto __15
__21:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) == '-') {
		goto __22
	}
	neg = 1
	j++
	goto __23
__22:
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) == '+') {
		goto __24
	}
	j++
__24:
	;
__23:
	;
__25:
	if !((j < n) && (iExp < 1000000)) {
		goto __26
	}
	if !((int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) >= '0') && (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) <= '9')) {
		goto __27
	}
	iExp = (((iExp * 10) + int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j))))) - '0')
__27:
	;
	j++
	goto __25
__26:
	;
	if !(neg != 0) {
		goto __28
	}
	iExp = -iExp
__28:
	;
	goto __15
__20:
	;
__19:
	;
__17:
	;
	i++
	goto __14
__15:
	;
	if !((*Decimal)(unsafe.Pointer(p)).FnFrac != 0) {
		goto __29
	}
	(*Decimal)(unsafe.Pointer(p)).FnFrac = ((*Decimal)(unsafe.Pointer(p)).FnDigit - ((*Decimal)(unsafe.Pointer(p)).FnFrac - 1))
__29:
	;
	if !(iExp > 0) {
		goto __30
	}
	if !((*Decimal)(unsafe.Pointer(p)).FnFrac > 0) {
		goto __32
	}
	if !(iExp <= (*Decimal)(unsafe.Pointer(p)).FnFrac) {
		goto __33
	}
	*(*int32)(unsafe.Pointer(p + 8 /* &.nFrac */)) -= (iExp)
	iExp = 0
	goto __34
__33:
	iExp = iExp - ((*Decimal)(unsafe.Pointer(p)).FnFrac)
	(*Decimal)(unsafe.Pointer(p)).FnFrac = 0
__34:
	;
__32:
	;
	if !(iExp > 0) {
		goto __35
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_realloc64(tls, (*Decimal)(unsafe.Pointer(p)).Fa, (uint64(((*Decimal)(unsafe.Pointer(p)).FnDigit + iExp) + 1)))
	if !((*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0)) {
		goto __36
	}
	goto new_no_mem
__36:
	;
	libc.Xmemset(tls, ((*Decimal)(unsafe.Pointer(p)).Fa + uintptr((*Decimal)(unsafe.Pointer(p)).FnDigit)), 0, uint32(iExp))
	*(*int32)(unsafe.Pointer(p + 4 /* &.nDigit */)) += (iExp)
__35:
	;
	goto __31
__30:
	if !(iExp < 0) {
		goto __37
	}
	iExp = -iExp
	nExtra = (((*Decimal)(unsafe.Pointer(p)).FnDigit - (*Decimal)(unsafe.Pointer(p)).FnFrac) - 1)
	if !(nExtra != 0) {
		goto __38
	}
	if !(nExtra >= iExp) {
		goto __39
	}
	*(*int32)(unsafe.Pointer(p + 8 /* &.nFrac */)) += (iExp)
	iExp = 0
	goto __40
__39:
	iExp = iExp - (nExtra)
	(*Decimal)(unsafe.Pointer(p)).FnFrac = ((*Decimal)(unsafe.Pointer(p)).FnDigit - 1)
__40:
	;
__38:
	;
	if !(iExp > 0) {
		goto __41
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_realloc64(tls, (*Decimal)(unsafe.Pointer(p)).Fa, (uint64(((*Decimal)(unsafe.Pointer(p)).FnDigit + iExp) + 1)))
	if !((*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0)) {
		goto __42
	}
	goto new_no_mem
__42:
	;
	libc.Xmemmove(tls, ((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(iExp)), (*Decimal)(unsafe.Pointer(p)).Fa, uint32((*Decimal)(unsafe.Pointer(p)).FnDigit))
	libc.Xmemset(tls, (*Decimal)(unsafe.Pointer(p)).Fa, 0, uint32(iExp))
	*(*int32)(unsafe.Pointer(p + 4 /* &.nDigit */)) += (iExp)
	*(*int32)(unsafe.Pointer(p + 8 /* &.nFrac */)) += (iExp)
__41:
	;
__37:
	;
__31:
	;
	return p

new_no_mem:
	if !(pCtx != 0) {
		goto __43
	}
	sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
__43:
	;
	sqlite3.Xsqlite3_free(tls, p)
	return uintptr(0)
}

// Make the given Decimal the result.
func decimal_result(tls *libc.TLS, pCtx uintptr, p uintptr) { /* decimal.c:183:13: */
	var z uintptr
	var i int32
	var j int32
	var n int32
	if (p == uintptr(0)) || ((*Decimal)(unsafe.Pointer(p)).Foom != 0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		return
	}
	if (*Decimal)(unsafe.Pointer(p)).FisNull != 0 {
		sqlite3.Xsqlite3_result_null(tls, pCtx)
		return
	}
	z = sqlite3.Xsqlite3_malloc(tls, ((*Decimal)(unsafe.Pointer(p)).FnDigit + 4))
	if z == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		return
	}
	i = 0
	if ((*Decimal)(unsafe.Pointer(p)).FnDigit == 0) || (((*Decimal)(unsafe.Pointer(p)).FnDigit == 1) && (int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa))) == 0)) {
		(*Decimal)(unsafe.Pointer(p)).Fsign = int8(0)
	}
	if (*Decimal)(unsafe.Pointer(p)).Fsign != 0 {
		*(*int8)(unsafe.Pointer(z)) = int8('-')
		i = 1
	}
	n = ((*Decimal)(unsafe.Pointer(p)).FnDigit - (*Decimal)(unsafe.Pointer(p)).FnFrac)
	if n <= 0 {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = int8('0')
	}
	j = 0
	for (n > 1) && (int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(j)))) == 0) {
		j++
		n--
	}
	for n > 0 {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = (int8(int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(j)))) + '0'))
		j++
		n--
	}
	if (*Decimal)(unsafe.Pointer(p)).FnFrac != 0 {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = int8('.')
		for ok := true; ok; ok = (j < (*Decimal)(unsafe.Pointer(p)).FnDigit) {
			*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = (int8(int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(j)))) + '0'))
			j++
		}
	}
	*(*int8)(unsafe.Pointer(z + uintptr(i))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, pCtx, z, i, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
}

// SQL Function:   decimal(X)
//
// Convert input X into decimal and then back into text
func decimalFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:238:13: */
	var p uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	_ = argc
	decimal_result(tls, context, p)
	decimal_free(tls, p)
}

// Compare to Decimal objects.  Return negative, 0, or positive if the
// first object is less than, equal to, or greater than the second.
//
// Preconditions for this routine:
//
//    pA!=0
//    pA->isNull==0
//    pB!=0
//    pB->isNull==0
func decimal_cmp(tls *libc.TLS, pA uintptr, pB uintptr) int32 { /* decimal.c:260:12: */
	var nASig int32
	var nBSig int32
	var rc int32
	var n int32
	if int32((*Decimal)(unsafe.Pointer(pA)).Fsign) != int32((*Decimal)(unsafe.Pointer(pB)).Fsign) {
		if (*Decimal)(unsafe.Pointer(pA)).Fsign != 0 {
			return -1
		}
		return +1
	}
	if (*Decimal)(unsafe.Pointer(pA)).Fsign != 0 {
		var pTemp uintptr = pA
		pA = pB
		pB = pTemp
	}
	nASig = ((*Decimal)(unsafe.Pointer(pA)).FnDigit - (*Decimal)(unsafe.Pointer(pA)).FnFrac)
	nBSig = ((*Decimal)(unsafe.Pointer(pB)).FnDigit - (*Decimal)(unsafe.Pointer(pB)).FnFrac)
	if nASig != nBSig {
		return (nASig - nBSig)
	}
	n = (*Decimal)(unsafe.Pointer(pA)).FnDigit
	if n > (*Decimal)(unsafe.Pointer(pB)).FnDigit {
		n = (*Decimal)(unsafe.Pointer(pB)).FnDigit
	}
	rc = libc.Xmemcmp(tls, (*Decimal)(unsafe.Pointer(pA)).Fa, (*Decimal)(unsafe.Pointer(pB)).Fa, uint32(n))
	if rc == 0 {
		rc = ((*Decimal)(unsafe.Pointer(pA)).FnDigit - (*Decimal)(unsafe.Pointer(pB)).FnDigit)
	}
	return rc
}

// SQL Function:   decimal_cmp(X, Y)
//
// Return negative, zero, or positive if X is less then, equal to, or
// greater than Y.
func decimalCmpFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:290:13: */
	var pA uintptr
	var pB uintptr
	var rc int32
	pA = uintptr(0)
	pB = uintptr(0)

	_ = argc
	pA = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	if !((pA == uintptr(0)) || ((*Decimal)(unsafe.Pointer(pA)).FisNull != 0)) {
		goto __1
	}
	goto cmp_done
__1:
	;
	pB = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*4)), 0, uintptr(0))
	if !((pB == uintptr(0)) || ((*Decimal)(unsafe.Pointer(pB)).FisNull != 0)) {
		goto __2
	}
	goto cmp_done
__2:
	;
	rc = decimal_cmp(tls, pA, pB)
	if !(rc < 0) {
		goto __3
	}
	rc = -1
	goto __4
__3:
	if !(rc > 0) {
		goto __5
	}
	rc = +1
__5:
	;
__4:
	;
	sqlite3.Xsqlite3_result_int(tls, context, rc)
cmp_done:
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

// Expand the Decimal so that it has a least nDigit digits and nFrac
// digits to the right of the decimal point.
func decimal_expand(tls *libc.TLS, p uintptr, nDigit int32, nFrac int32) { /* decimal.c:316:13: */
	var nAddSig int32
	var nAddFrac int32
	if p == uintptr(0) {
		return
	}
	nAddFrac = (nFrac - (*Decimal)(unsafe.Pointer(p)).FnFrac)
	nAddSig = ((nDigit - (*Decimal)(unsafe.Pointer(p)).FnDigit) - nAddFrac)
	if (nAddFrac == 0) && (nAddSig == 0) {
		return
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_realloc64(tls, (*Decimal)(unsafe.Pointer(p)).Fa, (uint64(nDigit + 1)))
	if (*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0) {
		(*Decimal)(unsafe.Pointer(p)).Foom = int8(1)
		return
	}
	if nAddSig != 0 {
		libc.Xmemmove(tls, ((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(nAddSig)), (*Decimal)(unsafe.Pointer(p)).Fa, uint32((*Decimal)(unsafe.Pointer(p)).FnDigit))
		libc.Xmemset(tls, (*Decimal)(unsafe.Pointer(p)).Fa, 0, uint32(nAddSig))
		*(*int32)(unsafe.Pointer(p + 4 /* &.nDigit */)) += (nAddSig)
	}
	if nAddFrac != 0 {
		libc.Xmemset(tls, ((*Decimal)(unsafe.Pointer(p)).Fa + uintptr((*Decimal)(unsafe.Pointer(p)).FnDigit)), 0, uint32(nAddFrac))
		*(*int32)(unsafe.Pointer(p + 4 /* &.nDigit */)) += (nAddFrac)
		*(*int32)(unsafe.Pointer(p + 8 /* &.nFrac */)) += (nAddFrac)
	}
}

// Add the value pB into pA.
//
// Both pA and pB might become denormalized by this routine.
func decimal_add(tls *libc.TLS, pA uintptr, pB uintptr) { /* decimal.c:345:13: */
	var nSig int32
	var nFrac int32
	var nDigit int32
	var i int32
	var rc int32
	if pA == uintptr(0) {
		return
	}
	if (((*Decimal)(unsafe.Pointer(pA)).Foom != 0) || (pB == uintptr(0))) || ((*Decimal)(unsafe.Pointer(pB)).Foom != 0) {
		(*Decimal)(unsafe.Pointer(pA)).Foom = int8(1)
		return
	}
	if ((*Decimal)(unsafe.Pointer(pA)).FisNull != 0) || ((*Decimal)(unsafe.Pointer(pB)).FisNull != 0) {
		(*Decimal)(unsafe.Pointer(pA)).FisNull = int8(1)
		return
	}
	nSig = ((*Decimal)(unsafe.Pointer(pA)).FnDigit - (*Decimal)(unsafe.Pointer(pA)).FnFrac)
	if (nSig != 0) && (int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa))) == 0) {
		nSig--
	}
	if nSig < ((*Decimal)(unsafe.Pointer(pB)).FnDigit - (*Decimal)(unsafe.Pointer(pB)).FnFrac) {
		nSig = ((*Decimal)(unsafe.Pointer(pB)).FnDigit - (*Decimal)(unsafe.Pointer(pB)).FnFrac)
	}
	nFrac = (*Decimal)(unsafe.Pointer(pA)).FnFrac
	if nFrac < (*Decimal)(unsafe.Pointer(pB)).FnFrac {
		nFrac = (*Decimal)(unsafe.Pointer(pB)).FnFrac
	}
	nDigit = ((nSig + nFrac) + 1)
	decimal_expand(tls, pA, nDigit, nFrac)
	decimal_expand(tls, pB, nDigit, nFrac)
	if ((*Decimal)(unsafe.Pointer(pA)).Foom != 0) || ((*Decimal)(unsafe.Pointer(pB)).Foom != 0) {
		(*Decimal)(unsafe.Pointer(pA)).Foom = int8(1)
	} else {
		if int32((*Decimal)(unsafe.Pointer(pA)).Fsign) == int32((*Decimal)(unsafe.Pointer(pB)).Fsign) {
			var carry int32 = 0
			for i = (nDigit - 1); i >= 0; i-- {
				var x int32 = ((int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i)))) + int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pB)).Fa + uintptr(i))))) + carry)
				if x >= 10 {
					carry = 1
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = (int8(x - 10))
				} else {
					carry = 0
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = int8(x)
				}
			}
		} else {
			var aA uintptr
			var aB uintptr
			var borrow int32 = 0
			rc = libc.Xmemcmp(tls, (*Decimal)(unsafe.Pointer(pA)).Fa, (*Decimal)(unsafe.Pointer(pB)).Fa, uint32(nDigit))
			if rc < 0 {
				aA = (*Decimal)(unsafe.Pointer(pB)).Fa
				aB = (*Decimal)(unsafe.Pointer(pA)).Fa
				(*Decimal)(unsafe.Pointer(pA)).Fsign = libc.BoolInt8(!((*Decimal)(unsafe.Pointer(pA)).Fsign != 0))
			} else {
				aA = (*Decimal)(unsafe.Pointer(pA)).Fa
				aB = (*Decimal)(unsafe.Pointer(pB)).Fa
			}
			for i = (nDigit - 1); i >= 0; i-- {
				var x int32 = ((int32(*(*int8)(unsafe.Pointer(aA + uintptr(i)))) - int32(*(*int8)(unsafe.Pointer(aB + uintptr(i))))) - borrow)
				if x < 0 {
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = (int8(x + 10))
					borrow = 1
				} else {
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = int8(x)
					borrow = 0
				}
			}
		}
	}
}

// Compare text in decimal order.
func decimalCollFunc(tls *libc.TLS, notUsed uintptr, nKey1 int32, pKey1 uintptr, nKey2 int32, pKey2 uintptr) int32 { /* decimal.c:413:12: */
	var zA uintptr = pKey1
	var zB uintptr = pKey2
	var pA uintptr = decimal_new(tls, uintptr(0), uintptr(0), nKey1, zA)
	var pB uintptr = decimal_new(tls, uintptr(0), uintptr(0), nKey2, zB)
	var rc int32
	_ = notUsed
	if (pA == uintptr(0)) || (pB == uintptr(0)) {
		rc = 0
	} else {
		rc = decimal_cmp(tls, pA, pB)
	}
	decimal_free(tls, pA)
	decimal_free(tls, pB)
	return rc
}

// SQL Function:   decimal_add(X, Y)
//                 decimal_sub(X, Y)
//
// Return the sum or difference of X and Y.
func decimalAddFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:441:13: */
	var pA uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	var pB uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*4)), 0, uintptr(0))
	_ = argc
	decimal_add(tls, pA, pB)
	decimal_result(tls, context, pA)
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

func decimalSubFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:454:13: */
	var pA uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	var pB uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*4)), 0, uintptr(0))
	_ = argc
	if pB != 0 {
		(*Decimal)(unsafe.Pointer(pB)).Fsign = libc.BoolInt8(!((*Decimal)(unsafe.Pointer(pB)).Fsign != 0))
		decimal_add(tls, pA, pB)
		decimal_result(tls, context, pA)
	}
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

// Aggregate funcion:   decimal_sum(X)
//
// Works like sum() except that it uses decimal arithmetic for unlimited
// precision.
func decimalSumStep(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:476:13: */
	var p uintptr
	var pArg uintptr
	_ = argc
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(Decimal{})))
	if p == uintptr(0) {
		return
	}
	if !(int32((*Decimal)(unsafe.Pointer(p)).FisInit) != 0) {
		(*Decimal)(unsafe.Pointer(p)).FisInit = int8(1)
		(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_malloc(tls, 2)
		if (*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0) {
			(*Decimal)(unsafe.Pointer(p)).Foom = int8(1)
		} else {
			*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa)) = int8(0)
		}
		(*Decimal)(unsafe.Pointer(p)).FnDigit = 1
		(*Decimal)(unsafe.Pointer(p)).FnFrac = 0
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	pArg = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	decimal_add(tls, p, pArg)
	decimal_free(tls, pArg)
}

func decimalSumInverse(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:502:13: */
	var p uintptr
	var pArg uintptr
	_ = argc
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(Decimal{})))
	if p == uintptr(0) {
		return
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	pArg = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	if pArg != 0 {
		(*Decimal)(unsafe.Pointer(pArg)).Fsign = libc.BoolInt8(!((*Decimal)(unsafe.Pointer(pArg)).Fsign != 0))
	}
	decimal_add(tls, p, pArg)
	decimal_free(tls, pArg)
}

func decimalSumValue(tls *libc.TLS, context uintptr) { /* decimal.c:518:13: */
	var p uintptr = sqlite3.Xsqlite3_aggregate_context(tls, context, 0)
	if p == uintptr(0) {
		return
	}
	decimal_result(tls, context, p)
}

func decimalSumFinalize(tls *libc.TLS, context uintptr) { /* decimal.c:523:13: */
	var p uintptr = sqlite3.Xsqlite3_aggregate_context(tls, context, 0)
	if p == uintptr(0) {
		return
	}
	decimal_result(tls, context, p)
	decimal_clear(tls, p)
}

// SQL Function:   decimal_mul(X, Y)
//
// Return the product of X and Y.
//
// All significant digits after the decimal point are retained.
// Trailing zeros after the decimal point are omitted as long as
// the number of digits after the decimal point is no less than
// either the number of digits in either input.
func decimalMulFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:540:13: */
	var pA uintptr
	var pB uintptr
	var acc uintptr
	var i int32
	var j int32
	var k int32
	var minFrac int32
	var f int8
	var carry int32
	var x int32
	pA = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	pB = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*4)), 0, uintptr(0))
	acc = uintptr(0)
	_ = argc
	if !((((((pA == uintptr(0)) || ((*Decimal)(unsafe.Pointer(pA)).Foom != 0)) || ((*Decimal)(unsafe.Pointer(pA)).FisNull != 0)) ||
		(pB == uintptr(0))) || ((*Decimal)(unsafe.Pointer(pB)).Foom != 0)) || ((*Decimal)(unsafe.Pointer(pB)).FisNull != 0)) {
		goto __1
	}
	goto mul_end
__1:
	;
	acc = sqlite3.Xsqlite3_malloc64(tls, (uint64(((*Decimal)(unsafe.Pointer(pA)).FnDigit + (*Decimal)(unsafe.Pointer(pB)).FnDigit) + 2)))
	if !(acc == uintptr(0)) {
		goto __2
	}
	sqlite3.Xsqlite3_result_error_nomem(tls, context)
	goto mul_end
__2:
	;
	libc.Xmemset(tls, acc, 0, (uint32(((*Decimal)(unsafe.Pointer(pA)).FnDigit + (*Decimal)(unsafe.Pointer(pB)).FnDigit) + 2)))
	minFrac = (*Decimal)(unsafe.Pointer(pA)).FnFrac
	if !((*Decimal)(unsafe.Pointer(pB)).FnFrac < minFrac) {
		goto __3
	}
	minFrac = (*Decimal)(unsafe.Pointer(pB)).FnFrac
__3:
	;
	i = ((*Decimal)(unsafe.Pointer(pA)).FnDigit - 1)
__4:
	if !(i >= 0) {
		goto __6
	}
	f = *(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i)))
	carry = 0
	j = ((*Decimal)(unsafe.Pointer(pB)).FnDigit - 1)
	k = ((i + j) + 3)
__7:
	if !(j >= 0) {
		goto __9
	}
	x = ((int32(*(*int8)(unsafe.Pointer(acc + uintptr(k)))) + (int32(f) * int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pB)).Fa + uintptr(j)))))) + carry)
	*(*int8)(unsafe.Pointer(acc + uintptr(k))) = (int8(x % 10))
	carry = (x / 10)
	goto __8
__8:
	j--
	k--
	goto __7
	goto __9
__9:
	;
	x = (int32(*(*int8)(unsafe.Pointer(acc + uintptr(k)))) + carry)
	*(*int8)(unsafe.Pointer(acc + uintptr(k))) = (int8(x % 10))
	*(*int8)(unsafe.Pointer(acc + uintptr((k - 1)))) += int8((x / 10))
	goto __5
__5:
	i--
	goto __4
	goto __6
__6:
	;
	sqlite3.Xsqlite3_free(tls, (*Decimal)(unsafe.Pointer(pA)).Fa)
	(*Decimal)(unsafe.Pointer(pA)).Fa = acc
	acc = uintptr(0)
	*(*int32)(unsafe.Pointer(pA + 4 /* &.nDigit */)) += ((*Decimal)(unsafe.Pointer(pB)).FnDigit + 2)
	*(*int32)(unsafe.Pointer(pA + 8 /* &.nFrac */)) += ((*Decimal)(unsafe.Pointer(pB)).FnFrac)
	*(*int8)(unsafe.Pointer(pA /* &.sign */)) ^= int8((int32((*Decimal)(unsafe.Pointer(pB)).Fsign)))
__10:
	if !(((*Decimal)(unsafe.Pointer(pA)).FnFrac > minFrac) && (int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(((*Decimal)(unsafe.Pointer(pA)).FnDigit - 1))))) == 0)) {
		goto __11
	}
	(*Decimal)(unsafe.Pointer(pA)).FnFrac--
	(*Decimal)(unsafe.Pointer(pA)).FnDigit--
	goto __10
__11:
	;
	decimal_result(tls, context, pA)

mul_end:
	sqlite3.Xsqlite3_free(tls, acc)
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

func sqlite3_decimal_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* decimal.c:597:5: */
	var rc int32 = SQLITE_OK
	var i uint32
	_ = pzErrMsg // Unused parameter

	_ = pApi

	for i = uint32(0); (i < (uint32(unsafe.Sizeof(aFunc)) / uint32(unsafe.Sizeof(struct {
		FzFuncName uintptr
		FnArg      int32
		FxFunc     uintptr
	}{})))) && (rc == SQLITE_OK); i++ {
		rc = sqlite3.Xsqlite3_create_function(tls, db, aFunc[i].FzFuncName, aFunc[i].FnArg,
			((SQLITE_UTF8 | SQLITE_INNOCUOUS) | SQLITE_DETERMINISTIC),
			uintptr(0), aFunc[i].FxFunc, uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_window_function(tls, db, ts+4687 /* "decimal_sum" */, 1,
			((SQLITE_UTF8 | SQLITE_INNOCUOUS) | SQLITE_DETERMINISTIC), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{decimalSumStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{decimalSumFinalize})),
			*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{decimalSumValue})), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{decimalSumInverse})), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_collation(tls, db, ts+4699 /* "decimal" */, SQLITE_UTF8,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
			}{decimalCollFunc})))
	}
	return rc
}

var aFunc = [5]struct {
	FzFuncName uintptr
	FnArg      int32
	FxFunc     uintptr
}{
	{FzFuncName: ts + 4699 /* "decimal" */, FnArg: 1, FxFunc: 0},
	{FzFuncName: ts + 4707 /* "decimal_cmp" */, FnArg: 2, FxFunc: 0},
	{FzFuncName: ts + 4719 /* "decimal_add" */, FnArg: 2, FxFunc: 0},
	{FzFuncName: ts + 4731 /* "decimal_sub" */, FnArg: 2, FxFunc: 0},
	{FzFuncName: ts + 4743 /* "decimal_mul" */, FnArg: 2, FxFunc: 0},
} /* decimal.c:607:5 */

// Structure used to accumulate the output
type EvalResult = struct {
	Fz      uintptr
	FzSep   uintptr
	FszSep  int32
	_       [4]byte
	FnAlloc sqlite3_int64
	FnUsed  sqlite3_int64
} /* eval.c:23:1 */

// Callback from sqlite_exec() for the eval() function.
func callback(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr, colnames uintptr) int32 { /* eval.c:34:12: */
	var p uintptr = pCtx
	var i int32
	if argv == uintptr(0) {
		return 0
	}
	for i = 0; i < argc; i++ {
		var z uintptr
		if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)) != 0 {
			z = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))
		} else {
			z = ts + 489 /* "" */
		}
		var sz size_t = libc.Xstrlen(tls, z)
		if (((sqlite3_int64(sz) + (*EvalResult)(unsafe.Pointer(p)).FnUsed) + sqlite3_int64((*EvalResult)(unsafe.Pointer(p)).FszSep)) + int64(1)) > (*EvalResult)(unsafe.Pointer(p)).FnAlloc {
			var zNew uintptr
			(*EvalResult)(unsafe.Pointer(p)).FnAlloc = (((((*EvalResult)(unsafe.Pointer(p)).FnAlloc * int64(2)) + sqlite3_int64(sz)) + sqlite3_int64((*EvalResult)(unsafe.Pointer(p)).FszSep)) + int64(1))
			// Using sqlite3_realloc64() would be better, but it is a recent
			// addition and will cause a segfault if loaded by an older version
			// of SQLite.
			if (*EvalResult)(unsafe.Pointer(p)).FnAlloc <= int64(0x7fffffff) {
				zNew = sqlite3.Xsqlite3_realloc64(tls, (*EvalResult)(unsafe.Pointer(p)).Fz, uint64((*EvalResult)(unsafe.Pointer(p)).FnAlloc))
			} else {
				zNew = uintptr(0)
			}
			if zNew == uintptr(0) {
				sqlite3.Xsqlite3_free(tls, (*EvalResult)(unsafe.Pointer(p)).Fz)
				libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(EvalResult{})))
				return 1
			}
			(*EvalResult)(unsafe.Pointer(p)).Fz = zNew
		}
		if (*EvalResult)(unsafe.Pointer(p)).FnUsed > int64(0) {
			libc.Xmemcpy(tls, ((*EvalResult)(unsafe.Pointer(p)).Fz + uintptr((*EvalResult)(unsafe.Pointer(p)).FnUsed)), (*EvalResult)(unsafe.Pointer(p)).FzSep, uint32((*EvalResult)(unsafe.Pointer(p)).FszSep))
			*(*sqlite3_int64)(unsafe.Pointer(p + 24 /* &.nUsed */)) += (sqlite3_int64((*EvalResult)(unsafe.Pointer(p)).FszSep))
		}
		libc.Xmemcpy(tls, ((*EvalResult)(unsafe.Pointer(p)).Fz + uintptr((*EvalResult)(unsafe.Pointer(p)).FnUsed)), z, sz)
		*(*sqlite3_int64)(unsafe.Pointer(p + 24 /* &.nUsed */)) += (sqlite3_int64(sz))
	}
	return 0
}

// Implementation of the eval(X) and eval(X,Y) SQL functions.
//
// Evaluate the SQL text in X.  Return the results, using string
// Y as the separator.  If Y is omitted, use a single space character.
func sqlEvalFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* eval.c:71:13: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var zSql uintptr
	var db uintptr
	*(*uintptr)(unsafe.Pointer(bp + 32 /* zErr */)) = uintptr(0)
	var rc int32
	// var x EvalResult at bp, 32

	libc.Xmemset(tls, bp /* &x */, 0, uint32(unsafe.Sizeof(EvalResult{})))
	(*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep = ts + 4755 /* " " */
	zSql = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zSql == uintptr(0) {
		return
	}
	if argc > 1 {
		(*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		if (*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep == uintptr(0) {
			return
		}
	}
	(*EvalResult)(unsafe.Pointer(bp /* &x */)).FszSep = int32(libc.Xstrlen(tls, (*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep))
	db = sqlite3.Xsqlite3_context_db_handle(tls, context)
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{callback})), bp /* &x */, bp+32 /* &zErr */)
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_result_error(tls, context, *(*uintptr)(unsafe.Pointer(bp + 32 /* zErr */)), -1)
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* zErr */)))
	} else if (*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
		sqlite3.Xsqlite3_free(tls, (*EvalResult)(unsafe.Pointer(bp /* &x */)).Fz)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, (*EvalResult)(unsafe.Pointer(bp /* &x */)).Fz, int32((*EvalResult)(unsafe.Pointer(bp /* &x */)).FnUsed), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func sqlite3_eval_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* eval.c:108:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4757 /* "eval" */, 1,
		(SQLITE_UTF8 | SQLITE_DIRECTONLY), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sqlEvalFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4757 /* "eval" */, 2,
			(SQLITE_UTF8 | SQLITE_DIRECTONLY), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{sqlEvalFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// explain_vtab is a subclass of sqlite3_vtab which will
// serve as the underlying representation of a explain virtual table
type explain_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
} /* explain.c:38:9 */

// explain_vtab is a subclass of sqlite3_vtab which will
// serve as the underlying representation of a explain virtual table
type explain_vtab = explain_vtab1 /* explain.c:38:29 */

// explain_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result from an EXPLAIN operation.
type explain_cursor1 = struct {
	Fbase     sqlite3_vtab_cursor
	Fdb       uintptr
	FzSql     uintptr
	FpExplain uintptr
	Frc       int32
} /* explain.c:48:9 */

// explain_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result from an EXPLAIN operation.
type explain_cursor = explain_cursor1 /* explain.c:48:31 */

// The explainConnect() method is invoked to create a new
// explain_vtab that describes the explain virtual table.
//
// Think of this routine as the constructor for explain_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the explain_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against explain will look like.
func explainConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* explain.c:70:12: */
	var pNew uintptr
	var rc int32

	// Column numbers

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+4762 /* "CREATE TABLE x(a..." */)
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(explain_vtab{})))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(explain_vtab{})))
		(*explain_vtab)(unsafe.Pointer(pNew)).Fdb = db
	}
	return rc
}

// This method is the destructor for explain_cursor objects.
func explainDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* explain.c:107:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// Constructor for a new explain_cursor object.
func explainOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* explain.c:115:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(explain_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(explain_cursor{})))
	(*explain_cursor)(unsafe.Pointer(pCur)).Fdb = (*explain_vtab)(unsafe.Pointer(p)).Fdb
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Destructor for a explain_cursor.
func explainClose(tls *libc.TLS, cur uintptr) int32 { /* explain.c:128:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Advance a explain_cursor to its next row of output.
func explainNext(tls *libc.TLS, cur uintptr) int32 { /* explain.c:140:12: */
	var pCur uintptr = cur
	(*explain_cursor)(unsafe.Pointer(pCur)).Frc = sqlite3.Xsqlite3_step(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	if ((*explain_cursor)(unsafe.Pointer(pCur)).Frc != SQLITE_DONE) && ((*explain_cursor)(unsafe.Pointer(pCur)).Frc != SQLITE_ROW) {
		return (*explain_cursor)(unsafe.Pointer(pCur)).Frc
	}
	return SQLITE_OK
}

// Return values of columns for the row at which the explain_cursor
// is currently pointing.
func explainColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* explain.c:151:12: */
	var pCur uintptr = cur
	if i == EXPLN_COLUMN_SQL {
		sqlite3.Xsqlite3_result_text(tls, ctx, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql, -1, libc.UintptrFromInt32(-1))
	} else {
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain, i))
	}
	return SQLITE_OK
}

// Return the rowid for the current row.  In this implementation, the
// rowid is the same as the output value.
func explainRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* explain.c:169:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain, 0)
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func explainEof(tls *libc.TLS, cur uintptr) int32 { /* explain.c:179:12: */
	var pCur uintptr = cur
	return (libc.Bool32((*explain_cursor)(unsafe.Pointer(pCur)).Frc != SQLITE_ROW))
}

// This method is called to "rewind" the explain_cursor object back
// to the first row of output.  This method is always called at least
// once prior to any call to explainColumn() or explainRowid() or
// explainEof().
//
// The argv[0] is the SQL statement that is to be explained.
func explainFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* explain.c:192:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pCur uintptr = pVtabCursor
	var zSql uintptr = uintptr(0)
	var rc int32
	sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	(*explain_cursor)(unsafe.Pointer(pCur)).FpExplain = uintptr(0)
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) != SQLITE_TEXT {
		(*explain_cursor)(unsafe.Pointer(pCur)).Frc = SQLITE_DONE
		return SQLITE_OK
	}
	sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
	(*explain_cursor)(unsafe.Pointer(pCur)).FzSql = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))))
	if (*explain_cursor)(unsafe.Pointer(pCur)).FzSql != 0 {
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+4824 /* "EXPLAIN %s" */, libc.VaList(bp+8, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql))
	}
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*explain_cursor)(unsafe.Pointer(pCur)).Fdb, zSql, -1, (pCur + 12 /* &.pExplain */), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	if rc != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
		(*explain_cursor)(unsafe.Pointer(pCur)).FpExplain = uintptr(0)
		sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
		(*explain_cursor)(unsafe.Pointer(pCur)).FzSql = uintptr(0)
	} else {
		(*explain_cursor)(unsafe.Pointer(pCur)).Frc = sqlite3.Xsqlite3_step(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
		if ((*explain_cursor)(unsafe.Pointer(pCur)).Frc == SQLITE_DONE) || ((*explain_cursor)(unsafe.Pointer(pCur)).Frc == SQLITE_ROW) {
			rc = SQLITE_OK
		} else {
			rc = (*explain_cursor)(unsafe.Pointer(pCur)).Frc
		}
	}
	return rc
}

// SQLite will invoke this method one or more times while planning a query
// that uses the explain virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
func explainBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* explain.c:235:12: */
	var i int32            // Loop counter
	var idx int32 = -1     // Index of a usable == constraint against SQL
	var unusable int32 = 0 // True if there are unusable constraints on SQL

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(500)
	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var p uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn != EXPLN_COLUMN_SQL {
			continue
		}
		if !(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable) != 0) {
			unusable = 1
		} else if int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			idx = i
		}
	}
	if idx >= 0 {
		// There exists a usable == constraint against the SQL column
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).Fomit = uint8(1)
	} else if unusable != 0 {
		// There are unusable constraints against the SQL column.  Do not allow
		// this plan to continue forward.
		return SQLITE_CONSTRAINT
	}
	return SQLITE_OK
}

// This following structure defines all the methods for the
// explain virtual table.
var explainModule = sqlite3_module{ // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xShadowName
} /* explain.c:271:23 */

func sqlite3ExplainVtabInit(tls *libc.TLS, db uintptr) int32 { /* explain.c:300:5: */
	var rc int32 = SQLITE_OK
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4835 /* "explain" */, uintptr(unsafe.Pointer(&explainModule)), uintptr(0))
	return rc
}

func sqlite3_explain_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* explain.c:311:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3ExplainVtabInit(tls, db)
	return rc
}

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	POSIX Standard: 6.5 File Control Operations	<fcntl.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This must be early so <bits/fcntl.h> can define types winningly.

// Get __mode_t, __dev_t and __off_t  .
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get the definitions of O_*, F_*, FD_*: all the
//    numbers and flag bits for `open', `fcntl', et al.
// O_*, F_*, FD_* bit values for Linux.
//    Copyright (C) 1995-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library.  If not, see
//    <http://www.gnu.org/licenses/>.

type flock = struct {
	Fl_type   int16
	Fl_whence int16
	_         [4]byte
	Fl_start  int64
	Fl_len    int64
	Fl_pid    int32
	_         [4]byte
} /* fcntl.h:28:1 */

// Define some inlines helping to catch common problems.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// These may be used to determine what facilities are present at compile time.
//    Their values can be obtained at run time from `sysconf'.

// POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.

// These are not #ifdef __USE_POSIX2 because they are
//    in the theoretically application-owned namespace.

// The utilities on GNU systems also correspond to this version.

// The utilities on GNU systems also correspond to this version.

// This symbol was required until the 2001 edition of POSIX.

// If defined, the implementation supports the
//    C Language Bindings Option.

// If defined, the implementation supports the
//    C Language Development Utilities Option.

// If defined, the implementation supports the
//    Software Development Utilities Option.

// If defined, the implementation supports the
//    creation of locales with the localedef utility.

// X/Open version number to which the library conforms.  It is selectable.

// Commands and utilities from XPG4 are available.

// We are compatible with the old published standards as well.

// The X/Open Unix extensions are available.

// The enhanced internationalization capabilities according to XPG4.2
//    are present.

// The legacy interfaces are also available.

// Get values of POSIX options:
//
//    If these symbols are defined, the corresponding features are
//    always available.  If not, they may be available sometimes.
//    The current values can be obtained with `sysconf'.
//
//    _POSIX_JOB_CONTROL		Job control is supported.
//    _POSIX_SAVED_IDS		Processes have a saved set-user-ID
// 				and a saved set-group-ID.
//    _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
//    _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
//    _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
//    _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
//    _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
//    _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
//    _POSIX_FSYNC			The fsync function is present.
//    _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
//    _POSIX_MEMLOCK		Locking of all memory is supported.
//    _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
//    _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
//    _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
//    _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
//    _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
//    _POSIX_THREADS		POSIX.1c pthreads are supported.
//    _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
//    _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
//    _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
//    _POSIX_THREAD_PRIORITY_SCHEDULING
// 				POSIX.1c thread execution scheduling supported.
//    _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
//    _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
//    _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
//    _POSIX_PII			Protocol-independent interfaces are supported.
//    _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
//    _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
//    _POSIX_PII_INTERNET		Internet family of protocols supported.
//    _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
//    _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
//    _POSIX_PII_OSI		ISO/OSI family of protocols supported.
//    _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
//    _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
//    _POSIX_POLL			Implementation supports `poll' function.
//    _POSIX_SELECT		Implementation supports `select' and `pselect'.
//
//    _XOPEN_REALTIME		X/Open realtime support is available.
//    _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
//    _XOPEN_SHM			Shared memory interface according to XPG4.2.
//
//    _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
// 				int, long, pointer, and off_t types.
//    _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
// 				int, long, and pointer and off_t with at least
// 				64 bits.
//    _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
// 				int, and 64-bit long, pointer, and off_t types.
//    _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
// 				least 32 bits int and long, pointer, and off_t
// 				with at least 64 bits.
//
//    If any of these symbols is defined as -1, the corresponding option is not
//    true for any file.  If any is defined as other than -1, the corresponding
//    option is true for all files.  If a symbol is not defined at all, the value
//    for a specific file can be obtained from `pathconf' and `fpathconf'.
//
//    _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
// 				the owner of a file.  `chown' can only be used
// 				to change the group ID of a file to a group of
// 				which the calling process is a member.
//    _POSIX_NO_TRUNC		Pathname components longer than
// 				NAME_MAX generate an error.
//    _POSIX_VDISABLE		If defined, if the value of an element of the
// 				`c_cc' member of `struct termios' is
// 				_POSIX_VDISABLE, no character will have the
// 				effect associated with that element.
//    _POSIX_SYNC_IO		Synchronous I/O may be performed.
//    _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
//    _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.
//
//    Support for the Large File Support interface is not generally available.
//    If it is available the following constants are defined to one.
//    _LFS64_LARGEFILE		Low-level I/O supports large files.
//    _LFS64_STDIO			Standard I/O supports large files.
//

// Define POSIX options for Linux.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public License as
//    published by the Free Software Foundation; either version 2.1 of the
//    License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; see the file COPYING.LIB.  If
//    not, see <http://www.gnu.org/licenses/>.

// Job control is supported.

// Processes have a saved set-user-ID and a saved set-group-ID.

// Priority scheduling is supported.

// Synchronizing file data is supported.

// The fsync function is present.

// Mapping of files to memory is supported.

// Locking of all memory is supported.

// Locking of ranges of memory is supported.

// Setting of memory protections is supported.

// Some filesystems allow all users to change file ownership.

// `c_cc' member of 'struct termios' structure can be disabled by
//    using the value _POSIX_VDISABLE.

// Filenames are not silently truncated.

// X/Open realtime support is available.

// X/Open thread realtime support is available.

// XPG4.2 shared memory is supported.

// Tell we have POSIX threads.

// We have the reentrant functions described in POSIX.

// We provide priority scheduling for threads.

// We support user-defined stack sizes.

// We support user-defined stacks.

// We support priority inheritence.

// We support priority protection, though only for non-robust
//    mutexes.

// We support priority inheritence for robust mutexes.

// We do not support priority protection for robust mutexes.

// We support POSIX.1b semaphores.

// Real-time signals are supported.

// We support asynchronous I/O.
// Alternative name for Unix98.
// Support for prioritization is also available.

// The LFS support in asynchronous I/O is also available.

// The rest of the LFS is also available.

// POSIX shared memory objects are implemented.

// CPU-time clocks support needs to be checked at runtime.

// Clock support in threads must be also checked at runtime.

// GNU libc provides regular expression handling.

// Reader/Writer locks are available.

// We have a POSIX shell.

// We support the Timeouts option.

// We support spinlocks.

// The `spawn' function family is supported.

// We have POSIX timers.

// The barrier functions are available.

// POSIX message queues are available.

// Thread process-shared synchronization is supported.

// The monotonic clock might be available.

// The clock selection interfaces are available.

// Advisory information interfaces are available.

// IPv6 support is available.

// Raw socket support is available.

// We have at least one terminal.

// Neither process nor thread sporadic server interfaces is available.

// trace.h is not available.

// Typed memory objects are not available.

// Get the environment definitions from Unix98.
// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This header should define the following symbols under the described
//    situations.  A value `1' means that the model is always supported,
//    `-1' means it is never supported.  Undefined means it cannot be
//    statically decided.
//
//    _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
//    _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
//
//    _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
//    _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type
//
//    The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
//    _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
//    _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
//    used in previous versions of the Unix standard and are available
//    only for compatibility.

// By default we have 32-bit wide `int', `long int', pointers and `off_t'
//    and all platforms support LFS.

// We optionally provide an environment with the above size but an 64-bit
//    side `off_t'.  Therefore we don't define _POSIX_V7_ILP32_OFFBIG.

// We can never provide environments with 64-bit wide pointers.

// CFLAGS.

// Standard file descriptors.

// All functions that are not declared anywhere else.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// The Single Unix specification says that some more types are
//    available here.

type useconds_t = uint32 /* unistd.h:255:22 */

type intptr_t = int32 /* unistd.h:267:20 */

type socklen_t = uint32 /* unistd.h:274:21 */

// Define some macros helping to catch buffer overflows.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	POSIX Standard: 5.1.2 Directory Operations	<dirent.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// This file defines `struct dirent'.
//
//    It defines the macro `_DIRENT_HAVE_D_NAMLEN' iff there is a `d_namlen'
//    member that gives the length of `d_name'.
//
//    It defines the macro `_DIRENT_HAVE_D_RECLEN' iff there is a `d_reclen'
//    member that gives the size of the entire directory entry.
//
//    It defines the macro `_DIRENT_HAVE_D_OFF' iff there is a `d_off'
//    member that gives the file offset of the next directory entry.
//
//    It defines the macro `_DIRENT_HAVE_D_TYPE' iff there is a `d_type'
//    member that gives the type of the file.
//

// Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type dirent = struct {
	Fd_ino    uint64
	Fd_off    int64
	Fd_reclen uint16
	Fd_type   uint8
	Fd_name   [256]int8
	_         [5]byte
} /* dirent.h:22:1 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Structure crudely representing a timezone.
//    This is obsolete and should never be used.
type timezone = struct {
	Ftz_minuteswest int32
	Ftz_dsttime     int32
} /* time.h:52:1 */

// Type of the second argument to `getitimer' and
//    the second and third arguments `setitimer'.
type itimerval = struct {
	Fit_interval struct {
		Ftv_sec  int32
		Ftv_usec int32
	}
	Fit_value struct {
		Ftv_sec  int32
		Ftv_usec int32
	}
} /* time.h:104:1 */

// Convenience macros for operations on timevals.
//    NOTE: `timercmp' does not work for >= or <=.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.23 Date and time	<time.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// This defines CLOCKS_PER_SEC, which is the number of processor clock
//    ticks per second, and possibly a number of other constants.
// System-dependent timing definitions.  Linux version.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <time.h> instead.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// ISO/IEC 9899:1999 7.23.1: Components of time
//    The macro `CLOCKS_PER_SEC' is an expression with type `clock_t' that is
//    the number per second of the value returned by the `clock' function.
// CAE XSH, Issue 4, Version 2: <time.h>
//    The value of CLOCKS_PER_SEC is required to be 1 million on all
//    XSI-conformant systems.

// Identifier for system-wide realtime clock.
// Monotonic system-wide clock.
// High-resolution timer from the CPU.
// Thread-specific CPU-time clock.
// Monotonic system-wide clock, not adjusted for frequency scaling.
// Identifier for system-wide realtime clock, updated only on ticks.
// Monotonic system-wide clock, updated only on ticks.
// Monotonic system-wide clock that includes time spent in suspension.
// Like CLOCK_REALTIME but also wakes suspended system.
// Like CLOCK_BOOTTIME but also wakes suspended system.
// Like CLOCK_REALTIME but in International Atomic Time.

// Flag to indicate time is absolute.

// Many of the typedefs and structs whose official home is this header
//    may also need to be defined by other headers.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// ISO C `broken-down time' structure.
type tm = struct {
	Ftm_sec    int32
	Ftm_min    int32
	Ftm_hour   int32
	Ftm_mday   int32
	Ftm_mon    int32
	Ftm_year   int32
	Ftm_wday   int32
	Ftm_yday   int32
	Ftm_isdst  int32
	Ftm_gmtoff int32
	Ftm_zone   uintptr
} /* struct_tm.h:7:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// NB: Include guard matches what <linux/time.h> uses.

// POSIX.1b structure for timer start values and intervals.
type itimerspec = struct {
	Fit_interval struct {
		Ftv_sec  int32
		Ftv_nsec int32
	}
	Fit_value struct {
		Ftv_sec  int32
		Ftv_nsec int32
	}
} /* struct_itimerspec.h:8:1 */

type sigevent = struct {
	Fsigev_value  struct{ Fsival_int int32 }
	Fsigev_signo  int32
	Fsigev_notify int32
	F_sigev_un    struct{ F_pad [13]int32 }
} /* sigevent_t.h:22:9 */

// Structure of the fsdir() table-valued function
//    0    1    2     3    4           5

// Set the result stored by context ctx to a blob containing the
// contents of file zName.  Or, leave the result unchanged (NULL)
// if the file does not exist or is unreadable.
//
// If the file exceeds the SQLite blob size limit, through an
// SQLITE_TOOBIG error.
//
// Throw an SQLITE_IOERR if there are difficulties pulling the file
// off of disk.
func readFileContents(tls *libc.TLS, ctx uintptr, zName uintptr) { /* fileio.c:133:13: */
	var in uintptr
	var nIn sqlite3_int64
	var pBuf uintptr
	var db uintptr
	var mxBlob int32

	in = libc.Xfopen(tls, zName, ts+4263 /* "rb" */)
	if in == uintptr(0) {
		// File does not exist or is unreadable. Leave the result set to NULL.
		return
	}
	libc.Xfseek(tls, in, 0, SEEK_END)
	nIn = sqlite3_int64(libc.Xftell(tls, in))
	libc.Xrewind(tls, in)
	db = sqlite3.Xsqlite3_context_db_handle(tls, ctx)
	mxBlob = sqlite3.Xsqlite3_limit(tls, db, SQLITE_LIMIT_LENGTH, -1)
	if nIn > sqlite3_int64(mxBlob) {
		sqlite3.Xsqlite3_result_error_code(tls, ctx, SQLITE_TOOBIG)
		libc.Xfclose(tls, in)
		return
	}
	pBuf = sqlite3.Xsqlite3_malloc64(tls, func() uint64 {
		if nIn != 0 {
			return uint64(nIn)
		}
		return uint64(1)
	}())
	if pBuf == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, ctx)
		libc.Xfclose(tls, in)
		return
	}
	if nIn == sqlite3_int64(libc.Xfread(tls, pBuf, uint32(1), size_t(nIn), in)) {
		sqlite3.Xsqlite3_result_blob64(tls, ctx, pBuf, uint64(nIn), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	} else {
		sqlite3.Xsqlite3_result_error_code(tls, ctx, SQLITE_IOERR)
		sqlite3.Xsqlite3_free(tls, pBuf)
	}
	libc.Xfclose(tls, in)
}

// Implementation of the "readfile(X)" SQL function.  The entire content
// of the file named X is read and returned as a BLOB.  NULL is returned
// if the file does not exist or is unreadable.
func readfileFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* fileio.c:175:13: */
	var zName uintptr
	_ = argc // Unused parameter
	zName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zName == uintptr(0) {
		return
	}
	readFileContents(tls, context, zName)
}

// Set the error message contained in context ctx to the results of
// vprintf(zFmt, ...).
func ctxErrorMsg(tls *libc.TLS, ctx uintptr, zFmt uintptr, va uintptr) { /* fileio.c:191:13: */
	var zMsg uintptr = uintptr(0)
	var ap va_list
	_ = ap
	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	sqlite3.Xsqlite3_result_error(tls, ctx, zMsg, -1)
	sqlite3.Xsqlite3_free(tls, zMsg)
	_ = ap
}

// This function is used in place of stat().  On Windows, special handling
// is required in order for the included time to be returned as UTC.  On all
// other systems, this function simply calls stat().
func fileStat(tls *libc.TLS, zPath uintptr, pStatBuf uintptr) int32 { /* fileio.c:261:12: */
	return libc.Xstat(tls, zPath, pStatBuf)
}

// This function is used in place of lstat().  On Windows, special handling
// is required in order for the included time to be returned as UTC.  On all
// other systems, this function simply calls lstat().
func fileLinkStat(tls *libc.TLS, zPath uintptr, pStatBuf uintptr) int32 { /* fileio.c:279:12: */
	return libc.Xlstat(tls, zPath, pStatBuf)
}

// Argument zFile is the name of a file that will be created and/or written
// by SQL function writefile(). This function ensures that the directory
// zFile will be written to exists, creating it if required. The permissions
// for any path components created by this function are set in accordance
// with the current umask.
//
// If an OOM condition is encountered, SQLITE_NOMEM is returned. Otherwise,
// SQLITE_OK is returned if the directory is successfully created, or
// SQLITE_ERROR otherwise.
func makeDirectory(tls *libc.TLS, zFile uintptr) int32 { /* fileio.c:303:12: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var zCopy uintptr = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zFile))
	var rc int32 = SQLITE_OK

	if zCopy == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var nCopy int32 = int32(libc.Xstrlen(tls, zCopy))
		var i int32 = 1

		for rc == SQLITE_OK {
			// var sStat stat at bp+8, 104

			var rc2 int32

			for ; (int32(*(*int8)(unsafe.Pointer(zCopy + uintptr(i)))) != '/') && (i < nCopy); i++ {
			}
			if i == nCopy {
				break
			}
			*(*int8)(unsafe.Pointer(zCopy + uintptr(i))) = int8(0)

			rc2 = fileStat(tls, zCopy, bp+8 /* &sStat */)
			if rc2 != 0 {
				if libc.Xmkdir(tls, zCopy, uint32(0777)) != 0 {
					rc = SQLITE_ERROR
				}
			} else {
				if !((((*stat)(unsafe.Pointer(bp + 8 /* &sStat */)).Fst_mode) & uint32(0170000)) == (uint32(0040000))) {
					rc = SQLITE_ERROR
				}
			}
			*(*int8)(unsafe.Pointer(zCopy + uintptr(i))) = int8('/')
			i++
		}

		sqlite3.Xsqlite3_free(tls, zCopy)
	}

	return rc
}

// This function does the work for the writefile() UDF. Refer to
// header comments at the top of this file for details.
func writeFile(tls *libc.TLS, pCtx uintptr, zFile uintptr, pData uintptr, mode mode_t, mtime sqlite3_int64) int32 { /* fileio.c:343:12: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	if ((mode) & mode_t(0170000)) == (mode_t(0120000)) {
		var zTo uintptr = sqlite3.Xsqlite3_value_text(tls, pData)
		if libc.Xsymlink(tls, zTo, zFile) < 0 {
			return 1
		}
	} else {
		if ((mode) & mode_t(0170000)) == (mode_t(0040000)) {
			if libc.Xmkdir(tls, zFile, mode) != 0 {
				// The mkdir() call to create the directory failed. This might not
				// be an error though - if there is already a directory at the same
				// path and either the permissions already match or can be changed
				// to do so using chmod(), it is not an error.
				// var sStat stat at bp, 104

				if ((((*(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))) != EEXIST) ||
					(0 != fileStat(tls, zFile, bp /* &sStat */))) ||
					!((((*stat)(unsafe.Pointer(bp /* &sStat */)).Fst_mode) & uint32(0170000)) == (uint32(0040000)))) ||
					((((*stat)(unsafe.Pointer(bp /* &sStat */)).Fst_mode & uint32(0777)) != (mode & mode_t(0777))) && (0 != libc.Xchmod(tls, zFile, (mode&mode_t(0777))))) {
					return 1
				}
			}
		} else {
			var nWrite sqlite3_int64 = int64(0)
			var z uintptr
			var rc int32 = 0
			var out uintptr = libc.Xfopen(tls, zFile, ts+4843 /* "wb" */)
			if out == uintptr(0) {
				return 1
			}
			z = sqlite3.Xsqlite3_value_blob(tls, pData)
			if z != 0 {
				var n sqlite3_int64 = sqlite3_int64(libc.Xfwrite(tls, z, uint32(1), uint32(sqlite3.Xsqlite3_value_bytes(tls, pData)), out))
				nWrite = sqlite3_int64(sqlite3.Xsqlite3_value_bytes(tls, pData))
				if nWrite != n {
					rc = 1
				}
			}
			libc.Xfclose(tls, out)
			if ((rc == 0) && (mode != 0)) && (libc.Xchmod(tls, zFile, (mode&mode_t(0777))) != 0) {
				rc = 1
			}
			if rc != 0 {
				return 2
			}
			sqlite3.Xsqlite3_result_int64(tls, pCtx, nWrite)
		}
	}

	if mtime >= int64(0) {
		// Legacy unix
		// var times [2]timeval at bp+104, 16

		(*timeval)(unsafe.Pointer(bp + 104 /* &times */)).Ftv_usec = libc.AssignPtrInt32(bp+104 /* &times */ +1*8+4 /* &.tv_usec */, 0)
		(*timeval)(unsafe.Pointer(bp + 104 /* &times */)).Ftv_sec = libc.Xtime(tls, uintptr(0))
		(*timeval)(unsafe.Pointer(bp + 104 /* &times */ + 1*8)).Ftv_sec = int32(mtime)
		if libc.Xutimes(tls, zFile, bp+104 /* &times[0] */) != 0 {
			return 1
		}
	}

	return 0
}

// Implementation of the "writefile(W,X[,Y[,Z]]])" SQL function.
// Refer to header comments at the top of this file for details.
func writefileFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* fileio.c:457:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zFile uintptr
	var mode mode_t = mode_t(0)
	var res int32
	var mtime sqlite3_int64 = int64(-1)

	if (argc < 2) || (argc > 4) {
		sqlite3.Xsqlite3_result_error(tls, context,
			ts+4846 /* "wrong number of ..." */, -1)
		return
	}

	zFile = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zFile == uintptr(0) {
		return
	}
	if argc >= 3 {
		mode = mode_t(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	}
	if argc == 4 {
		mtime = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
	}

	res = writeFile(tls, context, zFile, *(*uintptr)(unsafe.Pointer(argv + 1*4)), mode, mtime)
	if (res == 1) && ((*(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))) == ENOENT) {
		if makeDirectory(tls, zFile) == SQLITE_OK {
			res = writeFile(tls, context, zFile, *(*uintptr)(unsafe.Pointer(argv + 1*4)), mode, mtime)
		}
	}

	if (argc > 2) && (res != 0) {
		if ((mode) & mode_t(0170000)) == (mode_t(0120000)) {
			ctxErrorMsg(tls, context, ts+4896 /* "failed to create..." */, libc.VaList(bp, zFile))
		} else if ((mode) & mode_t(0170000)) == (mode_t(0040000)) {
			ctxErrorMsg(tls, context, ts+4925 /* "failed to create..." */, libc.VaList(bp+8, zFile))
		} else {
			ctxErrorMsg(tls, context, ts+4956 /* "failed to write ..." */, libc.VaList(bp+16, zFile))
		}
	}
}

// SQL function:   lsmode(MODE)
//
// Given a numberic st_mode from stat(), convert it into a human-readable
// text string in the style of "ls -l".
func lsModeFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* fileio.c:507:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int32
	var iMode int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
	// var z [16]int8 at bp, 16

	_ = argc
	if ((iMode) & 0170000) == (0120000) {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */)) = int8('l')
	} else if ((iMode) & 0170000) == (0100000) {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */)) = int8('-')
	} else if ((iMode) & 0170000) == (0040000) {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */)) = int8('d')
	} else {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */)) = int8('?')
	}
	for i = 0; i < 3; i++ {
		var m int32 = (iMode >> ((2 - i) * 3))
		var a uintptr = (bp /* &z */ + uintptr((1 + (i * 3))))
		*(*int8)(unsafe.Pointer(a)) = func() int8 {
			if (m & 0x4) != 0 {
				return int8('r')
			}
			return int8('-')
		}()
		*(*int8)(unsafe.Pointer(a + 1)) = func() int8 {
			if (m & 0x2) != 0 {
				return int8('w')
			}
			return int8('-')
		}()
		*(*int8)(unsafe.Pointer(a + 2)) = func() int8 {
			if (m & 0x1) != 0 {
				return int8('x')
			}
			return int8('-')
		}()
	}
	*(*int8)(unsafe.Pointer(bp /* &z[0] */ + 10)) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp /* &z[0] */, -1, libc.UintptrFromInt32(-1))
}

// Cursor type for recursively iterating through a directory structure.
type fsdir_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FnLvl  int32
	FiLvl  int32
	FaLvl  uintptr
	FzBase uintptr
	FnBase int32
	FsStat struct {
		Fst_dev     uint64
		F__pad1     uint16
		_           [2]byte
		F__st_ino   uint32
		Fst_mode    uint32
		Fst_nlink   uint32
		Fst_uid     uint32
		Fst_gid     uint32
		Fst_rdev    uint64
		F__pad2     uint16
		_           [6]byte
		Fst_size    int64
		Fst_blksize int32
		_           [4]byte
		Fst_blocks  int64
		Fst_atim    struct {
			Ftv_sec  int32
			Ftv_nsec int32
		}
		Fst_mtim struct {
			Ftv_sec  int32
			Ftv_nsec int32
		}
		Fst_ctim struct {
			Ftv_sec  int32
			Ftv_nsec int32
		}
		Fst_ino uint64
	}
	FzPath  uintptr
	_       [4]byte
	FiRowid sqlite3_int64
} /* fileio.c:541:9 */

// Cursor type for recursively iterating through a directory structure.
type fsdir_cursor = fsdir_cursor1 /* fileio.c:541:29 */
type FsdirLevel1 = struct {
	FpDir uintptr
	FzDir uintptr
} /* fileio.c:541:9 */

type FsdirLevel = FsdirLevel1 /* fileio.c:542:27 */

type fsdir_tab1 = struct{ Fbase sqlite3_vtab } /* fileio.c:564:9 */

type fsdir_tab = fsdir_tab1 /* fileio.c:564:26 */

// Construct a new fsdir virtual table object.
func fsdirConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* fileio.c:572:12: */
	var pNew uintptr = uintptr(0)
	var rc int32
	_ = pAux
	_ = argc
	_ = argv
	_ = pzErr
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+4981 /* "CREATE TABLE x(n..." */)
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fsdir_tab{})))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(fsdir_tab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_DIRECTONLY, 0)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc
}

// This method is the destructor for fsdir vtab objects.
func fsdirDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* fileio.c:599:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// Constructor for a new fsdir_cursor object.
func fsdirOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* fileio.c:607:12: */
	var pCur uintptr
	_ = p
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fsdir_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(fsdir_cursor{})))
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = -1
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Reset a cursor back to the state it was in when first returned
// by fsdirOpen().
func fsdirResetCursor(tls *libc.TLS, pCur uintptr) { /* fileio.c:622:13: */
	var i int32
	for i = 0; i <= (*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl; i++ {
		var pLvl uintptr = ((*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr(i)*8)
		if (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir != 0 {
			libc.Xclosedir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		}
		sqlite3.Xsqlite3_free(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
	}
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase = 0
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl = 0
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = -1
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
}

// Destructor for an fsdir_cursor.
func fsdirClose(tls *libc.TLS, cur uintptr) int32 { /* fileio.c:643:12: */
	var pCur uintptr = cur

	fsdirResetCursor(tls, pCur)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Set the error message for the virtual table associated with cursor
// pCur to the results of vprintf(zFmt, ...).
func fsdirSetErrmsg(tls *libc.TLS, pCur uintptr, zFmt uintptr, va uintptr) { /* fileio.c:655:13: */
	var ap va_list
	_ = ap
	ap = va
	(*sqlite3_vtab)(unsafe.Pointer((*fsdir_cursor)(unsafe.Pointer(pCur)).Fbase.FpVtab)).FzErrMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	_ = ap
}

// Advance an fsdir_cursor to its next row of output.
func fsdirNext(tls *libc.TLS, cur uintptr) int32 { /* fileio.c:666:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pCur uintptr = cur
	var m mode_t = (*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode

	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid++
	if ((m) & mode_t(0170000)) == (mode_t(0040000)) {
		// Descend into this directory
		var iNew int32 = ((*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl + 1)
		var pLvl uintptr
		if iNew >= (*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl {
			var nNew int32 = (iNew + 1)
			var nByte sqlite3_int64 = (sqlite3_int64(uint32(nNew) * uint32(unsafe.Sizeof(FsdirLevel{}))))
			var aNew uintptr = sqlite3.Xsqlite3_realloc64(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl, uint64(nByte))
			if aNew == uintptr(0) {
				return SQLITE_NOMEM
			}
			libc.Xmemset(tls, (aNew + uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl)*8), 0, (uint32(unsafe.Sizeof(FsdirLevel{})) * (uint32(nNew - (*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl))))
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl = aNew
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl = nNew
		}
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = iNew
		pLvl = ((*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr(iNew)*8)

		(*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir = (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir = libc.Xopendir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
		if (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir == uintptr(0) {
			fsdirSetErrmsg(tls, pCur, ts+5041 /* "cannot read dire..." */, libc.VaList(bp, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
			return SQLITE_ERROR
		}
	}

	for (*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl >= 0 {
		var pLvl uintptr = ((*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl)*8)
		var pEntry uintptr = libc.Xreaddir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		if pEntry != 0 {
			if int32(*(*int8)(unsafe.Pointer((pEntry + 19 /* &.d_name */)))) == '.' {
				if (int32(*(*int8)(unsafe.Pointer((pEntry + 19 /* &.d_name */) + 1))) == '.') && (int32(*(*int8)(unsafe.Pointer((pEntry + 19 /* &.d_name */) + 2))) == 0) {
					continue
				}
				if int32(*(*int8)(unsafe.Pointer((pEntry + 19 /* &.d_name */) + 1))) == 0 {
					continue
				}
			}
			sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts+5067 /* "%s/%s" */, libc.VaList(bp+8, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir, pEntry+19 /* &.d_name */))
			if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0) {
				return SQLITE_NOMEM
			}
			if fileLinkStat(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, (pCur+24 /* &.sStat */)) != 0 {
				fsdirSetErrmsg(tls, pCur, ts+5073 /* "cannot stat file..." */, libc.VaList(bp+24, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
				return SQLITE_ERROR
			}
			return SQLITE_OK
		}
		libc.Xclosedir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		sqlite3.Xsqlite3_free(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir = uintptr(0)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir = uintptr(0)
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl--
	}

	// EOF
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
	return SQLITE_OK
}

// Return values of columns for the row at which the series_cursor
// is currently pointing.
func fsdirColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* fileio.c:730:12: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var pCur uintptr = cur
	switch i {
	case FSDIR_COLUMN_NAME:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, ((*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath + uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase)), -1, libc.UintptrFromInt32(-1))
			break

		}

	case FSDIR_COLUMN_MODE:
		sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode))
		break

	case FSDIR_COLUMN_MTIME:
		sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mtim.Ftv_sec))
		break

	case FSDIR_COLUMN_DATA:
		{
			var m mode_t = (*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode
			if ((m) & mode_t(0170000)) == (mode_t(0040000)) {
				sqlite3.Xsqlite3_result_null(tls, ctx)
			} else if ((m) & mode_t(0170000)) == (mode_t(0120000)) {
				// var aStatic [64]int8 at bp, 64

				var aBuf uintptr = bp /* aStatic */
				var nBuf sqlite3_int64 = int64(64)
				var n int32

				for 1 != 0 {
					n = libc.Xreadlink(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, aBuf, uint32(nBuf))
					if sqlite3_int64(n) < nBuf {
						break
					}
					if aBuf != bp /* aStatic */ {
						sqlite3.Xsqlite3_free(tls, aBuf)
					}
					nBuf = (nBuf * int64(2))
					aBuf = sqlite3.Xsqlite3_malloc64(tls, uint64(nBuf))
					if aBuf == uintptr(0) {
						sqlite3.Xsqlite3_result_error_nomem(tls, ctx)
						return SQLITE_NOMEM
					}
				}

				sqlite3.Xsqlite3_result_text(tls, ctx, aBuf, n, libc.UintptrFromInt32(-1))
				if aBuf != bp /* aStatic */ {
					sqlite3.Xsqlite3_free(tls, aBuf)
				}
			} else {
				readFileContents(tls, ctx, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
			}

		}
		fallthrough
	case FSDIR_COLUMN_PATH:
		fallthrough
	default:
		{
			// The FSDIR_COLUMN_PATH and FSDIR_COLUMN_DIR are input parameters.
			// always return their values as NULL
			break

		}
	}
	return SQLITE_OK
}

// Return the rowid for the current row. In this implementation, the
// first row returned is assigned rowid value 1, and each subsequent
// row a value 1 more than that of the previous.
func fsdirRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* fileio.c:795:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func fsdirEof(tls *libc.TLS, cur uintptr) int32 { /* fileio.c:805:12: */
	var pCur uintptr = cur
	return (libc.Bool32((*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0)))
}

// xFilter callback.
//
// idxNum==1   PATH parameter only
// idxNum==2   Both PATH and DIR supplied
func fsdirFilter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* fileio.c:816:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zDir uintptr = uintptr(0)
	var pCur uintptr = cur
	_ = idxStr
	fsdirResetCursor(tls, pCur)

	if idxNum == 0 {
		fsdirSetErrmsg(tls, pCur, ts+5094 /* "table function f..." */, 0)
		return SQLITE_ERROR
	}

	zDir = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zDir == uintptr(0) {
		fsdirSetErrmsg(tls, pCur, ts+5136 /* "table function f..." */, 0)
		return SQLITE_ERROR
	}
	if argc == 2 {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	}
	if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase != 0 {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase = (int32(libc.Xstrlen(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase)) + 1)
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts+5067 /* "%s/%s" */, libc.VaList(bp, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase, zDir))
	} else {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, zDir))
	}

	if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0) {
		return SQLITE_NOMEM
	}
	if fileLinkStat(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, (pCur+24 /* &.sStat */)) != 0 {
		fsdirSetErrmsg(tls, pCur, ts+5073 /* "cannot stat file..." */, libc.VaList(bp+24, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
		return SQLITE_ERROR
	}

	return SQLITE_OK
}

// SQLite will invoke this method one or more times while planning a query
// that uses the generate_series virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
//
// In this implementation idxNum is used to represent the
// query plan.  idxStr is unused.
//
// The query plan is represented by values of idxNum:
//
//  (1)  The path value is supplied by argv[0]
//  (2)  Path is in argv[0] and dir is in argv[1]
func fsdirBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* fileio.c:872:12: */
	var i int32            // Loop over constraints
	var idxPath int32 = -1 // Index in pIdxInfo->aConstraint of PATH=
	var idxDir int32 = -1  // Index in pIdxInfo->aConstraint of DIR=
	var seenPath int32 = 0 // True if an unusable PATH= constraint is seen
	var seenDir int32 = 0  // True if an unusable DIR= constraint is seen
	var pConstraint uintptr

	_ = tab
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) != SQLITE_INDEX_CONSTRAINT_EQ {
			goto __2
		}
		switch (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn {
		case FSDIR_COLUMN_PATH:
			{
				if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable != 0 {
					idxPath = i
					seenPath = 0
				} else if idxPath < 0 {
					seenPath = 1
				}
				break

			}
		case FSDIR_COLUMN_DIR:
			{
				if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable != 0 {
					idxDir = i
					seenDir = 0
				} else if idxDir < 0 {
					seenDir = 1
				}
				break

			}
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (seenPath != 0) || (seenDir != 0) {
		// If input parameters are unusable, disallow this plan
		return SQLITE_CONSTRAINT
	}

	if idxPath < 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
		// The pIdxInfo->estimatedCost should have been initialized to a huge
		// number.  Leave it unchanged.
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(0x7fffffff)
	} else {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxPath)*8)).Fomit = uint8(1)
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxPath)*8)).FargvIndex = 1
		if idxDir >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxDir)*8)).Fomit = uint8(1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxDir)*8)).FargvIndex = 2
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 2
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
		} else {
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 100.0
		}
	}

	return SQLITE_OK
}

// Register the "fsdir" virtual table.
func fsdirRegister(tls *libc.TLS, db uintptr) int32 { /* fileio.c:938:12: */

	var rc int32 = sqlite3.Xsqlite3_create_module(tls, db, ts+5186 /* "fsdir" */, uintptr(unsafe.Pointer(&fsdirModule1)), uintptr(0))
	return rc
}

var fsdirModule1 = sqlite3_module{ // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xShadowName
} /* fileio.c:939:25 */

func sqlite3_fileio_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* fileio.c:976:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5192 /* "readfile" */, 1,
		(SQLITE_UTF8 | SQLITE_DIRECTONLY), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{readfileFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5201 /* "writefile" */, -1,
			(SQLITE_UTF8 | SQLITE_DIRECTONLY), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{writefileFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5211 /* "lsmode" */, 1, SQLITE_UTF8, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{lsModeFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = fsdirRegister(tls, db)
	}
	return rc
}

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// Forward declaration of objects used by this implementation
type fuzzer_vtab1 = struct {
	Fbase       sqlite3_vtab
	FzClassName uintptr
	FpRule      uintptr
	FnCursor    int32
} /* fuzzer.c:162:9 */

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// Forward declaration of objects used by this implementation
type fuzzer_vtab = fuzzer_vtab1 /* fuzzer.c:162:28 */
type fuzzer_cursor1 = struct {
	Fbase     sqlite3_vtab_cursor
	_         [4]byte
	FiRowid   sqlite3_int64
	FpVtab    uintptr
	FrLimit   fuzzer_cost
	FpStem    uintptr
	FpDone    uintptr
	FaQueue   [20]uintptr
	FmxQueue  int32
	FzBuf     uintptr
	FnBuf     int32
	FnStem    int32
	FiRuleset int32
	FnullRule fuzzer_rule
	FapHash   [4001]uintptr
} /* fuzzer.c:163:9 */

type fuzzer_cursor = fuzzer_cursor1 /* fuzzer.c:163:30 */
type fuzzer_rule1 = struct {
	FpNext    uintptr
	FzFrom    uintptr
	FrCost    fuzzer_cost
	FnFrom    fuzzer_len
	FnTo      fuzzer_len
	_         [2]byte
	FiRuleset fuzzer_ruleid
	FzTo      [4]int8
} /* fuzzer.c:162:9 */

type fuzzer_rule = fuzzer_rule1 /* fuzzer.c:164:28 */
type fuzzer_stem1 = struct {
	FzBasis    uintptr
	FpRule     uintptr
	FpNext     uintptr
	FpHash     uintptr
	FrBaseCost fuzzer_cost
	FrCostX    fuzzer_cost
	FnBasis    fuzzer_len
	Fn         fuzzer_len
	_          [2]byte
} /* fuzzer.c:163:9 */

type fuzzer_stem = fuzzer_stem1 /* fuzzer.c:166:28 */

// Various types.
//
// fuzzer_cost is the "cost" of an edit operation.
//
// fuzzer_len is the length of a matching string.
//
// fuzzer_ruleid is an ruleset identifier.
type fuzzer_cost = int32   /* fuzzer.c:177:13 */
type fuzzer_len = int8     /* fuzzer.c:178:21 */
type fuzzer_ruleid = int32 /* fuzzer.c:179:13 */

// The two input rule lists are both sorted in order of increasing
// cost.  Merge them together into a single list, sorted by cost, and
// return a pointer to the head of that list.
func fuzzerMergeRules(tls *libc.TLS, pA uintptr, pB uintptr) uintptr { /* fuzzer.c:261:20: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var head fuzzer_rule at bp, 24

	var pTail uintptr

	pTail = bp /* &head */
	for (pA != 0) && (pB != 0) {
		if (*fuzzer_rule)(unsafe.Pointer(pA)).FrCost <= (*fuzzer_rule)(unsafe.Pointer(pB)).FrCost {
			(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*fuzzer_rule)(unsafe.Pointer(pA)).FpNext
		} else {
			(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*fuzzer_rule)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*fuzzer_rule)(unsafe.Pointer(bp /* &head */)).FpNext
}

// Statement pStmt currently points to a row in the fuzzer data table. This
// function allocates and populates a fuzzer_rule structure according to
// the content of the row.
//
// If successful, *ppRule is set to point to the new object and SQLITE_OK
// is returned. Otherwise, *ppRule is zeroed, *pzErr may be set to point
// to an error message and an SQLite error code returned.
func fuzzerLoadOneRule(tls *libc.TLS, p uintptr, pStmt uintptr, ppRule uintptr, pzErr uintptr) int32 { /* fuzzer.c:294:12: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var iRuleset sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
	var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 2)
	var nCost int32 = sqlite3.Xsqlite3_column_int(tls, pStmt, 3)

	var rc int32 = SQLITE_OK       // Return code
	var nFrom int32                // Size of string zFrom, in bytes
	var nTo int32                  // Size of string zTo, in bytes
	var pRule uintptr = uintptr(0) // New rule object to return

	if zFrom == uintptr(0) {
		zFrom = ts + 489 /* "" */
	}
	if zTo == uintptr(0) {
		zTo = ts + 489 /* "" */
	}
	nFrom = int32(libc.Xstrlen(tls, zFrom))
	nTo = int32(libc.Xstrlen(tls, zTo))

	// Silently ignore null transformations
	if libc.Xstrcmp(tls, zFrom, zTo) == 0 {
		*(*uintptr)(unsafe.Pointer(ppRule)) = uintptr(0)
		return SQLITE_OK
	}

	if (nCost <= 0) || (nCost > FUZZER_MX_COST) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3165, /* "%s: cost must be..." */
			libc.VaList(bp, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, FUZZER_MX_COST))
		rc = SQLITE_ERROR
	} else if (nFrom > FUZZER_MX_LENGTH) || (nTo > FUZZER_MX_LENGTH) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3199, /* "%s: maximum stri..." */
			libc.VaList(bp+16, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, FUZZER_MX_LENGTH))
		rc = SQLITE_ERROR
	} else if (iRuleset < int64(0)) || (iRuleset > int64(FUZZER_MX_RULEID)) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+5218, /* "%s: ruleset must..." */
			libc.VaList(bp+32, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, FUZZER_MX_RULEID))
		rc = SQLITE_ERROR
	} else {

		pRule = sqlite3.Xsqlite3_malloc64(tls, (uint64((uint32(unsafe.Sizeof(fuzzer_rule{})) + uint32(nFrom)) + uint32(nTo))))
		if pRule == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pRule, 0, uint32(unsafe.Sizeof(fuzzer_rule{})))
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom = pRule + 20 /* &.zTo */
			*(*uintptr)(unsafe.Pointer(pRule + 4 /* &.zFrom */)) += (uintptr(nTo + 1))
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom = fuzzer_len(nFrom)
			libc.Xmemcpy(tls, (*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom, zFrom, (uint32(nFrom + 1)))
			libc.Xmemcpy(tls, pRule+20 /* &.zTo */, zTo, (uint32(nTo + 1)))
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo = fuzzer_len(nTo)
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FrCost = nCost
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FiRuleset = int32(iRuleset)
		}
	}

	*(*uintptr)(unsafe.Pointer(ppRule)) = pRule
	return rc
}

// Load the content of the fuzzer data table into memory.
func fuzzerLoadRules(tls *libc.TLS, db uintptr, p uintptr, zDb uintptr, zData uintptr, pzErr uintptr) int32 { /* fuzzer.c:363:12: */
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var rc int32 = SQLITE_OK // Return code
	var zSql uintptr         // SELECT used to read from rules table
	var pHead uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+3268 /* "SELECT * FROM %Q..." */, libc.VaList(bp, zDb, zData))
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var rc2 int32 // finalize() return code
		*(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+56 /* &pStmt */, uintptr(0))
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3288 /* "%s: %s" */, libc.VaList(bp+16, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, sqlite3.Xsqlite3_errmsg(tls, db)))
		} else if sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */))) != 4 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3295, /* "%s: %s has %d co..." */
				libc.VaList(bp+32, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, zData, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))))
			rc = SQLITE_ERROR
		} else {
			for (rc == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))) {
				*(*uintptr)(unsafe.Pointer(bp + 60 /* pRule */)) = uintptr(0)
				rc = fuzzerLoadOneRule(tls, p, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)), bp+60 /* &pRule */, pzErr)
				if *(*uintptr)(unsafe.Pointer(bp + 60 /* pRule */)) != 0 {
					(*fuzzer_rule)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 60 /* pRule */)))).FpNext = pHead
					pHead = *(*uintptr)(unsafe.Pointer(bp + 60 /* pRule */))
				}
			}
		}
		rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))
		if rc == SQLITE_OK {
			rc = rc2
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	// All rules are now in a singly linked list starting at pHead. This
	// block sorts them by cost and then sets fuzzer_vtab.pRule to point to
	// point to the head of the sorted list.
	if rc == SQLITE_OK {
		var i uint32
		var pX uintptr
		// var a [15]uintptr at bp+64, 60

		for i = uint32(0); i < (uint32(unsafe.Sizeof([15]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0)))); i++ {
			*(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)) = uintptr(0)
		}
		for (libc.AssignUintptr(&pX, pHead)) != uintptr(0) {
			pHead = (*fuzzer_rule)(unsafe.Pointer(pX)).FpNext
			(*fuzzer_rule)(unsafe.Pointer(pX)).FpNext = uintptr(0)
			for i = uint32(0); (*(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)) != 0) && (i < ((uint32(unsafe.Sizeof([15]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0)))) - uint32(1))); i++ {
				pX = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)), pX)
				*(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)) = uintptr(0)
			}
			*(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)) = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)), pX)
		}
		pX = *(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */))
		i = uint32(1)
		for ; i < (uint32(unsafe.Sizeof([15]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0)))); i++ {
			pX = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* &a[0] */ + uintptr(i)*4)), pX)
		}
		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = fuzzerMergeRules(tls, (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule, pX)
	} else {
		// An error has occurred. Setting p->pRule to point to the head of the
		// allocated list ensures that the list will be cleaned up in this case.

		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = pHead
	}

	return rc
}

// This function converts an SQL quoted string into an unquoted string
// and returns a pointer to a buffer allocated using sqlite3_malloc()
// containing the result. The caller should eventually free this buffer
// using sqlite3_free.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func fuzzerDequote(tls *libc.TLS, zIn uintptr) uintptr { /* fuzzer.c:449:13: */
	var nIn sqlite3_int64 // Size of input string, in bytes
	var zOut uintptr      // Output (dequoted) string

	nIn = sqlite3_int64(libc.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, (uint64(nIn + int64(1))))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn)) // Quote character (if any )

		if (((int32(q) != '[') && (int32(q) != '\'')) && (int32(q) != '"')) && (int32(q) != '`') {
			libc.Xmemcpy(tls, zOut, zIn, (size_t(nIn + int64(1))))
		} else {
			var iOut int32 = 0 // Index of next byte to write to output
			var iIn int32      // Index of next byte to read from input

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}

	}
	return zOut
}

// xDisconnect/xDestroy method for the fuzzer module.
func fuzzerDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* fuzzer.c:478:12: */
	var p uintptr = pVtab

	for (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule != 0 {
		var pRule uintptr = (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule
		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
		sqlite3.Xsqlite3_free(tls, pRule)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

// xConnect/xCreate method for the fuzzer module. Arguments are:
//
//   argv[0]   -> module name  ("fuzzer")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[3]   -> fuzzer rule table name
func fuzzerConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* fuzzer.c:498:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK      // Return code
	var pNew uintptr = uintptr(0) // New virtual table
	var zModule uintptr = *(*uintptr)(unsafe.Pointer(argv))
	var zDb uintptr = *(*uintptr)(unsafe.Pointer(argv + 1*4))

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
			ts+5255 /* "%s: wrong number..." */, libc.VaList(bp, zModule))
		rc = SQLITE_ERROR
	} else {
		var nModule sqlite3_int64 // Length of zModule, in bytes

		nModule = sqlite3_int64(libc.Xstrlen(tls, zModule))
		pNew = sqlite3.Xsqlite3_malloc64(tls, (uint64((sqlite3_int64(unsafe.Sizeof(fuzzer_vtab{})) + nModule) + int64(1))))
		if pNew == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			var zTab uintptr // Dequoted name of fuzzer data table

			libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(fuzzer_vtab{})))
			(*fuzzer_vtab)(unsafe.Pointer(pNew)).FzClassName = (pNew + 1*24)
			libc.Xmemcpy(tls, (*fuzzer_vtab)(unsafe.Pointer(pNew)).FzClassName, zModule, (size_t(nModule + int64(1))))

			zTab = fuzzerDequote(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
			if zTab == uintptr(0) {
				rc = SQLITE_NOMEM
			} else {
				rc = fuzzerLoadRules(tls, db, pNew, zDb, zTab, pzErr)
				sqlite3.Xsqlite3_free(tls, zTab)
			}

			if rc == SQLITE_OK {
				rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+5306 /* "CREATE TABLE x(w..." */)
			}
			if rc != SQLITE_OK {
				fuzzerDisconnect(tls, pNew)
				pNew = uintptr(0)
			} else {
				sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
			}
		}
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc
}

// Open a new fuzzer cursor.
func fuzzerOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* fuzzer.c:556:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fuzzer_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(fuzzer_cursor{})))
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	(*fuzzer_vtab)(unsafe.Pointer(p)).FnCursor++
	return SQLITE_OK
}

// Free all stems in a list.
func fuzzerClearStemList(tls *libc.TLS, pStem uintptr) { /* fuzzer.c:571:13: */
	for pStem != 0 {
		var pNext uintptr = (*fuzzer_stem)(unsafe.Pointer(pStem)).FpNext
		sqlite3.Xsqlite3_free(tls, pStem)
		pStem = pNext
	}
}

// Free up all the memory allocated by a cursor.  Set it rLimit to 0
// to indicate that it is at EOF.
func fuzzerClearCursor(tls *libc.TLS, pCur uintptr, clearHash int32) { /* fuzzer.c:583:13: */
	var i int32
	fuzzerClearStemList(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)
	fuzzerClearStemList(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone)
	for i = 0; i < FUZZER_NQUEUE; i++ {
		fuzzerClearStemList(tls, *(*uintptr)(unsafe.Pointer((pCur + 32 /* &.aQueue */) + uintptr(i)*4)))
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	if (clearHash != 0) && ((*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem != 0) {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue = 0
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = uintptr(0)
		libc.Xmemset(tls, pCur+32 /* &.aQueue */, 0, uint32(unsafe.Sizeof([20]uintptr{})))
		libc.Xmemset(tls, pCur+156 /* &.apHash */, 0, uint32(unsafe.Sizeof([4001]uintptr{})))
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem = 0
}

// Close a fuzzer cursor.
func fuzzerClose(tls *libc.TLS, cur uintptr) int32 { /* fuzzer.c:602:12: */
	var pCur uintptr = cur
	fuzzerClearCursor(tls, pCur, 0)
	sqlite3.Xsqlite3_free(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf)
	(*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Compute the current output term for a fuzzer_stem.
func fuzzerRender(tls *libc.TLS, pStem uintptr, pzBuf uintptr, pnBuf uintptr) int32 { /* fuzzer.c:614:12: */
	var pRule uintptr = (*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule
	var n int32   // Size of output term without nul-term
	var z uintptr // Buffer to assemble output term in

	n = ((int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) + int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo)) - int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom))
	if (*(*int32)(unsafe.Pointer(pnBuf))) < (n + 1) {
		(*(*uintptr)(unsafe.Pointer(pzBuf))) = sqlite3.Xsqlite3_realloc(tls, *(*uintptr)(unsafe.Pointer(pzBuf)), (n + 100))
		if (*(*uintptr)(unsafe.Pointer(pzBuf))) == uintptr(0) {
			return SQLITE_NOMEM
		}
		(*(*int32)(unsafe.Pointer(pnBuf))) = (n + 100)
	}
	n = int32((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn)
	z = *(*uintptr)(unsafe.Pointer(pzBuf))
	if n < 0 {
		libc.Xmemcpy(tls, z, (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis, (uint32(int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) + 1)))
	} else {
		libc.Xmemcpy(tls, z, (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis, uint32(n))
		libc.Xmemcpy(tls, (z + uintptr(n)), pRule+20 /* &.zTo */, uint32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo))
		libc.Xmemcpy(tls, (z + uintptr((n + int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo)))), ((*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis + uintptr((n + int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)))),
			(uint32(((int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) - n) - int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)) + 1)))
	}

	return SQLITE_OK
}

// Compute a hash on zBasis.
func fuzzerHash(tls *libc.TLS, z uintptr) uint32 { /* fuzzer.c:647:21: */
	var h uint32 = uint32(0)
	for *(*int8)(unsafe.Pointer(z)) != 0 {
		h = (((h << 3) ^ (h >> 29)) ^ uint32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))))
	}
	return (h % uint32(FUZZER_HASH))
}

// Current cost of a stem
func fuzzerCost(tls *libc.TLS, pStem uintptr) fuzzer_cost { /* fuzzer.c:656:20: */
	return libc.AssignPtrInt32(pStem+20 /* &.rCostX */, ((*fuzzer_stem)(unsafe.Pointer(pStem)).FrBaseCost + (*fuzzer_rule)(unsafe.Pointer((*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule)).FrCost))
}

// Return 1 if the string to which the cursor is point has already
// been emitted.  Return 0 if not.  Return -1 on a memory allocation
// failures.
func fuzzerSeen(tls *libc.TLS, pCur uintptr, pStem uintptr) int32 { /* fuzzer.c:694:12: */
	var h uint32
	var pLookup uintptr

	if fuzzerRender(tls, pStem, (pCur+116 /* &.zBuf */), (pCur+120 /* &.nBuf */)) == SQLITE_NOMEM {
		return -1
	}
	h = fuzzerHash(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf)
	pLookup = *(*uintptr)(unsafe.Pointer((pCur + 156 /* &.apHash */) + uintptr(h)*4))
	for (pLookup != 0) && (libc.Xstrcmp(tls, (*fuzzer_stem)(unsafe.Pointer(pLookup)).FzBasis, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf) != 0) {
		pLookup = (*fuzzer_stem)(unsafe.Pointer(pLookup)).FpHash
	}
	return (libc.Bool32(pLookup != uintptr(0)))
}

// If argument pRule is NULL, this function returns false.
//
// Otherwise, it returns true if rule pRule should be skipped. A rule
// should be skipped if it does not belong to rule-set iRuleset, or if
// applying it to stem pStem would create a string longer than
// FUZZER_MX_OUTPUT_LENGTH bytes.
func fuzzerSkipRule(tls *libc.TLS, pRule uintptr, pStem uintptr, iRuleset int32) int32 { /* fuzzer.c:717:12: */
	return (libc.Bool32((pRule != 0) && (((*fuzzer_rule)(unsafe.Pointer(pRule)).FiRuleset != iRuleset) ||
		(((int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) + int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo)) - int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)) > FUZZER_MX_OUTPUT_LENGTH))))
}

// Advance a fuzzer_stem to its next value.   Return 0 if there are
// no more values that can be generated by this fuzzer_stem.  Return
// -1 on a memory allocation failure.
func fuzzerAdvance(tls *libc.TLS, pCur uintptr, pStem uintptr) int32 { /* fuzzer.c:733:12: */
	var pRule uintptr
	for (libc.AssignUintptr(&pRule, (*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule)) != uintptr(0) {

		for int32((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn) < (int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) - int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)) {
			(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn++
			if (int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom) == 0) ||
				(libc.Xmemcmp(tls, ((*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis+uintptr((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn)), (*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom, uint32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)) == 0) {
				// Found a rewrite case.  Make sure it is not a duplicate
				var rc int32 = fuzzerSeen(tls, pCur, pStem)
				if rc < 0 {
					return -1
				}
				if rc == 0 {
					fuzzerCost(tls, pStem)
					return 1
				}
			}
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn = int8(-1)
		for ok := true; ok; ok = fuzzerSkipRule(tls, pRule, pStem, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset) != 0 {
			pRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = pRule
		if (pRule != 0) && (fuzzerCost(tls, pStem) > (*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit) {
			(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = uintptr(0)
		}
	}
	return 0
}

// The two input stem lists are both sorted in order of increasing
// rCostX.  Merge them together into a single list, sorted by rCostX, and
// return a pointer to the head of that new list.
func fuzzerMergeStems(tls *libc.TLS, pA uintptr, pB uintptr) uintptr { /* fuzzer.c:766:20: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var head fuzzer_stem at bp, 28

	var pTail uintptr

	pTail = bp /* &head */
	for (pA != 0) && (pB != 0) {
		if (*fuzzer_stem)(unsafe.Pointer(pA)).FrCostX <= (*fuzzer_stem)(unsafe.Pointer(pB)).FrCostX {
			(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*fuzzer_stem)(unsafe.Pointer(pA)).FpNext
		} else {
			(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*fuzzer_stem)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*fuzzer_stem)(unsafe.Pointer(bp /* &head */)).FpNext
}

// Load pCur->pStem with the lowest-cost stem.  Return a pointer
// to the lowest-cost stem.
func fuzzerLowestCostStem(tls *libc.TLS, pCur uintptr) uintptr { /* fuzzer.c:794:20: */
	var pBest uintptr
	var pX uintptr
	var iBest int32
	var i int32

	if (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem == uintptr(0) {
		iBest = -1
		pBest = uintptr(0)
		for i = 0; i <= (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue; i++ {
			pX = *(*uintptr)(unsafe.Pointer((pCur + 32 /* &.aQueue */) + uintptr(i)*4))
			if pX == uintptr(0) {
				continue
			}
			if (pBest == uintptr(0)) || ((*fuzzer_stem)(unsafe.Pointer(pBest)).FrCostX > (*fuzzer_stem)(unsafe.Pointer(pX)).FrCostX) {
				pBest = pX
				iBest = i
			}
		}
		if pBest != 0 {
			*(*uintptr)(unsafe.Pointer((pCur + 32 /* &.aQueue */) + uintptr(iBest)*4)) = (*fuzzer_stem)(unsafe.Pointer(pBest)).FpNext
			(*fuzzer_stem)(unsafe.Pointer(pBest)).FpNext = uintptr(0)
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = pBest
		}
	}
	return (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem
}

// Insert pNew into queue of pending stems.  Then find the stem
// with the lowest rCostX and move it into pCur->pStem.
// list.  The insert is done such the pNew is in the correct order
// according to fuzzer_stem.zBaseCost+fuzzer_stem.pRule->rCost.
func fuzzerInsert(tls *libc.TLS, pCur uintptr, pNew uintptr) uintptr { /* fuzzer.c:825:20: */
	var pX uintptr
	var i int32

	// If pCur->pStem exists and is greater than pNew, then make pNew
	// the new pCur->pStem and insert the old pCur->pStem instead.
	if ((libc.AssignUintptr(&pX, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)) != uintptr(0)) && ((*fuzzer_stem)(unsafe.Pointer(pX)).FrCostX > (*fuzzer_stem)(unsafe.Pointer(pNew)).FrCostX) {
		(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = uintptr(0)
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = pNew
		pNew = pX
	}

	// Insert the new value
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = uintptr(0)
	pX = pNew
	for i = 0; i <= (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue; i++ {
		if *(*uintptr)(unsafe.Pointer((pCur + 32 /* &.aQueue */) + uintptr(i)*4)) != 0 {
			pX = fuzzerMergeStems(tls, pX, *(*uintptr)(unsafe.Pointer((pCur + 32 /* &.aQueue */) + uintptr(i)*4)))
			*(*uintptr)(unsafe.Pointer((pCur + 32 /* &.aQueue */) + uintptr(i)*4)) = uintptr(0)
		} else {
			*(*uintptr)(unsafe.Pointer((pCur + 32 /* &.aQueue */) + uintptr(i)*4)) = pX
			break
		}
	}
	if i > (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue {
		if i < FUZZER_NQUEUE {
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue = i
			*(*uintptr)(unsafe.Pointer((pCur + 32 /* &.aQueue */) + uintptr(i)*4)) = pX
		} else {

			pX = fuzzerMergeStems(tls, pX, *(*uintptr)(unsafe.Pointer((pCur + 32 /* &.aQueue */) + 19*4)))
			*(*uintptr)(unsafe.Pointer((pCur + 32 /* &.aQueue */) + 19*4)) = pX
		}
	}

	return fuzzerLowestCostStem(tls, pCur)
}

// Allocate a new fuzzer_stem.  Add it to the hash table but do not
// link it into either the pCur->pStem or pCur->pDone lists.
func fuzzerNewStem(tls *libc.TLS, pCur uintptr, zWord uintptr, rBaseCost fuzzer_cost) uintptr { /* fuzzer.c:868:20: */
	var pNew uintptr
	var pRule uintptr
	var h uint32

	pNew = sqlite3.Xsqlite3_malloc64(tls, (uint64((uint32(unsafe.Sizeof(fuzzer_stem{})) + libc.Xstrlen(tls, zWord)) + uint32(1))))
	if pNew == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(fuzzer_stem{})))
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis = (pNew + 1*28)
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FnBasis = fuzzer_len(libc.Xstrlen(tls, zWord))
	libc.Xmemcpy(tls, (*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis, zWord, (uint32(int32((*fuzzer_stem)(unsafe.Pointer(pNew)).FnBasis) + 1)))
	pRule = (*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FpRule
	for fuzzerSkipRule(tls, pRule, pNew, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset) != 0 {
		pRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
	}
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpRule = pRule
	(*fuzzer_stem)(unsafe.Pointer(pNew)).Fn = int8(-1)
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FrBaseCost = libc.AssignPtrInt32(pNew+20 /* &.rCostX */, rBaseCost)
	h = fuzzerHash(tls, (*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis)
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpHash = *(*uintptr)(unsafe.Pointer((pCur + 156 /* &.apHash */) + uintptr(h)*4))
	*(*uintptr)(unsafe.Pointer((pCur + 156 /* &.apHash */) + uintptr(h)*4)) = pNew
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem++
	return pNew
}

// Advance a cursor to its next row of output
func fuzzerNext(tls *libc.TLS, cur uintptr) int32 { /* fuzzer.c:901:12: */
	var pCur uintptr = cur
	var rc int32
	var pStem uintptr
	var pNew uintptr

	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid++

	// Use the element the cursor is currently point to to create
	// a new stem and insert the new stem into the priority queue.
	pStem = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem
	if (*fuzzer_stem)(unsafe.Pointer(pStem)).FrCostX > 0 {
		rc = fuzzerRender(tls, pStem, (pCur + 116 /* &.zBuf */), (pCur + 120 /* &.nBuf */))
		if rc == SQLITE_NOMEM {
			return SQLITE_NOMEM
		}
		pNew = fuzzerNewStem(tls, pCur, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf, (*fuzzer_stem)(unsafe.Pointer(pStem)).FrCostX)
		if pNew != 0 {
			if fuzzerAdvance(tls, pCur, pNew) == 0 {
				(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone
				(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = pNew
			} else {
				if fuzzerInsert(tls, pCur, pNew) == pNew {
					return SQLITE_OK
				}
			}
		} else {
			return SQLITE_NOMEM
		}
	}

	// Adjust the priority queue so that the first element of the
	// stem list is the next lowest cost word.
	for (libc.AssignUintptr(&pStem, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)) != uintptr(0) {
		var res int32 = fuzzerAdvance(tls, pCur, pStem)
		if res < 0 {
			return SQLITE_NOMEM
		} else if res > 0 {
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
			pStem = fuzzerInsert(tls, pCur, pStem)
			if (libc.AssignInt32(&rc, fuzzerSeen(tls, pCur, pStem))) != 0 {
				if rc < 0 {
					return SQLITE_NOMEM
				}
				continue
			}
			return SQLITE_OK // New word found
		}
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpNext = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = pStem
		if fuzzerLowestCostStem(tls, pCur) != 0 {
			rc = fuzzerSeen(tls, pCur, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)
			if rc < 0 {
				return SQLITE_NOMEM
			}
			if rc == 0 {
				return SQLITE_OK
			}
		}
	}

	// Reach this point only if queue has been exhausted and there is
	// nothing left to be output.
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	return SQLITE_OK
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any fuzzerColumn, fuzzerRowid, or fuzzerEof call.
func fuzzerFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* fuzzer.c:969:12: */
	var pCur uintptr = pVtabCursor
	var zWord uintptr = ts + 489 /* "" */
	var pStem uintptr
	var idx int32

	fuzzerClearCursor(tls, pCur, 1)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 2147483647
	idx = 0
	if (idxNum & 1) != 0 {
		zWord = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		idx++
	}
	if (idxNum & 2) != 0 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*4)))
		idx++
	}
	if (idxNum & 4) != 0 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*4)))
		idx++
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FpNext = (*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FpRule
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FrCost = 0
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FnFrom = int8(0)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FnTo = int8(0)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FzFrom = ts + 489 /* "" */
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)

	// If the query term is longer than FUZZER_MX_OUTPUT_LENGTH bytes, this
	// query will return zero rows.
	if int32(libc.Xstrlen(tls, zWord)) < FUZZER_MX_OUTPUT_LENGTH {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = libc.AssignUintptr(&pStem, fuzzerNewStem(tls, pCur, zWord, 0))
		if pStem == uintptr(0) {
			return SQLITE_NOMEM
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = (pCur + 132 /* &.nullRule */)
		(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn = (*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis
	} else {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	}

	return SQLITE_OK
}

// Only the word and distance columns have values.  All other columns
// return NULL
func fuzzerColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* fuzzer.c:1020:12: */
	var pCur uintptr = cur
	if i == 0 {
		// the "word" column
		if fuzzerRender(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem, (pCur+116 /* &.zBuf */), (pCur+120 /* &.nBuf */)) == SQLITE_NOMEM {
			return SQLITE_NOMEM
		}
		sqlite3.Xsqlite3_result_text(tls, ctx, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf, -1, libc.UintptrFromInt32(-1))
	} else if i == 1 {
		// the "distance" column
		sqlite3.Xsqlite3_result_int(tls, ctx, (*fuzzer_stem)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)).FrCostX)
	} else {
		// All other columns are NULL
		sqlite3.Xsqlite3_result_null(tls, ctx)
	}
	return SQLITE_OK
}

// The rowid.
func fuzzerRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* fuzzer.c:1041:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// When the fuzzer_cursor.rLimit value is 0 or less, that is a signal
// that the cursor has nothing more to output.
func fuzzerEof(tls *libc.TLS, cur uintptr) int32 { /* fuzzer.c:1051:12: */
	var pCur uintptr = cur
	return (libc.Bool32((*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit <= 0))
}

// Search for terms of these forms:
//
//   (A)    word MATCH $str
//   (B1)   distance < $value
//   (B2)   distance <= $value
//   (C)    ruleid == $ruleid
//
// The distance< and distance<= are both treated as distance<=.
// The query plan number is a bit vector:
//
//   bit 1:   Term of the form (A) found
//   bit 2:   Term like (B1) or (B2) found
//   bit 3:   Term like (C) found
//
// If bit-1 is set, $str is always in filter.argv[0].  If bit-2 is set
// then $value is in filter.argv[0] if bit-1 is clear and is in
// filter.argv[1] if bit-1 is set.  If bit-3 is set, then $ruleid is
// in filter.argv[0] if bit-1 and bit-2 are both zero, is in
// filter.argv[1] if exactly one of bit-1 and bit-2 are set, and is in
// filter.argv[2] if both bit-1 and bit-2 are set.
func fuzzerBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* fuzzer.c:1078:12: */
	var iPlan int32 = 0
	var iDistTerm int32 = -1
	var iRulesetTerm int32 = -1
	var i int32
	var seenMatch int32 = 0
	var pConstraint uintptr
	var rCost float64 = 1e12

	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if ((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH) {
			seenMatch = 1
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if (((iPlan & 1) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH) {
			iPlan = iPlan | (1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / (1e6)
		}
		if (((iPlan & 2) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 1)) &&
			((int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT) ||
				(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE)) {
			iPlan = iPlan | (2)
			iDistTerm = i
			rCost = rCost / (10.0)
		}
		if (((iPlan & 4) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 2)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | (4)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			iRulesetTerm = i
			rCost = rCost / (10.0)
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (iPlan & 2) != 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = (1 + (libc.Bool32((iPlan & 1) != 0)))
	}
	if (iPlan & 4) != 0 {
		var idx int32 = 1
		if (iPlan & 1) != 0 {
			idx++
		}
		if (iPlan & 2) != 0 {
			idx++
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRulesetTerm)*8)).FargvIndex = idx
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) &&
		((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == 1)) &&
		(int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0) {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	if (seenMatch != 0) && ((iPlan & 1) == 0) {
		rCost = 1e99
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = rCost

	return SQLITE_OK
}

// A virtual table module that implements the "fuzzer".
var fuzzerModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* fuzzer.c:1147:23 */

func sqlite3_fuzzer_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* fuzzer.c:1176:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+5344 /* "fuzzer" */, uintptr(unsafe.Pointer(&fuzzerModule)), uintptr(0))
	return rc
}

// Mark a function parameter as unused, to suppress nuisance compiler
// warnings.

// Implementation of the ieee754() function
func ieee754func(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* ieee754.c:102:13: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	if argc == 1 {
		var m sqlite3_int64
		// var a sqlite3_int64 at bp+32, 8

		// var r float64 at bp+16, 8

		var e int32
		var isNeg int32
		// var zResult [100]int8 at bp+40, 100

		if (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_BLOB) &&
			(uint32(sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))) == uint32(unsafe.Sizeof(float64(0)))) {
			var x uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
			var i uint32
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 24 /* v */)) = uint64(0)
			for i = uint32(0); i < uint32(unsafe.Sizeof(float64(0))); i++ {
				*(*sqlite3_uint64)(unsafe.Pointer(bp + 24 /* v */)) = ((*(*sqlite3_uint64)(unsafe.Pointer(bp + 24 /* v */)) << 8) | sqlite3_uint64(*(*uint8)(unsafe.Pointer(x + uintptr(i)))))
			}
			libc.Xmemcpy(tls, bp+16 /* &r */, bp+24 /* &v */, uint32(unsafe.Sizeof(float64(0))))
		} else {
			*(*float64)(unsafe.Pointer(bp + 16 /* r */)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
		}
		if *(*float64)(unsafe.Pointer(bp + 16 /* r */)) < 0.0 {
			isNeg = 1
			*(*float64)(unsafe.Pointer(bp + 16 /* r */)) = -*(*float64)(unsafe.Pointer(bp + 16 /* r */))
		} else {
			isNeg = 0
		}
		libc.Xmemcpy(tls, bp+32 /* &a */, bp+16 /* &r */, uint32(unsafe.Sizeof(sqlite3_int64(0))))
		if *(*sqlite3_int64)(unsafe.Pointer(bp + 32 /* a */)) == int64(0) {
			e = 0
			m = int64(0)
		} else {
			e = (int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 32 /* a */)) >> 52))
			m = (*(*sqlite3_int64)(unsafe.Pointer(bp + 32 /* a */)) & ((sqlite3_int64((int64(1))) << 52) - int64(1)))
			if e == 0 {
				m <<= 1
			} else {
				m = m | (sqlite3_int64((int64(1))) << 52)
			}
			for ((e < 1075) && (m > int64(0))) && ((m & int64(1)) == int64(0)) {
				m >>= 1
				e++
			}
			if isNeg != 0 {
				m = -m
			}
		}
		switch *(*int32)(unsafe.Pointer(sqlite3.Xsqlite3_user_data(tls, context))) {
		case 0:
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40 /* &zResult[0] */, ts+5351, /* "ieee754(%lld,%d)" */
				libc.VaList(bp, m, (e-1075)))
			sqlite3.Xsqlite3_result_text(tls, context, bp+40 /* &zResult[0] */, -1, libc.UintptrFromInt32(-1))
			break
			fallthrough
		case 1:
			sqlite3.Xsqlite3_result_int64(tls, context, m)
			break
			fallthrough
		case 2:
			sqlite3.Xsqlite3_result_int(tls, context, (e - 1075))
			break
		}
	} else {
		var m sqlite3_int64
		var e sqlite3_int64
		// var a sqlite3_int64 at bp+152, 8

		// var r float64 at bp+144, 8

		var isNeg int32 = 0
		m = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
		e = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))

		// Limit the range of e.  Ticket 22dea1cfdb9151e4 2021-03-02
		if e > int64(10000) {
			e = int64(10000)
		} else if e < int64(-10000) {
			e = int64(-10000)
		}

		if m < int64(0) {
			isNeg = 1
			m = -m
			if m < int64(0) {
				return
			}
		} else if ((m == int64(0)) && (e > int64(-1000))) && (e < int64(1000)) {
			sqlite3.Xsqlite3_result_double(tls, context, 0.0)
			return
		}
		for ((m >> 32) & int64(0xffe00000)) != 0 {
			m >>= 1
			e++
		}
		for (m != int64(0)) && (((m >> 32) & int64(0xfff00000)) == int64(0)) {
			m <<= 1
			e--
		}
		e = e + (int64(1075))
		if e <= int64(0) {
			// Subnormal
			m >>= (int64(1) - e)
			e = int64(0)
		} else if e > int64(0x7ff) {
			e = int64(0x7ff)
		}
		*(*sqlite3_int64)(unsafe.Pointer(bp + 152 /* a */)) = (m & ((sqlite3_int64((int64(1))) << 52) - int64(1)))
		*(*sqlite3_int64)(unsafe.Pointer(bp + 152 /* a */)) |= (e << 52)
		if isNeg != 0 {
			*(*sqlite3_int64)(unsafe.Pointer(bp + 152 /* a */)) |= libc.Int64FromUint64((sqlite3_uint64((uint64(1))) << 63))
		}
		libc.Xmemcpy(tls, bp+144 /* &r */, bp+152 /* &a */, uint32(unsafe.Sizeof(float64(0))))
		sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 144 /* r */)))
	}
}

// Functions to convert between blobs and floats.
func ieee754func_from_blob(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* ieee754.c:213:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	_ = argc
	if (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_BLOB) &&
		(uint32(sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))) == uint32(unsafe.Sizeof(float64(0)))) {
		// var r float64 at bp, 8

		var x uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var i uint32
		*(*sqlite3_uint64)(unsafe.Pointer(bp + 8 /* v */)) = uint64(0)
		for i = uint32(0); i < uint32(unsafe.Sizeof(float64(0))); i++ {
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 8 /* v */)) = ((*(*sqlite3_uint64)(unsafe.Pointer(bp + 8 /* v */)) << 8) | sqlite3_uint64(*(*uint8)(unsafe.Pointer(x + uintptr(i)))))
		}
		libc.Xmemcpy(tls, bp /* &r */, bp+8 /* &v */, uint32(unsafe.Sizeof(float64(0))))
		sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp /* r */)))
	}
}

func ieee754func_to_blob(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* ieee754.c:233:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = argc
	if (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_FLOAT) ||
		(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_INTEGER) {
		*(*float64)(unsafe.Pointer(bp + 8 /* r */)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
		// var v sqlite3_uint64 at bp, 8

		// var a [8]uint8 at bp+16, 8

		var i uint32
		libc.Xmemcpy(tls, bp /* &v */, bp+8 /* &r */, uint32(unsafe.Sizeof(float64(0))))
		for i = uint32(1); i <= uint32(unsafe.Sizeof(float64(0))); i++ {
			*(*uint8)(unsafe.Pointer(bp + 16 /* &a[0] */ + uintptr((uint32(unsafe.Sizeof(float64(0))) - i)))) = (uint8(*(*sqlite3_uint64)(unsafe.Pointer(bp /* v */)) & uint64(0xff)))
			*(*sqlite3_uint64)(unsafe.Pointer(bp /* v */)) >>= 8
		}
		sqlite3.Xsqlite3_result_blob(tls, context, bp+16 /* &a[0] */, int32(unsafe.Sizeof(float64(0))), libc.UintptrFromInt32(-1))
	}
}

func sqlite3_ieee_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* ieee754.c:259:5: */
	var i uint32
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	for i = uint32(0); (i < (uint32(unsafe.Sizeof(aFunc1)) / uint32(unsafe.Sizeof(struct {
		FzFName uintptr
		FnArg   int32
		FiAux   int32
		FxFunc  uintptr
	}{})))) && (rc == SQLITE_OK); i++ {
		rc = sqlite3.Xsqlite3_create_function(tls, db, aFunc1[i].FzFName, aFunc1[i].FnArg,
			(SQLITE_UTF8 | SQLITE_INNOCUOUS),
			(uintptr(unsafe.Pointer(&aFunc1)) + uintptr(i)*16 + 8 /* &.iAux */),
			aFunc1[i].FxFunc, uintptr(0), uintptr(0))
	}
	return rc
}

var aFunc1 = [6]struct {
	FzFName uintptr
	FnArg   int32
	FiAux   int32
	FxFunc  uintptr
}{
	{FzFName: ts + 5368 /* "ieee754" */, FnArg: 1, FxFunc: 0},
	{FzFName: ts + 5368 /* "ieee754" */, FnArg: 2, FxFunc: 0},
	{FzFName: ts + 5376 /* "ieee754_mantissa" */, FnArg: 1, FiAux: 1, FxFunc: 0},
	{FzFName: ts + 5393 /* "ieee754_exponent" */, FnArg: 1, FiAux: 2, FxFunc: 0},
	{FzFName: ts + 5410 /* "ieee754_to_blob" */, FnArg: 1, FxFunc: 0},
	{FzFName: ts + 5426 /* "ieee754_from_blo..." */, FnArg: 1, FxFunc: 0},
} /* ieee754.c:269:5 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// This function is used to touch each page of a mapping of a memory
// mapped SQLite database. Assuming that the system has sufficient free
// memory and supports sufficiently large mappings, this causes the OS
// to cache the entire database in main memory, making subsequent
// database accesses faster.
//
// If the second parameter to this function is not NULL, it is the name of
// the specific database to operate on (i.e. "main" or the name of an
// attached database).
//
// SQLITE_OK is returned if successful, or an SQLite error code otherwise.
// It is not considered an error if the file is not memory-mapped, or if
// the mapping does not span the entire file. If an error does occur, a
// transaction may be left open on the database file.
//
// It is illegal to call this function when the database handle has an
// open transaction. SQLITE_MISUSE is returned in this case.
func sqlite3_mmap_warm(tls *libc.TLS, db uintptr, zDb uintptr) int32 { /* mmapwarm.c:37:5: */
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var rc int32 = SQLITE_OK
	var zSql uintptr = uintptr(0)
	var pgsz int32 = 0
	var nTotal int32 = 0

	if 0 == sqlite3.Xsqlite3_get_autocommit(tls, db) {
		return SQLITE_MISUSE
	}

	// Open a read-only transaction on the file in question
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+5444, /* "BEGIN; SELECT * ..." */
		libc.VaList(bp, func() uintptr {
			if zDb != 0 {
				return ts + 5485 /* "'" */
			}
			return ts + 489 /* "" */
		}(), func() uintptr {
			if zDb != 0 {
				return zDb
			}
			return ts + 489 /* "" */
		}(), func() uintptr {
			if zDb != 0 {
				return ts + 5487 /* "'." */
			}
			return ts + 489 /* "" */
		}()))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	// Find the SQLite page size of the file
	if rc == SQLITE_OK {
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+5490, /* "PRAGMA %s%q%spag..." */
			libc.VaList(bp+24, func() uintptr {
				if zDb != 0 {
					return ts + 5485 /* "'" */
				}
				return ts + 489 /* "" */
			}(), func() uintptr {
				if zDb != 0 {
					return zDb
				}
				return ts + 489 /* "" */
			}(), func() uintptr {
				if zDb != 0 {
					return ts + 5487 /* "'." */
				}
				return ts + 489 /* "" */
			}()))
		if zSql == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			*(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */)) = uintptr(0)
			rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+64 /* &pPgsz */, uintptr(0))
			sqlite3.Xsqlite3_free(tls, zSql)
			if rc == SQLITE_OK {
				if sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */))) == SQLITE_ROW {
					pgsz = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */)), 0)
				}
				rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */)))
			}
			if (rc == SQLITE_OK) && (pgsz == 0) {
				rc = SQLITE_ERROR
			}
		}
	}

	// Touch each mmap'd page of the file
	if rc == SQLITE_OK {
		var rc2 int32
		*(*uintptr)(unsafe.Pointer(bp + 68 /* pFd */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_file_control(tls, db, zDb, SQLITE_FCNTL_FILE_POINTER, bp+68 /* &pFd */)
		if (rc == SQLITE_OK) && ((*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 68 /* pFd */)))).FpMethods)).FiVersion >= 3) {
			var iPg sqlite3_int64 = int64(1)
			var p uintptr = (*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 68 /* pFd */)))).FpMethods
			for 1 != 0 {
				// var pMap uintptr at bp+72, 4

				rc = (*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer((p + 68 /* &.xFetch */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 68 /* pFd */)), (sqlite3_int64(pgsz) * iPg), pgsz, bp+72 /* &pMap */)
				if (rc != SQLITE_OK) || (*(*uintptr)(unsafe.Pointer(bp + 72 /* pMap */)) == uintptr(0)) {
					break
				}

				nTotal = nTotal + (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72 /* pMap */))))))
				nTotal = nTotal + (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72 /* pMap */)) + uintptr((pgsz - 1))))))

				rc = (*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer((p + 72 /* &.xUnfetch */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 68 /* pFd */)), (sqlite3_int64(pgsz) * iPg), *(*uintptr)(unsafe.Pointer(bp + 72 /* pMap */)))
				if rc != SQLITE_OK {
					break
				}
				iPg++
			}
			sqlite3.Xsqlite3_log(tls, SQLITE_OK,
				ts+5513 /* "sqlite3_mmap_war..." */, libc.VaList(bp+48, func() int64 {
					if iPg == int64(1) {
						return int64(0)
					}
					return iPg
				}(),
					sqlite3.Xsqlite3_db_filename(tls, db, zDb)))
		}

		rc2 = sqlite3.Xsqlite3_exec(tls, db, ts+5563 /* "END" */, uintptr(0), uintptr(0), uintptr(0))
		if rc == SQLITE_OK {
			rc = rc2
		}
	}

	return rc
}

// A structure to hold context of the next_char() computation across
// nested function calls.
type nextCharContext1 = struct {
	Fdb           uintptr
	FpStmt        uintptr
	FzPrefix      uintptr
	FnPrefix      int32
	FnAlloc       int32
	FnUsed        int32
	FaResult      uintptr
	FmallocFailed int32
	FotherError   int32
} /* nextchar.c:63:9 */

// A structure to hold context of the next_char() computation across
// nested function calls.
type nextCharContext = nextCharContext1 /* nextchar.c:63:32 */

// Append a result character if the character is not already in the
// result.
func nextCharAppend(tls *libc.TLS, p uintptr, c uint32) { /* nextchar.c:80:13: */
	var i int32
	for i = 0; i < (*nextCharContext)(unsafe.Pointer(p)).FnUsed; i++ {
		if *(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(p)).FaResult + uintptr(i)*4)) == c {
			return
		}
	}
	if ((*nextCharContext)(unsafe.Pointer(p)).FnUsed + 1) > (*nextCharContext)(unsafe.Pointer(p)).FnAlloc {
		var aNew uintptr
		var n int32 = (((*nextCharContext)(unsafe.Pointer(p)).FnAlloc * 2) + 30)
		aNew = sqlite3.Xsqlite3_realloc64(tls, (*nextCharContext)(unsafe.Pointer(p)).FaResult, (uint64(uint32(n) * uint32(unsafe.Sizeof(uint32(0))))))
		if aNew == uintptr(0) {
			(*nextCharContext)(unsafe.Pointer(p)).FmallocFailed = 1
			return
		} else {
			(*nextCharContext)(unsafe.Pointer(p)).FaResult = aNew
			(*nextCharContext)(unsafe.Pointer(p)).FnAlloc = n
		}
	}
	*(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(p)).FaResult + uintptr(libc.PostIncInt32(&(*nextCharContext)(unsafe.Pointer(p)).FnUsed, 1))*4)) = c
}

// Write a character into z[] as UTF8.  Return the number of bytes needed
// to hold the character
func writeUtf8(tls *libc.TLS, z uintptr, c uint32) int32 { /* nextchar.c:104:12: */
	if c < uint32(0x00080) {
		*(*uint8)(unsafe.Pointer(z)) = (uint8(c & uint32(0xff)))
		return 1
	}
	if c < uint32(0x00800) {
		*(*uint8)(unsafe.Pointer(z)) = (uint8(0xC0 + int32((uint8((c >> 6) & uint32(0x1F))))))
		*(*uint8)(unsafe.Pointer(z + 1)) = (uint8(0x80 + int32((uint8(c & uint32(0x3F))))))
		return 2
	}
	if c < uint32(0x10000) {
		*(*uint8)(unsafe.Pointer(z)) = (uint8(0xE0 + int32((uint8((c >> 12) & uint32(0x0F))))))
		*(*uint8)(unsafe.Pointer(z + 1)) = (uint8(0x80 + int32((uint8((c >> 6) & uint32(0x3F))))))
		*(*uint8)(unsafe.Pointer(z + 2)) = (uint8(0x80 + int32((uint8(c & uint32(0x3F))))))
		return 3
	}
	*(*uint8)(unsafe.Pointer(z)) = (uint8(0xF0 + int32((uint8((c >> 18) & uint32(0x07))))))
	*(*uint8)(unsafe.Pointer(z + 1)) = (uint8(0x80 + int32((uint8((c >> 12) & uint32(0x3F))))))
	*(*uint8)(unsafe.Pointer(z + 2)) = (uint8(0x80 + int32((uint8((c >> 6) & uint32(0x3F))))))
	*(*uint8)(unsafe.Pointer(z + 3)) = (uint8(0x80 + int32((uint8(c & uint32(0x3F))))))
	return 4
}

// Read a UTF8 character out of z[] and write it into *pOut.  Return
// the number of bytes in z[] that were used to construct the character.
func readUtf8(tls *libc.TLS, z uintptr, pOut uintptr) int32 { /* nextchar.c:131:12: */
	var c uint32 = uint32(*(*uint8)(unsafe.Pointer(z)))
	if c < uint32(0xc0) {
		*(*uint32)(unsafe.Pointer(pOut)) = c
		return 1
	} else {
		var n int32 = 1
		c = uint32(validBits[(c - uint32(0xc0))])
		for (int32(*(*uint8)(unsafe.Pointer(z + uintptr(n)))) & 0xc0) == 0x80 {
			c = ((c << 6) + (uint32(0x3f & int32(*(*uint8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&n, 1))))))))
		}
		if ((c < uint32(0x80)) || ((c & 0xFFFFF800) == uint32(0xD800))) || ((c & 0xFFFFFFFE) == uint32(0xFFFE)) {
			c = uint32(0xFFFD)
		}
		*(*uint32)(unsafe.Pointer(pOut)) = c
		return n
	}
	return int32(0)
}

var validBits = [64]uint8{
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x10), uint8(0x11), uint8(0x12), uint8(0x13), uint8(0x14), uint8(0x15), uint8(0x16), uint8(0x17),
	uint8(0x18), uint8(0x19), uint8(0x1a), uint8(0x1b), uint8(0x1c), uint8(0x1d), uint8(0x1e), uint8(0x1f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x00), uint8(0x01), uint8(0x00), uint8(0x00),
} /* nextchar.c:132:30 */

// The nextCharContext structure has been set up.  Add all "next" characters
// to the result set.
func findNextChars(tls *libc.TLS, p uintptr) { /* nextchar.c:164:13: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var cPrev uint32 = uint32(0)
	// var zPrev [8]uint8 at bp, 8

	var n int32
	var rc int32

	for {
		sqlite3.Xsqlite3_bind_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 1, (*nextCharContext)(unsafe.Pointer(p)).FzPrefix, (*nextCharContext)(unsafe.Pointer(p)).FnPrefix,
			uintptr(0))
		n = writeUtf8(tls, bp /* &zPrev[0] */, (cPrev + uint32(1)))
		sqlite3.Xsqlite3_bind_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 2, bp /* zPrev */, n, uintptr(0))
		rc = sqlite3.Xsqlite3_step(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
		if rc == SQLITE_DONE {
			sqlite3.Xsqlite3_reset(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
			return
		} else if rc != SQLITE_ROW {
			(*nextCharContext)(unsafe.Pointer(p)).FotherError = rc
			return
		} else {
			var zOut uintptr = sqlite3.Xsqlite3_column_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 0)
			// var cNext uint32 at bp+8, 4

			n = readUtf8(tls, (zOut + uintptr((*nextCharContext)(unsafe.Pointer(p)).FnPrefix)), bp+8 /* &cNext */)
			sqlite3.Xsqlite3_reset(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
			nextCharAppend(tls, p, *(*uint32)(unsafe.Pointer(bp + 8 /* cNext */)))
			cPrev = *(*uint32)(unsafe.Pointer(bp + 8 /* cNext */))
			if (*nextCharContext)(unsafe.Pointer(p)).FmallocFailed != 0 {
				return
			}
		}
	}
}

// next_character(A,T,F,W)
//
// Return a string composted of all next possible characters after
// A for elements of T.F.  If W is supplied, then it is an SQL expression
// that limits the elements in T.F that are considered.
func nextCharFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* nextchar.c:201:13: */
	bp := tls.Alloc(116)
	defer tls.Free(116)

	// var c nextCharContext at bp+80, 36

	var zTable uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	var zField uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	var zWhere uintptr
	var zCollName uintptr
	var zWhereClause uintptr = uintptr(0)
	var zColl uintptr = uintptr(0)
	var zSql uintptr
	var rc int32

	libc.Xmemset(tls, bp+80 /* &c */, 0, uint32(unsafe.Sizeof(nextCharContext{})))
	(*nextCharContext)(unsafe.Pointer(bp + 80 /* &c */)).Fdb = sqlite3.Xsqlite3_context_db_handle(tls, context)
	(*nextCharContext)(unsafe.Pointer(bp + 80 /* &c */)).FzPrefix = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	(*nextCharContext)(unsafe.Pointer(bp + 80 /* &c */)).FnPrefix = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if ((zTable == uintptr(0)) || (zField == uintptr(0))) || ((*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FzPrefix == uintptr(0)) {
		return
	}
	if ((argc >= 4) &&
		((libc.AssignUintptr(&zWhere, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4))))) != uintptr(0))) &&
		(int32(*(*uint8)(unsafe.Pointer(zWhere))) != 0) {
		zWhereClause = sqlite3.Xsqlite3_mprintf(tls, ts+5567 /* "AND (%s)" */, libc.VaList(bp, zWhere))
		if zWhereClause == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
	} else {
		zWhereClause = ts + 489 /* "" */
	}
	if ((argc >= 5) &&
		((libc.AssignUintptr(&zCollName, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4))))) != uintptr(0))) &&
		(int32(*(*uint8)(unsafe.Pointer(zCollName))) != 0) {
		zColl = sqlite3.Xsqlite3_mprintf(tls, ts+5576 /* "collate \"%w\"" */, libc.VaList(bp+8, zCollName))
		if zColl == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			if *(*int8)(unsafe.Pointer(zWhereClause)) != 0 {
				sqlite3.Xsqlite3_free(tls, zWhereClause)
			}
			return
		}
	} else {
		zColl = ts + 489 /* "" */
	}
	zSql = sqlite3.Xsqlite3_mprintf(tls,

		// 1114111 == 0x10ffff

		ts+5589, /* "SELECT %s FROM %..." */
		libc.VaList(bp+16, zField, zTable, zField, zColl, zField, zColl, zWhereClause, zColl))
	if *(*int8)(unsafe.Pointer(zWhereClause)) != 0 {
		sqlite3.Xsqlite3_free(tls, zWhereClause)
	}
	if *(*int8)(unsafe.Pointer(zColl)) != 0 {
		sqlite3.Xsqlite3_free(tls, zColl)
	}
	if zSql == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
		return
	}

	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).Fdb, zSql, -1, (bp + 80 /* &c */ + 4 /* &.pStmt */), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		sqlite3.Xsqlite3_result_error(tls, context, sqlite3.Xsqlite3_errmsg(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).Fdb), -1)
		return
	}
	findNextChars(tls, bp+80 /* &c */)
	if (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FmallocFailed != 0 {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		var pRes uintptr
		pRes = sqlite3.Xsqlite3_malloc64(tls, (uint64(((*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FnUsed * 4) + 1)))
		if pRes == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else {
			var i int32
			var n int32 = 0
			for i = 0; i < (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FnUsed; i++ {
				n = n + (writeUtf8(tls, (pRes + uintptr(n)), *(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FaResult + uintptr(i)*4))))
			}
			*(*uint8)(unsafe.Pointer(pRes + uintptr(n))) = uint8(0)
			sqlite3.Xsqlite3_result_text(tls, context, pRes, n, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		}
	}
	sqlite3.Xsqlite3_finalize(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FpStmt)
	sqlite3.Xsqlite3_free(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FaResult)
}

func sqlite3_nextchar_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* nextchar.c:292:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5697 /* "next_char" */, 3,
		(SQLITE_UTF8 | SQLITE_INNOCUOUS), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{nextCharFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5697 /* "next_char" */, 4,
			(SQLITE_UTF8 | SQLITE_INNOCUOUS), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nextCharFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5697 /* "next_char" */, 5,
			(SQLITE_UTF8 | SQLITE_INNOCUOUS), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nextCharFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// Implementation note:
//
// Much of the tokenizer logic is copied out of the tokenize.c source file
// of SQLite.  That logic could be simplified for this particular application,
// but that would impose a risk of introducing subtle errors.  It is best to
// keep the code as close to the original as possible.
//
// The tokenize code is in sync with the SQLite core as of 2018-01-08.
// Any future changes to the core tokenizer might require corresponding
// adjustments to the tokenizer logic in this module.

// Character classes for tokenizing
//
// In the sqlite3GetToken() function, a switch() on aiClass[c] is implemented
// using a lookup table, whereas a switch() directly on c uses a binary search.
// The lookup table is much faster.  To maximize speed, and to ensure that
// a lookup table is used, all of the classes need to be small integers and
// all of them need to be used within the switch.

var aiClass = [256]uint8{
	//         x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf
	/* 0x */ uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(7), uint8(7), uint8(27), uint8(7), uint8(7), uint8(27), uint8(27),
	/* 1x */ uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27),
	/* 2x */ uint8(7), uint8(15), uint8(8), uint8(5), uint8(4), uint8(22), uint8(24), uint8(8), uint8(17), uint8(18), uint8(21), uint8(20), uint8(23), uint8(11), uint8(26), uint8(16),
	/* 3x */ uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(5), uint8(19), uint8(12), uint8(14), uint8(13), uint8(6),
	/* 4x */ uint8(5), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	/* 5x */ uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(1), uint8(1), uint8(9), uint8(27), uint8(27), uint8(27), uint8(1),
	/* 6x */ uint8(8), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	/* 7x */ uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(1), uint8(1), uint8(27), uint8(10), uint8(27), uint8(25), uint8(27),
	/* 8x */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* 9x */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Ax */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Bx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Cx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Dx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Ex */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Fx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
} /* normalize.c:106:28 */

// An array to map all upper-case characters into their corresponding
// lower-case character.
//
// SQLite only considers US-ASCII (or EBCDIC) characters.  We do not
// handle case conversions for the UTF character set since the tables
// involved are nearly as big or bigger than SQLite itself.
var sqlite3UpperToLower = [256]uint8{
	uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17),
	uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24), uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35),
	uint8(36), uint8(37), uint8(38), uint8(39), uint8(40), uint8(41), uint8(42), uint8(43), uint8(44), uint8(45), uint8(46), uint8(47), uint8(48), uint8(49), uint8(50), uint8(51), uint8(52), uint8(53),
	uint8(54), uint8(55), uint8(56), uint8(57), uint8(58), uint8(59), uint8(60), uint8(61), uint8(62), uint8(63), uint8(64), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103),
	uint8(104), uint8(105), uint8(106), uint8(107), uint8(108), uint8(109), uint8(110), uint8(111), uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119), uint8(120), uint8(121),
	uint8(122), uint8(91), uint8(92), uint8(93), uint8(94), uint8(95), uint8(96), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103), uint8(104), uint8(105), uint8(106), uint8(107),
	uint8(108), uint8(109), uint8(110), uint8(111), uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119), uint8(120), uint8(121), uint8(122), uint8(123), uint8(124), uint8(125),
	uint8(126), uint8(127), uint8(128), uint8(129), uint8(130), uint8(131), uint8(132), uint8(133), uint8(134), uint8(135), uint8(136), uint8(137), uint8(138), uint8(139), uint8(140), uint8(141), uint8(142), uint8(143),
	uint8(144), uint8(145), uint8(146), uint8(147), uint8(148), uint8(149), uint8(150), uint8(151), uint8(152), uint8(153), uint8(154), uint8(155), uint8(156), uint8(157), uint8(158), uint8(159), uint8(160), uint8(161),
	uint8(162), uint8(163), uint8(164), uint8(165), uint8(166), uint8(167), uint8(168), uint8(169), uint8(170), uint8(171), uint8(172), uint8(173), uint8(174), uint8(175), uint8(176), uint8(177), uint8(178), uint8(179),
	uint8(180), uint8(181), uint8(182), uint8(183), uint8(184), uint8(185), uint8(186), uint8(187), uint8(188), uint8(189), uint8(190), uint8(191), uint8(192), uint8(193), uint8(194), uint8(195), uint8(196), uint8(197),
	uint8(198), uint8(199), uint8(200), uint8(201), uint8(202), uint8(203), uint8(204), uint8(205), uint8(206), uint8(207), uint8(208), uint8(209), uint8(210), uint8(211), uint8(212), uint8(213), uint8(214), uint8(215),
	uint8(216), uint8(217), uint8(218), uint8(219), uint8(220), uint8(221), uint8(222), uint8(223), uint8(224), uint8(225), uint8(226), uint8(227), uint8(228), uint8(229), uint8(230), uint8(231), uint8(232), uint8(233),
	uint8(234), uint8(235), uint8(236), uint8(237), uint8(238), uint8(239), uint8(240), uint8(241), uint8(242), uint8(243), uint8(244), uint8(245), uint8(246), uint8(247), uint8(248), uint8(249), uint8(250), uint8(251),
	uint8(252), uint8(253), uint8(254), uint8(255),
} /* normalize.c:133:28 */

// The following 256 byte lookup table is used to support SQLites built-in
// equivalents to the following standard library functions:
//
//   isspace()                        0x01
//   isalpha()                        0x02
//   isdigit()                        0x04
//   isalnum()                        0x06
//   isxdigit()                       0x08
//   toupper()                        0x20
//   SQLite identifier character      0x40
//   Quote character                  0x80
//
// Bit 0x20 is set if the mapped character requires translation to upper
// case. i.e. if the character is a lower-case ASCII character.
// If x is a lower-case ASCII character, then its upper-case equivalent
// is (x - 0x20). Therefore toupper() can be implemented as:
//
//   (x & ~(map[x]&0x20))
//
// The equivalent of tolower() is implemented using the sqlite3UpperToLower[]
// array. tolower() is used more often than toupper() by SQLite.
//
// Bit 0x40 is set if the character is non-alphanumeric and can be used in an
// SQLite identifier.  Identifiers are alphanumerics, "_", "$", and any
// non-ASCII UTF character. Hence the test for whether or not a character is
// part of an identifier is 0x46.
var sqlite3CtypeMap = [256]uint8{
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 00..07    ........
	uint8(0x00), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x00), uint8(0x00), // 08..0f    ........
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 10..17    ........
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 18..1f    ........
	uint8(0x01), uint8(0x00), uint8(0x80), uint8(0x00), uint8(0x40), uint8(0x00), uint8(0x00), uint8(0x80), // 20..27     !"#$%&'
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 28..2f    ()*+,-./
	uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), // 30..37    01234567
	uint8(0x0c), uint8(0x0c), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 38..3f    89:;<=>?

	uint8(0x00), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x02), // 40..47    @ABCDEFG
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), // 48..4f    HIJKLMNO
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), // 50..57    PQRSTUVW
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x80), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x40), // 58..5f    XYZ[\]^_
	uint8(0x80), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x22), // 60..67    `abcdefg
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), // 68..6f    hijklmno
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), // 70..77    pqrstuvw
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 78..7f    xyz{|}~.

	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 80..87    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 88..8f    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 90..97    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 98..9f    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // a0..a7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // a8..af    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // b0..b7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // b8..bf    ........

	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // c0..c7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // c8..cf    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // d0..d7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // d8..df    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // e0..e7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // e8..ef    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // f0..f7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // f8..ff    ........
} /* normalize.c:179:28 */

// If X is a character that can be used in an identifier then
// IdChar(X) will be true.  Otherwise it is false.
//
// For ASCII, any character with the high-order bit set is
// allowed in an identifier.  For 7-bit characters,
// sqlite3IsIdChar[X] must be 1.
//
// For EBCDIC, the rules are more complex but have the same
// end result.
//
// Ticket #1066.  the SQL standard does not allow '$' in the
// middle of identifiers.  But many SQL implementations do.
// SQLite will allow '$' in identifiers for compatibility.
// But the feature is undocumented.

// Ignore testcase() macros

// Token values

// Disable nuisence warnings about case fall-through

// Return the length (in bytes) of the token that begins at z[0].
// Store the token type in *tokenType before returning.
func sqlite3GetToken(tls *libc.TLS, z uintptr, tokenType uintptr) int32 { /* normalize.c:300:12: */
	var i int32
	var c int32
	switch int32(aiClass[*(*uint8)(unsafe.Pointer(z))]) { // Switch on the character-class of the first byte
	// of the token. See the comment on the CC_ defines
	// above.
	case CC_SPACE:
		{
			for i = 1; (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x01) != 0; i++ {
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_SPACE
			return i

		}
	case CC_MINUS:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) == '-' {
				for i = 2; ((libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0) && (c != '\n'); i++ {
				}
				*(*int32)(unsafe.Pointer(tokenType)) = TK_SPACE
				return i
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_LP:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_RP:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_SEMI:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_PLUS:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_STAR:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_SLASH:
		{
			if (int32(*(*uint8)(unsafe.Pointer(z + 1))) != '*') || (int32(*(*uint8)(unsafe.Pointer(z + 2))) == 0) {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}
			i = 3
			c = int32(*(*uint8)(unsafe.Pointer(z + 2)))
			for ; ((c != '*') || (int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '/')) && ((libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0); i++ {
			}
			if c != 0 {
				i++
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_SPACE
			return i

		}
	case CC_PERCENT:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_EQ:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return (1 + (libc.Bool32(int32(*(*uint8)(unsafe.Pointer(z + 1))) == '=')))

		}
	case CC_LT:
		{
			if (libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + 1))))) == '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else if c == '>' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else if c == '<' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}

		}
		fallthrough
	case CC_GT:
		{
			if (libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + 1))))) == '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else if c == '>' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}

		}
		fallthrough
	case CC_BANG:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) != '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
				return 1
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			}

		}
		fallthrough
	case CC_PIPE:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) != '|' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			}

		}
		fallthrough
	case CC_COMMA:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_AND:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_TILDA:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_QUOTE:
		{
			var delim int32 = int32(*(*uint8)(unsafe.Pointer(z)))

			for i = 1; (libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0; i++ {
				if c == delim {
					if int32(*(*uint8)(unsafe.Pointer(z + uintptr((i + 1))))) == delim {
						i++
					} else {
						break
					}
				}
			}
			if c == '\'' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
				return (i + 1)
			} else if c != 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_NAME
				return (i + 1)
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
				return i
			}

		}
		fallthrough
	case CC_DOT:
		{
			if !((int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + 1))]) & 0x04) != 0) {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}
			// If the next character is a digit, this is a floating point
			// number that begins with ".".  Fall thru into the next case
			/* no break */

		}
		fallthrough
	case CC_DIGIT:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			if ((int32(*(*uint8)(unsafe.Pointer(z))) == '0') && ((int32(*(*uint8)(unsafe.Pointer(z + 1))) == 'x') || (int32(*(*uint8)(unsafe.Pointer(z + 1))) == 'X'))) && ((int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + 2))]) & 0x08) != 0) {
				for i = 3; (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x08) != 0; i++ {
				}
				return i
			}
			for i = 0; (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x04) != 0; i++ {
			}
			if int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == '.' {
				i++
				for (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x04) != 0 {
					i++
				}
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			}
			if ((int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == 'e') || (int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == 'E')) && (((int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr((i + 1))))]) & 0x04) != 0) ||
				(((int32(*(*uint8)(unsafe.Pointer(z + uintptr((i + 1))))) == '+') || (int32(*(*uint8)(unsafe.Pointer(z + uintptr((i + 1))))) == '-')) && ((int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr((i + 2))))]) & 0x04) != 0))) {
				i = i + (2)
				for (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x04) != 0 {
					i++
				}
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			}
			for (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x46) != 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
				i++
			}
			return i

		}
	case CC_QUOTE2:
		{
			i = 1
			c = int32(*(*uint8)(unsafe.Pointer(z)))
			for ; (c != ']') && ((libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0); i++ {
			}
			*(*int32)(unsafe.Pointer(tokenType)) = func() int32 {
				if c == ']' {
					return TK_NAME
				}
				return TK_ERROR
			}()
			return i

		}
	case CC_VARNUM:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			for i = 1; (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x04) != 0; i++ {
			}
			return i

		}
	case CC_DOLLAR:
		fallthrough
	case CC_VARALPHA:
		{
			var n int32 = 0

			*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			for i = 1; (libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0; i++ {
				if (int32(sqlite3CtypeMap[uint8(c)]) & 0x46) != 0 {
					n++
				} else if (c == '(') && (n > 0) {
					for ok := true; ok; ok = ((((libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0) && !((int32(sqlite3CtypeMap[uint8(c)]) & 0x01) != 0)) && (c != ')')) {
						i++
					}
					if c == ')' {
						i++
					} else {
						*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
					}
					break
				} else if (c == ':') && (int32(*(*uint8)(unsafe.Pointer(z + uintptr((i + 1))))) == ':') {
					i++
				} else {
					break
				}
			}
			if n == 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
			}
			return i

		}
	case CC_KYWD:
		{
			for i = 1; int32(aiClass[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) <= CC_KYWD; i++ {
			}
			if (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x46) != 0 {
				// This token started out using characters that can appear in keywords,
				// but z[i] is a character not allowed within keywords, so this must
				// be an identifier instead
				i++
				break
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_NAME
			return i

		}
	case CC_X:
		{

			if int32(*(*uint8)(unsafe.Pointer(z + 1))) == '\'' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
				for i = 2; (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x08) != 0; i++ {
				}
				if (int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '\'') || ((i % 2) != 0) {
					*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
					for (*(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0) && (int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '\'') {
						i++
					}
				}
				if *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0 {
					i++
				}
				return i
			}
			// If it is not a BLOB literal, then it must be an ID, since no
			// SQL keywords start with the letter 'x'.  Fall through
			/* no break */

		}
		fallthrough
	case CC_ID:
		{
			i = 1
			break

		}
	default:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
			return 1

		}
	}
	for (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x46) != 0 {
		i++
	}
	*(*int32)(unsafe.Pointer(tokenType)) = TK_NAME
	return i
}

func sqlite3_normalize(tls *libc.TLS, zSql uintptr) uintptr { /* normalize.c:555:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var z uintptr          // The output string
	var nZ sqlite3_int64   // Size of the output string in bytes
	var nSql sqlite3_int64 // Size of the input string in bytes
	var i int32            // Next character to read from zSql[]
	var j int32            // Next slot to fill in on z[]
	// var tokenType int32 at bp, 4
	// Type of the next token
	var n int32 // Size of the next token
	var k int32 // Loop counter

	nSql = sqlite3_int64(libc.Xstrlen(tls, zSql))
	nZ = nSql
	z = sqlite3.Xsqlite3_malloc64(tls, (uint64(nZ + int64(2))))
	if z == uintptr(0) {
		return uintptr(0)
	}
	for i = libc.AssignInt32(&j, 0); *(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0; i = i + (n) {
		n = sqlite3GetToken(tls, (zSql + uintptr(i)), bp /* &tokenType */)
		switch *(*int32)(unsafe.Pointer(bp /* tokenType */)) {
		case TK_SPACE:
			{
				break

			}
		case TK_ERROR:
			{
				sqlite3.Xsqlite3_free(tls, z)
				return uintptr(0)

			}
		case TK_LITERAL:
			{
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8('?')
				break

			}
		case TK_PUNCT:
			fallthrough
		case TK_NAME:
			{
				if (n == 4) && (sqlite3.Xsqlite3_strnicmp(tls, (zSql+uintptr(i)), ts+5707 /* "NULL" */, 4) == 0) {
					if (((j >= 3) && (libc.Xstrncmp(tls, ((z+uintptr(j))-uintptr(2)), ts+5712 /* "is" */, uint32(2)) == 0)) && !((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr((j - 3)))))]) & 0x46) != 0)) ||
						(((j >= 4) && (libc.Xstrncmp(tls, ((z+uintptr(j))-uintptr(3)), ts+5715 /* "not" */, uint32(3)) == 0)) && !((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr((j - 4)))))]) & 0x46) != 0)) {
						// NULL is a keyword in this case, not a literal value
					} else {
						// Here the NULL is a literal value
						*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8('?')
						break
					}
				}
				if ((j > 0) && ((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr((j - 1)))))]) & 0x46) != 0)) && ((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zSql + uintptr(i))))]) & 0x46) != 0) {
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(' ')
				}
				for k = 0; k < n; k++ {
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(sqlite3UpperToLower[uint8(*(*int8)(unsafe.Pointer(zSql + uintptr((i + k)))))])
				}
				break

			}
		}
	}
	for (j > 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr((j - 1))))) == ' ') {
		j--
	}
	if (j > 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr((j - 1))))) != ';') {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(';')
	}
	*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)

	// Make a second pass converting "in(...)" where the "..." is not a
	// SELECT statement into "in(?,?,?)"
	for i = 0; i < j; i = n {
		var zIn uintptr = libc.Xstrstr(tls, (z + uintptr(i)), ts+5719 /* "in(" */)
		var nParen int32
		if zIn == uintptr(0) {
			break
		}
		n = (((int32(zIn) - int32(z)) / 1) + 3) // Index of first char past "in("
		if (n != 0) && ((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + libc.UintptrFromInt32(-1))))]) & 0x46) != 0) {
			continue
		}
		if (libc.Xstrncmp(tls, zIn, ts+5723 /* "in(select" */, uint32(9)) == 0) && !((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + 9)))]) & 0x46) != 0) {
			continue
		}
		if (libc.Xstrncmp(tls, zIn, ts+5733 /* "in(with" */, uint32(7)) == 0) && !((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + 7)))]) & 0x46) != 0) {
			continue
		}
		nParen = 1
		k = 0
		for ; *(*int8)(unsafe.Pointer(z + uintptr((n + k)))) != 0; k++ {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr((n + k))))) == '(' {
				nParen++
			}
			if int32(*(*int8)(unsafe.Pointer(z + uintptr((n + k))))) == ')' {
				nParen--
				if nParen == 0 {
					break
				}
			}
		}
		// k is the number of bytes in the "..." within "in(...)"
		if k < 5 {
			z = sqlite3.Xsqlite3_realloc64(tls, z, (uint64((j + (5 - k)) + 1)))
			if z == uintptr(0) {
				return uintptr(0)
			}
			libc.Xmemmove(tls, ((z + uintptr(n)) + uintptr(5)), ((z + uintptr(n)) + uintptr(k)), (uint32(j - (n + k))))
		} else if k > 5 {
			libc.Xmemmove(tls, ((z + uintptr(n)) + uintptr(5)), ((z + uintptr(n)) + uintptr(k)), (uint32(j - (n + k))))
		}
		j = ((j - k) + 5)
		*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)
		libc.Xmemcpy(tls, (z + uintptr(n)), ts+5741 /* "?,?,?" */, uint32(5))
	}
	return z
}

// For testing purposes, or to build a stand-alone SQL normalizer program,
// compile this one source file with the -DSQLITE_NORMALIZE_CLI and link
// it against any SQLite library.  The resulting command-line program will
// run sqlite3_normalize() over the text of all files named on the command-
// line and show the result on standard output.

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// The following object is the session context for a single percentile()
// function.  We have to remember all input Y values until the very end.
// Those values are accumulated in the Percentile.a[] array.
type Percentile1 = struct {
	FnAlloc uint32
	FnUsed  uint32
	FrPct   float64
	Fa      uintptr
	_       [4]byte
} /* percentile.c:71:9 */

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// The following object is the session context for a single percentile()
// function.  We have to remember all input Y values until the very end.
// Those values are accumulated in the Percentile.a[] array.
type Percentile = Percentile1 /* percentile.c:71:27 */

// Return TRUE if the input floating-point number is an infinity.
func isInfinity(tls *libc.TLS, r float64) int32 { /* percentile.c:82:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*float64)(unsafe.Pointer(bp + 8)) = r

	// var u sqlite3_uint64 at bp, 8

	libc.Xmemcpy(tls, bp /* &u */, bp+8 /* &r */, uint32(unsafe.Sizeof(sqlite3_uint64(0))))
	return (libc.Bool32(((*(*sqlite3_uint64)(unsafe.Pointer(bp /* u */)) >> 52) & uint64(0x7ff)) == uint64(0x7ff)))
}

// Return TRUE if two doubles differ by 0.001 or less
func sameValue(tls *libc.TLS, a float64, b float64) int32 { /* percentile.c:92:12: */
	a = a - (b)
	return (libc.Bool32((a >= -0.001) && (a <= 0.001)))
}

// The "step" function for percentile(Y,P) is called once for each
// input row.
func percentStep(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) { /* percentile.c:101:13: */
	var p uintptr
	var rPct float64
	var eType int32
	var y float64

	// Requirement 3:  P must be a number between 0 and 100
	eType = sqlite3.Xsqlite3_value_numeric_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rPct = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if (((eType != SQLITE_INTEGER) && (eType != SQLITE_FLOAT)) ||
		(rPct < 0.0)) || (rPct > 100.0) {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+5747 /* "2nd argument to ..." */, -1)
		return
	}

	// Allocate the session context.
	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, int32(unsafe.Sizeof(Percentile{})))
	if p == uintptr(0) {
		return
	}

	// Remember the P value.  Throw an error if the P value is different
	// from any prior row, per Requirement (2).
	if (*Percentile)(unsafe.Pointer(p)).FrPct == 0.0 {
		(*Percentile)(unsafe.Pointer(p)).FrPct = (rPct + 1.0)
	} else if !(sameValue(tls, (*Percentile)(unsafe.Pointer(p)).FrPct, (rPct+1.0)) != 0) {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+5814 /* "2nd argument to ..." */, -1)
		return
	}

	// Ignore rows for which Y is NULL
	eType = sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if eType == SQLITE_NULL {
		return
	}

	// If not NULL, then Y must be numeric.  Otherwise throw an error.
	// Requirement 4
	if (eType != SQLITE_INTEGER) && (eType != SQLITE_FLOAT) {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+5878 /* "1st argument to ..." */, -1)
		return
	}

	// Throw an error if the Y value is infinity or NaN
	y = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if isInfinity(tls, y) != 0 {
		sqlite3.Xsqlite3_result_error(tls, pCtx, ts+5922 /* "Inf input to per..." */, -1)
		return
	}

	// Allocate and store the Y
	if (*Percentile)(unsafe.Pointer(p)).FnUsed >= (*Percentile)(unsafe.Pointer(p)).FnAlloc {
		var n uint32 = (((*Percentile)(unsafe.Pointer(p)).FnAlloc * uint32(2)) + uint32(250))
		var a uintptr = sqlite3.Xsqlite3_realloc64(tls, (*Percentile)(unsafe.Pointer(p)).Fa, (uint64(uint32(unsafe.Sizeof(float64(0))) * n)))
		if a == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*Percentile)(unsafe.Pointer(p)).Fa)
			libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(Percentile{})))
			sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
			return
		}
		(*Percentile)(unsafe.Pointer(p)).FnAlloc = n
		(*Percentile)(unsafe.Pointer(p)).Fa = a
	}
	*(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(libc.PostIncUint32(&(*Percentile)(unsafe.Pointer(p)).FnUsed, 1))*8)) = y
}

// Compare to doubles for sorting using qsort()
func doubleCmp(tls *libc.TLS, pA uintptr, pB uintptr) int32 { /* percentile.c:170:25: */
	var a float64 = *(*float64)(unsafe.Pointer(pA))
	var b float64 = *(*float64)(unsafe.Pointer(pB))
	if a == b {
		return 0
	}
	if a < b {
		return -1
	}
	return +1
}

// Called to compute the final output of percentile() and to clean
// up all allocated memory.
func percentFinal(tls *libc.TLS, pCtx uintptr) { /* percentile.c:182:13: */
	var p uintptr
	var i1 uint32
	var i2 uint32
	var v1 float64
	var v2 float64
	var ix float64
	var vx float64
	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, 0)
	if p == uintptr(0) {
		return
	}
	if (*Percentile)(unsafe.Pointer(p)).Fa == uintptr(0) {
		return
	}
	if (*Percentile)(unsafe.Pointer(p)).FnUsed != 0 {
		libc.Xqsort(tls, (*Percentile)(unsafe.Pointer(p)).Fa, (*Percentile)(unsafe.Pointer(p)).FnUsed, uint32(unsafe.Sizeof(float64(0))), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		}{doubleCmp})))
		ix = ((((*Percentile)(unsafe.Pointer(p)).FrPct - 1.0) * (float64((*Percentile)(unsafe.Pointer(p)).FnUsed - uint32(1)))) * 0.01)
		i1 = uint32(ix)
		if (ix == float64(i1)) || (i1 == ((*Percentile)(unsafe.Pointer(p)).FnUsed - uint32(1))) {
			i2 = i1
		} else {
			i2 = (i1 + uint32(1))
		}
		v1 = *(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(i1)*8))
		v2 = *(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(i2)*8))
		vx = (v1 + ((v2 - v1) * (ix - float64(i1))))
		sqlite3.Xsqlite3_result_double(tls, pCtx, vx)
	}
	sqlite3.Xsqlite3_free(tls, (*Percentile)(unsafe.Pointer(p)).Fa)
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(Percentile{})))
}

func sqlite3_percentile_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* percentile.c:208:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5948 /* "percentile" */, 2,
		(SQLITE_UTF8 | SQLITE_INNOCUOUS), uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{percentStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{percentFinal})))
	return rc
}

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// prefixes_vtab is a subclass of sqlite3_vtab which is
// underlying representation of the virtual table
type prefixes_vtab1 = struct{ Fbase sqlite3_vtab } /* prefixes.c:33:9 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// prefixes_vtab is a subclass of sqlite3_vtab which is
// underlying representation of the virtual table
type prefixes_vtab = prefixes_vtab1 /* prefixes.c:33:30 */

// prefixes_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type prefixes_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	_       [4]byte
	FiRowid sqlite3_int64
	FzStr   uintptr
	FnStr   int32
} /* prefixes.c:43:9 */

// prefixes_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type prefixes_cursor = prefixes_cursor1 /* prefixes.c:43:32 */

// The prefixesConnect() method is invoked to create a new
// template virtual table.
//
// Think of this routine as the constructor for prefixes_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the prefixes_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against the virtual table will look like.
func prefixesConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* prefixes.c:64:12: */
	var pNew uintptr
	var rc int32

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+5959 /* "CREATE TABLE pre..." */)
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(prefixes_vtab{})))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(prefixes_vtab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	}
	return rc
}

// This method is the destructor for prefixes_vtab objects.
func prefixesDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* prefixes.c:90:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

// Constructor for a new prefixes_cursor object.
func prefixesOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* prefixes.c:99:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(prefixes_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(prefixes_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Destructor for a prefixes_cursor.
func prefixesClose(tls *libc.TLS, cur uintptr) int32 { /* prefixes.c:111:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_free(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Advance a prefixes_cursor to its next row of output.
func prefixesNext(tls *libc.TLS, cur uintptr) int32 { /* prefixes.c:122:12: */
	var pCur uintptr = cur
	(*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return SQLITE_OK
}

// Return values of columns for the row at which the prefixes_cursor
// is currently pointing.
func prefixesColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* prefixes.c:132:12: */
	var pCur uintptr = cur
	switch i {
	case 0:
		sqlite3.Xsqlite3_result_text(tls, ctx, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr, ((*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr - int32((*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid)),
			uintptr(0))
		break
	default:
		sqlite3.Xsqlite3_result_text(tls, ctx, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr, (*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr, uintptr(0))
		break
	}
	return SQLITE_OK
}

// Return the rowid for the current row.  In this implementation, the
// rowid is the same as the output value.
func prefixesRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* prefixes.c:154:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func prefixesEof(tls *libc.TLS, cur uintptr) int32 { /* prefixes.c:164:12: */
	var pCur uintptr = cur
	return (libc.Bool32((*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid > sqlite3_int64((*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr)))
}

// This method is called to "rewind" the prefixes_cursor object back
// to the first row of output.  This method is always called at least
// once prior to any call to prefixesColumn() or prefixesRowid() or
// prefixesEof().
func prefixesFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* prefixes.c:175:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	sqlite3.Xsqlite3_free(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr)
	if argc > 0 {
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))))
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr = func() int32 {
			if (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr != 0 {
				return int32(libc.Xstrlen(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr))
			}
			return 0
		}()
	} else {
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr = uintptr(0)
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr = 0
	}
	(*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(0)
	return SQLITE_OK
}

// SQLite will invoke this method one or more times while planning a query
// that uses the virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
func prefixesBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* prefixes.c:199:12: */
	// Search for a usable equality constraint against column 1
	// (original_string) and use it if at all possible
	var i int32
	var p uintptr

	i = 0
	p = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn != 1 {
			goto __2
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) != SQLITE_INDEX_CONSTRAINT_EQ {
			goto __2
		}
		if !(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable) != 0) {
			goto __2
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(10)
		return SQLITE_OK

	}
	goto __2
__2:
	i++
	p += 12
	goto __1
	goto __3
__3:
	;
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1000000000)
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1000000000)
	return SQLITE_OK
}

// This following structure defines all the methods for the
// virtual table.
var prefixesModule = sqlite3_module{
	/* xConnect    */ FxConnect: 0,
	/* xBestIndex  */ FxBestIndex: 0,
	/* xDisconnect */ FxDisconnect: 0,
	/* xOpen       */ FxOpen: 0,
	/* xClose      */ FxClose: 0,
	/* xFilter     */ FxFilter: 0,
	/* xNext       */ FxNext: 0,
	/* xEof        */ FxEof: 0,
	/* xColumn     */ FxColumn: 0,
	/* xRowid      */ FxRowid: 0,
} /* prefixes.c:227:23 */

// This is a copy of the SQLITE_SKIP_UTF8(zIn) macro in sqliteInt.h.
//
// Assuming zIn points to the first byte of a UTF-8 character,
// advance zIn to point to the first byte of the next UTF-8 character.

// Implementation of function prefix_length(). This function accepts two
// strings as arguments and returns the length in characters (not bytes),
// of the longest prefix shared by the two strings. For example:
//
//   prefix_length('abcdxxx', 'abcyy') == 3
//   prefix_length('abcdxxx', 'bcyyy') == 0
//   prefix_length('abcdxxx', 'ab')    == 2
//   prefix_length('ab',      'abcd')  == 2
//
// This function assumes the input is well-formed utf-8. If it is not,
// it is possible for this function to return -1.
func prefixLengthFunc(tls *libc.TLS, ctx uintptr, nVal int32, apVal uintptr) { /* prefixes.c:279:13: */
	var nByte int32    // Number of bytes to compare
	var nRet int32 = 0 // Return value
	var zL uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	var zR uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + 1*4)))
	var nL int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	var nR int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + 1*4)))
	var i int32

	nByte = func() int32 {
		if nL > nR {
			return nL
		}
		return nR
	}()
	for i = 0; i < nByte; i++ {
		if int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i)))) != int32(*(*uint8)(unsafe.Pointer(zR + uintptr(i)))) {
			break
		}
		if (int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i)))) & 0xC0) != 0x80 {
			nRet++
		}
	}

	if (int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i)))) & 0xC0) == 0x80 {
		nRet--
	}
	sqlite3.Xsqlite3_result_int(tls, ctx, nRet)
}

func sqlite3_prefixes_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* prefixes.c:305:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+6023 /* "prefixes" */, uintptr(unsafe.Pointer(&prefixesModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls,
			db, ts+6032 /* "prefix_length" */, 2, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{prefixLengthFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// The following #defines change the names of some functions implemented in
// this file to prevent name collisions with C-library functions of the
// same name.

// The end-of-input character

// The NFA is implemented as sequence of opcodes taken from the following
// set.  Each opcode has a single integer argument.

// Each opcode is a "state" in the NFA
type ReStateNumber = uint16 /* regexp.c:98:24 */

// Because this is an NFA and not a DFA, multiple states can be active at
// once.  An instance of the following object records all active states in
// the NFA.  The implementation is optimized for the common case where the
// number of actives states is small.
type ReStateSet1 = struct {
	FnState uint32
	FaState uintptr
} /* regexp.c:105:9 */

// Because this is an NFA and not a DFA, multiple states can be active at
// once.  An instance of the following object records all active states in
// the NFA.  The implementation is optimized for the common case where the
// number of actives states is small.
type ReStateSet = ReStateSet1 /* regexp.c:108:3 */

// An input string read one character at a time.
type ReInput1 = struct {
	Fz  uintptr
	Fi  int32
	Fmx int32
} /* regexp.c:112:9 */

// An input string read one character at a time.
type ReInput = ReInput1 /* regexp.c:112:24 */

// A compiled NFA (or an NFA that is in the process of being compiled) is
// an instance of the following object.
type ReCompiled1 = struct {
	FsIn       ReInput
	FzErr      uintptr
	FaOp       uintptr
	FaArg      uintptr
	FxNextChar uintptr
	FzInit     [12]uint8
	FnInit     int32
	FnState    uint32
	FnAlloc    uint32
} /* regexp.c:122:9 */

// A compiled NFA (or an NFA that is in the process of being compiled) is
// an instance of the following object.
type ReCompiled = ReCompiled1 /* regexp.c:122:27 */

// Add a state to the given state set if it is not already there
func re_add_state(tls *libc.TLS, pSet uintptr, newState int32) { /* regexp.c:136:13: */
	var i uint32
	for i = uint32(0); i < (*ReStateSet)(unsafe.Pointer(pSet)).FnState; i++ {
		if int32(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pSet)).FaState + uintptr(i)*2))) == newState {
			return
		}
	}
	*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pSet)).FaState + uintptr(libc.PostIncUint32(&(*ReStateSet)(unsafe.Pointer(pSet)).FnState, 1))*2)) = ReStateNumber(newState)
}

// Extract the next unicode character from *pzIn and return it.  Advance
// *pzIn to the first byte past the end of the character returned.  To
// be clear:  this routine converts utf8 to unicode.  This routine is
// optimized for the common case where the next character is a single byte.
func re_next_char(tls *libc.TLS, p uintptr) uint32 { /* regexp.c:147:17: */
	var c uint32
	if (*ReInput)(unsafe.Pointer(p)).Fi >= (*ReInput)(unsafe.Pointer(p)).Fmx {
		return uint32(0)
	}
	c = uint32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*ReInput)(unsafe.Pointer(p)).Fi, 1)))))
	if c >= uint32(0x80) {
		if (((c & uint32(0xe0)) == uint32(0xc0)) && ((*ReInput)(unsafe.Pointer(p)).Fi < (*ReInput)(unsafe.Pointer(p)).Fmx)) && ((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi)))) & 0xc0) == 0x80) {
			c = (((c & uint32(0x1f)) << 6) | (uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*ReInput)(unsafe.Pointer(p)).Fi, 1))))) & 0x3f)))
			if c < uint32(0x80) {
				c = uint32(0xfffd)
			}
		} else if ((((c & uint32(0xf0)) == uint32(0xe0)) && (((*ReInput)(unsafe.Pointer(p)).Fi + 1) < (*ReInput)(unsafe.Pointer(p)).Fmx)) && ((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi)))) & 0xc0) == 0x80)) &&
			((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 1))))) & 0xc0) == 0x80) {
			c = ((((c & uint32(0x0f)) << 12) | (uint32((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi)))) & 0x3f) << 6))) | (uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 1))))) & 0x3f)))
			*(*int32)(unsafe.Pointer(p + 4 /* &.i */)) += (2)
			if (c <= uint32(0x7ff)) || ((c >= uint32(0xd800)) && (c <= uint32(0xdfff))) {
				c = uint32(0xfffd)
			}
		} else if (((((c & uint32(0xf8)) == uint32(0xf0)) && (((*ReInput)(unsafe.Pointer(p)).Fi + 3) < (*ReInput)(unsafe.Pointer(p)).Fmx)) && ((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi)))) & 0xc0) == 0x80)) &&
			((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 1))))) & 0xc0) == 0x80)) && ((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 2))))) & 0xc0) == 0x80) {
			c = (((((c & uint32(0x07)) << 18) | (uint32((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi)))) & 0x3f) << 12))) | (uint32((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 1))))) & 0x3f) << 6))) |
				(uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 2))))) & 0x3f)))
			*(*int32)(unsafe.Pointer(p + 4 /* &.i */)) += (3)
			if (c <= uint32(0xffff)) || (c > uint32(0x10ffff)) {
				c = uint32(0xfffd)
			}
		} else {
			c = uint32(0xfffd)
		}
	}
	return c
}

func re_next_char_nocase(tls *libc.TLS, p uintptr) uint32 { /* regexp.c:172:17: */
	var c uint32 = re_next_char(tls, p)
	if (c >= uint32('A')) && (c <= uint32('Z')) {
		c = c + (uint32('a' - 'A'))
	}
	return c
}

// Return true if c is a perl "word" character:  [A-Za-z0-9_]
func re_word_char(tls *libc.TLS, c int32) int32 { /* regexp.c:179:12: */
	return (libc.Bool32(((((c >= '0') && (c <= '9')) || ((c >= 'a') && (c <= 'z'))) ||
		((c >= 'A') && (c <= 'Z'))) || (c == '_')))
}

// Return true if c is a "digit" character:  [0-9]
func re_digit_char(tls *libc.TLS, c int32) int32 { /* regexp.c:185:12: */
	return (libc.Bool32((c >= '0') && (c <= '9')))
}

// Return true if c is a perl "space" character:  [ \t\r\n\v\f]
func re_space_char(tls *libc.TLS, c int32) int32 { /* regexp.c:190:12: */
	return (libc.Bool32((((((c == ' ') || (c == '\t')) || (c == '\n')) || (c == '\r')) || (c == '\v')) || (c == '\f')))
}

// Run a compiled regular expression on the zero-terminated input
// string zIn[].  Return true on a match and false if there is no match.
func sqlite3re_match(tls *libc.TLS, pRe uintptr, zIn uintptr, nIn int32) int32 { /* regexp.c:197:12: */
	bp := tls.Alloc(228)
	defer tls.Free(228)

	// var aStateSet [2]ReStateSet at bp, 16

	var pThis uintptr
	var pNext uintptr
	// var aSpace [100]ReStateNumber at bp+16, 200

	var pToFree uintptr
	var i uint32
	var iSwap uint32
	var c int32
	var cPrev int32
	var rc int32
	// var in ReInput at bp+216, 12

	var x uint8
	var j int32
	var n int32
	var hit int32
	var x1 int32
	i = uint32(0)
	iSwap = uint32(0)
	c = (RE_EOF + 1)
	cPrev = 0
	rc = 0

	(*ReInput)(unsafe.Pointer(bp + 216 /* &in */)).Fz = zIn
	(*ReInput)(unsafe.Pointer(bp + 216 /* &in */)).Fi = 0
	(*ReInput)(unsafe.Pointer(bp + 216 /* &in */)).Fmx = func() int32 {
		if nIn >= 0 {
			return nIn
		}
		return int32(libc.Xstrlen(tls, zIn))
	}()

	// Look for the initial prefix match, if there is one.
	if !((*ReCompiled)(unsafe.Pointer(pRe)).FnInit != 0) {
		goto __1
	}
	x = *(*uint8)(unsafe.Pointer((pRe + 28 /* &.zInit */)))
__2:
	if !((((*ReInput)(unsafe.Pointer(bp+216 /* &in */)).Fi + (*ReCompiled)(unsafe.Pointer(pRe)).FnInit) <= (*ReInput)(unsafe.Pointer(bp+216 /* &in */)).Fmx) &&
		((int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((*ReInput)(unsafe.Pointer(bp+216 /* &in */)).Fi)))) != int32(x)) || (libc.Xstrncmp(tls, (zIn+uintptr((*ReInput)(unsafe.Pointer(bp+216 /* &in */)).Fi)), pRe+28 /* &.zInit */, uint32((*ReCompiled)(unsafe.Pointer(pRe)).FnInit)) != 0))) {
		goto __3
	}
	(*ReInput)(unsafe.Pointer(bp+216 /* &in */)).Fi++
	goto __2
__3:
	;
	if !(((*ReInput)(unsafe.Pointer(bp+216 /* &in */)).Fi + (*ReCompiled)(unsafe.Pointer(pRe)).FnInit) > (*ReInput)(unsafe.Pointer(bp+216 /* &in */)).Fmx) {
		goto __4
	}
	return 0
__4:
	;
__1:
	;

	if !((*ReCompiled)(unsafe.Pointer(pRe)).FnState <= (uint32(unsafe.Sizeof([100]ReStateNumber{})) / (uint32(unsafe.Sizeof(ReStateNumber(0))) * uint32(2)))) {
		goto __5
	}
	pToFree = uintptr(0)
	(*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */)).FaState = bp + 16 /* &aSpace[0] */
	goto __6
__5:
	pToFree = sqlite3.Xsqlite3_malloc64(tls, (uint64((uint32(unsafe.Sizeof(ReStateNumber(0))) * uint32(2)) * (*ReCompiled)(unsafe.Pointer(pRe)).FnState)))
	if !(pToFree == uintptr(0)) {
		goto __7
	}
	return -1
__7:
	;
	(*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */)).FaState = pToFree
__6:
	;
	(*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */ + 1*8)).FaState = ((*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */)).FaState + uintptr((*ReCompiled)(unsafe.Pointer(pRe)).FnState)*2)
	pNext = (bp /* &aStateSet */ + 1*8)
	(*ReStateSet)(unsafe.Pointer(pNext)).FnState = uint32(0)
	re_add_state(tls, pNext, 0)
__8:
	if !((c != RE_EOF) && ((*ReStateSet)(unsafe.Pointer(pNext)).FnState > uint32(0))) {
		goto __9
	}
	cPrev = c
	c = int32((*(*func(*libc.TLS, uintptr) uint32)(unsafe.Pointer((pRe + 24 /* &.xNextChar */))))(tls, bp+216 /* &in */))
	pThis = pNext
	pNext = (bp /* &aStateSet */ + uintptr(iSwap)*8)
	iSwap = (uint32(1) - iSwap)
	(*ReStateSet)(unsafe.Pointer(pNext)).FnState = uint32(0)
	i = uint32(0)
__10:
	if !(i < (*ReStateSet)(unsafe.Pointer(pThis)).FnState) {
		goto __12
	}
	x1 = int32(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pThis)).FaState + uintptr(i)*2)))
	switch int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x1)))) {
	case RE_OP_MATCH:
		goto __14
	case RE_OP_ANY:
		goto __15
	case RE_OP_WORD:
		goto __16
	case RE_OP_NOTWORD:
		goto __17
	case RE_OP_DIGIT:
		goto __18
	case RE_OP_NOTDIGIT:
		goto __19
	case RE_OP_SPACE:
		goto __20
	case RE_OP_NOTSPACE:
		goto __21
	case RE_OP_BOUNDARY:
		goto __22
	case RE_OP_ANYSTAR:
		goto __23
	case RE_OP_FORK:
		goto __24
	case RE_OP_GOTO:
		goto __25
	case RE_OP_ACCEPT:
		goto __26
	case RE_OP_CC_EXC:
		goto __27
	case RE_OP_CC_INC:
		goto __28
	}
	goto __13
__14:
	if !(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4)) == c) {
		goto __29
	}
	re_add_state(tls, pNext, (x1 + 1))
__29:
	;
	goto __13

__15:
	if !(c != 0) {
		goto __30
	}
	re_add_state(tls, pNext, (x1 + 1))
__30:
	;
	goto __13

__16:
	if !(re_word_char(tls, c) != 0) {
		goto __31
	}
	re_add_state(tls, pNext, (x1 + 1))
__31:
	;
	goto __13

__17:
	if !(!(re_word_char(tls, c) != 0) && (c != 0)) {
		goto __32
	}
	re_add_state(tls, pNext, (x1 + 1))
__32:
	;
	goto __13

__18:
	if !(re_digit_char(tls, c) != 0) {
		goto __33
	}
	re_add_state(tls, pNext, (x1 + 1))
__33:
	;
	goto __13

__19:
	if !(!(re_digit_char(tls, c) != 0) && (c != 0)) {
		goto __34
	}
	re_add_state(tls, pNext, (x1 + 1))
__34:
	;
	goto __13

__20:
	if !(re_space_char(tls, c) != 0) {
		goto __35
	}
	re_add_state(tls, pNext, (x1 + 1))
__35:
	;
	goto __13

__21:
	if !(!(re_space_char(tls, c) != 0) && (c != 0)) {
		goto __36
	}
	re_add_state(tls, pNext, (x1 + 1))
__36:
	;
	goto __13

__22:
	if !(re_word_char(tls, c) != re_word_char(tls, cPrev)) {
		goto __37
	}
	re_add_state(tls, pThis, (x1 + 1))
__37:
	;
	goto __13

__23:
	re_add_state(tls, pNext, x1)
	re_add_state(tls, pThis, (x1 + 1))
	goto __13

__24:
	re_add_state(tls, pThis, (x1 + *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4))))
	re_add_state(tls, pThis, (x1 + 1))
	goto __13

__25:
	re_add_state(tls, pThis, (x1 + *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4))))
	goto __13

__26:
	rc = 1
	goto re_match_end

__27:
	if !(c == 0) {
		goto __38
	}
	goto __13
__38:
	;
	// fall-through

__28:
	j = 1
	n = *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4))
	hit = 0
	j = 1
__39:
	if !((j > 0) && (j < n)) {
		goto __41
	}
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr((x1 + j))))) == RE_OP_CC_VALUE) {
		goto __42
	}
	if !(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr((x1+j))*4)) == c) {
		goto __44
	}
	hit = 1
	j = -1
__44:
	;
	goto __43
__42:
	if !((*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr((x1+j))*4)) <= c) && (*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(((x1+j)+1))*4)) >= c)) {
		goto __45
	}
	hit = 1
	j = -1
	goto __46
__45:
	j++
__46:
	;
__43:
	;
	goto __40
__40:
	j++
	goto __39
	goto __41
__41:
	;
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x1)))) == RE_OP_CC_EXC) {
		goto __47
	}
	hit = libc.BoolInt32(!(hit != 0))
__47:
	;
	if !(hit != 0) {
		goto __48
	}
	re_add_state(tls, pNext, (x1 + n))
__48:
	;
	goto __13

__13:
	;
	goto __11
__11:
	i++
	goto __10
	goto __12
__12:
	;
	goto __8
__9:
	;
	i = uint32(0)
__49:
	if !(i < (*ReStateSet)(unsafe.Pointer(pNext)).FnState) {
		goto __51
	}
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pNext)).FaState + uintptr(i)*2)))))) == RE_OP_ACCEPT) {
		goto __52
	}
	rc = 1
	goto __51
__52:
	;
	goto __50
__50:
	i++
	goto __49
	goto __51
__51:
	;
re_match_end:
	sqlite3.Xsqlite3_free(tls, pToFree)
	return rc
}

// Resize the opcode and argument arrays for an RE under construction.
func re_resize(tls *libc.TLS, p uintptr, N int32) int32 { /* regexp.c:340:12: */
	var aOp uintptr
	var aArg uintptr
	aOp = sqlite3.Xsqlite3_realloc64(tls, (*ReCompiled)(unsafe.Pointer(p)).FaOp, (uint64(uint32(N) * uint32(unsafe.Sizeof(int8(0))))))
	if aOp == uintptr(0) {
		return 1
	}
	(*ReCompiled)(unsafe.Pointer(p)).FaOp = aOp
	aArg = sqlite3.Xsqlite3_realloc64(tls, (*ReCompiled)(unsafe.Pointer(p)).FaArg, (uint64(uint32(N) * uint32(unsafe.Sizeof(int32(0))))))
	if aArg == uintptr(0) {
		return 1
	}
	(*ReCompiled)(unsafe.Pointer(p)).FaArg = aArg
	(*ReCompiled)(unsafe.Pointer(p)).FnAlloc = uint32(N)
	return 0
}

// Insert a new opcode and argument into an RE under construction.  The
// insertion point is just prior to existing opcode iBefore.
func re_insert(tls *libc.TLS, p uintptr, iBefore int32, op int32, arg int32) int32 { /* regexp.c:356:12: */
	var i int32
	if ((*ReCompiled)(unsafe.Pointer(p)).FnAlloc <= (*ReCompiled)(unsafe.Pointer(p)).FnState) && (re_resize(tls, p, (int32((*ReCompiled)(unsafe.Pointer(p)).FnAlloc*uint32(2)))) != 0) {
		return 0
	}
	for i = int32((*ReCompiled)(unsafe.Pointer(p)).FnState); i > iBefore; i-- {
		*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(i))) = *(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr((i - 1))))
		*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr((i-1))*4))
	}
	(*ReCompiled)(unsafe.Pointer(p)).FnState++
	*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(iBefore))) = int8(op)
	*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iBefore)*4)) = arg
	return iBefore
}

// Append a new opcode and argument to the end of the RE under construction.
func re_append(tls *libc.TLS, p uintptr, op int32, arg int32) int32 { /* regexp.c:371:12: */
	return re_insert(tls, p, int32((*ReCompiled)(unsafe.Pointer(p)).FnState), op, arg)
}

// Make a copy of N opcodes starting at iStart onto the end of the RE
// under construction.
func re_copy(tls *libc.TLS, p uintptr, iStart int32, N int32) { /* regexp.c:378:13: */
	if (((*ReCompiled)(unsafe.Pointer(p)).FnState + uint32(N)) >= (*ReCompiled)(unsafe.Pointer(p)).FnAlloc) && (re_resize(tls, p, (int32(((*ReCompiled)(unsafe.Pointer(p)).FnAlloc*uint32(2))+uint32(N)))) != 0) {
		return
	}
	libc.Xmemcpy(tls, ((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr((*ReCompiled)(unsafe.Pointer(p)).FnState)), ((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(iStart)), (uint32(N) * uint32(unsafe.Sizeof(int8(0)))))
	libc.Xmemcpy(tls, ((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr((*ReCompiled)(unsafe.Pointer(p)).FnState)*4), ((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iStart)*4), (uint32(N) * uint32(unsafe.Sizeof(int32(0)))))
	*(*uint32)(unsafe.Pointer(p + 44 /* &.nState */)) += (uint32(N))
}

// Return true if c is a hexadecimal digit character:  [0-9a-fA-F]
// If c is a hex digit, also set *pV = (*pV)*16 + valueof(c).  If
// c is not a hex digit *pV is unchanged.
func re_hex(tls *libc.TLS, c int32, pV uintptr) int32 { /* regexp.c:389:12: */
	if (c >= '0') && (c <= '9') {
		c = c - ('0')
	} else if (c >= 'a') && (c <= 'f') {
		c = c - ('a' - 10)
	} else if (c >= 'A') && (c <= 'F') {
		c = c - ('A' - 10)
	} else {
		return 0
	}
	*(*int32)(unsafe.Pointer(pV)) = (((*(*int32)(unsafe.Pointer(pV))) * 16) + (c & 0xff))
	return 1
}

// A backslash character has been seen, read the next character and
// return its interpretation.
func re_esc_char(tls *libc.TLS, p uintptr) uint32 { /* regexp.c:406:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	*(*int32)(unsafe.Pointer(bp /* v */)) = 0
	var c int8
	if (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi >= (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		return uint32(0)
	}
	c = int8(*(*uint8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi))))
	if (int32(c) == 'u') && (((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi + 4) < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx) {
		var zIn uintptr = ((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi))
		if (((re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 1))), bp /* &v */) != 0) &&
			(re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 2))), bp /* &v */) != 0)) &&
			(re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 3))), bp /* &v */) != 0)) &&
			(re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 4))), bp /* &v */) != 0) {
			*(*int32)(unsafe.Pointer(p /* &.sIn */ + 4 /* &.i */)) += (5)
			return uint32(*(*int32)(unsafe.Pointer(bp /* v */)))
		}
	}
	if (int32(c) == 'x') && (((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi + 2) < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx) {
		var zIn uintptr = ((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi))
		if (re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 1))), bp /* &v */) != 0) &&
			(re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 2))), bp /* &v */) != 0) {
			*(*int32)(unsafe.Pointer(p /* &.sIn */ + 4 /* &.i */)) += (3)
			return uint32(*(*int32)(unsafe.Pointer(bp /* v */)))
		}
	}
	for i = 0; (zEsc[i] != 0) && (int32(zEsc[i]) != int32(c)); i++ {
	}
	if zEsc[i] != 0 {
		if i < 6 {
			c = zTrans[i]
		}
		(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
	} else {
		(*ReCompiled)(unsafe.Pointer(p)).FzErr = ts + 6046 /* "unknown \\ escape" */
	}
	return uint32(c)
}

var zEsc = *(*[21]int8)(unsafe.Pointer(ts + 6063 /* "afnrtv\\()*.+?[$^..." */)) /* regexp.c:407:21 */
var zTrans = *(*[7]int8)(unsafe.Pointer(ts + 6084 /* "\a\f\n\r\t\v" */))        /* regexp.c:408:21 */

// Peek at the next byte of input
func rePeek(tls *libc.TLS, p uintptr) uint8 { /* regexp.c:447:22: */
	if (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		return *(*uint8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi)))
	}
	return uint8(0)
}

// Compile RE text into a sequence of opcodes.  Continue up to the
// first unmatched ")" character, then return.  If an error is found,
// return a pointer to the error message string.
func re_subcompile_re(tls *libc.TLS, p uintptr) uintptr { /* regexp.c:455:19: */
	var zErr uintptr
	var iStart int32
	var iEnd int32
	var iGoto int32
	iStart = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
	zErr = re_subcompile_string(tls, p)
	if zErr != 0 {
		return zErr
	}
	for int32(rePeek(tls, p)) == '|' {
		iEnd = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
		re_insert(tls, p, iStart, RE_OP_FORK, ((iEnd + 2) - iStart))
		iGoto = re_append(tls, p, RE_OP_GOTO, 0)
		(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
		zErr = re_subcompile_string(tls, p)
		if zErr != 0 {
			return zErr
		}
		*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iGoto)*4)) = (int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iGoto)))
	}
	return uintptr(0)
}

// Compile an element of regular expression text (anything that can be
// an operand to the "|" operator).  Return NULL on success or a pointer
// to the error message if there is a problem.
func re_subcompile_string(tls *libc.TLS, p uintptr) uintptr { /* regexp.c:477:19: */
	var iPrev int32 = -1
	var iStart int32
	var c uint32
	var zErr uintptr
	for (libc.AssignUint32(&c, (*(*func(*libc.TLS, uintptr) uint32)(unsafe.Pointer((p + 24 /* &.xNextChar */))))(tls, (p /* &.sIn */)))) != uint32(0) {
		iStart = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
		switch c {
		case uint32('|'):
			fallthrough
		case uint32('$'):
			fallthrough
		case uint32(')'):
			{
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi--
				return uintptr(0)

			}
		case uint32('('):
			{
				zErr = re_subcompile_re(tls, p)
				if zErr != 0 {
					return zErr
				}
				if int32(rePeek(tls, p)) != ')' {
					return ts + 6091 /* "unmatched '('" */
				}
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				break

			}
		case uint32('.'):
			{
				if int32(rePeek(tls, p)) == '*' {
					re_append(tls, p, RE_OP_ANYSTAR, 0)
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				} else {
					re_append(tls, p, RE_OP_ANY, 0)
				}
				break

			}
		case uint32('*'):
			{
				if iPrev < 0 {
					return ts + 6105 /* "'*' without oper..." */
				}
				re_insert(tls, p, iPrev, RE_OP_GOTO, (int32(((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iPrev)) + uint32(1))))
				re_append(tls, p, RE_OP_FORK, (int32((uint32(iPrev) - (*ReCompiled)(unsafe.Pointer(p)).FnState) + uint32(1))))
				break

			}
		case uint32('+'):
			{
				if iPrev < 0 {
					return ts + 6125 /* "'+' without oper..." */
				}
				re_append(tls, p, RE_OP_FORK, (int32(uint32(iPrev) - (*ReCompiled)(unsafe.Pointer(p)).FnState)))
				break

			}
		case uint32('?'):
			{
				if iPrev < 0 {
					return ts + 6145 /* "'?' without oper..." */
				}
				re_insert(tls, p, iPrev, RE_OP_FORK, (int32(((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iPrev)) + uint32(1))))
				break

			}
		case uint32('{'):
			{
				var m int32 = 0
				var n int32 = 0
				var sz int32
				var j int32
				if iPrev < 0 {
					return ts + 6165 /* "'{m,n}' without ..." */
				}
				for ((libc.AssignUint32(&c, uint32(rePeek(tls, p)))) >= uint32('0')) && (c <= uint32('9')) {
					m = (int32(((uint32(m * 10)) + c) - uint32('0')))
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				}
				n = m
				if c == uint32(',') {
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					n = 0
					for ((libc.AssignUint32(&c, uint32(rePeek(tls, p)))) >= uint32('0')) && (c <= uint32('9')) {
						n = (int32(((uint32(n * 10)) + c) - uint32('0')))
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					}
				}
				if c != uint32('}') {
					return ts + 6189 /* "unmatched '{'" */
				}
				if (n > 0) && (n < m) {
					return ts + 6203 /* "n less than m in..." */
				}
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				sz = (int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iPrev)))
				if m == 0 {
					if n == 0 {
						return ts + 6228 /* "both m and n are..." */
					}
					re_insert(tls, p, iPrev, RE_OP_FORK, (sz + 1))
					n--
				} else {
					for j = 1; j < m; j++ {
						re_copy(tls, p, iPrev, sz)
					}
				}
				for j = m; j < n; j++ {
					re_append(tls, p, RE_OP_FORK, (sz + 1))
					re_copy(tls, p, iPrev, sz)
				}
				if (n == 0) && (m > 0) {
					re_append(tls, p, RE_OP_FORK, -sz)
				}
				break

			}
		case uint32('['):
			{
				var iFirst int32 = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
				if int32(rePeek(tls, p)) == '^' {
					re_append(tls, p, RE_OP_CC_EXC, 0)
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				} else {
					re_append(tls, p, RE_OP_CC_INC, 0)
				}
				for (libc.AssignUint32(&c, (*(*func(*libc.TLS, uintptr) uint32)(unsafe.Pointer((p + 24 /* &.xNextChar */))))(tls, (p /* &.sIn */)))) != uint32(0) {
					if (c == uint32('[')) && (int32(rePeek(tls, p)) == ':') {
						return ts + 6261 /* "POSIX character ..." */
					}
					if c == uint32('\\') {
						c = re_esc_char(tls, p)
					}
					if int32(rePeek(tls, p)) == '-' {
						re_append(tls, p, RE_OP_CC_RANGE, int32(c))
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
						c = (*(*func(*libc.TLS, uintptr) uint32)(unsafe.Pointer((p + 24 /* &.xNextChar */))))(tls, (p /* &.sIn */))
						if c == uint32('\\') {
							c = re_esc_char(tls, p)
						}
						re_append(tls, p, RE_OP_CC_RANGE, int32(c))
					} else {
						re_append(tls, p, RE_OP_CC_VALUE, int32(c))
					}
					if int32(rePeek(tls, p)) == ']' {
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
						break
					}
				}
				if c == uint32(0) {
					return ts + 6299 /* "unclosed '['" */
				}
				*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iFirst)*4)) = (int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iFirst)))
				break

			}
		case uint32('\\'):
			{
				var specialOp int32 = 0
				switch int32(rePeek(tls, p)) {
				case 'b':
					specialOp = RE_OP_BOUNDARY
					break
				case 'd':
					specialOp = RE_OP_DIGIT
					break
				case 'D':
					specialOp = RE_OP_NOTDIGIT
					break
				case 's':
					specialOp = RE_OP_SPACE
					break
				case 'S':
					specialOp = RE_OP_NOTSPACE
					break
				case 'w':
					specialOp = RE_OP_WORD
					break
				case 'W':
					specialOp = RE_OP_NOTWORD
					break
				}
				if specialOp != 0 {
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					re_append(tls, p, specialOp, 0)
				} else {
					c = re_esc_char(tls, p)
					re_append(tls, p, RE_OP_MATCH, int32(c))
				}
				break

			}
		default:
			{
				re_append(tls, p, RE_OP_MATCH, int32(c))
				break

			}
		}
		iPrev = iStart
	}
	return uintptr(0)
}

// Free and reclaim all the memory used by a previously compiled
// regular expression.  Applications should invoke this routine once
// for every call to re_compile() to avoid memory leaks.
func sqlite3re_free(tls *libc.TLS, pRe uintptr) { /* regexp.c:616:13: */
	if pRe != 0 {
		sqlite3.Xsqlite3_free(tls, (*ReCompiled)(unsafe.Pointer(pRe)).FaOp)
		sqlite3.Xsqlite3_free(tls, (*ReCompiled)(unsafe.Pointer(pRe)).FaArg)
		sqlite3.Xsqlite3_free(tls, pRe)
	}
}

// Compile a textual regular expression in zIn[] into a compiled regular
// expression suitable for us by re_match() and return a pointer to the
// compiled regular expression in *ppRe.  Return NULL on success or an
// error message if something goes wrong.
func sqlite3re_compile(tls *libc.TLS, ppRe uintptr, zIn uintptr, noCase int32) uintptr { /* regexp.c:630:19: */
	var pRe uintptr
	var zErr uintptr
	var i int32
	var j int32

	*(*uintptr)(unsafe.Pointer(ppRe)) = uintptr(0)
	pRe = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(ReCompiled{})))
	if pRe == uintptr(0) {
		return ts + 1930 /* "out of memory" */
	}
	libc.Xmemset(tls, pRe, 0, uint32(unsafe.Sizeof(ReCompiled{})))
	(*ReCompiled)(unsafe.Pointer(pRe)).FxNextChar = func() uintptr {
		if noCase != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr) uint32
			}{re_next_char_nocase}))
		}
		return *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) uint32
		}{re_next_char}))
	}()
	if re_resize(tls, pRe, 30) != 0 {
		sqlite3re_free(tls, pRe)
		return ts + 1930 /* "out of memory" */
	}
	if int32(*(*int8)(unsafe.Pointer(zIn))) == '^' {
		zIn++
	} else {
		re_append(tls, pRe, RE_OP_ANYSTAR, 0)
	}
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fz = zIn
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi = 0
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx = int32(libc.Xstrlen(tls, zIn))
	zErr = re_subcompile_re(tls, pRe)
	if zErr != 0 {
		sqlite3re_free(tls, pRe)
		return zErr
	}
	if (int32(rePeek(tls, pRe)) == '$') && (((*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi + 1) >= (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx) {
		re_append(tls, pRe, RE_OP_MATCH, RE_EOF)
		re_append(tls, pRe, RE_OP_ACCEPT, 0)
		*(*uintptr)(unsafe.Pointer(ppRe)) = pRe
	} else if (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi >= (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx {
		re_append(tls, pRe, RE_OP_ACCEPT, 0)
		*(*uintptr)(unsafe.Pointer(ppRe)) = pRe
	} else {
		sqlite3re_free(tls, pRe)
		return ts + 6312 /* "unrecognized cha..." */
	}

	// The following is a performance optimization.  If the regex begins with
	// ".*" (if the input regex lacks an initial "^") and afterwards there are
	// one or more matching characters, enter those matching characters into
	// zInit[].  The re_match() routine can then search ahead in the input
	// string looking for the initial match without having to run the whole
	// regex engine over the string.  Do not worry able trying to match
	// unicode characters beyond plane 0 - those are very rare and this is
	// just an optimization.
	if (int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp))) == RE_OP_ANYSTAR) && !(noCase != 0) {
		j = 0
		i = 1
		for ; (j < (int32(unsafe.Sizeof([12]uint8{})) - 2)) && (int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(i)))) == RE_OP_MATCH); i++ {
			var x uint32 = uint32(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(i)*4)))
			if x <= uint32(127) {
				*(*uint8)(unsafe.Pointer((pRe + 28 /* &.zInit */) + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(x)
			} else if x <= uint32(0xfff) {
				*(*uint8)(unsafe.Pointer((pRe + 28 /* &.zInit */) + uintptr(libc.PostIncInt32(&j, 1)))) = (uint8(uint32(0xc0) | (x >> 6)))
				*(*uint8)(unsafe.Pointer((pRe + 28 /* &.zInit */) + uintptr(libc.PostIncInt32(&j, 1)))) = (uint8(uint32(0x80) | (x & uint32(0x3f))))
			} else if x <= uint32(0xffff) {
				*(*uint8)(unsafe.Pointer((pRe + 28 /* &.zInit */) + uintptr(libc.PostIncInt32(&j, 1)))) = (uint8(uint32(0xd0) | (x >> 12)))
				*(*uint8)(unsafe.Pointer((pRe + 28 /* &.zInit */) + uintptr(libc.PostIncInt32(&j, 1)))) = (uint8(uint32(0x80) | ((x >> 6) & uint32(0x3f))))
				*(*uint8)(unsafe.Pointer((pRe + 28 /* &.zInit */) + uintptr(libc.PostIncInt32(&j, 1)))) = (uint8(uint32(0x80) | (x & uint32(0x3f))))
			} else {
				break
			}
		}
		if (j > 0) && (int32(*(*uint8)(unsafe.Pointer((pRe + 28 /* &.zInit */) + uintptr((j - 1))))) == 0) {
			j--
		}
		(*ReCompiled)(unsafe.Pointer(pRe)).FnInit = j
	}
	return (*ReCompiled)(unsafe.Pointer(pRe)).FzErr
}

// Implementation of the regexp() SQL function.  This function implements
// the build-in REGEXP operator.  The first argument to the function is the
// pattern and the second argument is the string.  So, the SQL statements:
//
//       A REGEXP B
//
// is implemented as regexp(B,A).
func re_sql_func(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* regexp.c:710:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var pRe uintptr at bp, 4
	// Compiled regular expression
	var zPattern uintptr // The regular expression
	var zStr uintptr     // String being searched
	var zErr uintptr     // Compile error message
	var setAux int32 = 0 // True to invoke sqlite3_set_auxdata()

	_ = argc // Unused
	*(*uintptr)(unsafe.Pointer(bp /* pRe */)) = sqlite3.Xsqlite3_get_auxdata(tls, context, 0)
	if *(*uintptr)(unsafe.Pointer(bp /* pRe */)) == uintptr(0) {
		zPattern = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		if zPattern == uintptr(0) {
			return
		}
		zErr = sqlite3re_compile(tls, bp /* &pRe */, zPattern, (libc.Bool32(sqlite3.Xsqlite3_user_data(tls, context) != uintptr(0))))
		if zErr != 0 {
			sqlite3re_free(tls, *(*uintptr)(unsafe.Pointer(bp /* pRe */)))
			sqlite3.Xsqlite3_result_error(tls, context, zErr, -1)
			return
		}
		if *(*uintptr)(unsafe.Pointer(bp /* pRe */)) == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
		setAux = 1
	}
	zStr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if zStr != uintptr(0) {
		sqlite3.Xsqlite3_result_int(tls, context, sqlite3re_match(tls, *(*uintptr)(unsafe.Pointer(bp /* pRe */)), zStr, -1))
	}
	if setAux != 0 {
		sqlite3.Xsqlite3_set_auxdata(tls, context, 0, *(*uintptr)(unsafe.Pointer(bp /* pRe */)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3re_free})))
	}
}

// Invoke this routine to register the regexp() function with the
// SQLite database connection.
func sqlite3_regexp_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* regexp.c:754:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6335 /* "regexp" */, 2, (SQLITE_UTF8 | SQLITE_INNOCUOUS),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{re_sql_func})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		// The regexpi(PATTERN,STRING) function is a case-insensitive version
		// of regexp(PATTERN,STRING).
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6342 /* "regexpi" */, 2, (SQLITE_UTF8 | SQLITE_INNOCUOUS),
			db, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{re_sql_func})), uintptr(0), uintptr(0))
	}
	return rc
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// These are defined by the user (or the compiler)
//    to specify the desired environment:
//
//    __STRICT_ANSI__	ISO Standard C.
//    _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
//    _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
//    __STDC_WANT_LIB_EXT2__
// 			Extensions to ISO C99 from TR 27431-2:2010.
//    __STDC_WANT_IEC_60559_BFP_EXT__
// 			Extensions to ISO C11 from TS 18661-1:2014.
//    __STDC_WANT_IEC_60559_FUNCS_EXT__
// 			Extensions to ISO C11 from TS 18661-4:2015.
//    __STDC_WANT_IEC_60559_TYPES_EXT__
// 			Extensions to ISO C11 from TS 18661-3:2015.
//
//    _POSIX_SOURCE	IEEE Std 1003.1.
//    _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
// 			if >=199309L, add IEEE Std 1003.1b-1993;
// 			if >=199506L, add IEEE Std 1003.1c-1995;
// 			if >=200112L, all of IEEE 1003.1-2004
// 			if >=200809L, all of IEEE 1003.1-2008
//    _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
// 			Single Unix conformance is wanted, to 600 for the
// 			sixth revision, to 700 for the seventh revision.
//    _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
//    _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
//    _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
//    _FILE_OFFSET_BITS=N	Select default filesystem interface.
//    _ATFILE_SOURCE	Additional *at interfaces.
//    _GNU_SOURCE		All of the above, plus GNU extensions.
//    _DEFAULT_SOURCE	The default set of features (taking precedence over
// 			__STRICT_ANSI__).
//
//    _FORTIFY_SOURCE	Add security hardening to many library functions.
// 			Set to 1 or 2; 2 performs stricter checks than 1.
//
//    _REENTRANT, _THREAD_SAFE
// 			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.
//
//    The `-ansi' switch to the GNU C compiler, and standards conformance
//    options such as `-std=c99', define __STRICT_ANSI__.  If none of
//    these are defined, or if _DEFAULT_SOURCE is defined, the default is
//    to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
//    200809L, as well as enabling miscellaneous functions from BSD and
//    SVID.  If more than one of these are defined, they accumulate.  For
//    example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
//    give you ISO C, 1003.1, and 1003.2, but nothing else.
//
//    These are defined by this file and are used by the
//    header files to decide what to declare or define:
//
//    __GLIBC_USE (F)	Define things from feature set F.  This is defined
// 			to 1 or 0; the subsequent macros are either defined
// 			or undefined, and those tests should be moved to
// 			__GLIBC_USE.
//    __USE_ISOC11		Define ISO C11 things.
//    __USE_ISOC99		Define ISO C99 things.
//    __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
//    __USE_ISOCXX11	Define ISO C++11 things.
//    __USE_POSIX		Define IEEE Std 1003.1 things.
//    __USE_POSIX2		Define IEEE Std 1003.2 things.
//    __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
//    __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
//    __USE_XOPEN		Define XPG things.
//    __USE_XOPEN_EXTENDED	Define X/Open Unix things.
//    __USE_UNIX98		Define Single Unix V2 things.
//    __USE_XOPEN2K        Define XPG6 things.
//    __USE_XOPEN2KXSI     Define XPG6 XSI things.
//    __USE_XOPEN2K8       Define XPG7 things.
//    __USE_XOPEN2K8XSI    Define XPG7 XSI things.
//    __USE_LARGEFILE	Define correct standard I/O things.
//    __USE_LARGEFILE64	Define LFS things with separate names.
//    __USE_FILE_OFFSET64	Define 64bit interface as default.
//    __USE_MISC		Define things from 4.3BSD or System V Unix.
//    __USE_ATFILE		Define *at interfaces and AT_* constants for them.
//    __USE_GNU		Define GNU extensions.
//    __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
//
//    The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
//    defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
//    only for compatibility.  All new code should use the other symbols
//    to test for features.
//
//    All macros listed above as possibly being defined by this file are
//    explicitly undefined if they are not explicitly defined.
//    Feature-test macros that are not defined by the user or compiler
//    but are implied by the other feature-test macros defined (or by the
//    lack of any definitions) are defined by the file.
//
//    ISO C feature test macros depend on the definition of the macro
//    when an affected header is included, not when the first system
//    header is included, and so they are handled in
//    <bits/libc-header-start.h>, which does not have a multiple include
//    guard.  Feature test macros that can be handled from the first
//    system header included are handled here.

// Undefine everything, so we get a clean slate.

// Suppress kernel-name space pollution unless user expressedly asks
//    for it.

// Convenience macro to test the version of gcc.
//    Use like this:
//    #if __GNUC_PREREQ (2,8)
//    ... code requiring gcc 2.8 or later ...
//    #endif
//    Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
//    added in 2.0.

// Similarly for clang.  Features added to GCC after version 4.2 may
//    or may not also be available in clang, and clang's definitions of
//    __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
//    features can be queried via __has_extension/__has_feature.

// Whether to use feature set F.

// _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
//    _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
//    issue a warning; the expectation is that the source is being
//    transitioned to use the new macro.

// If _GNU_SOURCE was defined by the user, turn on all the other features.

// If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
//    define _DEFAULT_SOURCE.

// This is to enable the ISO C11 extension.

// This is to enable the ISO C99 extension.

// This is to enable the ISO C90 Amendment 1:1995 extension.

// If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
//    is defined, use POSIX.1-2008 (or another version depending on
//    _XOPEN_SOURCE).

// Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
//    defined in all multithreaded code.  GNU libc has not required this
//    for many years.  We now treat them as compatibility synonyms for
//    _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
//    comprehensive support for multithreaded code.  Using them never
//    lowers the selected level of POSIX conformance, only raises it.

// The function 'gets' existed in C89, but is impossible to use
//    safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
//    compatibility with various implementations of <cstdio>, this test
//    must consider only the value of __cplusplus when compiling C++.

// Get definitions of __STDC_* predefined macros, if the compiler has
//    not preincluded this header automatically.
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This macro indicates that the installed library is the GNU C Library.
//    For historic reasons the value now is 6 and this will stay from now
//    on.  The use of this variable is deprecated.  Use __GLIBC__ and
//    __GLIBC_MINOR__ now (see below) when you want to test for a specific
//    GNU C library version and use the values in <gnu/lib-names.h> to get
//    the sonames of the shared libraries.

// Major and minor version number of the GNU C library package.  Use
//    these macros to test for features in specific releases.

// This is here only because every header file already includes this one.
// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// We are almost always included from features.h.

// The GNU libc does not support any K&R compilers or the traditional mode
//    of ISO C compilers anymore.  Check for some of the combinations not
//    anymore supported.

// Some user header file might have defined this before.

// All functions, except those with callbacks or those that
//    synchronize memory, are leaf functions.

// GCC can always grok prototypes.  For C++ programs we add throw()
//    to help it optimize the function calls.  But this works only with
//    gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
//    as non-throwing using a function attribute since programs can use
//    the -fexceptions options for C code as well.

// Compilers that are not clang may object to
//        #if defined __clang__ && __has_extension(...)
//    even though they do not need to evaluate the right-hand side of the &&.

// These two macros are not used in glibc anymore.  They are kept here
//    only because some other projects expect the macros to be defined.

// For these things, GCC behaves the ANSI way normally,
//    and the non-ANSI way under -traditional.

// This is not a typedef so `const __ptr_t' does the right thing.

// C++ needs to know that types and declarations are C, not C++.

// Fortify support.

// Support for flexible arrays.
//    Headers that should use flexible arrays only if they're "real"
//    (e.g. only if they won't affect sizeof()) should test
//    #if __glibc_c99_flexarr_available.

// __asm__ ("xyz") is used throughout the headers to rename functions
//    at the assembly language level.  This is wrapped by the __REDIRECT
//    macro, in order to support compilers that can do this some other
//    way.  When compilers don't support asm-names at all, we have to do
//    preprocessor tricks instead (which don't have exactly the right
//    semantics, but it's the best we can do).
//
//    Example:
//    int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid);

//
// #elif __SOME_OTHER_COMPILER__
//
// # define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)

// GCC has various useful declarations that can be made with the
//    `__attribute__' syntax.  All of the ways we use this do fine if
//    they are omitted for compilers that don't understand it.

// At some point during the gcc 2.96 development the `malloc' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Tell the compiler which arguments to an allocation function
//    indicate the size of the allocation.

// At some point during the gcc 2.96 development the `pure' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// This declaration tells the compiler that the value is constant.

// At some point during the gcc 3.1 development the `used' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Since version 3.2, gcc allows marking deprecated functions.

// Since version 4.5, gcc also allows one to specify the message printed
//    when a deprecated function is used.  clang claims to be gcc 4.2, but
//    may also support this feature.

// At some point during the gcc 2.8 development the `format_arg' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.
//    If several `format_arg' attributes are given for the same function, in
//    gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
//    all designated arguments are considered.

// At some point during the gcc 2.97 development the `strfmon' format
//    attribute for functions was introduced.  We don't want to use it
//    unconditionally (although this would be possible) since it
//    generates warnings.

// The nonull function attribute allows to mark pointer parameters which
//    must not be NULL.

// If fortification mode, we warn about unused results of certain
//    function calls which can lead to problems.

// Forces a function to be always inlined.
// The Linux kernel defines __always_inline in stddef.h (283d7573), and
//    it conflicts with this definition.  Therefore undefine it first to
//    allow either header to be included first.

// Associate error messages with the source location of the call site rather
//    than with the source location inside the function.

// GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
//    inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
//    or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
//    older than 4.3 may define these macros and still not guarantee GNU inlining
//    semantics.
//
//    clang++ identifies itself as gcc-4.2, but has support for GNU inlining
//    semantics, that can be checked fot by using the __GNUC_STDC_INLINE_ and
//    __GNUC_GNU_INLINE__ macro definitions.

// GCC 4.3 and above allow passing all anonymous arguments of an
//    __extern_always_inline function to some other vararg function.

// It is possible to compile containing GCC extensions even if GCC is
//    run in pedantic mode if the uses are carefully marked using the
//    `__extension__' keyword.  But this is not generally available before
//    version 2.8.

// __restrict is known in EGCS 1.2 and above.

// ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
//      array_name[restrict]
//    GCC 3.1 supports this.

// Describes a char array whose address can safely be passed as the first
//    argument to strncpy and strncat, as the char array is not necessarily
//    a NUL-terminated string.

// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Properties of long double type.
//    Copyright (C) 2016-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This header is included by <sys/cdefs.h>.
//
//    If long double is ABI-compatible with double, it should define
//    __NO_LONG_DOUBLE_MATH to 1; otherwise, it should leave
//    __NO_LONG_DOUBLE_MATH undefined.
//
//    If this build of the GNU C Library supports both long double
//    ABI-compatible with double and some other long double format not
//    ABI-compatible with double, it should define
//    __LONG_DOUBLE_MATH_OPTIONAL to 1; otherwise, it should leave
//    __LONG_DOUBLE_MATH_OPTIONAL undefined.
//
//    If __NO_LONG_DOUBLE_MATH is already defined, this header must not
//    define anything; this is needed to work with the definition of
//    __NO_LONG_DOUBLE_MATH in nldbl-compat.h.

// In the default version of this header, long double is
//    ABI-compatible with double.

// __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is
//    intended for use in preprocessor macros.
//
//    Note: MESSAGE must be a _single_ string; concatenation of string
//    literals is not supported.

// Generic selection (ISO C11) is a C-only feature, available in GCC
//    since version 4.9.  Previous versions do not provide generic
//    selection, even though they might set __STDC_VERSION__ to 201112L,
//    when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
//    when testing __STDC_VERSION__ for generic selection support.
//    On the other hand, Clang also defines __GNUC__, so a clang-specific
//    check is required to enable the use of generic selection.

// If we don't have __REDIRECT, prototypes will be missing if
//    __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64].

// Decide whether we can define 'extern inline' functions in headers.

// This is here only because every header file already includes this one.
//    Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
//    <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
//    that will always return failure (and set errno to ENOSYS).
// This file is automatically generated.
//    This file selects the right generated file of `__stub_FUNCTION' macros
//    based on the architecture being compiled for.

// This file is automatically generated.
//    It defines a symbol `__stub_FUNCTION' for each function
//    in the C library which is a stub, meaning it will fail
//    every time called, usually setting errno to ENOSYS.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

//      remember(V,PTR)
//
// Return the integer value V.  Also save the value of V in a
// C-language variable whose address is PTR.
func rememberFunc(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) { /* remember.c:45:13: */
	var v sqlite3_int64
	var ptr uintptr

	v = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	ptr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+3921 /* "carray" */)
	if ptr != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(ptr)) = v
	}
	sqlite3.Xsqlite3_result_int64(tls, pCtx, v)
}

func sqlite3_remember_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* remember.c:62:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6350 /* "remember" */, 2, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{rememberFunc})), uintptr(0), uintptr(0))
	return rc
}

// series_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type series_cursor1 = struct {
	Fbase    sqlite3_vtab_cursor
	FisDesc  int32
	FiRowid  sqlite3_int64
	FiValue  sqlite3_int64
	FmnValue sqlite3_int64
	FmxValue sqlite3_int64
	FiStep   sqlite3_int64
} /* series.c:83:9 */

// series_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type series_cursor = series_cursor1 /* series.c:83:30 */

// The seriesConnect() method is invoked to create a new
// series_vtab that describes the generate_series virtual table.
//
// Think of this routine as the constructor for series_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the series_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against generate_series will look like.
func seriesConnect(tls *libc.TLS, db uintptr, pUnused uintptr, argcUnused int32, argvUnused uintptr, ppVtab uintptr, pzErrUnused uintptr) int32 { /* series.c:107:12: */
	var pNew uintptr
	var rc int32

	// Column numbers

	_ = pUnused
	_ = argcUnused
	_ = argvUnused
	_ = pzErrUnused
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+6359 /* "CREATE TABLE x(v..." */)
	if rc == SQLITE_OK {
		pNew = libc.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(sqlite3_vtab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	}
	return rc
}

// This method is the destructor for series_cursor objects.
func seriesDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* series.c:141:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// Constructor for a new series_cursor object.
func seriesOpen(tls *libc.TLS, pUnused uintptr, ppCursor uintptr) int32 { /* series.c:149:12: */
	var pCur uintptr
	_ = pUnused
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(series_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(series_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Destructor for a series_cursor.
func seriesClose(tls *libc.TLS, cur uintptr) int32 { /* series.c:162:12: */
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

// Advance a series_cursor to its next row of output.
func seriesNext(tls *libc.TLS, cur uintptr) int32 { /* series.c:171:12: */
	var pCur uintptr = cur
	if (*series_cursor)(unsafe.Pointer(pCur)).FisDesc != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pCur + 16 /* &.iValue */)) -= ((*series_cursor)(unsafe.Pointer(pCur)).FiStep)
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pCur + 16 /* &.iValue */)) += ((*series_cursor)(unsafe.Pointer(pCur)).FiStep)
	}
	(*series_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return SQLITE_OK
}

// Return values of columns for the row at which the series_cursor
// is currently pointing.
func seriesColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* series.c:186:12: */
	var pCur uintptr = cur
	var x sqlite3_int64 = int64(0)
	switch i {
	case SERIES_COLUMN_START:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FmnValue
		break
	case SERIES_COLUMN_STOP:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FmxValue
		break
	case SERIES_COLUMN_STEP:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FiStep
		break
	default:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FiValue
		break
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, x)
	return SQLITE_OK
}

// Return the rowid for the current row. In this implementation, the
// first row returned is assigned rowid value 1, and each subsequent
// row a value 1 more than that of the previous.
func seriesRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* series.c:208:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*series_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func seriesEof(tls *libc.TLS, cur uintptr) int32 { /* series.c:218:12: */
	var pCur uintptr = cur
	if (*series_cursor)(unsafe.Pointer(pCur)).FisDesc != 0 {
		return (libc.Bool32((*series_cursor)(unsafe.Pointer(pCur)).FiValue < (*series_cursor)(unsafe.Pointer(pCur)).FmnValue))
	} else {
		return (libc.Bool32((*series_cursor)(unsafe.Pointer(pCur)).FiValue > (*series_cursor)(unsafe.Pointer(pCur)).FmxValue))
	}
	return int32(0)
}

// True to cause run-time checking of the start=, stop=, and/or step=
// parameters.  The only reason to do this is for testing the
// constraint checking logic for virtual tables in the SQLite core.

// This method is called to "rewind" the series_cursor object back
// to the first row of output.  This method is always called at least
// once prior to any call to seriesColumn() or seriesRowid() or
// seriesEof().
//
// The query plan selected by seriesBestIndex is passed in the idxNum
// parameter.  (idxStr is not used in this implementation.)  idxNum
// is a bitmask showing which constraints are available:
//
//    1:    start=VALUE
//    2:    stop=VALUE
//    4:    step=VALUE
//
// Also, if bit 8 is set, that means that the series should be output
// in descending order rather than in ascending order.  If bit 16 is
// set, then output must appear in ascending order.
//
// This routine should initialize the cursor and position it so that it
// is pointing at the first row, or pointing off the end of the table
// (so that seriesEof() will return true) if the table is empty.
func seriesFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStrUnused uintptr, argc int32, argv uintptr) int32 { /* series.c:257:12: */
	var pCur uintptr = pVtabCursor
	var i int32 = 0
	_ = idxStrUnused
	if (idxNum & 1) != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&i, 1))*4)))
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = int64(0)
	}
	if (idxNum & 2) != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&i, 1))*4)))
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0xffffffff)
	}
	if (idxNum & 4) != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FiStep = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&i, 1))*4)))
		if (*series_cursor)(unsafe.Pointer(pCur)).FiStep == int64(0) {
			(*series_cursor)(unsafe.Pointer(pCur)).FiStep = int64(1)
		} else if (*series_cursor)(unsafe.Pointer(pCur)).FiStep < int64(0) {
			(*series_cursor)(unsafe.Pointer(pCur)).FiStep = -(*series_cursor)(unsafe.Pointer(pCur)).FiStep
			if (idxNum & 16) == 0 {
				idxNum = idxNum | (8)
			}
		}
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FiStep = int64(1)
	}
	for i = 0; i < argc; i++ {
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))) == SQLITE_NULL {
			// If any of the constraints have a NULL value, then return no rows.
			// See ticket https://www.sqlite.org/src/info/fac496b61722daf2
			(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = int64(1)
			(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0)
			break
		}
	}
	if (idxNum & 8) != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FisDesc = 1
		(*series_cursor)(unsafe.Pointer(pCur)).FiValue = (*series_cursor)(unsafe.Pointer(pCur)).FmxValue
		if (*series_cursor)(unsafe.Pointer(pCur)).FiStep > int64(0) {
			*(*sqlite3_int64)(unsafe.Pointer(pCur + 16 /* &.iValue */)) -= (((*series_cursor)(unsafe.Pointer(pCur)).FmxValue - (*series_cursor)(unsafe.Pointer(pCur)).FmnValue) % (*series_cursor)(unsafe.Pointer(pCur)).FiStep)
		}
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FisDesc = 0
		(*series_cursor)(unsafe.Pointer(pCur)).FiValue = (*series_cursor)(unsafe.Pointer(pCur)).FmnValue
	}
	(*series_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
	return SQLITE_OK
}

// SQLite will invoke this method one or more times while planning a query
// that uses the generate_series virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
//
// In this implementation idxNum is used to represent the
// query plan.  idxStr is unused.
//
// The query plan is represented by bits in idxNum:
//
//  (1)  start = $value  -- constraint exists
//  (2)  stop = $value   -- constraint exists
//  (4)  step = $value   -- constraint exists
//  (8)  output in descending order
func seriesBestIndex(tls *libc.TLS, tabUnused uintptr, pIdxInfo uintptr) int32 { /* series.c:325:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var i int32
	var j int32                // Loop over constraints
	var idxNum int32 = 0       // The query plan bitmask
	var unusableMask int32 = 0 // Mask of unusable constraints
	var nArg int32 = 0         // Number of arguments that seriesFilter() expects
	// var aIdx [3]int32 at bp, 12
	// Constraints on start, stop, and step
	var pConstraint uintptr

	// This implementation assumes that the start, stop, and step columns
	// are the last three columns in the virtual table.

	_ = tabUnused
	*(*int32)(unsafe.Pointer(bp /* &aIdx[0] */)) = libc.AssignPtrInt32(bp /* &aIdx */ +1*4, libc.AssignPtrInt32(bp /* &aIdx */ +2*4, -1))
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		var iCol int32  // 0 for start, 1 for stop, 2 for step
		var iMask int32 // bitmask for those column
		if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn < SERIES_COLUMN_START {
			goto __2
		}
		iCol = ((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn - SERIES_COLUMN_START)

		iMask = (int32(1) << iCol)
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			unusableMask = unusableMask | (iMask)
			goto __2
		} else if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			idxNum = idxNum | (iMask)
			*(*int32)(unsafe.Pointer(bp /* &aIdx[0] */ + uintptr(iCol)*4)) = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	for i = 0; i < 3; i++ {
		if (libc.AssignInt32(&j, *(*int32)(unsafe.Pointer(bp /* &aIdx[0] */ + uintptr(i)*4)))) >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(j)*8)).FargvIndex = libc.PreIncInt32(&nArg, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(j)*8)).Fomit = libc.BoolUint8(!(1 != 0))
		}
	}
	if (unusableMask & ^idxNum) != 0 {
		// The start, stop, and step columns are inputs.  Therefore if there
		// are unusable constraints on any of start, stop, or step then
		// this plan is unusable
		return SQLITE_CONSTRAINT
	}
	if (idxNum & 3) == 3 {
		// Both start= and stop= boundaries are available.  This is the
		// the preferred case
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = (float64(2 - (libc.Bool32((idxNum & 4) != 0))))
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1000)
		if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 {
			if (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc != 0 {
				idxNum = idxNum | (8)
			} else {
				idxNum = idxNum | (16)
			}
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
		}
	} else {
		// If either boundary is missing, we have to generate a huge span
		// of numbers.  Make this case very expensive so that the query
		// planner will work hard to avoid it.
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(2147483647)
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	return SQLITE_OK
}

// This following structure defines all the methods for the
// generate_series virtual table.
var seriesModule = sqlite3_module{ // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xShadowName
} /* series.c:397:23 */

func sqlite3_series_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* series.c:429:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	if sqlite3.Xsqlite3_libversion_number(tls) < 3008012 {
		*(*uintptr)(unsafe.Pointer(pzErrMsg)) = sqlite3.Xsqlite3_mprintf(tls,
			ts+6418 /* "generate_series(..." */, 0)
		return SQLITE_ERROR
	}
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+6468 /* "generate_series" */, uintptr(unsafe.Pointer(&seriesModule)), uintptr(0))
	return rc
}

type u16 = uint16 /* spellfix.c:34:26 */

// Character classes for ASCII characters:
//
//   0   ''        Silent letters:   H W
//   1   'A'       Any vowel:   A E I O U (Y)
//   2   'B'       A bilabeal stop or fricative:  B F P V W
//   3   'C'       Other fricatives or back stops:  C G J K Q S X Z
//   4   'D'       Alveolar stops:  D T
//   5   'H'       Letter H at the beginning of a word
//   6   'L'       Glide:  L
//   7   'R'       Semivowel:  R
//   8   'M'       Nasals:  M N
//   9   'Y'       Letter Y at the beginning of a word.
//   10  '9'       Digits: 0 1 2 3 4 5 6 7 8 9
//   11  ' '       White space
//   12  '?'       Other.

// The following table gives the character class for non-initial ASCII
// characters.
var midClass = [128]uint8{
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_SPACE),
	/* ! */ uint8(CCLASS_OTHER) /* " */, uint8(CCLASS_OTHER) /* # */, uint8(CCLASS_OTHER),
	/* $ */ uint8(CCLASS_OTHER) /* % */, uint8(CCLASS_OTHER) /* & */, uint8(CCLASS_OTHER),
	/* ' */ uint8(CCLASS_SILENT) /* ( */, uint8(CCLASS_OTHER) /* ) */, uint8(CCLASS_OTHER),
	/* * */ uint8(CCLASS_OTHER) /* + */, uint8(CCLASS_OTHER) /* , */, uint8(CCLASS_OTHER),
	/* - */ uint8(CCLASS_OTHER) /* . */, uint8(CCLASS_OTHER) /* / */, uint8(CCLASS_OTHER),
	/* 0 */ uint8(CCLASS_DIGIT) /* 1 */, uint8(CCLASS_DIGIT) /* 2 */, uint8(CCLASS_DIGIT),
	/* 3 */ uint8(CCLASS_DIGIT) /* 4 */, uint8(CCLASS_DIGIT) /* 5 */, uint8(CCLASS_DIGIT),
	/* 6 */ uint8(CCLASS_DIGIT) /* 7 */, uint8(CCLASS_DIGIT) /* 8 */, uint8(CCLASS_DIGIT),
	/* 9 */ uint8(CCLASS_DIGIT) /* : */, uint8(CCLASS_OTHER) /* ; */, uint8(CCLASS_OTHER),
	/* < */ uint8(CCLASS_OTHER) /* = */, uint8(CCLASS_OTHER) /* > */, uint8(CCLASS_OTHER),
	/* ? */ uint8(CCLASS_OTHER) /* @ */, uint8(CCLASS_OTHER) /* A */, uint8(CCLASS_VOWEL),
	/* B */ uint8(CCLASS_B) /* C */, uint8(CCLASS_C) /* D */, uint8(CCLASS_D),
	/* E */ uint8(CCLASS_VOWEL) /* F */, uint8(CCLASS_B) /* G */, uint8(CCLASS_C),
	/* H */ uint8(CCLASS_SILENT) /* I */, uint8(CCLASS_VOWEL) /* J */, uint8(CCLASS_C),
	/* K */ uint8(CCLASS_C) /* L */, uint8(CCLASS_L) /* M */, uint8(CCLASS_M),
	/* N */ uint8(CCLASS_M) /* O */, uint8(CCLASS_VOWEL) /* P */, uint8(CCLASS_B),
	/* Q */ uint8(CCLASS_C) /* R */, uint8(CCLASS_R) /* S */, uint8(CCLASS_C),
	/* T */ uint8(CCLASS_D) /* U */, uint8(CCLASS_VOWEL) /* V */, uint8(CCLASS_B),
	/* W */ uint8(CCLASS_B) /* X */, uint8(CCLASS_C) /* Y */, uint8(CCLASS_VOWEL),
	/* Z */ uint8(CCLASS_C) /* [ */, uint8(CCLASS_OTHER) /* \ */, uint8(CCLASS_OTHER),
	/* ] */ uint8(CCLASS_OTHER) /* ^ */, uint8(CCLASS_OTHER) /* _ */, uint8(CCLASS_OTHER),
	/* ` */ uint8(CCLASS_OTHER) /* a */, uint8(CCLASS_VOWEL) /* b */, uint8(CCLASS_B),
	/* c */ uint8(CCLASS_C) /* d */, uint8(CCLASS_D) /* e */, uint8(CCLASS_VOWEL),
	/* f */ uint8(CCLASS_B) /* g */, uint8(CCLASS_C) /* h */, uint8(CCLASS_SILENT),
	/* i */ uint8(CCLASS_VOWEL) /* j */, uint8(CCLASS_C) /* k */, uint8(CCLASS_C),
	/* l */ uint8(CCLASS_L) /* m */, uint8(CCLASS_M) /* n */, uint8(CCLASS_M),
	/* o */ uint8(CCLASS_VOWEL) /* p */, uint8(CCLASS_B) /* q */, uint8(CCLASS_C),
	/* r */ uint8(CCLASS_R) /* s */, uint8(CCLASS_C) /* t */, uint8(CCLASS_D),
	/* u */ uint8(CCLASS_VOWEL) /* v */, uint8(CCLASS_B) /* w */, uint8(CCLASS_B),
	/* x */ uint8(CCLASS_C) /* y */, uint8(CCLASS_VOWEL) /* z */, uint8(CCLASS_C),
	/* { */ uint8(CCLASS_OTHER) /* | */, uint8(CCLASS_OTHER) /* } */, uint8(CCLASS_OTHER),
	/* ~ */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
} /* spellfix.c:75:28 */
// This tables gives the character class for ASCII characters that form the
// initial character of a word.  The only difference from midClass is with
// the letters H, W, and Y.
var initClass = [128]uint8{
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_SPACE),
	/* ! */ uint8(CCLASS_OTHER) /* " */, uint8(CCLASS_OTHER) /* # */, uint8(CCLASS_OTHER),
	/* $ */ uint8(CCLASS_OTHER) /* % */, uint8(CCLASS_OTHER) /* & */, uint8(CCLASS_OTHER),
	/* ' */ uint8(CCLASS_OTHER) /* ( */, uint8(CCLASS_OTHER) /* ) */, uint8(CCLASS_OTHER),
	/* * */ uint8(CCLASS_OTHER) /* + */, uint8(CCLASS_OTHER) /* , */, uint8(CCLASS_OTHER),
	/* - */ uint8(CCLASS_OTHER) /* . */, uint8(CCLASS_OTHER) /* / */, uint8(CCLASS_OTHER),
	/* 0 */ uint8(CCLASS_DIGIT) /* 1 */, uint8(CCLASS_DIGIT) /* 2 */, uint8(CCLASS_DIGIT),
	/* 3 */ uint8(CCLASS_DIGIT) /* 4 */, uint8(CCLASS_DIGIT) /* 5 */, uint8(CCLASS_DIGIT),
	/* 6 */ uint8(CCLASS_DIGIT) /* 7 */, uint8(CCLASS_DIGIT) /* 8 */, uint8(CCLASS_DIGIT),
	/* 9 */ uint8(CCLASS_DIGIT) /* : */, uint8(CCLASS_OTHER) /* ; */, uint8(CCLASS_OTHER),
	/* < */ uint8(CCLASS_OTHER) /* = */, uint8(CCLASS_OTHER) /* > */, uint8(CCLASS_OTHER),
	/* ? */ uint8(CCLASS_OTHER) /* @ */, uint8(CCLASS_OTHER) /* A */, uint8(CCLASS_VOWEL),
	/* B */ uint8(CCLASS_B) /* C */, uint8(CCLASS_C) /* D */, uint8(CCLASS_D),
	/* E */ uint8(CCLASS_VOWEL) /* F */, uint8(CCLASS_B) /* G */, uint8(CCLASS_C),
	/* H */ uint8(CCLASS_SILENT) /* I */, uint8(CCLASS_VOWEL) /* J */, uint8(CCLASS_C),
	/* K */ uint8(CCLASS_C) /* L */, uint8(CCLASS_L) /* M */, uint8(CCLASS_M),
	/* N */ uint8(CCLASS_M) /* O */, uint8(CCLASS_VOWEL) /* P */, uint8(CCLASS_B),
	/* Q */ uint8(CCLASS_C) /* R */, uint8(CCLASS_R) /* S */, uint8(CCLASS_C),
	/* T */ uint8(CCLASS_D) /* U */, uint8(CCLASS_VOWEL) /* V */, uint8(CCLASS_B),
	/* W */ uint8(CCLASS_B) /* X */, uint8(CCLASS_C) /* Y */, uint8(CCLASS_Y),
	/* Z */ uint8(CCLASS_C) /* [ */, uint8(CCLASS_OTHER) /* \ */, uint8(CCLASS_OTHER),
	/* ] */ uint8(CCLASS_OTHER) /* ^ */, uint8(CCLASS_OTHER) /* _ */, uint8(CCLASS_OTHER),
	/* ` */ uint8(CCLASS_OTHER) /* a */, uint8(CCLASS_VOWEL) /* b */, uint8(CCLASS_B),
	/* c */ uint8(CCLASS_C) /* d */, uint8(CCLASS_D) /* e */, uint8(CCLASS_VOWEL),
	/* f */ uint8(CCLASS_B) /* g */, uint8(CCLASS_C) /* h */, uint8(CCLASS_SILENT),
	/* i */ uint8(CCLASS_VOWEL) /* j */, uint8(CCLASS_C) /* k */, uint8(CCLASS_C),
	/* l */ uint8(CCLASS_L) /* m */, uint8(CCLASS_M) /* n */, uint8(CCLASS_M),
	/* o */ uint8(CCLASS_VOWEL) /* p */, uint8(CCLASS_B) /* q */, uint8(CCLASS_C),
	/* r */ uint8(CCLASS_R) /* s */, uint8(CCLASS_C) /* t */, uint8(CCLASS_D),
	/* u */ uint8(CCLASS_VOWEL) /* v */, uint8(CCLASS_B) /* w */, uint8(CCLASS_B),
	/* x */ uint8(CCLASS_C) /* y */, uint8(CCLASS_Y) /* z */, uint8(CCLASS_C),
	/* { */ uint8(CCLASS_OTHER) /* | */, uint8(CCLASS_OTHER) /* } */, uint8(CCLASS_OTHER),
	/* ~ */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
} /* spellfix.c:125:28 */

// Mapping from the character class number (0-13) to a symbol for each
// character class.  Note that initClass[] can be used to map the class
// symbol back into the class number.
var className = *(*[14]uint8)(unsafe.Pointer(ts + 6484 /* ".ABCDHLRMY9 ?" */)) /* spellfix.c:176:28 */

// Generate a "phonetic hash" from a string of ASCII characters
// in zIn[0..nIn-1].
//
//   * Map characters by character class as defined above.
//   * Omit double-letters
//   * Omit vowels beside R and L
//   * Omit T when followed by CH
//   * Omit W when followed by R
//   * Omit D when followed by J or G
//   * Omit K in KN or G in GN at the beginning of a word
//
// Space to hold the result is obtained from sqlite3_malloc()
//
// Return NULL if memory allocation fails.
func phoneticHash(tls *libc.TLS, zIn uintptr, nIn int32) uintptr { /* spellfix.c:194:22: */
	var zOut uintptr = sqlite3.Xsqlite3_malloc64(tls, (uint64(nIn + 1)))
	var i int32
	var nOut int32 = 0
	var cPrev int8 = int8(0x77)
	var cPrevX int8 = int8(0x77)
	var aClass uintptr = uintptr(unsafe.Pointer(&initClass))

	if zOut == uintptr(0) {
		return uintptr(0)
	}
	if nIn > 2 {
		switch int32(*(*uint8)(unsafe.Pointer(zIn))) {
		case 'g':
			fallthrough
		case 'k':
			{
				if int32(*(*uint8)(unsafe.Pointer(zIn + 1))) == 'n' {
					zIn++
					nIn--
				}
				break

			}
		}
	}
	for i = 0; i < nIn; i++ {
		var c uint8 = *(*uint8)(unsafe.Pointer(zIn + uintptr(i)))
		if (i + 1) < nIn {
			if (int32(c) == 'w') && (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((i + 1))))) == 'r') {
				continue
			}
			if (int32(c) == 'd') && ((int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((i + 1))))) == 'j') || (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((i + 1))))) == 'g')) {
				continue
			}
			if (i + 2) < nIn {
				if ((int32(c) == 't') && (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((i + 1))))) == 'c')) && (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((i + 2))))) == 'h') {
					continue
				}
			}
		}
		c = *(*uint8)(unsafe.Pointer(aClass + uintptr((int32(c) & 0x7f))))
		if int32(c) == CCLASS_SPACE {
			continue
		}
		if (int32(c) == CCLASS_OTHER) && (int32(cPrev) != CCLASS_DIGIT) {
			continue
		}
		aClass = uintptr(unsafe.Pointer(&midClass))
		if (int32(c) == CCLASS_VOWEL) && ((int32(cPrevX) == CCLASS_R) || (int32(cPrevX) == CCLASS_L)) {
			continue /* No vowels beside L or R */
		}
		if ((int32(c) == CCLASS_R) || (int32(c) == CCLASS_L)) && (int32(cPrevX) == CCLASS_VOWEL) {
			nOut-- // No vowels beside L or R
		}
		cPrev = int8(c)
		if int32(c) == CCLASS_SILENT {
			continue
		}
		cPrevX = int8(c)
		c = className[c]

		if (nOut == 0) || (int32(c) != int32(*(*uint8)(unsafe.Pointer(zOut + uintptr((nOut - 1)))))) {
			*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = c
		}
	}
	*(*uint8)(unsafe.Pointer(zOut + uintptr(nOut))) = uint8(0)
	return zOut
}

// This is an SQL function wrapper around phoneticHash().  See
// the description of phoneticHash() for additional information.
func phoneticHashSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:246:13: */
	var zIn uintptr
	var zOut uintptr

	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zIn == uintptr(0) {
		return
	}
	zOut = phoneticHash(tls, zIn, sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv))))
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, zOut, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

// Return the character class number for a character given its
// context.
func characterClass(tls *libc.TLS, cPrev int8, c int8) int8 { /* spellfix.c:268:13: */
	if int32(cPrev) == 0 {
		return int8(initClass[(int32(c) & 0x7f)])
	}
	return int8(midClass[(int32(c) & 0x7f)])
}

// Return the cost of inserting or deleting character c immediately
// following character cPrev.  If cPrev==0, that means c is the first
// character of the word.
func insertOrDeleteCost(tls *libc.TLS, cPrev int8, c int8, cNext int8) int32 { /* spellfix.c:277:12: */
	var classC int8 = characterClass(tls, cPrev, c)
	var classCprev int8

	if int32(classC) == CCLASS_SILENT {
		// Insert or delete "silent" characters such as H or W
		return 1
	}
	if int32(cPrev) == int32(c) {
		// Repeated characters, or miss a repeat
		return 10
	}
	if (int32(classC) == CCLASS_VOWEL) && ((int32(cPrev) == 'r') || (int32(cNext) == 'r')) {
		return 20 // Insert a vowel before or after 'r'
	}
	classCprev = characterClass(tls, cPrev, cPrev)
	if int32(classC) == int32(classCprev) {
		if int32(classC) == CCLASS_VOWEL {
			// Remove or add a new vowel to a vowel cluster
			return 15
		} else {
			// Remove or add a consonant not in the same class
			return 50
		}
	}

	// any other character insertion or deletion
	return 100
}

// Divide the insertion cost by this factor when appending to the
// end of the word.

// Return the cost of substituting cTo in place of cFrom assuming
// the previous character is cPrev.  If cPrev==0 then cTo is the first
// character of the word.
func substituteCost(tls *libc.TLS, cPrev int8, cFrom int8, cTo int8) int32 { /* spellfix.c:318:12: */
	var classFrom int8
	var classTo int8
	if int32(cFrom) == int32(cTo) {
		// Exact match
		return 0
	}
	if (int32(cFrom) == (int32(cTo) ^ 0x20)) && (((int32(cTo) >= 'A') && (int32(cTo) <= 'Z')) || ((int32(cTo) >= 'a') && (int32(cTo) <= 'z'))) {
		// differ only in case
		return 0
	}
	classFrom = characterClass(tls, cPrev, cFrom)
	classTo = characterClass(tls, cPrev, cTo)
	if int32(classFrom) == int32(classTo) {
		// Same character class
		return 40
	}
	if (((int32(classFrom) >= CCLASS_B) && (int32(classFrom) <= CCLASS_Y)) &&
		(int32(classTo) >= CCLASS_B)) && (int32(classTo) <= CCLASS_Y) {
		// Convert from one consonant to another, but in a different class
		return 75
	}
	// Any other subsitution
	return 100
}

// Given two strings zA and zB which are pure ASCII, return the cost
// of transforming zA into zB.  If zA ends with '*' assume that it is
// a prefix of zB and give only minimal penalty for extra characters
// on the end of zB.
//
// Smaller numbers mean a closer match.
//
// Negative values indicate an error:
//    -1  One of the inputs is NULL
//    -2  Non-ASCII characters on input
//    -3  Unable to allocate memory
//
// If pnMatch is not NULL, then *pnMatch is set to the number of bytes
// of zB that matched the pattern in zA. If zA does not end with a '*',
// then this value is always the number of bytes in zB (i.e. strlen(zB)).
// If zA does end in a '*', then it is the number of bytes in the prefix
// of zB that was deemed to match zA.
func editdist1(tls *libc.TLS, zA uintptr, zB uintptr, pnMatch uintptr) int32 { /* spellfix.c:362:12: */
	bp := tls.Alloc(300)
	defer tls.Free(300)

	var nA int32
	var nB int32 // Number of characters in zA[] and zB[]
	var xA int32
	var xB int32 // Loop counters for zA[] and zB[]
	var cA int8 = int8(0)
	var cB int8 // Current character of zA and zB
	var cAprev int8
	var cBprev int8 // Previous character of zA and zB
	var cAnext int8
	var cBnext int8                 // Next character in zA and zB
	var d int32                     // North-west cost value
	var dc int32 = 0                // North-west character value
	var res int32                   // Final result
	var m uintptr                   // The cost matrix
	var cx uintptr                  // Corresponding character values
	var toFree uintptr = uintptr(0) // Malloced space
	var nMatch int32 = 0
	// var mStack [75]int32 at bp, 300
	// Stack space to use if not too much is needed

	// Early out if either input is NULL
	if (zA == uintptr(0)) || (zB == uintptr(0)) {
		return -1
	}

	// Skip any common prefix
	for (*(*int8)(unsafe.Pointer(zA)) != 0) && (int32(*(*int8)(unsafe.Pointer(zA))) == int32(*(*int8)(unsafe.Pointer(zB)))) {
		dc = int32(*(*int8)(unsafe.Pointer(zA)))
		zA++
		zB++
		nMatch++
	}
	if pnMatch != 0 {
		*(*int32)(unsafe.Pointer(pnMatch)) = nMatch
	}
	if (int32(*(*int8)(unsafe.Pointer(zA))) == 0) && (int32(*(*int8)(unsafe.Pointer(zB))) == 0) {
		return 0
	}

	// Verify input strings and measure their lengths
	for nA = 0; *(*int8)(unsafe.Pointer(zA + uintptr(nA))) != 0; nA++ {
		if (int32(*(*int8)(unsafe.Pointer(zA + uintptr(nA)))) & 0x80) != 0 {
			return -2
		}
	}
	for nB = 0; *(*int8)(unsafe.Pointer(zB + uintptr(nB))) != 0; nB++ {
		if (int32(*(*int8)(unsafe.Pointer(zB + uintptr(nB)))) & 0x80) != 0 {
			return -2
		}
	}

	// Special processing if either string is empty
	if nA == 0 {
		cBprev = int8(dc)
		for xB = libc.AssignInt32(&res, 0); (int32(libc.AssignInt8(&cB, *(*int8)(unsafe.Pointer(zB + uintptr(xB)))))) != 0; xB++ {
			res = res + (insertOrDeleteCost(tls, cBprev, cB, *(*int8)(unsafe.Pointer(zB + uintptr((xB + 1))))) / FINAL_INS_COST_DIV)
			cBprev = cB
		}
		return res
	}
	if nB == 0 {
		cAprev = int8(dc)
		for xA = libc.AssignInt32(&res, 0); (int32(libc.AssignInt8(&cA, *(*int8)(unsafe.Pointer(zA + uintptr(xA)))))) != 0; xA++ {
			res = res + (insertOrDeleteCost(tls, cAprev, cA, *(*int8)(unsafe.Pointer(zA + uintptr((xA + 1))))))
			cAprev = cA
		}
		return res
	}

	// A is a prefix of B
	if (int32(*(*int8)(unsafe.Pointer(zA))) == '*') && (int32(*(*int8)(unsafe.Pointer(zA + 1))) == 0) {
		return 0
	}

	// Allocate and initialize the Wagner matrix
	if uint32(nB) < ((uint32(unsafe.Sizeof([75]int32{})) * uint32(4)) / (uint32(unsafe.Sizeof(int32(0))) * uint32(5))) {
		m = bp /* &mStack[0] */
	} else {
		m = libc.AssignUintptr(&toFree, sqlite3.Xsqlite3_malloc64(tls, (uint64(((uint32((nB+1)*5))*uint32(unsafe.Sizeof(int32(0))))/uint32(4)))))
		if m == uintptr(0) {
			return -3
		}
	}
	cx = (m + uintptr((nB+1))*4)

	// Compute the Wagner edit distance
	*(*int32)(unsafe.Pointer(m)) = 0
	*(*int8)(unsafe.Pointer(cx)) = int8(dc)
	cBprev = int8(dc)
	for xB = 1; xB <= nB; xB++ {
		cBnext = *(*int8)(unsafe.Pointer(zB + uintptr(xB)))
		cB = *(*int8)(unsafe.Pointer(zB + uintptr((xB - 1))))
		*(*int8)(unsafe.Pointer(cx + uintptr(xB))) = cB
		*(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) = (*(*int32)(unsafe.Pointer(m + uintptr((xB-1))*4)) + insertOrDeleteCost(tls, cBprev, cB, cBnext))
		cBprev = cB
	}
	cAprev = int8(dc)
	for xA = 1; xA <= nA; xA++ {
		var lastA int32 = (libc.Bool32(xA == nA))
		cA = *(*int8)(unsafe.Pointer(zA + uintptr((xA - 1))))
		cAnext = *(*int8)(unsafe.Pointer(zA + uintptr(xA)))
		if (int32(cA) == '*') && (lastA != 0) {
			break
		}
		d = *(*int32)(unsafe.Pointer(m))
		dc = int32(*(*int8)(unsafe.Pointer(cx)))
		*(*int32)(unsafe.Pointer(m)) = (d + insertOrDeleteCost(tls, cAprev, cA, cAnext))
		cBprev = int8(0)
		for xB = 1; xB <= nB; xB++ {
			var totalCost int32
			var insCost int32
			var delCost int32
			var subCost int32
			var ncx int32
			cB = *(*int8)(unsafe.Pointer(zB + uintptr((xB - 1))))
			cBnext = *(*int8)(unsafe.Pointer(zB + uintptr(xB)))

			// Cost to insert cB
			insCost = insertOrDeleteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr((xB - 1)))), cB, cBnext)
			if lastA != 0 {
				insCost = insCost / (FINAL_INS_COST_DIV)
			}

			// Cost to delete cA
			delCost = insertOrDeleteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr(xB))), cA, cBnext)

			// Cost to substitute cA->cB
			subCost = substituteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr((xB - 1)))), cA, cB)

			// Best cost
			totalCost = (insCost + *(*int32)(unsafe.Pointer(m + uintptr((xB-1))*4)))
			ncx = int32(cB)
			if (delCost + *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))) < totalCost {
				totalCost = (delCost + *(*int32)(unsafe.Pointer(m + uintptr(xB)*4)))
				ncx = int32(cA)
			}
			if (subCost + d) < totalCost {
				totalCost = (subCost + d)
			}

			// Update the matrix
			d = *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))
			dc = int32(*(*int8)(unsafe.Pointer(cx + uintptr(xB))))
			*(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) = totalCost
			*(*int8)(unsafe.Pointer(cx + uintptr(xB))) = int8(ncx)
			cBprev = cB
		}
		cAprev = cA
	}

	// Free the wagner matrix and return the result
	if int32(cA) == '*' {
		res = *(*int32)(unsafe.Pointer(m + 1*4))
		for xB = 1; xB <= nB; xB++ {
			if *(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) < res {
				res = *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))
				if pnMatch != 0 {
					*(*int32)(unsafe.Pointer(pnMatch)) = (xB + nMatch)
				}
			}
		}
	} else {
		res = *(*int32)(unsafe.Pointer(m + uintptr(nB)*4))
		// In the current implementation, pnMatch is always NULL if zA does
		// not end in "*"

	}
	sqlite3.Xsqlite3_free(tls, toFree)
	return res
}

// Function:    editdist(A,B)
//
// Return the cost of transforming string A into string B.  Both strings
// must be pure ASCII text.  If A ends with '*' then it is assumed to be
// a prefix of B and extra characters on the end of B have minimal additional
// cost.
func editdistSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:518:13: */
	var res int32 = editdist1(tls,
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))),
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))),
		uintptr(0))
	if res < 0 {
		if res == (-3) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else if res == (-2) {
			sqlite3.Xsqlite3_result_error(tls, context, ts+6498 /* "non-ASCII input ..." */, -1)
		} else {
			sqlite3.Xsqlite3_result_error(tls, context, ts+6528 /* "NULL input to ed..." */, -1)
		}
	} else {
		sqlite3.Xsqlite3_result_int(tls, context, res)
	}
}

// End of the fixed-cost edit distance implementation
//
//
// Begin: Configurable cost unicode edit distance routines
// Forward declaration of structures
type EditDist3Cost1 = struct {
	FpNext uintptr
	FnFrom u8
	FnTo   u8
	FiCost u16
	Fa     [4]int8
} /* spellfix.c:546:9 */

// End of the fixed-cost edit distance implementation
//
//
// Begin: Configurable cost unicode edit distance routines
// Forward declaration of structures
type EditDist3Cost = EditDist3Cost1 /* spellfix.c:546:30 */
type EditDist3Config1 = struct {
	FnLang int32
	Fa     uintptr
} /* spellfix.c:547:9 */

type EditDist3Config = EditDist3Config1 /* spellfix.c:547:32 */
type EditDist3From1 = struct {
	FnSubst  int32
	FnDel    int32
	FnByte   int32
	FapSubst uintptr
	FapDel   uintptr
} /* spellfix.c:549:9 */

type EditDist3From = EditDist3From1 /* spellfix.c:549:30 */
type EditDist3FromString1 = struct {
	Fz        uintptr
	Fn        int32
	FisPrefix int32
	Fa        uintptr
} /* spellfix.c:550:9 */

type EditDist3FromString = EditDist3FromString1 /* spellfix.c:550:36 */
type EditDist3To1 = struct {
	FnIns  int32
	FnByte int32
	FapIns uintptr
} /* spellfix.c:551:9 */

type EditDist3To = EditDist3To1 /* spellfix.c:551:28 */
type EditDist3ToString1 = struct {
	Fz uintptr
	Fn int32
	Fa uintptr
} /* spellfix.c:552:9 */

type EditDist3ToString = EditDist3ToString1 /* spellfix.c:552:34 */
type EditDist3Lang1 = struct {
	FiLang    int32
	FiInsCost int32
	FiDelCost int32
	FiSubCost int32
	FpCost    uintptr
} /* spellfix.c:547:9 */

type EditDist3Lang = EditDist3Lang1 /* spellfix.c:553:30 */

// The default EditDist3Lang object, with default costs.
var editDist3Lang = EditDist3Lang{FiInsCost: 100, FiDelCost: 100, FiSubCost: 150} /* spellfix.c:583:28 */

// Clear or delete an instance of the object that records all edit-distance
// weights.
func editDist3ConfigClear(tls *libc.TLS, p uintptr) { /* spellfix.c:640:13: */
	var i int32
	if p == uintptr(0) {
		return
	}
	for i = 0; i < (*EditDist3Config)(unsafe.Pointer(p)).FnLang; i++ {
		var pCost uintptr
		var pNext uintptr
		pCost = (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr(i)*20)).FpCost
		for pCost != 0 {
			pNext = (*EditDist3Cost)(unsafe.Pointer(pCost)).FpNext
			sqlite3.Xsqlite3_free(tls, pCost)
			pCost = pNext
		}
	}
	sqlite3.Xsqlite3_free(tls, (*EditDist3Config)(unsafe.Pointer(p)).Fa)
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(EditDist3Config{})))
}

func editDist3ConfigDelete(tls *libc.TLS, pIn uintptr) { /* spellfix.c:655:13: */
	var p uintptr = pIn
	editDist3ConfigClear(tls, p)
	sqlite3.Xsqlite3_free(tls, p)
}

// Compare the FROM values of two EditDist3Cost objects, for sorting.
// Return negative, zero, or positive if the A is less than, equal to,
// or greater than B.
func editDist3CostCompare(tls *libc.TLS, pA uintptr, pB uintptr) int32 { /* spellfix.c:665:12: */
	var n int32 = int32((*EditDist3Cost)(unsafe.Pointer(pA)).FnFrom)
	var rc int32
	if n > int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom) {
		n = int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom)
	}
	rc = libc.Xstrncmp(tls, pA+8 /* &.a */, pB+8 /* &.a */, uint32(n))
	if rc == 0 {
		rc = (int32((*EditDist3Cost)(unsafe.Pointer(pA)).FnFrom) - int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom))
	}
	return rc
}

// Merge together two sorted lists of EditDist3Cost objects, in order
// of increasing FROM.
func editDist3CostMerge(tls *libc.TLS, pA uintptr, pB uintptr) uintptr { /* spellfix.c:678:22: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*uintptr)(unsafe.Pointer(bp /* pHead */)) = uintptr(0)
	var ppTail uintptr = bp /* &pHead */
	var p uintptr
	for (pA != 0) && (pB != 0) {
		if editDist3CostCompare(tls, pA, pB) <= 0 {
			p = pA
			pA = (*EditDist3Cost)(unsafe.Pointer(pA)).FpNext
		} else {
			p = pB
			pB = (*EditDist3Cost)(unsafe.Pointer(pB)).FpNext
		}
		*(*uintptr)(unsafe.Pointer(ppTail)) = p
		ppTail = (p /* &.pNext */)
	}
	if pA != 0 {
		*(*uintptr)(unsafe.Pointer(ppTail)) = pA
	} else {
		*(*uintptr)(unsafe.Pointer(ppTail)) = pB
	}
	return *(*uintptr)(unsafe.Pointer(bp /* pHead */))
}

// Sort a list of EditDist3Cost objects into order of increasing FROM
func editDist3CostSort(tls *libc.TLS, pList uintptr) uintptr { /* spellfix.c:707:22: */
	bp := tls.Alloc(240)
	defer tls.Free(240)

	// var ap [60]uintptr at bp, 240

	var p uintptr
	var i int32
	var mx int32 = 0
	*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + 1*4)) = uintptr(0)
	for pList != 0 {
		p = pList
		pList = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext
		(*EditDist3Cost)(unsafe.Pointer(p)).FpNext = uintptr(0)
		for i = 0; *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*4)) != 0; i++ {
			p = editDist3CostMerge(tls, *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*4)), p)
			*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*4)) = uintptr(0)
		}
		*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*4)) = p
		if i > mx {
			mx = i
			*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr((i+1))*4)) = uintptr(0)
		}
	}
	p = uintptr(0)
	for i = 0; i <= mx; i++ {
		if *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*4)) != 0 {
			p = editDist3CostMerge(tls, p, *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*4)))
		}
	}
	return p
}

// Load all edit-distance weights from a table.
func editDist3ConfigLoad(tls *libc.TLS, p uintptr, db uintptr, zTable uintptr) int32 { /* spellfix.c:737:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var pStmt uintptr at bp+8, 4

	var rc int32
	var rc2 int32
	var zSql uintptr
	var iLangPrev int32 = -9999
	var pLang uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+6553 /* "SELECT iLang, cF..." */, libc.VaList(bp, zTable))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+8 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		return rc
	}
	editDist3ConfigClear(tls, p)
	for sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */))) == SQLITE_ROW {
		var iLang int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 0)
		var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
		var nFrom int32
		if zFrom != 0 {
			nFrom = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
		} else {
			nFrom = 0
		}
		var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 2)
		var nTo int32
		if zTo != 0 {
			nTo = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 2)
		} else {
			nTo = 0
		}
		var iCost int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 3)

		if (nFrom > 100) || (nTo > 100) {
			continue
		}
		if iCost < 0 {
			continue
		}
		if iCost >= 10000 {
			continue
		} // Costs above 10K are considered infinite
		if (pLang == uintptr(0)) || (iLang != iLangPrev) {
			var pNew uintptr
			pNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3Config)(unsafe.Pointer(p)).Fa, (uint64((uint32((*EditDist3Config)(unsafe.Pointer(p)).FnLang + 1)) * uint32(unsafe.Sizeof(EditDist3Lang{})))))
			if pNew == uintptr(0) {
				rc = SQLITE_NOMEM
				break
			}
			(*EditDist3Config)(unsafe.Pointer(p)).Fa = pNew
			pLang = ((*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr((*EditDist3Config)(unsafe.Pointer(p)).FnLang)*20)
			(*EditDist3Config)(unsafe.Pointer(p)).FnLang++
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiLang = iLang
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost = 100
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost = 100
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost = 150
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost = uintptr(0)
			iLangPrev = iLang
		}
		if ((nFrom == 1) && (int32(*(*int8)(unsafe.Pointer(zFrom))) == '?')) && (nTo == 0) {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost = iCost
		} else if ((nFrom == 0) && (nTo == 1)) && (int32(*(*int8)(unsafe.Pointer(zTo))) == '?') {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost = iCost
		} else if (((nFrom == 1) && (nTo == 1)) && (int32(*(*int8)(unsafe.Pointer(zFrom))) == '?')) && (int32(*(*int8)(unsafe.Pointer(zTo))) == '?') {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost = iCost
		} else {
			var pCost uintptr
			var nExtra int32 = ((nFrom + nTo) - 4)
			if nExtra < 0 {
				nExtra = 0
			}
			pCost = sqlite3.Xsqlite3_malloc64(tls, (uint64(uint32(unsafe.Sizeof(EditDist3Cost{})) + uint32(nExtra))))
			if pCost == uintptr(0) {
				rc = SQLITE_NOMEM
				break
			}
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FnFrom = u8(nFrom)
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FnTo = u8(nTo)
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FiCost = u16(iCost)
			libc.Xmemcpy(tls, pCost+8 /* &.a */, zFrom, uint32(nFrom))
			libc.Xmemcpy(tls, ((pCost + 8 /* &.a */) + uintptr(nFrom)), zTo, uint32(nTo))
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FpNext = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost = pCost
		}
	}
	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
	if rc == SQLITE_OK {
		rc = rc2
	}
	if rc == SQLITE_OK {
		var iLang int32
		for iLang = 0; iLang < (*EditDist3Config)(unsafe.Pointer(p)).FnLang; iLang++ {
			(*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr(iLang)*20)).FpCost = editDist3CostSort(tls, (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa+uintptr(iLang)*20)).FpCost)
		}
	}
	return rc
}

// Return the length (in bytes) of a utf-8 character.  Or return a maximum
// of N.
func utf8Len(tls *libc.TLS, c uint8, N int32) int32 { /* spellfix.c:818:12: */
	var len int32 = 1
	if int32(c) > 0x7f {
		if (int32(c) & 0xe0) == 0xc0 {
			len = 2
		} else if (int32(c) & 0xf0) == 0xe0 {
			len = 3
		} else {
			len = 4
		}
	}
	if len > N {
		len = N
	}
	return len
}

// Return TRUE (non-zero) if the To side of the given cost matches
// the given string.
func matchTo(tls *libc.TLS, p uintptr, z uintptr, n int32) int32 { /* spellfix.c:837:12: */

	if int32(*(*int8)(unsafe.Pointer((p + 8 /* &.a */) + uintptr((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)))) != int32(*(*int8)(unsafe.Pointer(z))) {
		return 0
	}
	if int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo) > n {
		return 0
	}
	if libc.Xstrncmp(tls, ((p+8 /* &.a */)+uintptr((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)), z, uint32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo)) != 0 {
		return 0
	}
	return 1
}

// Return TRUE (non-zero) if the From side of the given cost matches
// the given string.
func matchFrom(tls *libc.TLS, p uintptr, z uintptr, n int32) int32 { /* spellfix.c:849:12: */

	if (*EditDist3Cost)(unsafe.Pointer(p)).FnFrom != 0 {
		if int32(*(*int8)(unsafe.Pointer((p + 8 /* &.a */)))) != int32(*(*int8)(unsafe.Pointer(z))) {
			return 0
		}
		if libc.Xstrncmp(tls, p+8 /* &.a */, z, uint32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)) != 0 {
			return 0
		}
	}
	return 1
}

// Return TRUE (non-zero) of the next FROM character and the next TO
// character are the same.
func matchFromTo(tls *libc.TLS, pStr uintptr, n1 int32, z2 uintptr, n2 int32) int32 { /* spellfix.c:862:12: */
	var b1 int32 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(n1)*20)).FnByte
	if b1 > n2 {
		return 0
	}

	if int32(*(*int8)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fz + uintptr(n1)))) != int32(*(*int8)(unsafe.Pointer(z2))) {
		return 0
	}
	if libc.Xstrncmp(tls, ((*EditDist3FromString)(unsafe.Pointer(pStr)).Fz+uintptr(n1)), z2, uint32(b1)) != 0 {
		return 0
	}
	return 1
}

// Delete an EditDist3FromString objecct
func editDist3FromStringDelete(tls *libc.TLS, p uintptr) { /* spellfix.c:879:13: */
	var i int32
	if p != 0 {
		for i = 0; i < (*EditDist3FromString)(unsafe.Pointer(p)).Fn; i++ {
			sqlite3.Xsqlite3_free(tls, (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(p)).Fa+uintptr(i)*20)).FapDel)
			sqlite3.Xsqlite3_free(tls, (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(p)).Fa+uintptr(i)*20)).FapSubst)
		}
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Create a EditDist3FromString object.
func editDist3FromStringNew(tls *libc.TLS, pLang uintptr, z uintptr, n int32) uintptr { /* spellfix.c:893:28: */
	var pStr uintptr
	var p uintptr
	var i int32

	if z == uintptr(0) {
		return uintptr(0)
	}
	if n < 0 {
		n = int32(libc.Xstrlen(tls, z))
	}
	pStr = sqlite3.Xsqlite3_malloc64(tls, (uint64(((uint32(unsafe.Sizeof(EditDist3FromString{})) + (uint32(unsafe.Sizeof(EditDist3From{})) * uint32(n))) + uint32(n)) + uint32(1))))
	if pStr == uintptr(0) {
		return uintptr(0)
	}
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fa = (pStr + 1*16)
	libc.Xmemset(tls, (*EditDist3FromString)(unsafe.Pointer(pStr)).Fa, 0, (uint32(unsafe.Sizeof(EditDist3From{})) * uint32(n)))
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fn = n
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fz = ((*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(n)*20)
	libc.Xmemcpy(tls, (*EditDist3FromString)(unsafe.Pointer(pStr)).Fz, z, (uint32(n + 1)))
	if (n != 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr((n - 1))))) == '*') {
		(*EditDist3FromString)(unsafe.Pointer(pStr)).FisPrefix = 1
		n--
		(*EditDist3FromString)(unsafe.Pointer(pStr)).Fn--
		*(*int8)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fz + uintptr(n))) = int8(0)
	} else {
		(*EditDist3FromString)(unsafe.Pointer(pStr)).FisPrefix = 0
	}

	for i = 0; i < n; i++ {
		var pFrom uintptr = ((*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(i)*20)
		libc.Xmemset(tls, pFrom, 0, uint32(unsafe.Sizeof(EditDist3From{})))
		(*EditDist3From)(unsafe.Pointer(pFrom)).FnByte = utf8Len(tls, uint8(*(*int8)(unsafe.Pointer(z + uintptr(i)))), (n - i))
		for p = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost; p != 0; p = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext {
			var apNew uintptr
			if (i + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)) > n {
				continue
			}
			if matchFrom(tls, p, (z+uintptr(i)), (n-i)) == 0 {
				continue
			}
			if int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo) == 0 {
				apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3From)(unsafe.Pointer(pFrom)).FapDel,
					(uint64(uint32(unsafe.Sizeof(uintptr(0))) * (uint32((*EditDist3From)(unsafe.Pointer(pFrom)).FnDel + 1)))))
				if apNew == uintptr(0) {
					break
				}
				(*EditDist3From)(unsafe.Pointer(pFrom)).FapDel = apNew
				*(*uintptr)(unsafe.Pointer(apNew + uintptr(libc.PostIncInt32(&(*EditDist3From)(unsafe.Pointer(pFrom)).FnDel, 1))*4)) = p
			} else {
				apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3From)(unsafe.Pointer(pFrom)).FapSubst,
					(uint64(uint32(unsafe.Sizeof(uintptr(0))) * (uint32((*EditDist3From)(unsafe.Pointer(pFrom)).FnSubst + 1)))))
				if apNew == uintptr(0) {
					break
				}
				(*EditDist3From)(unsafe.Pointer(pFrom)).FapSubst = apNew
				*(*uintptr)(unsafe.Pointer(apNew + uintptr(libc.PostIncInt32(&(*EditDist3From)(unsafe.Pointer(pFrom)).FnSubst, 1))*4)) = p
			}
		}
		if p != 0 {
			editDist3FromStringDelete(tls, pStr)
			pStr = uintptr(0)
			break
		}
	}
	return pStr
}

// Update entry m[i] such that it is the minimum of its current value
// and m[j]+iCost.
func updateCost(tls *libc.TLS, m uintptr, i int32, j int32, iCost int32) { /* spellfix.c:955:13: */
	var b uint32

	b = (*(*uint32)(unsafe.Pointer(m + uintptr(j)*4)) + uint32(iCost))
	if b < *(*uint32)(unsafe.Pointer(m + uintptr(i)*4)) {
		*(*uint32)(unsafe.Pointer(m + uintptr(i)*4)) = b
	}
}

// How much stack space (int bytes) to use for Wagner matrix in
// editDist3Core().  If more space than this is required, the entire
// matrix is taken from the heap.  To reduce the load on the memory
// allocator, make this value as large as practical for the
// architecture in use.

// Compute the edit distance between two strings.
//
// If an error occurs, return a negative number which is the error code.
//
// If pnMatch is not NULL, then *pnMatch is set to the number of characters
// (not bytes) in z2 that matched the search pattern in *pFrom. If pFrom does
// not contain the pattern for a prefix-search, then this is always the number
// of characters in z2. If pFrom does contain a prefix search pattern, then
// it is the number of characters in the prefix of z2 that was deemed to
// match pFrom.
func editDist3Core(tls *libc.TLS, pFrom uintptr, z2 uintptr, n2 int32, pLang uintptr, pnMatch uintptr) int32 { /* spellfix.c:990:12: */
	bp := tls.Alloc(1040)
	defer tls.Free(1040)

	var k int32
	var n int32
	var i1 int32
	var b1 int32
	var i2 int32
	var b2 int32
	// var f EditDist3FromString at bp+1024, 16

	var a2 uintptr
	var m uintptr
	var pToFree uintptr
	var szRow int32
	var p uintptr
	var res int32
	var nByte sqlite3_uint64
	// var stackSpace [256]uint32 at bp, 1024

	var apNew uintptr
	var cx int32  // Index of current cell
	var cxp int32 // Index of cell immediately to the left
	var cxd int32 // Index of cell to the left and one row above
	var cxu int32
	var rx int32 // Starting index for current row
	var rxp int32
	var b int32
	var nExtra int32
	*(*EditDist3FromString)(unsafe.Pointer(bp + 1024 /* f */)) = *(*EditDist3FromString)(unsafe.Pointer(pFrom))

	// allocate the Wagner matrix and the aTo[] array for the TO string
	n = (((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fn + 1) * (n2 + 1))
	n = ((n + 1) & libc.CplInt32(1))
	nByte = (sqlite3_uint64((uint32(n) * uint32(unsafe.Sizeof(uint32(0)))) + (uint32(unsafe.Sizeof(EditDist3To{})) * uint32(n2))))
	if !(nByte <= sqlite3_uint64(unsafe.Sizeof([256]uint32{}))) {
		goto __1
	}
	m = bp /* &stackSpace[0] */
	pToFree = uintptr(0)
	goto __2
__1:
	m = libc.AssignUintptr(&pToFree, sqlite3.Xsqlite3_malloc64(tls, nByte))
	if !(m == uintptr(0)) {
		goto __3
	}
	return -1
__3:
	; // Out of memory
__2:
	;
	a2 = (m + uintptr(n)*4)
	libc.Xmemset(tls, a2, 0, (uint32(unsafe.Sizeof(EditDist3To{})) * uint32(n2)))

	// Fill in the a1[] matrix for all characters of the TO string
	i2 = 0
__4:
	if !(i2 < n2) {
		goto __6
	}
	(*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*12)).FnByte = utf8Len(tls, uint8(*(*int8)(unsafe.Pointer(z2 + uintptr(i2)))), (n2 - i2))
	p = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost
__7:
	if !(p != 0) {
		goto __9
	}
	if !(int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom) > 0) {
		goto __10
	}
	goto __9
__10:
	;
	if !((i2 + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo)) > n2) {
		goto __11
	}
	goto __8
__11:
	;
	if !(int32(*(*int8)(unsafe.Pointer((p + 8 /* &.a */)))) > int32(*(*int8)(unsafe.Pointer(z2 + uintptr(i2))))) {
		goto __12
	}
	goto __9
__12:
	;
	if !(matchTo(tls, p, (z2+uintptr(i2)), (n2-i2)) == 0) {
		goto __13
	}
	goto __8
__13:
	;
	(*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FnIns++
	apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FapIns, (uint64(uint32(unsafe.Sizeof(uintptr(0))) * uint32((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FnIns))))
	if !(apNew == uintptr(0)) {
		goto __14
	}
	res = -1 // Out of memory
	goto editDist3Abort
__14:
	;
	(*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*12)).FapIns = apNew
	*(*uintptr)(unsafe.Pointer((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FapIns + uintptr(((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FnIns-1))*4)) = p
	goto __8
__8:
	p = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext
	goto __7
	goto __9
__9:
	;
	goto __5
__5:
	i2++
	goto __4
	goto __6
__6:
	;

	// Prepare to compute the minimum edit distance
	szRow = ((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fn + 1)
	libc.Xmemset(tls, m, 0x01, ((uint32((n2 + 1) * szRow)) * uint32(unsafe.Sizeof(uint32(0)))))
	*(*uint32)(unsafe.Pointer(m)) = uint32(0)

	// First fill in the top-row of the matrix with FROM deletion costs
	i1 = 0
__15:
	if !(i1 < (*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fn) {
		goto __17
	}
	b1 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa + uintptr(i1)*20)).FnByte
	updateCost(tls, m, (i1 + b1), i1, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost)
	k = 0
__18:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*20)).FnDel) {
		goto __20
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*20)).FapDel + uintptr(k)*4))
	updateCost(tls, m, (i1 + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)), i1, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __19
__19:
	k++
	goto __18
	goto __20
__20:
	;
	goto __16
__16:
	i1 = i1 + (b1)
	goto __15
	goto __17
__17:
	;

	// Fill in all subsequent rows, top-to-bottom, left-to-right
	i2 = 0
__21:
	if !(i2 < n2) {
		goto __23
	} // Starting index for previous row
	b2 = (*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*12)).FnByte
	rx = (szRow * (i2 + b2))
	rxp = (szRow * i2)
	updateCost(tls, m, rx, rxp, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost)
	k = 0
__24:
	if !(k < (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FnIns) {
		goto __26
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FapIns + uintptr(k)*4))
	updateCost(tls, m, (szRow * (i2 + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo))), rxp, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __25
__25:
	k++
	goto __24
	goto __26
__26:
	;
	i1 = 0
__27:
	if !(i1 < (*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fn) {
		goto __29
	} // Index of cell immediately above
	b1 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa + uintptr(i1)*20)).FnByte
	cxp = (rx + i1)
	cx = (cxp + b1)
	cxd = (rxp + i1)
	cxu = (cxd + b1)
	updateCost(tls, m, cx, cxp, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost)
	k = 0
__30:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*20)).FnDel) {
		goto __32
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*20)).FapDel + uintptr(k)*4))
	updateCost(tls, m, (cxp + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)), cxp, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __31
__31:
	k++
	goto __30
	goto __32
__32:
	;
	updateCost(tls, m, cx, cxu, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost)
	if !(matchFromTo(tls, bp+1024 /* &f */, i1, (z2+uintptr(i2)), (n2-i2)) != 0) {
		goto __33
	}
	updateCost(tls, m, cx, cxd, 0)
__33:
	;
	updateCost(tls, m, cx, cxd, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost)
	k = 0
__34:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*20)).FnSubst) {
		goto __36
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*20)).FapSubst + uintptr(k)*4))
	if !(matchTo(tls, p, (z2+uintptr(i2)), (n2-i2)) != 0) {
		goto __37
	}
	updateCost(tls, m, ((cxd + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)) + (szRow * int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo))), cxd, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
__37:
	;
	goto __35
__35:
	k++
	goto __34
	goto __36
__36:
	;
	goto __28
__28:
	i1 = i1 + (b1)
	goto __27
	goto __29
__29:
	;
	goto __22
__22:
	i2 = i2 + (b2)
	goto __21
	goto __23
__23:
	;

	// Free memory allocations and return the result
	res = int32(*(*uint32)(unsafe.Pointer(m + uintptr(((szRow*(n2+1))-1))*4)))
	n = n2
	if !((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).FisPrefix != 0) {
		goto __38
	}
	i2 = 1
__39:
	if !(i2 <= n2) {
		goto __41
	}
	b = int32(*(*uint32)(unsafe.Pointer(m + uintptr(((szRow*i2)-1))*4)))
	if !(b <= res) {
		goto __42
	}
	res = b
	n = (i2 - 1)
__42:
	;
	goto __40
__40:
	i2++
	goto __39
	goto __41
__41:
	;
__38:
	;
	if !(pnMatch != 0) {
		goto __43
	}
	nExtra = 0
	k = 0
__44:
	if !(k < n) {
		goto __46
	}
	if !((int32(*(*int8)(unsafe.Pointer(z2 + uintptr(k)))) & 0xc0) == 0x80) {
		goto __47
	}
	nExtra++
__47:
	;
	goto __45
__45:
	k++
	goto __44
	goto __46
__46:
	;
	*(*int32)(unsafe.Pointer(pnMatch)) = (n - nExtra)
__43:
	;

editDist3Abort:
	i2 = 0
__48:
	if !(i2 < n2) {
		goto __50
	}
	sqlite3.Xsqlite3_free(tls, (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FapIns)
	goto __49
__49:
	i2++
	goto __48
	goto __50
__50:
	;
	sqlite3.Xsqlite3_free(tls, pToFree)
	return res
}

// Get an appropriate EditDist3Lang object.
func editDist3FindLang(tls *libc.TLS, pConfig uintptr, iLang int32) uintptr { /* spellfix.c:1150:28: */
	var i int32
	for i = 0; i < (*EditDist3Config)(unsafe.Pointer(pConfig)).FnLang; i++ {
		if (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(pConfig)).Fa+uintptr(i)*20)).FiLang == iLang {
			return ((*EditDist3Config)(unsafe.Pointer(pConfig)).Fa + uintptr(i)*20)
		}
	}
	return uintptr(unsafe.Pointer(&editDist3Lang))
}

// Function:    editdist3(A,B,iLang)
//              editdist3(tablename)
//
// Return the cost of transforming string A into string B using edit
// weights for iLang.
//
// The second form loads edit weights into memory from a table.
func editDist3SqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:1170:13: */
	var pConfig uintptr = sqlite3.Xsqlite3_user_data(tls, context)
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var rc int32
	if argc == 1 {
		var zTable uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		rc = editDist3ConfigLoad(tls, pConfig, db, zTable)
		if rc != 0 {
			sqlite3.Xsqlite3_result_error_code(tls, context, rc)
		}
	} else {
		var zA uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var zB uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		var nA int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var nB int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		var iLang int32
		if argc == 3 {
			iLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
		} else {
			iLang = 0
		}
		var pLang uintptr = editDist3FindLang(tls, pConfig, iLang)
		var pFrom uintptr
		var dist int32

		pFrom = editDist3FromStringNew(tls, pLang, zA, nA)
		if pFrom == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
		dist = editDist3Core(tls, pFrom, zB, nB, pLang, uintptr(0))
		editDist3FromStringDelete(tls, pFrom)
		if dist == (-1) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else {
			sqlite3.Xsqlite3_result_int(tls, context, dist)
		}
	}
}

// Register the editDist3 function with SQLite
func editDist3Install(tls *libc.TLS, db uintptr) int32 { /* spellfix.c:1210:12: */
	var rc int32
	var pConfig uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(EditDist3Config{})))
	if pConfig == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pConfig, 0, uint32(unsafe.Sizeof(EditDist3Config{})))
	rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+6625, /* "editdist3" */
		2, (SQLITE_UTF8 | SQLITE_DETERMINISTIC), pConfig,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{editDist3SqlFunc})), uintptr(0), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+6625, /* "editdist3" */
			3, (SQLITE_UTF8 | SQLITE_DETERMINISTIC), pConfig,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{editDist3SqlFunc})), uintptr(0), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+6625, /* "editdist3" */
			1, (SQLITE_UTF8 | SQLITE_DETERMINISTIC), pConfig,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{editDist3SqlFunc})), uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{editDist3ConfigDelete})))
	} else {
		sqlite3.Xsqlite3_free(tls, pConfig)
	}
	return rc
}

// End configurable cost unicode edit distance routines
//
//
// Begin transliterate unicode-to-ascii implementation

// This lookup table is used to help decode the first byte of
// a multi-byte UTF8 character.
var sqlite3Utf8Trans1 = [64]uint8{
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x10), uint8(0x11), uint8(0x12), uint8(0x13), uint8(0x14), uint8(0x15), uint8(0x16), uint8(0x17),
	uint8(0x18), uint8(0x19), uint8(0x1a), uint8(0x1b), uint8(0x1c), uint8(0x1d), uint8(0x1e), uint8(0x1f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x00), uint8(0x01), uint8(0x00), uint8(0x00),
} /* spellfix.c:1243:28 */

// Return the value of the first UTF-8 character in the string.
func utf8Read(tls *libc.TLS, z uintptr, n int32, pSize uintptr) int32 { /* spellfix.c:1258:12: */
	var c int32
	var i int32

	// All callers to this routine (in the current implementation)
	// always have n>0.
	if 0 != 0 {
		c = libc.AssignInt32(&i, 0)
	} else {
		c = int32(*(*uint8)(unsafe.Pointer(z)))
		i = 1
		if c >= 0xc0 {
			c = int32(sqlite3Utf8Trans1[(c - 0xc0)])
			for (i < n) && ((int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) & 0xc0) == 0x80) {
				c = ((c << 6) + (0x3f & int32(*(*uint8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))))))
			}
		}
	}
	*(*int32)(unsafe.Pointer(pSize)) = i
	return c
}

// Return the number of characters in the utf-8 string in the nIn byte
// buffer pointed to by zIn.
func utf8Charlen(tls *libc.TLS, zIn uintptr, nIn int32) int32 { /* spellfix.c:1283:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	var nChar int32 = 0
	for i = 0; i < nIn; nChar++ {
		// var sz int32 at bp, 4

		utf8Read(tls, (zIn + uintptr(i)), (nIn - i), bp /* &sz */)
		i = i + (*(*int32)(unsafe.Pointer(bp /* sz */)))
	}
	return nChar
}

type Transliteration1 = struct {
	FcFrom uint16
	FcTo0  uint8
	FcTo1  uint8
	FcTo2  uint8
	FcTo3  uint8
} /* spellfix.c:1294:9 */

type Transliteration = Transliteration1 /* spellfix.c:1294:32 */

// Table of translations from unicode characters into ASCII.
var translit = [389]Transliteration{
	{FcFrom: uint16(0x00A0), FcTo0: uint8(0x20)},                                                             //  to
	{FcFrom: uint16(0x00B5), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x00C0), FcTo0: uint8(0x41)},                                                             //  to A
	{FcFrom: uint16(0x00C1), FcTo0: uint8(0x41)},                                                             //  to A
	{FcFrom: uint16(0x00C2), FcTo0: uint8(0x41)},                                                             //  to A
	{FcFrom: uint16(0x00C3), FcTo0: uint8(0x41)},                                                             //  to A
	{FcFrom: uint16(0x00C4), FcTo0: uint8(0x41), FcTo1: uint8(0x65)},                                         //  to Ae
	{FcFrom: uint16(0x00C5), FcTo0: uint8(0x41), FcTo1: uint8(0x61)},                                         //  to Aa
	{FcFrom: uint16(0x00C6), FcTo0: uint8(0x41), FcTo1: uint8(0x45)},                                         //  to AE
	{FcFrom: uint16(0x00C7), FcTo0: uint8(0x43)},                                                             //  to C
	{FcFrom: uint16(0x00C8), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x00C9), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x00CA), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x00CB), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x00CC), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x00CD), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x00CE), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x00CF), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x00D0), FcTo0: uint8(0x44)},                                                             //  to D
	{FcFrom: uint16(0x00D1), FcTo0: uint8(0x4E)},                                                             //  to N
	{FcFrom: uint16(0x00D2), FcTo0: uint8(0x4F)},                                                             //  to O
	{FcFrom: uint16(0x00D3), FcTo0: uint8(0x4F)},                                                             //  to O
	{FcFrom: uint16(0x00D4), FcTo0: uint8(0x4F)},                                                             //  to O
	{FcFrom: uint16(0x00D5), FcTo0: uint8(0x4F)},                                                             //  to O
	{FcFrom: uint16(0x00D6), FcTo0: uint8(0x4F), FcTo1: uint8(0x65)},                                         //  to Oe
	{FcFrom: uint16(0x00D7), FcTo0: uint8(0x78)},                                                             //  to x
	{FcFrom: uint16(0x00D8), FcTo0: uint8(0x4F)},                                                             //  to O
	{FcFrom: uint16(0x00D9), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x00DA), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x00DB), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x00DC), FcTo0: uint8(0x55), FcTo1: uint8(0x65)},                                         //  to Ue
	{FcFrom: uint16(0x00DD), FcTo0: uint8(0x59)},                                                             //  to Y
	{FcFrom: uint16(0x00DE), FcTo0: uint8(0x54), FcTo1: uint8(0x68)},                                         //  to Th
	{FcFrom: uint16(0x00DF), FcTo0: uint8(0x73), FcTo1: uint8(0x73)},                                         //  to ss
	{FcFrom: uint16(0x00E0), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x00E1), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x00E2), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x00E3), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x00E4), FcTo0: uint8(0x61), FcTo1: uint8(0x65)},                                         //  to ae
	{FcFrom: uint16(0x00E5), FcTo0: uint8(0x61), FcTo1: uint8(0x61)},                                         //  to aa
	{FcFrom: uint16(0x00E6), FcTo0: uint8(0x61), FcTo1: uint8(0x65)},                                         //  to ae
	{FcFrom: uint16(0x00E7), FcTo0: uint8(0x63)},                                                             //  to c
	{FcFrom: uint16(0x00E8), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x00E9), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x00EA), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x00EB), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x00EC), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x00ED), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x00EE), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x00EF), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x00F0), FcTo0: uint8(0x64)},                                                             //  to d
	{FcFrom: uint16(0x00F1), FcTo0: uint8(0x6E)},                                                             //  to n
	{FcFrom: uint16(0x00F2), FcTo0: uint8(0x6F)},                                                             //  to o
	{FcFrom: uint16(0x00F3), FcTo0: uint8(0x6F)},                                                             //  to o
	{FcFrom: uint16(0x00F4), FcTo0: uint8(0x6F)},                                                             //  to o
	{FcFrom: uint16(0x00F5), FcTo0: uint8(0x6F)},                                                             //  to o
	{FcFrom: uint16(0x00F6), FcTo0: uint8(0x6F), FcTo1: uint8(0x65)},                                         //  to oe
	{FcFrom: uint16(0x00F7), FcTo0: uint8(0x3A)},                                                             //  to :
	{FcFrom: uint16(0x00F8), FcTo0: uint8(0x6F)},                                                             //  to o
	{FcFrom: uint16(0x00F9), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x00FA), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x00FB), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x00FC), FcTo0: uint8(0x75), FcTo1: uint8(0x65)},                                         //  to ue
	{FcFrom: uint16(0x00FD), FcTo0: uint8(0x79)},                                                             //  to y
	{FcFrom: uint16(0x00FE), FcTo0: uint8(0x74), FcTo1: uint8(0x68)},                                         //  to th
	{FcFrom: uint16(0x00FF), FcTo0: uint8(0x79)},                                                             //  to y
	{FcFrom: uint16(0x0100), FcTo0: uint8(0x41)},                                                             //  to A
	{FcFrom: uint16(0x0101), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x0102), FcTo0: uint8(0x41)},                                                             //  to A
	{FcFrom: uint16(0x0103), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x0104), FcTo0: uint8(0x41)},                                                             //  to A
	{FcFrom: uint16(0x0105), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x0106), FcTo0: uint8(0x43)},                                                             //  to C
	{FcFrom: uint16(0x0107), FcTo0: uint8(0x63)},                                                             //  to c
	{FcFrom: uint16(0x0108), FcTo0: uint8(0x43), FcTo1: uint8(0x68)},                                         //  to Ch
	{FcFrom: uint16(0x0109), FcTo0: uint8(0x63), FcTo1: uint8(0x68)},                                         //  to ch
	{FcFrom: uint16(0x010A), FcTo0: uint8(0x43)},                                                             //  to C
	{FcFrom: uint16(0x010B), FcTo0: uint8(0x63)},                                                             //  to c
	{FcFrom: uint16(0x010C), FcTo0: uint8(0x43)},                                                             //  to C
	{FcFrom: uint16(0x010D), FcTo0: uint8(0x63)},                                                             //  to c
	{FcFrom: uint16(0x010E), FcTo0: uint8(0x44)},                                                             //  to D
	{FcFrom: uint16(0x010F), FcTo0: uint8(0x64)},                                                             //  to d
	{FcFrom: uint16(0x0110), FcTo0: uint8(0x44)},                                                             //  to D
	{FcFrom: uint16(0x0111), FcTo0: uint8(0x64)},                                                             //  to d
	{FcFrom: uint16(0x0112), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x0113), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x0114), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x0115), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x0116), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x0117), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x0118), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x0119), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x011A), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x011B), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x011C), FcTo0: uint8(0x47), FcTo1: uint8(0x68)},                                         //  to Gh
	{FcFrom: uint16(0x011D), FcTo0: uint8(0x67), FcTo1: uint8(0x68)},                                         //  to gh
	{FcFrom: uint16(0x011E), FcTo0: uint8(0x47)},                                                             //  to G
	{FcFrom: uint16(0x011F), FcTo0: uint8(0x67)},                                                             //  to g
	{FcFrom: uint16(0x0120), FcTo0: uint8(0x47)},                                                             //  to G
	{FcFrom: uint16(0x0121), FcTo0: uint8(0x67)},                                                             //  to g
	{FcFrom: uint16(0x0122), FcTo0: uint8(0x47)},                                                             //  to G
	{FcFrom: uint16(0x0123), FcTo0: uint8(0x67)},                                                             //  to g
	{FcFrom: uint16(0x0124), FcTo0: uint8(0x48), FcTo1: uint8(0x68)},                                         //  to Hh
	{FcFrom: uint16(0x0125), FcTo0: uint8(0x68), FcTo1: uint8(0x68)},                                         //  to hh
	{FcFrom: uint16(0x0126), FcTo0: uint8(0x48)},                                                             //  to H
	{FcFrom: uint16(0x0127), FcTo0: uint8(0x68)},                                                             //  to h
	{FcFrom: uint16(0x0128), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x0129), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x012A), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x012B), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x012C), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x012D), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x012E), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x012F), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x0130), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x0131), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x0132), FcTo0: uint8(0x49), FcTo1: uint8(0x4A)},                                         //  to IJ
	{FcFrom: uint16(0x0133), FcTo0: uint8(0x69), FcTo1: uint8(0x6A)},                                         //  to ij
	{FcFrom: uint16(0x0134), FcTo0: uint8(0x4A), FcTo1: uint8(0x68)},                                         //  to Jh
	{FcFrom: uint16(0x0135), FcTo0: uint8(0x6A), FcTo1: uint8(0x68)},                                         //  to jh
	{FcFrom: uint16(0x0136), FcTo0: uint8(0x4B)},                                                             //  to K
	{FcFrom: uint16(0x0137), FcTo0: uint8(0x6B)},                                                             //  to k
	{FcFrom: uint16(0x0138), FcTo0: uint8(0x6B)},                                                             //  to k
	{FcFrom: uint16(0x0139), FcTo0: uint8(0x4C)},                                                             //  to L
	{FcFrom: uint16(0x013A), FcTo0: uint8(0x6C)},                                                             //  to l
	{FcFrom: uint16(0x013B), FcTo0: uint8(0x4C)},                                                             //  to L
	{FcFrom: uint16(0x013C), FcTo0: uint8(0x6C)},                                                             //  to l
	{FcFrom: uint16(0x013D), FcTo0: uint8(0x4C)},                                                             //  to L
	{FcFrom: uint16(0x013E), FcTo0: uint8(0x6C)},                                                             //  to l
	{FcFrom: uint16(0x013F), FcTo0: uint8(0x4C), FcTo1: uint8(0x2E)},                                         //  to L.
	{FcFrom: uint16(0x0140), FcTo0: uint8(0x6C), FcTo1: uint8(0x2E)},                                         //  to l.
	{FcFrom: uint16(0x0141), FcTo0: uint8(0x4C)},                                                             //  to L
	{FcFrom: uint16(0x0142), FcTo0: uint8(0x6C)},                                                             //  to l
	{FcFrom: uint16(0x0143), FcTo0: uint8(0x4E)},                                                             //  to N
	{FcFrom: uint16(0x0144), FcTo0: uint8(0x6E)},                                                             //  to n
	{FcFrom: uint16(0x0145), FcTo0: uint8(0x4E)},                                                             //  to N
	{FcFrom: uint16(0x0146), FcTo0: uint8(0x6E)},                                                             //  to n
	{FcFrom: uint16(0x0147), FcTo0: uint8(0x4E)},                                                             //  to N
	{FcFrom: uint16(0x0148), FcTo0: uint8(0x6E)},                                                             //  to n
	{FcFrom: uint16(0x0149), FcTo0: uint8(0x27), FcTo1: uint8(0x6E)},                                         //  to 'n
	{FcFrom: uint16(0x014A), FcTo0: uint8(0x4E), FcTo1: uint8(0x47)},                                         //  to NG
	{FcFrom: uint16(0x014B), FcTo0: uint8(0x6E), FcTo1: uint8(0x67)},                                         //  to ng
	{FcFrom: uint16(0x014C), FcTo0: uint8(0x4F)},                                                             //  to O
	{FcFrom: uint16(0x014D), FcTo0: uint8(0x6F)},                                                             //  to o
	{FcFrom: uint16(0x014E), FcTo0: uint8(0x4F)},                                                             //  to O
	{FcFrom: uint16(0x014F), FcTo0: uint8(0x6F)},                                                             //  to o
	{FcFrom: uint16(0x0150), FcTo0: uint8(0x4F)},                                                             //  to O
	{FcFrom: uint16(0x0151), FcTo0: uint8(0x6F)},                                                             //  to o
	{FcFrom: uint16(0x0152), FcTo0: uint8(0x4F), FcTo1: uint8(0x45)},                                         //  to OE
	{FcFrom: uint16(0x0153), FcTo0: uint8(0x6F), FcTo1: uint8(0x65)},                                         //  to oe
	{FcFrom: uint16(0x0154), FcTo0: uint8(0x52)},                                                             //  to R
	{FcFrom: uint16(0x0155), FcTo0: uint8(0x72)},                                                             //  to r
	{FcFrom: uint16(0x0156), FcTo0: uint8(0x52)},                                                             //  to R
	{FcFrom: uint16(0x0157), FcTo0: uint8(0x72)},                                                             //  to r
	{FcFrom: uint16(0x0158), FcTo0: uint8(0x52)},                                                             //  to R
	{FcFrom: uint16(0x0159), FcTo0: uint8(0x72)},                                                             //  to r
	{FcFrom: uint16(0x015A), FcTo0: uint8(0x53)},                                                             //  to S
	{FcFrom: uint16(0x015B), FcTo0: uint8(0x73)},                                                             //  to s
	{FcFrom: uint16(0x015C), FcTo0: uint8(0x53), FcTo1: uint8(0x68)},                                         //  to Sh
	{FcFrom: uint16(0x015D), FcTo0: uint8(0x73), FcTo1: uint8(0x68)},                                         //  to sh
	{FcFrom: uint16(0x015E), FcTo0: uint8(0x53)},                                                             //  to S
	{FcFrom: uint16(0x015F), FcTo0: uint8(0x73)},                                                             //  to s
	{FcFrom: uint16(0x0160), FcTo0: uint8(0x53)},                                                             //  to S
	{FcFrom: uint16(0x0161), FcTo0: uint8(0x73)},                                                             //  to s
	{FcFrom: uint16(0x0162), FcTo0: uint8(0x54)},                                                             //  to T
	{FcFrom: uint16(0x0163), FcTo0: uint8(0x74)},                                                             //  to t
	{FcFrom: uint16(0x0164), FcTo0: uint8(0x54)},                                                             //  to T
	{FcFrom: uint16(0x0165), FcTo0: uint8(0x74)},                                                             //  to t
	{FcFrom: uint16(0x0166), FcTo0: uint8(0x54)},                                                             //  to T
	{FcFrom: uint16(0x0167), FcTo0: uint8(0x74)},                                                             //  to t
	{FcFrom: uint16(0x0168), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x0169), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x016A), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x016B), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x016C), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x016D), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x016E), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x016F), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x0170), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x0171), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x0172), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x0173), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x0174), FcTo0: uint8(0x57)},                                                             //  to W
	{FcFrom: uint16(0x0175), FcTo0: uint8(0x77)},                                                             //  to w
	{FcFrom: uint16(0x0176), FcTo0: uint8(0x59)},                                                             //  to Y
	{FcFrom: uint16(0x0177), FcTo0: uint8(0x79)},                                                             //  to y
	{FcFrom: uint16(0x0178), FcTo0: uint8(0x59)},                                                             //  to Y
	{FcFrom: uint16(0x0179), FcTo0: uint8(0x5A)},                                                             //  to Z
	{FcFrom: uint16(0x017A), FcTo0: uint8(0x7A)},                                                             //  to z
	{FcFrom: uint16(0x017B), FcTo0: uint8(0x5A)},                                                             //  to Z
	{FcFrom: uint16(0x017C), FcTo0: uint8(0x7A)},                                                             //  to z
	{FcFrom: uint16(0x017D), FcTo0: uint8(0x5A)},                                                             //  to Z
	{FcFrom: uint16(0x017E), FcTo0: uint8(0x7A)},                                                             //  to z
	{FcFrom: uint16(0x017F), FcTo0: uint8(0x73)},                                                             //  to s
	{FcFrom: uint16(0x0192), FcTo0: uint8(0x66)},                                                             //  to f
	{FcFrom: uint16(0x0218), FcTo0: uint8(0x53)},                                                             //  to S
	{FcFrom: uint16(0x0219), FcTo0: uint8(0x73)},                                                             //  to s
	{FcFrom: uint16(0x021A), FcTo0: uint8(0x54)},                                                             //  to T
	{FcFrom: uint16(0x021B), FcTo0: uint8(0x74)},                                                             //  to t
	{FcFrom: uint16(0x0386), FcTo0: uint8(0x41)},                                                             //  to A
	{FcFrom: uint16(0x0388), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x0389), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x038A), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x038C), FcTo0: uint8(0x4f)},                                                             //  to O
	{FcFrom: uint16(0x038E), FcTo0: uint8(0x59)},                                                             //  to Y
	{FcFrom: uint16(0x038F), FcTo0: uint8(0x4f)},                                                             //  to O
	{FcFrom: uint16(0x0390), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x0391), FcTo0: uint8(0x41)},                                                             //  to A
	{FcFrom: uint16(0x0392), FcTo0: uint8(0x42)},                                                             //  to B
	{FcFrom: uint16(0x0393), FcTo0: uint8(0x47)},                                                             //  to G
	{FcFrom: uint16(0x0394), FcTo0: uint8(0x44)},                                                             //  to D
	{FcFrom: uint16(0x0395), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x0396), FcTo0: uint8(0x5a)},                                                             //  to Z
	{FcFrom: uint16(0x0397), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x0398), FcTo0: uint8(0x54), FcTo1: uint8(0x68)},                                         //  to Th
	{FcFrom: uint16(0x0399), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x039A), FcTo0: uint8(0x4b)},                                                             //  to K
	{FcFrom: uint16(0x039B), FcTo0: uint8(0x4c)},                                                             //  to L
	{FcFrom: uint16(0x039C), FcTo0: uint8(0x4d)},                                                             //  to M
	{FcFrom: uint16(0x039D), FcTo0: uint8(0x4e)},                                                             //  to N
	{FcFrom: uint16(0x039E), FcTo0: uint8(0x58)},                                                             //  to X
	{FcFrom: uint16(0x039F), FcTo0: uint8(0x4f)},                                                             //  to O
	{FcFrom: uint16(0x03A0), FcTo0: uint8(0x50)},                                                             //  to P
	{FcFrom: uint16(0x03A1), FcTo0: uint8(0x52)},                                                             //  to R
	{FcFrom: uint16(0x03A3), FcTo0: uint8(0x53)},                                                             //  to S
	{FcFrom: uint16(0x03A4), FcTo0: uint8(0x54)},                                                             //  to T
	{FcFrom: uint16(0x03A5), FcTo0: uint8(0x59)},                                                             //  to Y
	{FcFrom: uint16(0x03A6), FcTo0: uint8(0x46)},                                                             //  to F
	{FcFrom: uint16(0x03A7), FcTo0: uint8(0x43), FcTo1: uint8(0x68)},                                         //  to Ch
	{FcFrom: uint16(0x03A8), FcTo0: uint8(0x50), FcTo1: uint8(0x73)},                                         //  to Ps
	{FcFrom: uint16(0x03A9), FcTo0: uint8(0x4f)},                                                             //  to O
	{FcFrom: uint16(0x03AA), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x03AB), FcTo0: uint8(0x59)},                                                             //  to Y
	{FcFrom: uint16(0x03AC), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x03AD), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x03AE), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x03AF), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x03B1), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x03B2), FcTo0: uint8(0x62)},                                                             //  to b
	{FcFrom: uint16(0x03B3), FcTo0: uint8(0x67)},                                                             //  to g
	{FcFrom: uint16(0x03B4), FcTo0: uint8(0x64)},                                                             //  to d
	{FcFrom: uint16(0x03B5), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x03B6), FcTo0: uint8(0x7a)},                                                             //  to z
	{FcFrom: uint16(0x03B7), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x03B8), FcTo0: uint8(0x74), FcTo1: uint8(0x68)},                                         //  to th
	{FcFrom: uint16(0x03B9), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x03BA), FcTo0: uint8(0x6b)},                                                             //  to k
	{FcFrom: uint16(0x03BB), FcTo0: uint8(0x6c)},                                                             //  to l
	{FcFrom: uint16(0x03BC), FcTo0: uint8(0x6d)},                                                             //  to m
	{FcFrom: uint16(0x03BD), FcTo0: uint8(0x6e)},                                                             //  to n
	{FcFrom: uint16(0x03BE), FcTo0: uint8(0x78)},                                                             //  to x
	{FcFrom: uint16(0x03BF), FcTo0: uint8(0x6f)},                                                             //  to o
	{FcFrom: uint16(0x03C0), FcTo0: uint8(0x70)},                                                             //  to p
	{FcFrom: uint16(0x03C1), FcTo0: uint8(0x72)},                                                             //  to r
	{FcFrom: uint16(0x03C3), FcTo0: uint8(0x73)},                                                             //  to s
	{FcFrom: uint16(0x03C4), FcTo0: uint8(0x74)},                                                             //  to t
	{FcFrom: uint16(0x03C5), FcTo0: uint8(0x79)},                                                             //  to y
	{FcFrom: uint16(0x03C6), FcTo0: uint8(0x66)},                                                             //  to f
	{FcFrom: uint16(0x03C7), FcTo0: uint8(0x63), FcTo1: uint8(0x68)},                                         //  to ch
	{FcFrom: uint16(0x03C8), FcTo0: uint8(0x70), FcTo1: uint8(0x73)},                                         //  to ps
	{FcFrom: uint16(0x03C9), FcTo0: uint8(0x6f)},                                                             //  to o
	{FcFrom: uint16(0x03CA), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x03CB), FcTo0: uint8(0x79)},                                                             //  to y
	{FcFrom: uint16(0x03CC), FcTo0: uint8(0x6f)},                                                             //  to o
	{FcFrom: uint16(0x03CD), FcTo0: uint8(0x79)},                                                             //  to y
	{FcFrom: uint16(0x03CE), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x0400), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x0401), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x0402), FcTo0: uint8(0x44)},                                                             //  to D
	{FcFrom: uint16(0x0403), FcTo0: uint8(0x47)},                                                             //  to G
	{FcFrom: uint16(0x0404), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x0405), FcTo0: uint8(0x5a)},                                                             //  to Z
	{FcFrom: uint16(0x0406), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x0407), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x0408), FcTo0: uint8(0x4a)},                                                             //  to J
	{FcFrom: uint16(0x0409), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x040A), FcTo0: uint8(0x4e)},                                                             //  to N
	{FcFrom: uint16(0x040B), FcTo0: uint8(0x44)},                                                             //  to D
	{FcFrom: uint16(0x040C), FcTo0: uint8(0x4b)},                                                             //  to K
	{FcFrom: uint16(0x040D), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x040E), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x040F), FcTo0: uint8(0x44)},                                                             //  to D
	{FcFrom: uint16(0x0410), FcTo0: uint8(0x41)},                                                             //  to A
	{FcFrom: uint16(0x0411), FcTo0: uint8(0x42)},                                                             //  to B
	{FcFrom: uint16(0x0412), FcTo0: uint8(0x56)},                                                             //  to V
	{FcFrom: uint16(0x0413), FcTo0: uint8(0x47)},                                                             //  to G
	{FcFrom: uint16(0x0414), FcTo0: uint8(0x44)},                                                             //  to D
	{FcFrom: uint16(0x0415), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x0416), FcTo0: uint8(0x5a), FcTo1: uint8(0x68)},                                         //  to Zh
	{FcFrom: uint16(0x0417), FcTo0: uint8(0x5a)},                                                             //  to Z
	{FcFrom: uint16(0x0418), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x0419), FcTo0: uint8(0x49)},                                                             //  to I
	{FcFrom: uint16(0x041A), FcTo0: uint8(0x4b)},                                                             //  to K
	{FcFrom: uint16(0x041B), FcTo0: uint8(0x4c)},                                                             //  to L
	{FcFrom: uint16(0x041C), FcTo0: uint8(0x4d)},                                                             //  to M
	{FcFrom: uint16(0x041D), FcTo0: uint8(0x4e)},                                                             //  to N
	{FcFrom: uint16(0x041E), FcTo0: uint8(0x4f)},                                                             //  to O
	{FcFrom: uint16(0x041F), FcTo0: uint8(0x50)},                                                             //  to P
	{FcFrom: uint16(0x0420), FcTo0: uint8(0x52)},                                                             //  to R
	{FcFrom: uint16(0x0421), FcTo0: uint8(0x53)},                                                             //  to S
	{FcFrom: uint16(0x0422), FcTo0: uint8(0x54)},                                                             //  to T
	{FcFrom: uint16(0x0423), FcTo0: uint8(0x55)},                                                             //  to U
	{FcFrom: uint16(0x0424), FcTo0: uint8(0x46)},                                                             //  to F
	{FcFrom: uint16(0x0425), FcTo0: uint8(0x4b), FcTo1: uint8(0x68)},                                         //  to Kh
	{FcFrom: uint16(0x0426), FcTo0: uint8(0x54), FcTo1: uint8(0x63)},                                         //  to Tc
	{FcFrom: uint16(0x0427), FcTo0: uint8(0x43), FcTo1: uint8(0x68)},                                         //  to Ch
	{FcFrom: uint16(0x0428), FcTo0: uint8(0x53), FcTo1: uint8(0x68)},                                         //  to Sh
	{FcFrom: uint16(0x0429), FcTo0: uint8(0x53), FcTo1: uint8(0x68), FcTo2: uint8(0x63), FcTo3: uint8(0x68)}, //  to Shch
	{FcFrom: uint16(0x042A), FcTo0: uint8(0x61)},                                                             //  to A
	{FcFrom: uint16(0x042B), FcTo0: uint8(0x59)},                                                             //  to Y
	{FcFrom: uint16(0x042C), FcTo0: uint8(0x59)},                                                             //  to Y
	{FcFrom: uint16(0x042D), FcTo0: uint8(0x45)},                                                             //  to E
	{FcFrom: uint16(0x042E), FcTo0: uint8(0x49), FcTo1: uint8(0x75)},                                         //  to Iu
	{FcFrom: uint16(0x042F), FcTo0: uint8(0x49), FcTo1: uint8(0x61)},                                         //  to Ia
	{FcFrom: uint16(0x0430), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x0431), FcTo0: uint8(0x62)},                                                             //  to b
	{FcFrom: uint16(0x0432), FcTo0: uint8(0x76)},                                                             //  to v
	{FcFrom: uint16(0x0433), FcTo0: uint8(0x67)},                                                             //  to g
	{FcFrom: uint16(0x0434), FcTo0: uint8(0x64)},                                                             //  to d
	{FcFrom: uint16(0x0435), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x0436), FcTo0: uint8(0x7a), FcTo1: uint8(0x68)},                                         //  to zh
	{FcFrom: uint16(0x0437), FcTo0: uint8(0x7a)},                                                             //  to z
	{FcFrom: uint16(0x0438), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x0439), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x043A), FcTo0: uint8(0x6b)},                                                             //  to k
	{FcFrom: uint16(0x043B), FcTo0: uint8(0x6c)},                                                             //  to l
	{FcFrom: uint16(0x043C), FcTo0: uint8(0x6d)},                                                             //  to m
	{FcFrom: uint16(0x043D), FcTo0: uint8(0x6e)},                                                             //  to n
	{FcFrom: uint16(0x043E), FcTo0: uint8(0x6f)},                                                             //  to o
	{FcFrom: uint16(0x043F), FcTo0: uint8(0x70)},                                                             //  to p
	{FcFrom: uint16(0x0440), FcTo0: uint8(0x72)},                                                             //  to r
	{FcFrom: uint16(0x0441), FcTo0: uint8(0x73)},                                                             //  to s
	{FcFrom: uint16(0x0442), FcTo0: uint8(0x74)},                                                             //  to t
	{FcFrom: uint16(0x0443), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x0444), FcTo0: uint8(0x66)},                                                             //  to f
	{FcFrom: uint16(0x0445), FcTo0: uint8(0x6b), FcTo1: uint8(0x68)},                                         //  to kh
	{FcFrom: uint16(0x0446), FcTo0: uint8(0x74), FcTo1: uint8(0x63)},                                         //  to tc
	{FcFrom: uint16(0x0447), FcTo0: uint8(0x63), FcTo1: uint8(0x68)},                                         //  to ch
	{FcFrom: uint16(0x0448), FcTo0: uint8(0x73), FcTo1: uint8(0x68)},                                         //  to sh
	{FcFrom: uint16(0x0449), FcTo0: uint8(0x73), FcTo1: uint8(0x68), FcTo2: uint8(0x63), FcTo3: uint8(0x68)}, //  to shch
	{FcFrom: uint16(0x044A), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x044B), FcTo0: uint8(0x79)},                                                             //  to y
	{FcFrom: uint16(0x044C), FcTo0: uint8(0x79)},                                                             //  to y
	{FcFrom: uint16(0x044D), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x044E), FcTo0: uint8(0x69), FcTo1: uint8(0x75)},                                         //  to iu
	{FcFrom: uint16(0x044F), FcTo0: uint8(0x69), FcTo1: uint8(0x61)},                                         //  to ia
	{FcFrom: uint16(0x0450), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x0451), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x0452), FcTo0: uint8(0x64)},                                                             //  to d
	{FcFrom: uint16(0x0453), FcTo0: uint8(0x67)},                                                             //  to g
	{FcFrom: uint16(0x0454), FcTo0: uint8(0x65)},                                                             //  to e
	{FcFrom: uint16(0x0455), FcTo0: uint8(0x7a)},                                                             //  to z
	{FcFrom: uint16(0x0456), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x0457), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x0458), FcTo0: uint8(0x6a)},                                                             //  to j
	{FcFrom: uint16(0x0459), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x045A), FcTo0: uint8(0x6e)},                                                             //  to n
	{FcFrom: uint16(0x045B), FcTo0: uint8(0x64)},                                                             //  to d
	{FcFrom: uint16(0x045C), FcTo0: uint8(0x6b)},                                                             //  to k
	{FcFrom: uint16(0x045D), FcTo0: uint8(0x69)},                                                             //  to i
	{FcFrom: uint16(0x045E), FcTo0: uint8(0x75)},                                                             //  to u
	{FcFrom: uint16(0x045F), FcTo0: uint8(0x64)},                                                             //  to d
	{FcFrom: uint16(0x1E02), FcTo0: uint8(0x42)},                                                             //  to B
	{FcFrom: uint16(0x1E03), FcTo0: uint8(0x62)},                                                             //  to b
	{FcFrom: uint16(0x1E0A), FcTo0: uint8(0x44)},                                                             //  to D
	{FcFrom: uint16(0x1E0B), FcTo0: uint8(0x64)},                                                             //  to d
	{FcFrom: uint16(0x1E1E), FcTo0: uint8(0x46)},                                                             //  to F
	{FcFrom: uint16(0x1E1F), FcTo0: uint8(0x66)},                                                             //  to f
	{FcFrom: uint16(0x1E40), FcTo0: uint8(0x4D)},                                                             //  to M
	{FcFrom: uint16(0x1E41), FcTo0: uint8(0x6D)},                                                             //  to m
	{FcFrom: uint16(0x1E56), FcTo0: uint8(0x50)},                                                             //  to P
	{FcFrom: uint16(0x1E57), FcTo0: uint8(0x70)},                                                             //  to p
	{FcFrom: uint16(0x1E60), FcTo0: uint8(0x53)},                                                             //  to S
	{FcFrom: uint16(0x1E61), FcTo0: uint8(0x73)},                                                             //  to s
	{FcFrom: uint16(0x1E6A), FcTo0: uint8(0x54)},                                                             //  to T
	{FcFrom: uint16(0x1E6B), FcTo0: uint8(0x74)},                                                             //  to t
	{FcFrom: uint16(0x1E80), FcTo0: uint8(0x57)},                                                             //  to W
	{FcFrom: uint16(0x1E81), FcTo0: uint8(0x77)},                                                             //  to w
	{FcFrom: uint16(0x1E82), FcTo0: uint8(0x57)},                                                             //  to W
	{FcFrom: uint16(0x1E83), FcTo0: uint8(0x77)},                                                             //  to w
	{FcFrom: uint16(0x1E84), FcTo0: uint8(0x57)},                                                             //  to W
	{FcFrom: uint16(0x1E85), FcTo0: uint8(0x77)},                                                             //  to w
	{FcFrom: uint16(0x1EF2), FcTo0: uint8(0x59)},                                                             //  to Y
	{FcFrom: uint16(0x1EF3), FcTo0: uint8(0x79)},                                                             //  to y
	{FcFrom: uint16(0xFB00), FcTo0: uint8(0x66), FcTo1: uint8(0x66)},                                         //  to ff
	{FcFrom: uint16(0xFB01), FcTo0: uint8(0x66), FcTo1: uint8(0x69)},                                         //  to fi
	{FcFrom: uint16(0xFB02), FcTo0: uint8(0x66), FcTo1: uint8(0x6C)},                                         //  to fl
	{FcFrom: uint16(0xFB05), FcTo0: uint8(0x73), FcTo1: uint8(0x74)},                                         //  to st
	{FcFrom: uint16(0xFB06), FcTo0: uint8(0x73), FcTo1: uint8(0x74)},                                         //  to st
} /* spellfix.c:1306:30 */

func spellfixFindTranslit(tls *libc.TLS, c int32, pxTop uintptr) uintptr { /* spellfix.c:1698:30: */
	*(*int32)(unsafe.Pointer(pxTop)) = (int32((uint32(unsafe.Sizeof(translit)) / uint32(unsafe.Sizeof(Transliteration{}))) - uint32(1)))
	return uintptr(unsafe.Pointer(&translit))
}

// Convert the input string from UTF-8 into pure ASCII by converting
// all non-ASCII characters to some combination of characters in the
// ASCII subset.
//
// The returned string might contain more characters than the input.
//
// Space to hold the returned string comes from sqlite3_malloc() and
// should be freed by the caller.
func transliterate(tls *libc.TLS, zIn uintptr, nIn int32) uintptr { /* spellfix.c:1713:22: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zOut uintptr = sqlite3.Xsqlite3_malloc64(tls, (uint64((nIn * 4) + 1)))
	var c int32
	// var sz int32 at bp, 4

	var nOut int32
	if zOut == uintptr(0) {
		return uintptr(0)
	}
	nOut = 0
	for nIn > 0 {
		c = utf8Read(tls, zIn, nIn, bp /* &sz */)
		zIn += uintptr(*(*int32)(unsafe.Pointer(bp /* sz */)))
		nIn = nIn - (*(*int32)(unsafe.Pointer(bp /* sz */)))
		if c <= 127 {
			*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = uint8(c)
		} else {
			// var xTop int32 at bp+4, 4

			var xBtm int32
			var x int32
			var tbl uintptr = spellfixFindTranslit(tls, c, bp+4 /* &xTop */)
			xBtm = 0
			for *(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) >= xBtm {
				x = ((*(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) + xBtm) / 2)
				if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) == c {
					*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo0
					if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo1 != 0 {
						*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo1
						if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo2 != 0 {
							*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo2
							if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo3 != 0 {
								*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo3
							}
						}
					}
					c = 0
					break
				} else if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) > c {
					*(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) = (x - 1)
				} else {
					xBtm = (x + 1)
				}
			}
			if c != 0 {
				*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = uint8('?')
			}
		}
	}
	*(*uint8)(unsafe.Pointer(zOut + uintptr(nOut))) = uint8(0)
	return zOut
}

// Return the number of characters in the shortest prefix of the input
// string that transliterates to an ASCII string nTrans bytes or longer.
// Or, if the transliteration of the input string is less than nTrans
// bytes in size, return the number of characters in the input string.
func translen_to_charlen(tls *libc.TLS, zIn uintptr, nIn int32, nTrans int32) int32 { /* spellfix.c:1771:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var c int32
	// var sz int32 at bp, 4

	var nOut int32
	var nChar int32

	i = libc.AssignInt32(&nOut, 0)
	for nChar = 0; (i < nIn) && (nOut < nTrans); nChar++ {
		c = utf8Read(tls, (zIn + uintptr(i)), (nIn - i), bp /* &sz */)
		i = i + (*(*int32)(unsafe.Pointer(bp /* sz */)))

		nOut++
		if c >= 128 {
			// var xTop int32 at bp+4, 4

			var xBtm int32
			var x int32
			var tbl uintptr = spellfixFindTranslit(tls, c, bp+4 /* &xTop */)
			xBtm = 0
			for *(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) >= xBtm {
				x = ((*(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) + xBtm) / 2)
				if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) == c {
					if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo1 != 0 {
						nOut++
						if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo2 != 0 {
							nOut++
							if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo3 != 0 {
								nOut++
							}
						}
					}
					break
				} else if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) > c {
					*(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) = (x - 1)
				} else {
					xBtm = (x + 1)
				}
			}
		}
	}

	return nChar
}

//    spellfix1_translit(X)
//
// Convert a string that contains non-ASCII Roman characters into
// pure ASCII.
func transliterateSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:1817:13: */
	var zIn uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var nIn int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var zOut uintptr = transliterate(tls, zIn, nIn)
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, zOut, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

//    spellfix1_scriptcode(X)
//
// Try to determine the dominant script used by the word X and return
// its ISO 15924 numeric code.
//
// The current implementation only understands the following scripts:
//
//    215  (Latin)
//    220  (Cyrillic)
//    200  (Greek)
//
// This routine will return 998 if the input X contains characters from
// two or more of the above scripts or 999 if X contains no characters
// from any of the above scripts.
func scriptCodeSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:1848:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zIn uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var nIn int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var c int32
	// var sz int32 at bp, 4

	var scriptMask int32 = 0
	var res int32
	var seenDigit int32 = 0

	for nIn > 0 {
		c = utf8Read(tls, zIn, nIn, bp /* &sz */)
		zIn += uintptr(*(*int32)(unsafe.Pointer(bp /* sz */)))
		nIn = nIn - (*(*int32)(unsafe.Pointer(bp /* sz */)))
		if c < 0x02af {
			if (c >= 0x80) || (int32(midClass[(c&0x7f)]) < CCLASS_DIGIT) {
				scriptMask = scriptMask | (SCRIPT_LATIN)
			} else if (c >= '0') && (c <= '9') {
				seenDigit = 1
			}
		} else if (c >= 0x0400) && (c <= 0x04ff) {
			scriptMask = scriptMask | (SCRIPT_CYRILLIC)
		} else if (c >= 0x0386) && (c <= 0x03ce) {
			scriptMask = scriptMask | (SCRIPT_GREEK)
		} else if (c >= 0x0590) && (c <= 0x05ff) {
			scriptMask = scriptMask | (SCRIPT_HEBREW)
		} else if (c >= 0x0600) && (c <= 0x06ff) {
			scriptMask = scriptMask | (SCRIPT_ARABIC)
		}
	}
	if (scriptMask == 0) && (seenDigit != 0) {
		scriptMask = SCRIPT_LATIN
	}
	switch scriptMask {
	case 0:
		res = 999
		break
	case SCRIPT_LATIN:
		res = 215
		break
	case SCRIPT_CYRILLIC:
		res = 220
		break
	case SCRIPT_GREEK:
		res = 200
		break
	case SCRIPT_HEBREW:
		res = 125
		break
	case SCRIPT_ARABIC:
		res = 160
		break
	default:
		res = 998
		break
	}
	sqlite3.Xsqlite3_result_int(tls, context, res)
}

// End transliterate
//
//
// Begin spellfix1 virtual table.

// Maximum length of a phonehash used for querying the shadow table

// Maximum number of hash strings to examine per query

type spellfix1_vtab1 = struct {
	Fbase       sqlite3_vtab
	Fdb         uintptr
	FzDbName    uintptr
	FzTableName uintptr
	FzCostTable uintptr
	FpConfig3   uintptr
} /* spellfix.c:1910:9 */

// End transliterate
//
//
// Begin spellfix1 virtual table.

// Maximum length of a phonehash used for querying the shadow table

// Maximum number of hash strings to examine per query

type spellfix1_vtab = spellfix1_vtab1 /* spellfix.c:1910:31 */
type spellfix1_cursor1 = struct {
	Fbase      sqlite3_vtab_cursor
	FpVTab     uintptr
	FzPattern  uintptr
	FidxNum    int32
	FnRow      int32
	FnAlloc    int32
	FiRow      int32
	FiLang     int32
	FiTop      int32
	FiScope    int32
	FnSearch   int32
	FpFullScan uintptr
	Fa         uintptr
} /* spellfix.c:1911:9 */

type spellfix1_cursor = spellfix1_cursor1 /* spellfix.c:1911:33 */

// Fuzzy-search cursor object
type spellfix1_row = struct {
	FiRowid    sqlite3_int64
	FzWord     uintptr
	FiRank     int32
	FiDistance int32
	FiScore    int32
	FiMatchlen int32
	FzHash     [32]int8
	_          [4]byte
} /* spellfix.c:1911:9 */

// Construct one or more SQL statements from the format string given
// and then evaluate those statements. The success code is written
// into *pRc.
//
// If *pRc is initially non-zero then this routine is a no-op.
func spellfix1DbExec(tls *libc.TLS, pRc uintptr, db uintptr, zFormat uintptr, va uintptr) { /* spellfix.c:1955:13: */
	var ap va_list
	_ = ap
	var zSql uintptr
	if *(*int32)(unsafe.Pointer(pRc)) != 0 {
		return
	}
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	if zSql == uintptr(0) {
		*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
	} else {
		*(*int32)(unsafe.Pointer(pRc)) = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
}

// xDisconnect/xDestroy method for the fuzzy-search module.
func spellfix1Uninit(tls *libc.TLS, isDestroy int32, pVTab uintptr) int32 { /* spellfix.c:1978:12: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr = pVTab
	*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = SQLITE_OK
	if isDestroy != 0 {
		var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb
		spellfix1DbExec(tls, bp+16 /* &rc */, db, ts+6635, /* "DROP TABLE IF EX..." */
			libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName))
	}
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName)
		editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
		sqlite3.Xsqlite3_free(tls, p)
	}
	return *(*int32)(unsafe.Pointer(bp + 16 /* rc */))
}

func spellfix1Disconnect(tls *libc.TLS, pVTab uintptr) int32 { /* spellfix.c:1994:12: */
	return spellfix1Uninit(tls, 0, pVTab)
}

func spellfix1Destroy(tls *libc.TLS, pVTab uintptr) int32 { /* spellfix.c:1997:12: */
	return spellfix1Uninit(tls, 1, pVTab)
}

// Make a copy of a string.  Remove leading and trailing whitespace
// and dequote it.
func spellfix1Dequote(tls *libc.TLS, zIn uintptr) uintptr { /* spellfix.c:2005:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zOut uintptr
	var i int32
	var j int32
	var c int8
	for (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zIn)))))*2))) & int32(_ISspace)) != 0 {
		zIn++
	}
	zOut = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zIn))
	if zOut == uintptr(0) {
		return uintptr(0)
	}
	i = int32(libc.Xstrlen(tls, zOut))
	*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = int8(0)
	c = *(*int8)(unsafe.Pointer(zOut))
	if (int32(c) == '\'') || (int32(c) == '"') {
		i = 1
		j = 0
		for ; 1 != 0; i++ {
			*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(zOut + uintptr(i)))
			if int32(*(*int8)(unsafe.Pointer(zOut + uintptr(i)))) == int32(c) {
				if int32(*(*int8)(unsafe.Pointer(zOut + uintptr((i + 1))))) == int32(c) {
					i++
				} else {
					*(*int8)(unsafe.Pointer(zOut + uintptr((j - 1)))) = int8(0)
					break
				}
			}
		}
	}
	return zOut
}

// xConnect/xCreate method for the spellfix1 module. Arguments are:
//
//   argv[0]   -> module name  ("spellfix1")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[3].. -> optional arguments (i.e. "edit_cost_table" parameter)
func spellfix1Init(tls *libc.TLS, isCreate int32, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 { /* spellfix.c:2043:12: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var pNew uintptr = uintptr(0)
	// const char *zModule = argv[0]; // not used
	var zDbName uintptr = *(*uintptr)(unsafe.Pointer(argv + 1*4))
	var zTableName uintptr = *(*uintptr)(unsafe.Pointer(argv + 2*4))
	var nDbName int32
	*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = SQLITE_OK
	var i int32

	nDbName = int32(libc.Xstrlen(tls, zDbName))
	pNew = sqlite3.Xsqlite3_malloc64(tls, (uint64((uint32(unsafe.Sizeof(spellfix1_vtab{})) + uint32(nDbName)) + uint32(1))))
	if pNew == uintptr(0) {
		*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = SQLITE_NOMEM
	} else {
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(spellfix1_vtab{})))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzDbName = (pNew + 1*32)
		libc.Xmemcpy(tls, (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzDbName, zDbName, (uint32(nDbName + 1)))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zTableName))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).Fdb = db
		if (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzTableName == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = SQLITE_NOMEM
		} else {
			sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = sqlite3.Xsqlite3_declare_vtab(tls, db,

				ts+6672 /* "CREATE TABLE x(w..." */)
		}
		if (*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) == SQLITE_OK) && (isCreate != 0) {
			spellfix1DbExec(tls, bp+56 /* &rc */, db,

				ts+6826, /* "CREATE TABLE IF ..." */
				libc.VaList(bp+8, zDbName, zTableName))
			spellfix1DbExec(tls, bp+56 /* &rc */, db,

				ts+6960, /* "CREATE INDEX IF ..." */
				libc.VaList(bp+24, zDbName, zTableName, zTableName))
		}
		for i = 3; (*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) == SQLITE_OK) && (i < argc); i++ {
			if (libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), ts+7045 /* "edit_cost_table=" */, uint32(16)) == 0) && ((*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable == uintptr(0)) {
				(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable = spellfix1Dequote(tls, (*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)) + 16))
				if (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = SQLITE_NOMEM
				}
				continue
			}
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+7062 /* "bad argument to ..." */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = SQLITE_ERROR
		}
	}

	if (*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) != 0) && (pNew != 0) {
		*(*uintptr)(unsafe.Pointer(ppVTab)) = uintptr(0)
		spellfix1Uninit(tls, 0, (pNew /* &.base */))
	} else {
		*(*uintptr)(unsafe.Pointer(ppVTab)) = pNew
	}
	return *(*int32)(unsafe.Pointer(bp + 56 /* rc */))
}

// The xConnect and xCreate methods
func spellfix1Connect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 { /* spellfix.c:2133:12: */
	return spellfix1Init(tls, 0, db, pAux, argc, argv, ppVTab, pzErr)
}

func spellfix1Create(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 { /* spellfix.c:2142:12: */
	return spellfix1Init(tls, 1, db, pAux, argc, argv, ppVTab, pzErr)
}

// Clear all of the content from a cursor.
func spellfix1ResetCursor(tls *libc.TLS, pCur uintptr) { /* spellfix.c:2155:13: */
	var i int32
	for i = 0; i < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow; i++ {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(i)*64)).FzWord)
	}
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow = 0
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = 0
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch = 0
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan = uintptr(0)
	}
}

// Resize the cursor to hold up to N rows of content
func spellfix1ResizeCursor(tls *libc.TLS, pCur uintptr, N int32) { /* spellfix.c:2172:13: */
	var aNew uintptr

	aNew = sqlite3.Xsqlite3_realloc64(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa, (uint64(uint32(unsafe.Sizeof(spellfix1_row{})) * uint32(N))))
	if (aNew == uintptr(0)) && (N > 0) {
		spellfix1ResetCursor(tls, pCur)
		sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa)
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc = 0
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa = uintptr(0)
	} else {
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc = N
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa = aNew
	}
}

// Close a fuzzy-search cursor.
func spellfix1Close(tls *libc.TLS, cur uintptr) int32 { /* spellfix.c:2191:12: */
	var pCur uintptr = cur
	spellfix1ResetCursor(tls, pCur)
	spellfix1ResizeCursor(tls, pCur, 0)
	sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

//
// The plan number is a bitmask of the SPELLFIX_IDXNUM_* values defined
// above.
//
// filter.argv[*] values contains $str, $langid, $top, $scope and $rowid
// if specified and in that order.
func spellfix1BestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* spellfix.c:2217:12: */
	var iPlan int32 = 0
	var iLangTerm int32 = -1
	var iTopTerm int32 = -1
	var iScopeTerm int32 = -1
	var iDistTerm int32 = -1
	var iRowidTerm int32 = -1
	var i int32
	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}

		// Terms of the form:  word MATCH $str
		if (((iPlan & SPELLFIX_IDXNUM_MATCH) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_WORD)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH) {
			iPlan = iPlan | (SPELLFIX_IDXNUM_MATCH)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}

		// Terms of the form:  langid = $langid
		if (((iPlan & SPELLFIX_IDXNUM_LANGID) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_LANGID)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | (SPELLFIX_IDXNUM_LANGID)
			iLangTerm = i
		}

		// Terms of the form:  top = $top
		if (((iPlan & SPELLFIX_IDXNUM_TOP) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_TOP)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | (SPELLFIX_IDXNUM_TOP)
			iTopTerm = i
		}

		// Terms of the form:  scope = $scope
		if (((iPlan & SPELLFIX_IDXNUM_SCOPE) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_SCOPE)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | (SPELLFIX_IDXNUM_SCOPE)
			iScopeTerm = i
		}

		// Terms of the form:  distance < $dist or distance <= $dist
		if (((iPlan & (0x10 | 0x20)) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_DISTANCE)) &&
			((int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT) ||
				(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE)) {
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT {
				iPlan = iPlan | (SPELLFIX_IDXNUM_DISTLT)
			} else {
				iPlan = iPlan | (SPELLFIX_IDXNUM_DISTLE)
			}
			iDistTerm = i
		}

		// Terms of the form:  distance < $dist or distance <= $dist
		if (((iPlan & SPELLFIX_IDXNUM_ROWID) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn < 0)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | (SPELLFIX_IDXNUM_ROWID)
			iRowidTerm = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (iPlan & SPELLFIX_IDXNUM_MATCH) != 0 {
		var idx int32 = 2
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
		if (((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) &&
			((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == SPELLFIX_COL_SCORE)) &&
			(int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0) {
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1 // Default order by iScore
		}
		if (iPlan & SPELLFIX_IDXNUM_LANGID) != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).Fomit = uint8(1)
		}
		if (iPlan & SPELLFIX_IDXNUM_TOP) != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iTopTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iTopTerm)*8)).Fomit = uint8(1)
		}
		if (iPlan & SPELLFIX_IDXNUM_SCOPE) != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iScopeTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iScopeTerm)*8)).Fomit = uint8(1)
		}
		if (iPlan & (0x10 | 0x20)) != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).Fomit = uint8(1)
		}
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e5
	} else if (iPlan & SPELLFIX_IDXNUM_ROWID) != 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = SPELLFIX_IDXNUM_ROWID
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRowidTerm)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRowidTerm)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(5)
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e50
	}
	return SQLITE_OK
}

// Open a new fuzzy-search cursor.
func spellfix1Open(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* spellfix.c:2331:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(spellfix1_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(spellfix1_cursor{})))
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Adjust a distance measurement by the words rank in order to show
// preference to common words.
func spellfix1Score(tls *libc.TLS, iDistance int32, iRank int32) int32 { /* spellfix.c:2346:12: */
	var iLog2 int32
	iLog2 = 0
__1:
	if !(iRank > 0) {
		goto __3
	}
	{
	}
	goto __2
__2:
	iLog2++
	iRank >>= 1
	goto __1
	goto __3
__3:
	;
	return ((iDistance + 32) - iLog2)
}

// Compare two spellfix1_row objects for sorting purposes in qsort() such
// that they sort in order of increasing distance.
func spellfix1RowCompare(tls *libc.TLS, A uintptr, B uintptr) int32 { /* spellfix.c:2356:25: */
	var a uintptr = A
	var b uintptr = B
	return ((*spellfix1_row)(unsafe.Pointer(a)).FiScore - (*spellfix1_row)(unsafe.Pointer(b)).FiScore)
}

// A structure used to pass information from spellfix1FilterForMatch()
// into spellfix1RunQuery().
type MatchQuery1 = struct {
	FpCur       uintptr
	FpStmt      uintptr
	FzHash      [32]int8
	FzPattern   uintptr
	FnPattern   int32
	FpMatchStr3 uintptr
	FpConfig3   uintptr
	FpLang      uintptr
	FiLang      int32
	FiScope     int32
	FiMaxDist   int32
	Frc         int32
	FnRun       int32
	FazPrior    [1][32]int8
} /* spellfix.c:2366:9 */

// A structure used to pass information from spellfix1FilterForMatch()
// into spellfix1RunQuery().
type MatchQuery = MatchQuery1 /* spellfix.c:2381:3 */

// Run a query looking for the best matches against zPattern using
// zHash as the character class seed hash.
func spellfix1RunQuery(tls *libc.TLS, p uintptr, zQuery uintptr, nQuery int32) { /* spellfix.c:2387:13: */
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var zK1 uintptr
	var zWord uintptr
	var iDist int32
	var iRank int32
	var iScore int32
	var iWorst int32 = 0
	var idx int32
	var idxWorst int32 = -1
	var i int32
	var iScope int32 = (*MatchQuery)(unsafe.Pointer(p)).FiScope
	var pCur uintptr = (*MatchQuery)(unsafe.Pointer(p)).FpCur
	var pStmt uintptr = (*MatchQuery)(unsafe.Pointer(p)).FpStmt
	// var zHash1 [32]int8 at bp+8, 32

	// var zHash2 [32]int8 at bp+40, 32

	var zClass uintptr
	var nClass int32
	var rc int32

	if ((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa == uintptr(0)) || ((*MatchQuery)(unsafe.Pointer(p)).Frc != 0) {
		return
	} // Prior memory allocation failure
	zClass = phoneticHash(tls, zQuery, nQuery)
	if zClass == uintptr(0) {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
		return
	}
	nClass = int32(libc.Xstrlen(tls, zClass))
	if nClass > (SPELLFIX_MX_HASH - 2) {
		nClass = (SPELLFIX_MX_HASH - 2)
		*(*int8)(unsafe.Pointer(zClass + uintptr(nClass))) = int8(0)
	}
	if nClass <= iScope {
		if nClass > 2 {
			iScope = (nClass - 1)
		} else {
			iScope = nClass
		}
	}
	libc.Xmemcpy(tls, bp+8 /* &zHash1[0] */, zClass, uint32(iScope))
	sqlite3.Xsqlite3_free(tls, zClass)
	*(*int8)(unsafe.Pointer(bp + 8 /* &zHash1[0] */ + uintptr(iScope))) = int8(0)
	libc.Xmemcpy(tls, bp+40 /* &zHash2[0] */, bp+8 /* &zHash1[0] */, uint32(iScope))
	*(*int8)(unsafe.Pointer(bp + 40 /* &zHash2[0] */ + uintptr(iScope))) = int8('Z')
	*(*int8)(unsafe.Pointer(bp + 40 /* &zHash2[0] */ + uintptr((iScope + 1)))) = int8(0)

	libc.Xmemcpy(tls, ((p + 80 /* &.azPrior */) + uintptr(libc.PostIncInt32(&(*MatchQuery)(unsafe.Pointer(p)).FnRun, 1))*32), bp+8 /* &zHash1[0] */, (uint32(iScope + 1)))
	if (sqlite3.Xsqlite3_bind_text(tls, pStmt, 1, bp+8 /* &zHash1[0] */, -1, uintptr(0)) == SQLITE_NOMEM) ||
		(sqlite3.Xsqlite3_bind_text(tls, pStmt, 2, bp+40 /* &zHash2[0] */, -1, uintptr(0)) == SQLITE_NOMEM) {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
		return
	}
	for sqlite3.Xsqlite3_step(tls, pStmt) == SQLITE_ROW {
		*(*int32)(unsafe.Pointer(bp + 72 /* iMatchlen */)) = -1
		iRank = sqlite3.Xsqlite3_column_int(tls, pStmt, 2)
		if (*MatchQuery)(unsafe.Pointer(p)).FpMatchStr3 != 0 {
			var nWord int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, 1)
			zWord = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
			iDist = editDist3Core(tls, (*MatchQuery)(unsafe.Pointer(p)).FpMatchStr3, zWord, nWord, (*MatchQuery)(unsafe.Pointer(p)).FpLang, bp+72 /* &iMatchlen */)
		} else {
			zK1 = sqlite3.Xsqlite3_column_text(tls, pStmt, 3)
			if zK1 == uintptr(0) {
				continue
			}
			iDist = editdist1(tls, (*MatchQuery)(unsafe.Pointer(p)).FzPattern, zK1, uintptr(0))
		}
		if iDist < 0 {
			(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
			break
		}
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch++

		// If there is a "distance < $dist" or "distance <= $dist" constraint,
		// check if this row meets it. If not, jump back up to the top of the
		// loop to process the next row. Otherwise, if the row does match the
		// distance constraint, check if the pCur->a[] array is already full.
		// If it is and no explicit "top = ?" constraint was present in the
		// query, grow the array to ensure there is room for the new entry.

		if (*MatchQuery)(unsafe.Pointer(p)).FiMaxDist >= 0 {
			if iDist > (*MatchQuery)(unsafe.Pointer(p)).FiMaxDist {
				continue
			}
			if ((*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow >= (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc) && (((*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum & SPELLFIX_IDXNUM_TOP) == 0) {
				spellfix1ResizeCursor(tls, pCur, (((*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc * 2) + 10))
				if (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa == uintptr(0) {
					break
				}
			}
		}

		iScore = spellfix1Score(tls, iDist, iRank)
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			idx = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow
		} else if iScore < iWorst {
			idx = idxWorst
			sqlite3.Xsqlite3_free(tls, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*64)).FzWord)
		} else {
			continue
		}

		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FzWord = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_column_text(tls, pStmt, 1)))
		if (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*64)).FzWord == uintptr(0) {
			(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
			break
		}
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiRowid = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiRank = iRank
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiDistance = iDist
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiScore = iScore
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiMatchlen = *(*int32)(unsafe.Pointer(bp + 72 /* iMatchlen */))
		libc.Xmemcpy(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*64+28 /* &.zHash */, bp+8 /* &zHash1[0] */, (uint32(iScope + 1)))
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow++
		}
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow == (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			iWorst = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa)).FiScore
			idxWorst = 0
			for i = 1; i < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow; i++ {
				iScore = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(i)*64)).FiScore
				if iWorst < iScore {
					iWorst = iScore
					idxWorst = i
				}
			}
		}
	}
	rc = sqlite3.Xsqlite3_reset(tls, pStmt)
	if rc != 0 {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = rc
	}
}

// This version of the xFilter method work if the MATCH term is present
// and we are doing a scan.
func spellfix1FilterForMatch(tls *libc.TLS, pCur uintptr, argc int32, argv uintptr) int32 { /* spellfix.c:2526:12: */
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var idxNum int32
	var zMatchThis uintptr // RHS of the MATCH operator
	var pMatchStr3 uintptr // zMatchThis as an editdist string
	var zPattern uintptr   // Transliteration of zMatchThis
	var nPattern int32     // Length of zPattern
	var iLimit int32       // Max number of rows of output
	var iScope int32       // Use this many characters of zClass
	var iLang int32        // Language code
	var zSql uintptr       // SQL of shadow table query
	// var pStmt uintptr at bp+136, 4
	// Shadow table query
	var rc int32  // Result code
	var idx int32 // Next available filter parameter
	var p uintptr // The virtual table that owns pCur
	// var x MatchQuery at bp+24, 112
	idxNum = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum
	pMatchStr3 = uintptr(0)
	iLimit = 20
	iScope = 3
	iLang = 0
	*(*uintptr)(unsafe.Pointer(bp + 136 /* pStmt */)) = uintptr(0)
	idx = 1
	p = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab // For passing info to RunQuery()

	// Load the cost table if we have not already done so
	if !(((*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable != uintptr(0)) && ((*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 == uintptr(0))) {
		goto __1
	}
	(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(EditDist3Config{})))
	if !((*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 == uintptr(0)) {
		goto __2
	}
	return SQLITE_NOMEM
__2:
	;
	libc.Xmemset(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, 0, uint32(unsafe.Sizeof(EditDist3Config{})))
	rc = editDist3ConfigLoad(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
	if !(rc != 0) {
		goto __3
	}
	return rc
__3:
	;
__1:
	;
	libc.Xmemset(tls, bp+24 /* &x */, 0, uint32(unsafe.Sizeof(MatchQuery{})))
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = 3    // Default scope if none specified by "WHERE scope=N"
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiMaxDist = -1 // Maximum allowed edit distance

	if !((idxNum & 2) != 0) {
		goto __4
	}
	iLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*4)))
__4:
	;
	if !((idxNum & 4) != 0) {
		goto __5
	}
	iLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*4)))
	if !(iLimit < 1) {
		goto __6
	}
	iLimit = 1
__6:
	;
__5:
	;
	if !((idxNum & 8) != 0) {
		goto __7
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*4)))
	if !((*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FiScope < 1) {
		goto __8
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = 1
__8:
	;
	if !((*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FiScope > (SPELLFIX_MX_HASH - 2)) {
		goto __9
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = (SPELLFIX_MX_HASH - 2)
__9:
	;
__7:
	;
	if !((idxNum & (16 | 32)) != 0) {
		goto __10
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiMaxDist = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*4)))
	if !((idxNum & 16) != 0) {
		goto __11
	}
	(*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FiMaxDist--
__11:
	;
	if !((*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FiMaxDist < 0) {
		goto __12
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiMaxDist = 0
__12:
	;
__10:
	;
	spellfix1ResetCursor(tls, pCur)
	spellfix1ResizeCursor(tls, pCur, iLimit)
	zMatchThis = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if !(zMatchThis == uintptr(0)) {
		goto __13
	}
	return SQLITE_OK
__13:
	;
	if !((*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 != 0) {
		goto __14
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpLang = editDist3FindLang(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, iLang)
	pMatchStr3 = editDist3FromStringNew(tls, (*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FpLang, zMatchThis, -1)
	if !(pMatchStr3 == uintptr(0)) {
		goto __16
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = SQLITE_NOMEM
	goto filter_exit
__16:
	;
	goto __15
__14:
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpLang = uintptr(0)
__15:
	;
	zPattern = transliterate(tls, zMatchThis, sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv))))
	sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern)
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern = zPattern
	if !(zPattern == uintptr(0)) {
		goto __17
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = SQLITE_NOMEM
	goto filter_exit
__17:
	;
	nPattern = int32(libc.Xstrlen(tls, zPattern))
	if !(int32(*(*int8)(unsafe.Pointer(zPattern + uintptr((nPattern - 1))))) == '*') {
		goto __18
	}
	nPattern--
__18:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls,

		ts+7096, /* "SELECT id, word,..." */
		libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, iLang))
	if !(zSql == uintptr(0)) {
		goto __19
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = SQLITE_NOMEM
	*(*uintptr)(unsafe.Pointer(bp + 136 /* pStmt */)) = uintptr(0)
	goto filter_exit
__19:
	;
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb, zSql, -1, bp+136 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiLang = iLang
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpCur = pCur
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpStmt = *(*uintptr)(unsafe.Pointer(bp + 136 /* pStmt */))
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FzPattern = zPattern
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FnPattern = nPattern
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpMatchStr3 = pMatchStr3
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiLang = iLang
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = rc
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpConfig3 = (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3
	if !((*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).Frc == SQLITE_OK) {
		goto __20
	}
	spellfix1RunQuery(tls, bp+24 /* &x */, zPattern, nPattern)
__20:
	;

	if !((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa != 0) {
		goto __21
	}
	libc.Xqsort(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa, uint32((*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow), uint32(unsafe.Sizeof(spellfix1_row{})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{spellfix1RowCompare})))
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiTop = iLimit
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiScope = iScope
	goto __22
__21:
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = SQLITE_NOMEM
__22:
	;

filter_exit:
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 136 /* pStmt */)))
	editDist3FromStringDelete(tls, pMatchStr3)
	return (*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc
}

// This version of xFilter handles a full-table scan case
func spellfix1FilterForFullScan(tls *libc.TLS, pCur uintptr, argc int32, argv uintptr) int32 { /* spellfix.c:2641:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	var idxNum int32 = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum
	var zSql uintptr
	var pVTab uintptr = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab
	spellfix1ResetCursor(tls, pCur)

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+7196, /* "SELECT word, ran..." */
		libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).FzTableName,
			func() uintptr {
				if (idxNum & 64) != 0 {
					return ts + 7255 /* " WHERE rowid=?" */
				}
				return ts + 489 /* "" */
			}()))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).Fdb, zSql, -1, (pCur + 44 /* &.pFullScan */), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if (rc == SQLITE_OK) && ((idxNum & 64) != 0) {

		rc = sqlite3.Xsqlite3_bind_value(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, 1, *(*uintptr)(unsafe.Pointer(argv)))
	}
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow = libc.AssignPtrInt32(pCur+24 /* &.iRow */, 0)
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_step(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
		if rc == SQLITE_ROW {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = -1
			rc = SQLITE_OK
		}
		if rc == SQLITE_DONE {
			rc = SQLITE_OK
		}
	} else {
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = 0
	}
	return rc
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any spellfix1Column, spellfix1Rowid, or spellfix1Eof call.
func spellfix1Filter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* spellfix.c:2681:12: */
	var pCur uintptr = cur
	var rc int32
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum = idxNum
	if (idxNum & 1) != 0 {
		rc = spellfix1FilterForMatch(tls, pCur, argc, argv)
	} else {
		rc = spellfix1FilterForFullScan(tls, pCur, argc, argv)
	}
	return rc
}

// Advance a cursor to its next row of output
func spellfix1Next(tls *libc.TLS, cur uintptr) int32 { /* spellfix.c:2701:12: */
	var pCur uintptr = cur
	var rc int32 = SQLITE_OK
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow {
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
			rc = sqlite3.Xsqlite3_step(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
			if rc != SQLITE_ROW {
				(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow
			}
			if (rc == SQLITE_ROW) || (rc == SQLITE_DONE) {
				rc = SQLITE_OK
			}
		} else {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow++
		}
	}
	return rc
}

// Return TRUE if we are at the end-of-file
func spellfix1Eof(tls *libc.TLS, cur uintptr) int32 { /* spellfix.c:2719:12: */
	var pCur uintptr = cur
	return (libc.Bool32((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow >= (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow))
}

// Return columns from the current row.
func spellfix1Column(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* spellfix.c:2727:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCur uintptr = cur
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		if i <= SPELLFIX_COL_LANGID {
			sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, i))
		} else {
			sqlite3.Xsqlite3_result_null(tls, ctx)
		}
		return SQLITE_OK
	}
	switch i {
	case SPELLFIX_COL_WORD:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FzWord, -1, uintptr(0))
			break

		}
	case SPELLFIX_COL_RANK:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiRank)
			break

		}
	case SPELLFIX_COL_DISTANCE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiDistance)
			break

		}
	case SPELLFIX_COL_LANGID:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiLang)
			break

		}
	case SPELLFIX_COL_SCORE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiScore)
			break

		}
	case SPELLFIX_COL_MATCHLEN:
		{
			*(*int32)(unsafe.Pointer(bp /* iMatchlen */)) = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiMatchlen
			if *(*int32)(unsafe.Pointer(bp /* iMatchlen */)) < 0 {
				var nPattern int32 = int32(libc.Xstrlen(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern))
				var zWord uintptr = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FzWord
				var nWord int32 = int32(libc.Xstrlen(tls, zWord))

				if (nPattern > 0) && (int32(*(*int8)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern + uintptr((nPattern - 1))))) == '*') {
					var zTranslit uintptr
					var res int32
					zTranslit = transliterate(tls, zWord, nWord)
					if !(zTranslit != 0) {
						return SQLITE_NOMEM
					}
					res = editdist1(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern, zTranslit, bp /* &iMatchlen */)
					sqlite3.Xsqlite3_free(tls, zTranslit)
					if res < 0 {
						return SQLITE_NOMEM
					}
					*(*int32)(unsafe.Pointer(bp /* iMatchlen */)) = translen_to_charlen(tls, zWord, nWord, *(*int32)(unsafe.Pointer(bp /* iMatchlen */)))
				} else {
					*(*int32)(unsafe.Pointer(bp /* iMatchlen */)) = utf8Charlen(tls, zWord, nWord)
				}
			}

			sqlite3.Xsqlite3_result_int(tls, ctx, *(*int32)(unsafe.Pointer(bp /* iMatchlen */)))
			break

		}
	case SPELLFIX_COL_PHONEHASH:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64+28 /* &.zHash */, -1, uintptr(0))
			break

		}
	case SPELLFIX_COL_TOP:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiTop)
			break

		}
	case SPELLFIX_COL_SCOPE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiScope)
			break

		}
	case SPELLFIX_COL_SRCHCNT:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch)
			break

		}
	default:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break

		}
	}
	return SQLITE_OK
}

// The rowid.
func spellfix1Rowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* spellfix.c:2813:12: */
	var pCur uintptr = cur
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, 4)
	} else {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiRowid
	}
	return SQLITE_OK
}

// This function is called by the xUpdate() method. It returns a string
// containing the conflict mode that xUpdate() should use for the current
// operation. One of: "ROLLBACK", "IGNORE", "ABORT" or "REPLACE".
func spellfix1GetConflict(tls *libc.TLS, db uintptr) uintptr { /* spellfix.c:2828:19: */
	var eConflict int32 = sqlite3.Xsqlite3_vtab_on_conflict(tls, db)

	return azConflict[(eConflict - 1)]
}

var azConflict = [5]uintptr{
	// Note: Instead of "FAIL" - "ABORT".
	ts + 7270 /* "ROLLBACK" */, ts + 7279 /* "IGNORE" */, ts + 7286 /* "ABORT" */, ts + 7286 /* "ABORT" */, ts + 7292, /* "REPLACE" */
} /* spellfix.c:2829:21 */

// The xUpdate() method.
func spellfix1Update(tls *libc.TLS, pVTab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 { /* spellfix.c:2851:12: */
	bp := tls.Alloc(284)
	defer tls.Free(284)

	*(*int32)(unsafe.Pointer(bp + 280 /* rc */)) = SQLITE_OK
	var rowid sqlite3_int64
	var newRowid sqlite3_int64
	var p uintptr = pVTab
	var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb

	if argc == 1 {
		// A delete operation on the rowid given by argv[0]
		rowid = libc.AssignPtrInt64(pRowid, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
		spellfix1DbExec(tls, bp+280 /* &rc */, db,
			ts+7300, /* "DELETE FROM \"%w\"..." */
			libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, rowid))
	} else {
		var zWord uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
		var nWord int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
		var iLang int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 5*4)))
		var iRank int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
		var zSoundslike uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 12*4)))
		var nSoundslike int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 12*4)))
		var zK1 uintptr
		var zK2 uintptr
		var i int32
		var c int8
		var zConflict uintptr = spellfix1GetConflict(tls, db)

		if zWord == uintptr(0) {
			// Inserts of the form:  INSERT INTO table(command) VALUES('xyzzy');
			// cause zWord to be NULL, so we look at the "command" column to see
			// what special actions to take
			var zCmd uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 13*4)))
			if zCmd == uintptr(0) {
				(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+7343, /* "NOT NULL constra..." */
					libc.VaList(bp+24, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName))
				return (SQLITE_CONSTRAINT | (int32(5) << 8))
			}
			if libc.Xstrcmp(tls, zCmd, ts+7379 /* "reset" */) == 0 {
				// Reset the  edit cost table (if there is one).
				editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = uintptr(0)
				return SQLITE_OK
			}
			if libc.Xstrncmp(tls, zCmd, ts+7045 /* "edit_cost_table=" */, uint32(16)) == 0 {
				editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = uintptr(0)
				sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable = spellfix1Dequote(tls, (zCmd + uintptr(16)))
				if (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable == uintptr(0) {
					return SQLITE_NOMEM
				}
				if (int32(*(*int8)(unsafe.Pointer((*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable))) == 0) || (sqlite3.Xsqlite3_stricmp(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable, ts+7385 /* "null" */) == 0) {
					sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
					(*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable = uintptr(0)
				}
				return SQLITE_OK
			}
			(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+7390, /* "unknown value fo..." */
				libc.VaList(bp+32, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, zCmd))
			return SQLITE_ERROR
		}
		if iRank < 1 {
			iRank = 1
		}
		if zSoundslike != 0 {
			zK1 = transliterate(tls, zSoundslike, nSoundslike)
		} else {
			zK1 = transliterate(tls, zWord, nWord)
		}
		if zK1 == uintptr(0) {
			return SQLITE_NOMEM
		}
		for i = 0; (int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer(zK1 + uintptr(i)))))) != 0; i++ {
			if (int32(c) >= 'A') && (int32(c) <= 'Z') {
				*(*int8)(unsafe.Pointer(zK1 + uintptr(i))) += int8(('a' - 'A'))
			}
		}
		zK2 = phoneticHash(tls, zK1, i)
		if zK2 == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, zK1)
			return SQLITE_NOMEM
		}
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
			if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))) == SQLITE_NULL {
				spellfix1DbExec(tls, bp+280 /* &rc */, db,

					ts+7425, /* "INSERT INTO \"%w\"..." */
					libc.VaList(bp+48, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName,
						iRank, iLang, zWord, zK1, zWord, zK2))
			} else {
				newRowid = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
				spellfix1DbExec(tls, bp+280 /* &rc */, db,

					ts+7511, /* "INSERT OR %s INT..." */
					libc.VaList(bp+112, zConflict, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName,
						newRowid, iRank, iLang, zWord, zK1, zWord, zK2))
			}
			*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_last_insert_rowid(tls, db)
		} else {
			rowid = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
			newRowid = libc.AssignPtrInt64(pRowid, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
			spellfix1DbExec(tls, bp+280 /* &rc */, db,

				ts+7611, /* "UPDATE OR %s \"%w..." */
				libc.VaList(bp+192, zConflict, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, newRowid, iRank, iLang,
					zWord, zK1, zWord, zK2, rowid))
		}
		sqlite3.Xsqlite3_free(tls, zK1)
		sqlite3.Xsqlite3_free(tls, zK2)
	}
	return *(*int32)(unsafe.Pointer(bp + 280 /* rc */))
}

// Rename the spellfix1 table.
func spellfix1Rename(tls *libc.TLS, pVTab uintptr, zNew uintptr) int32 { /* spellfix.c:2966:12: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var p uintptr = pVTab
	var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb
	*(*int32)(unsafe.Pointer(bp + 32 /* rc */)) = SQLITE_OK
	var zNewName uintptr = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zNew))
	if zNewName == uintptr(0) {
		return SQLITE_NOMEM
	}
	spellfix1DbExec(tls, bp+32 /* &rc */, db,
		ts+7720, /* "ALTER TABLE \"%w\"..." */
		libc.VaList(bp+8, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, zNewName))
	if *(*int32)(unsafe.Pointer(bp + 32 /* rc */)) == SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName)
		(*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName = zNewName
	} else {
		sqlite3.Xsqlite3_free(tls, zNewName)
	}
	return *(*int32)(unsafe.Pointer(bp + 32 /* rc */))
}

// A virtual table module that provides fuzzy search.
var spellfix1Module = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate - handle CREATE VIRTUAL TABLE
	FxConnect:    0, // xConnect - reconnected to an existing table
	FxBestIndex:  0, // xBestIndex - figure out how to do a query
	FxDisconnect: 0, // xDisconnect - close a connection
	FxDestroy:    0, // xDestroy - handle DROP TABLE
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRowid - read data
	FxUpdate:     0, // xFindMethod
	FxRename:     0, // xRename
} /* spellfix.c:2991:23 */

// Register the various functions and the virtual table.
func spellfix1Register(tls *libc.TLS, db uintptr) int32 { /* spellfix.c:3017:12: */
	var rc int32 = SQLITE_OK
	var i int32
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7769 /* "spellfix1_transl..." */, 1,
		(SQLITE_UTF8 | SQLITE_DETERMINISTIC), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{transliterateSqlFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7788 /* "spellfix1_editdi..." */, 2,
			(SQLITE_UTF8 | SQLITE_DETERMINISTIC), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{editdistSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7807 /* "spellfix1_phoneh..." */, 1,
			(SQLITE_UTF8 | SQLITE_DETERMINISTIC), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{phoneticHashSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7827 /* "spellfix1_script..." */, 1,
			(SQLITE_UTF8 | SQLITE_DETERMINISTIC), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{scriptCodeSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+7848 /* "spellfix1" */, uintptr(unsafe.Pointer(&spellfix1Module)), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = editDist3Install(tls, db)
	}

	// Verify sanity of the translit[] table
	for i = 0; uint32(i) < ((uint32(unsafe.Sizeof(translit)) / uint32(unsafe.Sizeof(Transliteration{}))) - uint32(1)); i++ {

	}

	return rc
}

// Extension load function.
func sqlite3_spellfix_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* spellfix.c:3061:5: */
	_ = pApi

	return spellfix1Register(tls, db)
	return SQLITE_OK
}

// Determine if this is running on a big-endian or little-endian
// processor
var totype_one int32 = 1 /* totype.c:49:13 */

// Constants for the largest and smallest possible 64-bit signed integers.
// These macros are designed to work correctly on both 32-bit and 64-bit
// compilers.

// Return TRUE if character c is a whitespace character
func totypeIsspace(tls *libc.TLS, c uint8) int32 { /* totype.c:70:12: */
	return (libc.Bool32((((((int32(c) == ' ') || (int32(c) == '\t')) || (int32(c) == '\n')) || (int32(c) == '\v')) || (int32(c) == '\f')) || (int32(c) == '\r')))
}

// Return TRUE if character c is a digit
func totypeIsdigit(tls *libc.TLS, c uint8) int32 { /* totype.c:77:12: */
	return (libc.Bool32((int32(c) >= '0') && (int32(c) <= '9')))
}

// Compare the 19-character string zNum against the text representation
// value 2^63:  9223372036854775808.  Return negative, zero, or positive
// if zNum is less than, equal to, or greater than the string.
// Note that zNum must contain exactly 19 characters.
//
// Unlike memcmp() this routine is guaranteed to return the difference
// in the values of the last digit if the only difference is in the
// last digit.  So, for example,
//
//      totypeCompare2pow63("9223372036854775800")
//
// will return -8.
func totypeCompare2pow63(tls *libc.TLS, zNum uintptr) int32 { /* totype.c:95:12: */
	var c int32 = 0
	var i int32
	// 012345678901234567
	var pow63 uintptr = ts + 7858 /* "9223372036854775..." */
	for i = 0; (c == 0) && (i < 18); i++ {
		c = ((int32(*(*int8)(unsafe.Pointer(zNum + uintptr(i)))) - int32(*(*int8)(unsafe.Pointer(pow63 + uintptr(i))))) * 10)
	}
	if c == 0 {
		c = (int32(*(*int8)(unsafe.Pointer(zNum + 18))) - '8')
	}
	return c
}

// Convert zNum to a 64-bit signed integer.
//
// If the zNum value is representable as a 64-bit twos-complement
// integer, then write that value into *pNum and return 0.
//
// If zNum is exactly 9223372036854665808, return 2.  This special
// case is broken out because while 9223372036854665808 cannot be a
// signed 64-bit integer, its negative -9223372036854665808 can be.
//
// If zNum is too big for a 64-bit integer and is not
// 9223372036854665808  or if zNum contains any non-numeric text,
// then return 1.
//
// The string is not necessarily zero-terminated.
func totypeAtoi64(tls *libc.TLS, zNum uintptr, pNum uintptr, length int32) int32 { /* totype.c:125:12: */
	var u sqlite3_uint64 = uint64(0)
	var neg int32 = 0 // assume positive
	var i int32
	var c int32 = 0
	var nonNum int32 = 0
	var zStart uintptr
	var zEnd uintptr = (zNum + uintptr(length))

	for (zNum < zEnd) && (totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(zNum)))) != 0) {
		zNum++
	}
	if zNum < zEnd {
		if int32(*(*int8)(unsafe.Pointer(zNum))) == '-' {
			neg = 1
			zNum++
		} else if int32(*(*int8)(unsafe.Pointer(zNum))) == '+' {
			zNum++
		}
	}
	zStart = zNum
	for (zNum < zEnd) && (int32(*(*int8)(unsafe.Pointer(zNum))) == '0') {
		zNum++
	} // Skip leading zeros.
	for i = 0; (((zNum + uintptr(i)) < zEnd) && ((libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(zNum + uintptr(i)))))) >= '0')) && (c <= '9'); i++ {
		u = (((u * uint64(10)) + sqlite3_uint64(c)) - uint64('0'))
	}
	if u > (uint64(int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32))) {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = ((int64(-1)) - (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)))
	} else if neg != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = -sqlite3_int64(u)
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = sqlite3_int64(u)
	}
	if ((((c != 0) && ((zNum + uintptr(i)) < zEnd)) || ((i == 0) && (zStart == zNum))) || (i > 19)) || (nonNum != 0) {
		// zNum is empty or contains non-numeric text or is longer
		// than 19 digits (thus guaranteeing that it is too large)
		return 1
	} else if i < 19 {
		// Less than 19 digits, so we know that it fits in 64 bits

		return 0
	} else {
		// zNum is a 19-digit numbers.  Compare it against 9223372036854775808.
		c = totypeCompare2pow63(tls, zNum)
		if c < 0 {
			// zNum is less than 9223372036854775808 so it fits

			return 0
		} else if c > 0 {
			// zNum is greater than 9223372036854775808 so it overflows
			return 1
		} else {
			// zNum is exactly 9223372036854775808.  Fits if negative.  The
			// special case 2 overflow if positive

			if neg != 0 {
				return 0
			}
			return 2
		}
	}
	return int32(0)
}

// The string z[] is an text representation of a real number.
// Convert this string to a double and write it into *pResult.
//
// The string is not necessarily zero-terminated.
//
// Return TRUE if the result is a valid real number (or integer) and FALSE
// if the string is empty or contains extraneous text.  Valid numbers
// are in one of these formats:
//
//    [+-]digits[E[+-]digits]
//    [+-]digits.[digits][E[+-]digits]
//    [+-].digits[E[+-]digits]
//
// Leading and trailing whitespace is ignored for the purpose of determining
// validity.
//
// If some prefix of the input string is a valid number, this routine
// returns FALSE but it still converts the prefix and writes the result
// into *pResult.
func totypeAtoF(tls *libc.TLS, z uintptr, pResult uintptr, length int32) int32 { /* totype.c:204:12: */
	var zEnd uintptr
	// sign * significand * (10 ^ (esign * exponent))
	var sign int32      // sign of significand
	var s sqlite3_int64 // significand
	var d int32         // adjust exponent for shifting decimal point
	var esign int32     // sign of exponent
	var e int32         // exponent
	var eValid int32    // True exponent is either not used or is well-formed
	var result float64
	var nDigits int32
	var nonNum int32
	var scale float64
	zEnd = (z + uintptr(length))
	sign = 1
	s = int64(0)
	d = 0
	esign = 1
	e = 0
	eValid = 1
	nDigits = 0
	nonNum = 0

	*(*float64)(unsafe.Pointer(pResult)) = 0.0 // Default return value, in case of an error

	// skip leading spaces
__1:
	if !((z < zEnd) && (totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) {
		goto __2
	}
	z++
	goto __1
__2:
	;
	if !(z >= zEnd) {
		goto __3
	}
	return 0
__3:
	;

	// get sign of significand
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '-') {
		goto __4
	}
	sign = -1
	z++
	goto __5
__4:
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '+') {
		goto __6
	}
	z++
__6:
	;
__5:
	;

	// skip leading zeroes
__7:
	if !((z < zEnd) && (int32(*(*int8)(unsafe.Pointer(z))) == '0')) {
		goto __8
	}
	z++
	nDigits++
	goto __7
__8:
	;

	// copy max significant digits to significand
__9:
	if !(((z < zEnd) && (totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) && (s < (((int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)) - int64(9)) / int64(10)))) {
		goto __10
	}
	s = ((s * int64(10)) + (sqlite3_int64(int32(*(*int8)(unsafe.Pointer(z))) - '0')))
	z++
	nDigits++
	goto __9
__10:
	;

	// skip non-significant significand digits
	// (increase exponent by d to shift decimal left)
__11:
	if !((z < zEnd) && (totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) {
		goto __12
	}
	z++
	nDigits++
	d++
	goto __11
__12:
	;
	if !(z >= zEnd) {
		goto __13
	}
	goto totype_atof_calc
__13:
	;

	// if decimal point is present
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '.') {
		goto __14
	}
	z++
	// copy digits from after decimal to significand
	// (decrease exponent by d to shift decimal right)
__15:
	if !(((z < zEnd) && (totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) && (s < (((int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)) - int64(9)) / int64(10)))) {
		goto __16
	}
	s = ((s * int64(10)) + (sqlite3_int64(int32(*(*int8)(unsafe.Pointer(z))) - '0')))
	z++
	nDigits++
	d--
	goto __15
__16:
	;
	// skip non-significant digits
__17:
	if !((z < zEnd) && (totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) {
		goto __18
	}
	z++
	nDigits++
	goto __17
__18:
	;
__14:
	;
	if !(z >= zEnd) {
		goto __19
	}
	goto totype_atof_calc
__19:
	;

	// if exponent is present
	if !((int32(*(*int8)(unsafe.Pointer(z))) == 'e') || (int32(*(*int8)(unsafe.Pointer(z))) == 'E')) {
		goto __20
	}
	z++
	eValid = 0
	if !(z >= zEnd) {
		goto __21
	}
	goto totype_atof_calc
__21:
	;
	// get sign of exponent
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '-') {
		goto __22
	}
	esign = -1
	z++
	goto __23
__22:
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '+') {
		goto __24
	}
	z++
__24:
	;
__23:
	;
	// copy digits to exponent
__25:
	if !((z < zEnd) && (totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) {
		goto __26
	}
	if e < 10000 {
		e = ((e * 10) + (int32(*(*int8)(unsafe.Pointer(z))) - '0'))
	} else {
		e = 10000
	}
	z++
	eValid = 1
	goto __25
__26:
	;
__20:
	;

	// skip trailing spaces
	if !((nDigits != 0) && (eValid != 0)) {
		goto __27
	}
__28:
	if !((z < zEnd) && (totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) {
		goto __29
	}
	z++
	goto __28
__29:
	;
__27:
	;

totype_atof_calc:
	// adjust exponent by d, and update sign
	e = ((e * esign) + d)
	if !(e < 0) {
		goto __30
	}
	esign = -1
	e = e * (-1)
	goto __31
__30:
	esign = 1
__31:
	;

	// if 0 significand
	if !(!(s != 0)) {
		goto __32
	}
	// In the IEEE 754 standard, zero is signed.
	// Add the sign if we've seen at least one digit
	if (sign < 0) && (nDigits != 0) {
		result = -libc.Float64FromFloat64(float64(0))
	} else {
		result = float64(0)
	}
	goto __33
__32:
	// attempt to reduce exponent
	if !(esign > 0) {
		goto __34
	}
__36:
	if !((s < ((int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)) / int64(10))) && (e > 0)) {
		goto __37
	}
	e--
	s = s * (int64(10))
	goto __36
__37:
	;
	goto __35
__34:
__38:
	if !(!((int32(s % int64(10))) != 0) && (e > 0)) {
		goto __39
	}
	e--
	s = s / (int64(10))
	goto __38
__39:
	;
__35:
	;

	// adjust the sign of significand
	if sign < 0 {
		s = -s
	} else {
		s = s
	}

	// if exponent, scale significand as appropriate
	// and store in result.
	if !(e != 0) {
		goto __40
	}
	scale = 1.0
	// attempt to handle extremely small/large numbers better
	if !((e > 307) && (e < 342)) {
		goto __42
	}
__44:
	if !((e % 308) != 0) {
		goto __45
	}
	scale = scale * (1.0e+1)
	e = e - (1)
	goto __44
__45:
	;
	if !(esign < 0) {
		goto __46
	}
	result = (float64(s) / scale)
	result = result / (1.0e+308)
	goto __47
__46:
	result = (float64(s) * scale)
	result = result * (1.0e+308)
__47:
	;
	goto __43
__42:
	if !(e >= 342) {
		goto __48
	}
	if !(esign < 0) {
		goto __50
	}
	result = (0.0 * float64(s))
	goto __51
__50:
	result = ((libc.Float64(1e308) * libc.Float64(1e308)) * float64(s)) // Infinity
__51:
	;
	goto __49
__48:
	// 1.0e+22 is the largest power of 10 than can be
	// represented exactly.
__52:
	if !((e % 22) != 0) {
		goto __53
	}
	scale = scale * (1.0e+1)
	e = e - (1)
	goto __52
__53:
	;
__54:
	if !(e > 0) {
		goto __55
	}
	scale = scale * (1.0e+22)
	e = e - (22)
	goto __54
__55:
	;
	if !(esign < 0) {
		goto __56
	}
	result = (float64(s) / scale)
	goto __57
__56:
	result = (float64(s) * scale)
__57:
	;
__49:
	;
__43:
	;
	goto __41
__40:
	result = float64(s)
__41:
	;
__33:
	;

	// store the result
	*(*float64)(unsafe.Pointer(pResult)) = result

	// return true if number and no extra non-whitespace chracters after
	return (libc.Bool32((((z >= zEnd) && (nDigits > 0)) && (eValid != 0)) && (nonNum == 0)))
}

// tointeger(X):  If X is any value (integer, double, blob, or string) that
// can be losslessly converted into an integer, then make the conversion and
// return the result.  Otherwise, return NULL.
func tointegerFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* totype.c:358:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = argc
	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) {
	case SQLITE_FLOAT:
		{
			var rVal float64 = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
			var iVal sqlite3_int64 = sqlite3_int64(rVal)
			if rVal == float64(iVal) {
				sqlite3.Xsqlite3_result_int64(tls, context, iVal)
			}
			break

		}
	case SQLITE_INTEGER:
		{
			sqlite3.Xsqlite3_result_int64(tls, context, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
			break

		}
	case SQLITE_BLOB:
		{
			var zBlob uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zBlob != 0 {
				var nBlob int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if uint32(nBlob) == uint32(unsafe.Sizeof(sqlite3_int64(0))) {
					// var iVal sqlite3_int64 at bp+8, 8

					if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&totype_one))))) == 0 {
						var i int32
						// var zBlobRev [8]uint8 at bp, 8

						for i = 0; uint32(i) < uint32(unsafe.Sizeof(sqlite3_int64(0))); i++ {
							*(*uint8)(unsafe.Pointer(bp /* &zBlobRev[0] */ + uintptr(i))) = *(*uint8)(unsafe.Pointer(zBlob + uintptr(((uint32(unsafe.Sizeof(sqlite3_int64(0))) - uint32(1)) - uint32(i)))))
						}
						libc.Xmemcpy(tls, bp+8 /* &iVal */, bp /* &zBlobRev[0] */, uint32(unsafe.Sizeof(sqlite3_int64(0))))
					} else {
						libc.Xmemcpy(tls, bp+8 /* &iVal */, zBlob, uint32(unsafe.Sizeof(sqlite3_int64(0))))
					}
					sqlite3.Xsqlite3_result_int64(tls, context, *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* iVal */)))
				}
			}
			break

		}
	case SQLITE_TEXT:
		{
			var zStr uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zStr != 0 {
				var nStr int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if (nStr != 0) && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr))) != 0) {
					// var iVal sqlite3_int64 at bp+16, 8

					if !(totypeAtoi64(tls, zStr, bp+16 /* &iVal */, nStr) != 0) {
						sqlite3.Xsqlite3_result_int64(tls, context, *(*sqlite3_int64)(unsafe.Pointer(bp + 16 /* iVal */)))
					}
				}
			}
			break

		}
	default:
		{

			break

		}
	}
}

// toreal(X): If X is any value (integer, double, blob, or string) that can
// be losslessly converted into a real number, then do so and return that
// real number.  Otherwise return NULL.
func torealFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* totype.c:428:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = argc
	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) {
	case SQLITE_FLOAT:
		{
			sqlite3.Xsqlite3_result_double(tls, context, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv))))
			break

		}
	case SQLITE_INTEGER:
		{
			var iVal sqlite3_int64 = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
			var rVal float64 = float64(iVal)
			if iVal == sqlite3_int64(rVal) {
				sqlite3.Xsqlite3_result_double(tls, context, rVal)
			}
			break

		}
	case SQLITE_BLOB:
		{
			var zBlob uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zBlob != 0 {
				var nBlob int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if uint32(nBlob) == uint32(unsafe.Sizeof(float64(0))) {
					// var rVal float64 at bp+8, 8

					if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&totype_one))))) == 1 {
						var i int32
						// var zBlobRev [8]uint8 at bp, 8

						for i = 0; uint32(i) < uint32(unsafe.Sizeof(float64(0))); i++ {
							*(*uint8)(unsafe.Pointer(bp /* &zBlobRev[0] */ + uintptr(i))) = *(*uint8)(unsafe.Pointer(zBlob + uintptr(((uint32(unsafe.Sizeof(float64(0))) - uint32(1)) - uint32(i)))))
						}
						libc.Xmemcpy(tls, bp+8 /* &rVal */, bp /* &zBlobRev[0] */, uint32(unsafe.Sizeof(float64(0))))
					} else {
						libc.Xmemcpy(tls, bp+8 /* &rVal */, zBlob, uint32(unsafe.Sizeof(float64(0))))
					}
					sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 8 /* rVal */)))
				}
			}
			break

		}
	case SQLITE_TEXT:
		{
			var zStr uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zStr != 0 {
				var nStr int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if ((nStr != 0) && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr))) != 0)) && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr + uintptr((nStr - 1))))) != 0) {
					// var rVal float64 at bp+16, 8

					if totypeAtoF(tls, zStr, bp+16 /* &rVal */, nStr) != 0 {
						sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 16 /* rVal */)))
						return
					}
				}
			}
			break

		}
	default:
		{

			break

		}
	}
}

func sqlite3_totype_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* totype.c:497:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7877 /* "tointeger" */, 1,
		((SQLITE_UTF8 | SQLITE_DETERMINISTIC) | SQLITE_INNOCUOUS), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tointegerFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7887 /* "toreal" */, 1,
			((SQLITE_UTF8 | SQLITE_DETERMINISTIC) | SQLITE_INNOCUOUS), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{torealFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Largest and smallest possible 64-bit signed integers. These macros
// copied from sqliteInt.h.

// The following is also copied from sqliteInt.h. To facilitate coverage
// testing.

// The swarmvtab module attempts to keep the number of open database files
// at or below this limit. This may not be possible if there are too many
// simultaneous queries.

type UnionCsr1 = struct {
	Fbase      sqlite3_vtab_cursor
	FpStmt     uintptr
	FiMaxRowid sqlite3_int64
	FiTab      int32
	_          [4]byte
} /* unionvtab.c:181:9 */

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Largest and smallest possible 64-bit signed integers. These macros
// copied from sqliteInt.h.

// The following is also copied from sqliteInt.h. To facilitate coverage
// testing.

// The swarmvtab module attempts to keep the number of open database files
// at or below this limit. This may not be possible if there are too many
// simultaneous queries.

type UnionCsr = UnionCsr1 /* unionvtab.c:181:25 */
type UnionTab1 = struct {
	Fbase        sqlite3_vtab
	Fdb          uintptr
	FbSwarm      int32
	FiPK         int32
	FnSrc        int32
	FaSrc        uintptr
	FbHasContext int32
	FzSourceStr  uintptr
	FpNotFound   uintptr
	FpOpenClose  uintptr
	FpClosable   uintptr
	FnOpen       int32
	FnMaxOpen    int32
} /* unionvtab.c:182:9 */

type UnionTab = UnionTab1 /* unionvtab.c:182:25 */
type UnionSrc1 = struct {
	FzDb           uintptr
	FzTab          uintptr
	FiMin          sqlite3_int64
	FiMax          sqlite3_int64
	FzFile         uintptr
	FzContext      uintptr
	FnUser         int32
	Fdb            uintptr
	FpNextClosable uintptr
	_              [4]byte
} /* unionvtab.c:182:9 */

type UnionSrc = UnionSrc1 /* unionvtab.c:183:25 */

// Given UnionTab table pTab and UnionSrc object pSrc, return the database
// handle that should be used to access the table identified by pSrc. This
// is the main db handle for "unionvtab" tables, or the source-specific
// handle for "swarmvtab".

// If *pRc is other than SQLITE_OK when this function is called, it
// always returns NULL. Otherwise, it attempts to allocate and return
// a pointer to nByte bytes of zeroed memory. If the memory allocation
// is attempted but fails, NULL is returned and *pRc is set to
// SQLITE_NOMEM.
func unionMalloc(tls *libc.TLS, pRc uintptr, nByte sqlite3_int64) uintptr { /* unionvtab.c:253:13: */
	var pRet uintptr

	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		pRet = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
		if pRet != 0 {
			libc.Xmemset(tls, pRet, 0, size_t(nByte))
		} else {
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		}
	} else {
		pRet = uintptr(0)
	}
	return pRet
}

// If *pRc is other than SQLITE_OK when this function is called, it
// always returns NULL. Otherwise, it attempts to allocate and return
// a copy of the nul-terminated string passed as the second argument.
// If the allocation is attempted but fails, NULL is returned and *pRc is
// set to SQLITE_NOMEM.
func unionStrdup(tls *libc.TLS, pRc uintptr, zIn uintptr) uintptr { /* unionvtab.c:276:13: */
	var zRet uintptr = uintptr(0)
	if zIn != 0 {
		var nByte sqlite3_int64 = (sqlite3_int64(libc.Xstrlen(tls, zIn) + size_t(1)))
		zRet = unionMalloc(tls, pRc, nByte)
		if zRet != 0 {
			libc.Xmemcpy(tls, zRet, zIn, size_t(nByte))
		}
	}
	return zRet
}

// If the first character of the string passed as the only argument to this
// function is one of the 4 that may be used as an open quote character
// in SQL, this function assumes that the input is a well-formed quoted SQL
// string. In this case the string is dequoted in place.
//
// If the first character of the input is not an open quote, then this
// function is a no-op.
func unionDequote(tls *libc.TLS, z uintptr) { /* unionvtab.c:297:13: */
	if z != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(z))

		// Set stack variable q to the close-quote character
		if (((int32(q) == '[') || (int32(q) == '\'')) || (int32(q) == '"')) || (int32(q) == '`') {
			var iIn int32 = 1
			var iOut int32 = 0
			if int32(q) == '[' {
				q = int8(']')
			}
			for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
					if int32(*(*int8)(unsafe.Pointer(z + uintptr((iIn + 1))))) != int32(q) {
						// Character iIn was the close quote.
						iIn++
						break
					} else {
						// Character iIn and iIn+1 form an escaped quote character. Skip
						// the input cursor past both and copy a single quote character
						// to the output buffer.
						iIn = iIn + (2)
						*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = q
					}
				} else {
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
				}
			}
			*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
		}
	}
}

// This function is a no-op if *pRc is set to other than SQLITE_OK when it
// is called. NULL is returned in this case.
//
// Otherwise, the SQL statement passed as the third argument is prepared
// against the database handle passed as the second. If the statement is
// successfully prepared, a pointer to the new statement handle is
// returned. It is the responsibility of the caller to eventually free the
// statement by calling sqlite3_finalize(). Alternatively, if statement
// compilation fails, NULL is returned, *pRc is set to an SQLite error
// code and *pzErr may be set to an error message buffer allocated by
// sqlite3_malloc().
func unionPrepare(tls *libc.TLS, pRc uintptr, db uintptr, zSql uintptr, pzErr uintptr) uintptr { /* unionvtab.c:341:21: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* pRet */)) = uintptr(0)

	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		var rc int32 = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+8 /* &pRet */, uintptr(0))
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+7894 /* "sql error: %s" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
			*(*int32)(unsafe.Pointer(pRc)) = rc
		}
	}
	return *(*uintptr)(unsafe.Pointer(bp + 8 /* pRet */))
}

// Like unionPrepare(), except prepare the results of vprintf(zFmt, ...)
// instead of a constant SQL string.
func unionPreparePrintf(tls *libc.TLS, pRc uintptr, pzErr uintptr, db uintptr, zFmt uintptr, va uintptr) uintptr { /* unionvtab.c:363:21: */
	var pRet uintptr = uintptr(0)
	var zSql uintptr
	var ap va_list
	_ = ap
	ap = va

	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		if zSql == uintptr(0) {
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		} else {
			pRet = unionPrepare(tls, pRc, db, zSql, pzErr)
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	_ = ap
	return pRet
}

// Call sqlite3_reset() on SQL statement pStmt. If *pRc is set to
// SQLITE_OK when this function is called, then it is set to the
// value returned by sqlite3_reset() before this function exits.
// In this case, *pzErr may be set to point to an error message
// buffer allocated by sqlite3_malloc().

// Call sqlite3_finalize() on SQL statement pStmt. If *pRc is set to
// SQLITE_OK when this function is called, then it is set to the
// value returned by sqlite3_finalize() before this function exits.
func unionFinalize(tls *libc.TLS, pRc uintptr, pStmt uintptr, pzErr uintptr) { /* unionvtab.c:414:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var db uintptr = sqlite3.Xsqlite3_db_handle(tls, pStmt)
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, pStmt)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(pRc)) = rc
		if rc != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
		}
	}
}

// If an "openclose" UDF was supplied when this virtual table was created,
// invoke it now. The first argument passed is the name of the database
// file for source pSrc. The second is integer value bClose.
//
// If successful, return SQLITE_OK. Otherwise an SQLite error code. In this
// case if argument pzErr is not NULL, also set (*pzErr) to an English
// language error message. The caller is responsible for eventually freeing
// any error message using sqlite3_free().
func unionInvokeOpenClose(tls *libc.TLS, pTab uintptr, pSrc uintptr, bClose int32, pzErr uintptr) int32 { /* unionvtab.c:435:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK
	if (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose != 0 {
		sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, -1, uintptr(0))
		if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
			sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext, -1, uintptr(0))
		}
		sqlite3.Xsqlite3_bind_int(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, (2 + (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext), bClose)
		sqlite3.Xsqlite3_step(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose)
		if SQLITE_OK != (libc.AssignInt32(&rc, sqlite3.Xsqlite3_reset(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose))) {
			if pzErr != 0 {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*UnionTab)(unsafe.Pointer(pTab)).Fdb)))
			}
		}
	}
	return rc
}

// This function is a no-op for unionvtab. For swarmvtab, it attempts to
// close open database files until at most nMax are open. An SQLite error
// code is returned if an error occurs, or SQLITE_OK otherwise.
func unionCloseSources(tls *libc.TLS, pTab uintptr, nMax int32) { /* unionvtab.c:463:13: */
	for ((*UnionTab)(unsafe.Pointer(pTab)).FpClosable != 0) && ((*UnionTab)(unsafe.Pointer(pTab)).FnOpen > nMax) {
		var p uintptr
		var pp uintptr
		for pp = (pTab + 48 /* &.pClosable */); (*UnionSrc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pp)))).FpNextClosable != 0; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 40 /* &.pNextClosable */) {
		}
		p = *(*uintptr)(unsafe.Pointer(pp))

		sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(p)).Fdb)
		(*UnionSrc)(unsafe.Pointer(p)).Fdb = uintptr(0)
		*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
		(*UnionTab)(unsafe.Pointer(pTab)).FnOpen--
		unionInvokeOpenClose(tls, pTab, p, 1, uintptr(0))
	}
}

// xDisconnect method.
func unionDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* unionvtab.c:481:12: */
	if pVtab != 0 {
		var pTab uintptr = pVtab
		var i int32
		for i = 0; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
			var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(i)*48)
			var bHaveSrcDb int32 = (libc.Bool32((*UnionSrc)(unsafe.Pointer(pSrc)).Fdb != uintptr(0)))
			sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
			if bHaveSrcDb != 0 {
				unionInvokeOpenClose(tls, pTab, pSrc, 1, uintptr(0))
			}
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext)
		}
		sqlite3.Xsqlite3_finalize(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound)
		sqlite3.Xsqlite3_finalize(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose)
		sqlite3.Xsqlite3_free(tls, (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr)
		sqlite3.Xsqlite3_free(tls, (*UnionTab)(unsafe.Pointer(pTab)).FaSrc)
		sqlite3.Xsqlite3_free(tls, pTab)
	}
	return SQLITE_OK
}

// Check that the table identified by pSrc is a rowid table. If not,
// return SQLITE_ERROR and set (*pzErr) to point to an English language
// error message. If the table is a rowid table and no error occurs,
// return SQLITE_OK and leave (*pzErr) unmodified.
func unionIsIntkeyTable(tls *libc.TLS, db uintptr, pSrc uintptr, pzErr uintptr) int32 { /* unionvtab.c:512:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*int32)(unsafe.Pointer(bp + 28 /* bPk */)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 24 /* zType */)) = uintptr(0)
	var rc int32

	sqlite3.Xsqlite3_table_column_metadata(tls,
		db, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, ts+7908 /* "_rowid_" */, bp+24 /* &zType */, uintptr(0), uintptr(0), bp+28 /* &bPk */, uintptr(0))
	rc = sqlite3.Xsqlite3_errcode(tls, db)
	if (rc == SQLITE_ERROR) ||
		((rc == SQLITE_OK) && (!(*(*int32)(unsafe.Pointer(bp + 28 /* bPk */)) != 0) || (sqlite3.Xsqlite3_stricmp(tls, ts+7916 /* "integer" */, *(*uintptr)(unsafe.Pointer(bp + 24 /* zType */))) != 0))) {
		rc = SQLITE_ERROR
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+7924, /* "no such rowid ta..." */
			libc.VaList(bp, func() uintptr {
				if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
					return (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb
				}
				return ts + 489 /* "" */
			}(),
				func() uintptr {
					if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
						return ts + 7952 /* "." */
					}
					return ts + 489 /* "" */
				}(),
				(*UnionSrc)(unsafe.Pointer(pSrc)).FzTab))
	}
	return rc
}

// This function is a no-op if *pRc is other than SQLITE_OK when it is
// called. In this case it returns NULL.
//
// Otherwise, this function checks that the source table passed as the
// second argument (a) exists, (b) is not a view and (c) has a column
// named "_rowid_" of type "integer" that is the primary key.
// If this is not the case, *pRc is set to SQLITE_ERROR and NULL is
// returned.
//
// Finally, if the source table passes the checks above, a nul-terminated
// string describing the column names and types belonging to the source
// table is returned. Tables with the same set of column names and types
// cause this function to return identical strings. Is is the responsibility
// of the caller to free the returned string using sqlite3_free() when
// it is no longer required.
func unionSourceToStr(tls *libc.TLS, pRc uintptr, pTab uintptr, pSrc uintptr, pzErr uintptr) uintptr { /* unionvtab.c:555:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zRet uintptr = uintptr(0)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		var db uintptr = func() uintptr {
			if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
				return (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb
			}
			return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
		}()
		*(*int32)(unsafe.Pointer(bp /* rc */)) = unionIsIntkeyTable(tls, db, pSrc, pzErr)
		var pStmt uintptr = unionPrepare(tls, bp /* &rc */, db,

			ts+7954 /* "SELECT group_con..." */, pzErr)
		if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
			sqlite3.Xsqlite3_bind_text(tls, pStmt, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pStmt, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb, -1, uintptr(0))
			if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt) {
				var z uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
				zRet = unionStrdup(tls, bp /* &rc */, z)
			}
			unionFinalize(tls, bp /* &rc */, pStmt, pzErr)
		}
		*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp /* rc */))
	}

	return zRet
}

// Check that all configured source tables exist and have the same column
// names and datatypes. If this is not the case, or if some other error
// occurs, return an SQLite error code. In this case *pzErr may be set
// to point to an error message buffer allocated by sqlite3_mprintf().
// Or, if no problems regarding the source tables are detected and no
// other error occurs, SQLITE_OK is returned.
func unionSourceCheck(tls *libc.TLS, pTab uintptr, pzErr uintptr) int32 { /* unionvtab.c:592:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var z0 uintptr = uintptr(0)
	var i int32

	z0 = unionSourceToStr(tls, bp /* &rc */, pTab, ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc), pzErr)
	for i = 1; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
		var z uintptr = unionSourceToStr(tls, bp /* &rc */, pTab, ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(i)*48), pzErr)
		if (*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (sqlite3.Xsqlite3_stricmp(tls, z, z0) != 0) {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8038 /* "source table sch..." */, 0)
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_ERROR
		}
		sqlite3.Xsqlite3_free(tls, z)
	}
	sqlite3.Xsqlite3_free(tls, z0)

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Try to open the swarmvtab database.  If initially unable, invoke the
// not-found callback UDF and then try again.
func unionOpenDatabaseInner(tls *libc.TLS, pTab uintptr, pSrc uintptr, pzErr uintptr) int32 { /* unionvtab.c:616:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32

	rc = unionInvokeOpenClose(tls, pTab, pSrc, 0, pzErr)
	if rc != SQLITE_OK {
		return rc
	}

	rc = sqlite3.Xsqlite3_open_v2(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, (pSrc + 36 /* &.db */), openFlags, uintptr(0))
	if rc == SQLITE_OK {
		return rc
	}
	if (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound != 0 {
		sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
		(*UnionSrc)(unsafe.Pointer(pSrc)).Fdb = uintptr(0)
		sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, -1, uintptr(0))
		if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
			sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext, -1, uintptr(0))
		}
		sqlite3.Xsqlite3_step(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound)
		if SQLITE_OK != (libc.AssignInt32(&rc, sqlite3.Xsqlite3_reset(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound))) {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*UnionTab)(unsafe.Pointer(pTab)).Fdb)))
			return rc
		}
		rc = sqlite3.Xsqlite3_open_v2(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, (pSrc + 36 /* &.db */), openFlags, uintptr(0))
	}
	if rc != SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, sqlite3.Xsqlite3_errmsg(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)))
	}
	return rc
}

var openFlags int32 = (SQLITE_OPEN_READONLY | SQLITE_OPEN_URI) /* unionvtab.c:617:20 */

// This function may only be called for swarmvtab tables. The results of
// calling it on a unionvtab table are undefined.
//
// For a swarmvtab table, this function ensures that source database iSrc
// is open. If the database is opened successfully and the schema is as
// expected, or if it is already open when this function is called, SQLITE_OK
// is returned.
//
// Alternatively If an error occurs while opening the databases, or if the
// database schema is unsuitable, an SQLite error code is returned and (*pzErr)
// may be set to point to an English language error message. In this case it is
// the responsibility of the caller to eventually free the error message buffer
// using sqlite3_free().
func unionOpenDatabase(tls *libc.TLS, pTab uintptr, iSrc int32, pzErr uintptr) int32 { /* unionvtab.c:660:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(iSrc)*48)

	if (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb == uintptr(0) {
		unionCloseSources(tls, pTab, ((*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen - 1))
		*(*int32)(unsafe.Pointer(bp /* rc */)) = unionOpenDatabaseInner(tls, pTab, pSrc, pzErr)
		if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
			var z uintptr = unionSourceToStr(tls, bp /* &rc */, pTab, pSrc, pzErr)
			if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
				if (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr == uintptr(0) {
					(*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr = z
				} else {
					if sqlite3.Xsqlite3_stricmp(tls, z, (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr) != 0 {
						*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8038 /* "source table sch..." */, 0)
						*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_ERROR
					}
					sqlite3.Xsqlite3_free(tls, z)
				}
			}
		}

		if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
			(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = (*UnionTab)(unsafe.Pointer(pTab)).FpClosable
			(*UnionTab)(unsafe.Pointer(pTab)).FpClosable = pSrc
			(*UnionTab)(unsafe.Pointer(pTab)).FnOpen++
		} else {
			sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
			(*UnionSrc)(unsafe.Pointer(pSrc)).Fdb = uintptr(0)
			unionInvokeOpenClose(tls, pTab, pSrc, 1, uintptr(0))
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// This function is a no-op for unionvtab tables. For swarmvtab, increment
// the reference count for source table iTab. If the reference count was
// zero before it was incremented, also remove the source from the closable
// list.
func unionIncrRefcount(tls *libc.TLS, pTab uintptr, iTab int32) { /* unionvtab.c:704:13: */
	if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
		var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(iTab)*48)

		if (*UnionSrc)(unsafe.Pointer(pSrc)).FnUser == 0 {
			var pp uintptr
			for pp = (pTab + 48 /* &.pClosable */); *(*uintptr)(unsafe.Pointer(pp)) != pSrc; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 40 /* &.pNextClosable */) {
			}
			*(*uintptr)(unsafe.Pointer(pp)) = (*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable
			(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = uintptr(0)
		}
		(*UnionSrc)(unsafe.Pointer(pSrc)).FnUser++
	}
}

// Finalize the SQL statement pCsr->pStmt and return the result.
//
// If this is a swarmvtab table (not unionvtab) and pCsr->pStmt was not
// NULL when this function was called, also decrement the reference
// count on the associated source table. If this means the source tables
// refcount is now zero, add it to the closable list.
func unionFinalizeCsrStmt(tls *libc.TLS, pCsr uintptr) int32 { /* unionvtab.c:726:12: */
	var rc int32 = SQLITE_OK
	if (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt != 0 {
		var pTab uintptr = (*UnionCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
		var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*48)
		rc = sqlite3.Xsqlite3_finalize(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt)
		(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
		if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
			(*UnionSrc)(unsafe.Pointer(pSrc)).FnUser--

			if (*UnionSrc)(unsafe.Pointer(pSrc)).FnUser == 0 {
				(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = (*UnionTab)(unsafe.Pointer(pTab)).FpClosable
				(*UnionTab)(unsafe.Pointer(pTab)).FpClosable = pSrc
			}
			unionCloseSources(tls, pTab, (*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen)
		}
	}
	return rc
}

// Return true if the argument is a space, tab, CR or LF character.
func union_isspace(tls *libc.TLS, c int8) int32 { /* unionvtab.c:749:12: */
	return (libc.Bool32((((int32(c) == ' ') || (int32(c) == '\n')) || (int32(c) == '\r')) || (int32(c) == '\t')))
}

// Return true if the argument is an alphanumeric character in the
// ASCII range.
func union_isidchar(tls *libc.TLS, c int8) int32 { /* unionvtab.c:757:12: */
	return (libc.Bool32((((int32(c) >= 'a') && (int32(c) <= 'z')) || ((int32(c) >= 'A') && (int32(c) < 'Z'))) || ((int32(c) >= '0') && (int32(c) <= '9'))))
}

// This function is called to handle all arguments following the first
// (the SQL statement) passed to a swarmvtab (not unionvtab) CREATE
// VIRTUAL TABLE statement. It may bind parameters to the SQL statement
// or configure members of the UnionTab object passed as the second
// argument.
//
// Refer to header comments at the top of this file for a description
// of the arguments parsed.
//
// This function is a no-op if *pRc is other than SQLITE_OK when it is
// called. Otherwise, if an error occurs, *pRc is set to an SQLite error
// code. In this case *pzErr may be set to point to a buffer containing
// an English language error message. It is the responsibility of the
// caller to eventually free the buffer using sqlite3_free().
func unionConfigureVtab(tls *libc.TLS, pRc uintptr, pTab uintptr, pStmt uintptr, nArg int32, azArg uintptr, pzErr uintptr) { /* unionvtab.c:777:13: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = *(*int32)(unsafe.Pointer(pRc))
	var i int32
	if *(*int32)(unsafe.Pointer(bp + 64 /* rc */)) == SQLITE_OK {
		(*UnionTab)(unsafe.Pointer(pTab)).FbHasContext = (libc.Bool32(sqlite3.Xsqlite3_column_count(tls, pStmt) > 4))
	}
	for i = 0; (*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) == SQLITE_OK) && (i < nArg); i++ {
		var zArg uintptr = unionStrdup(tls, bp+64 /* &rc */, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4)))
		if zArg != 0 {
			var nOpt int32 = 0 // Size of option name in bytes
			var zOpt uintptr   // Pointer to option name
			var zVal uintptr   // Pointer to value

			unionDequote(tls, zArg)
			zOpt = zArg
			for union_isspace(tls, *(*int8)(unsafe.Pointer(zOpt))) != 0 {
				zOpt++
			}
			zVal = zOpt
			if int32(*(*int8)(unsafe.Pointer(zVal))) == ':' {
				zVal++
			}
			for union_isidchar(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
				zVal++
			}
			nOpt = ((int32(zVal) - int32(zOpt)) / 1)

			for union_isspace(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
				zVal++
			}
			if int32(*(*int8)(unsafe.Pointer(zVal))) == '=' {
				*(*int8)(unsafe.Pointer(zOpt + uintptr(nOpt))) = int8(0)
				zVal++
				for union_isspace(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
					zVal++
				}
				zVal = unionStrdup(tls, bp+64 /* &rc */, zVal)
				if zVal != 0 {
					unionDequote(tls, zVal)
					if int32(*(*int8)(unsafe.Pointer(zOpt))) == ':' {
						// A value to bind to the SQL statement
						var iParam int32 = sqlite3.Xsqlite3_bind_parameter_index(tls, pStmt, zOpt)
						if iParam == 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+8067 /* "swarmvtab: no su..." */, libc.VaList(bp, zOpt))
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
						} else {
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = sqlite3.Xsqlite3_bind_text(tls, pStmt, iParam, zVal, -1, libc.UintptrFromInt32(-1))
						}
					} else if (nOpt == 7) && (0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+8104 /* "maxopen" */, 7)) {
						(*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen = libc.Xatoi(tls, zVal)
						if (*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen <= 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8112 /* "swarmvtab: illeg..." */, 0)
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
						}
					} else if (nOpt == 7) && (0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+8145 /* "missing" */, 7)) {
						if (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound != 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+8153 /* "swarmvtab: dupli..." */, 0)
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
						} else {
							(*UnionTab)(unsafe.Pointer(pTab)).FpNotFound = unionPreparePrintf(tls, bp+64 /* &rc */, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
								ts+8191 /* "SELECT \"%w\"(?%s)" */, libc.VaList(bp+8, zVal, func() uintptr {
									if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
										return ts + 8208 /* ",?" */
									}
									return ts + 489 /* "" */
								}()))
						}
					} else if (nOpt == 9) && (0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+8211 /* "openclose" */, 9)) {
						if (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose != 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+8221 /* "swarmvtab: dupli..." */, 0)
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
						} else {
							(*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose = unionPreparePrintf(tls, bp+64 /* &rc */, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
								ts+8261 /* "SELECT \"%w\"(?,?%..." */, libc.VaList(bp+24, zVal, func() uintptr {
									if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
										return ts + 8208 /* ",?" */
									}
									return ts + 489 /* "" */
								}()))
						}
					} else {
						*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8280 /* "swarmvtab: unrec..." */, libc.VaList(bp+40, zOpt))
						*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
					}
					sqlite3.Xsqlite3_free(tls, zVal)
				}
			} else {
				if (i == 0) && (nArg == 1) {
					(*UnionTab)(unsafe.Pointer(pTab)).FpNotFound = unionPreparePrintf(tls, bp+64 /* &rc */, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
						ts+8315 /* "SELECT \"%w\"(?)" */, libc.VaList(bp+48, zArg))
				} else {
					*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8330 /* "swarmvtab: parse..." */, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4))))
					*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
				}
			}
			sqlite3.Xsqlite3_free(tls, zArg)
		}
	}
	*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp + 64 /* rc */))
}

// xConnect/xCreate method.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("unionvtab" or "swarmvtab")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[3]   -> SQL statement
//   argv[4]   -> not-found callback UDF name
func unionConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* unionvtab.c:883:12: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var pTab uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
	var bSwarm int32 = func() int32 {
		if pAux == uintptr(0) {
			return 0
		}
		return 1
	}()
	var zVtab uintptr = func() uintptr {
		if bSwarm != 0 {
			return ts + 8357 /* "swarmvtab" */
		}
		return ts + 8367 /* "unionvtab" */
	}()

	if sqlite3.Xsqlite3_stricmp(tls, ts+8377 /* "temp" */, *(*uintptr)(unsafe.Pointer(argv + 1*4))) != 0 {
		// unionvtab tables may only be created in the temp schema
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8382 /* "%s tables must b..." */, libc.VaList(bp, zVtab))
		*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_ERROR
	} else if (argc < 4) || ((argc > 4) && (bSwarm == 0)) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8423 /* "wrong number of ..." */, libc.VaList(bp+8, zVtab))
		*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_ERROR
	} else {
		var nAlloc int32 = 0                                                                          // Allocated size of pTab->aSrc[]
		var pStmt uintptr = uintptr(0)                                                                // Argument statement
		var zArg uintptr = unionStrdup(tls, bp+40 /* &rc */, *(*uintptr)(unsafe.Pointer(argv + 3*4))) // Copy of argument to CVT

		// Prepare the SQL statement. Instead of executing it directly, sort
		// the results by the "minimum rowid" field. This makes it easier to
		// check that there are no rowid range overlaps between source tables
		// and that the UnionTab.aSrc[] array is always sorted by rowid.
		unionDequote(tls, zArg)
		pStmt = unionPreparePrintf(tls, bp+40 /* &rc */, pzErr, db,
			ts+8456 /* "SELECT * FROM (%..." */, libc.VaList(bp+16, zArg))

		// Allocate the UnionTab structure
		pTab = unionMalloc(tls, bp+40 /* &rc */, int64(unsafe.Sizeof(UnionTab{})))
		if pTab != 0 {

			(*UnionTab)(unsafe.Pointer(pTab)).Fdb = db
			(*UnionTab)(unsafe.Pointer(pTab)).FbSwarm = bSwarm
			(*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen = SWARMVTAB_MAX_OPEN
		}

		// Parse other CVT arguments, if any
		if bSwarm != 0 {
			unionConfigureVtab(tls, bp+40 /* &rc */, pTab, pStmt, (argc - 4), (argv + 4*4), pzErr)
		}

		// Iterate through the rows returned by the SQL statement specified
		// as an argument to the CREATE VIRTUAL TABLE statement.
		for (*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt)) {
			var zDb uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
			var zTab uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
			var iMin sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 2)
			var iMax sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 3)
			var pSrc uintptr

			// Grow the pTab->aSrc[] array if required.
			if nAlloc <= (*UnionTab)(unsafe.Pointer(pTab)).FnSrc {
				var nNew int32
				if nAlloc != 0 {
					nNew = (nAlloc * 2)
				} else {
					nNew = 8
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc64(tls,
					(*UnionTab)(unsafe.Pointer(pTab)).FaSrc, (uint64(uint32(nNew) * uint32(unsafe.Sizeof(UnionSrc{})))))
				if aNew == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_NOMEM
					break
				} else {
					libc.Xmemset(tls, (aNew + uintptr((*UnionTab)(unsafe.Pointer(pTab)).FnSrc)*48), 0, ((uint32(nNew - (*UnionTab)(unsafe.Pointer(pTab)).FnSrc)) * uint32(unsafe.Sizeof(UnionSrc{}))))
					(*UnionTab)(unsafe.Pointer(pTab)).FaSrc = aNew
					nAlloc = nNew
				}
			}

			// Check for problems with the specified range of rowids
			if (iMax < iMin) || (((*UnionTab)(unsafe.Pointer(pTab)).FnSrc > 0) && (iMin <= (*UnionSrc)(unsafe.Pointer((*UnionTab)(unsafe.Pointer(pTab)).FaSrc+uintptr(((*UnionTab)(unsafe.Pointer(pTab)).FnSrc-1))*48)).FiMax)) {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8486 /* "rowid range mism..." */, 0)
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_ERROR
			}

			if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == SQLITE_OK {
				pSrc = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(libc.PostIncInt32(&(*UnionTab)(unsafe.Pointer(pTab)).FnSrc, 1))*48)
				(*UnionSrc)(unsafe.Pointer(pSrc)).FzTab = unionStrdup(tls, bp+40 /* &rc */, zTab)
				(*UnionSrc)(unsafe.Pointer(pSrc)).FiMin = iMin
				(*UnionSrc)(unsafe.Pointer(pSrc)).FiMax = iMax
				if bSwarm != 0 {
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzFile = unionStrdup(tls, bp+40 /* &rc */, zDb)
				} else {
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzDb = unionStrdup(tls, bp+40 /* &rc */, zDb)
				}
				if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
					var zContext uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 4)
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzContext = unionStrdup(tls, bp+40 /* &rc */, zContext)
				}
			}
		}
		unionFinalize(tls, bp+40 /* &rc */, pStmt, pzErr)
		pStmt = uintptr(0)

		// It is an error if the SELECT statement returned zero rows. If only
		// because there is no way to determine the schema of the virtual
		// table in this case.
		if (*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == SQLITE_OK) && ((*UnionTab)(unsafe.Pointer(pTab)).FnSrc == 0) {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8513 /* "no source tables..." */, 0)
			*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_ERROR
		}

		// For unionvtab, verify that all source tables exist and have
		// compatible schemas. For swarmvtab, attach the first database and
		// check that the first table is a rowid table only.
		if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == SQLITE_OK {
			if bSwarm != 0 {
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = unionOpenDatabase(tls, pTab, 0, pzErr)
			} else {
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = unionSourceCheck(tls, pTab, pzErr)
			}
		}

		// Compose a CREATE TABLE statement and pass it to declare_vtab()
		if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == SQLITE_OK {
			var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc)
			var tdb uintptr = func() uintptr {
				if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
					return (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb
				}
				return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
			}()
			pStmt = unionPreparePrintf(tls, bp+40 /* &rc */, pzErr, tdb,

				ts+8541, /* "SELECT 'CREATE T..." */
				libc.VaList(bp+24, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb))
		}
		if (*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == SQLITE_OK) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt)) {
			var zDecl uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
			*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = sqlite3.Xsqlite3_declare_vtab(tls, db, zDecl)
			(*UnionTab)(unsafe.Pointer(pTab)).FiPK = sqlite3.Xsqlite3_column_int(tls, pStmt, 1)
		}

		unionFinalize(tls, bp+40 /* &rc */, pStmt, pzErr)
	}

	if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) != SQLITE_OK {
		unionDisconnect(tls, pTab)
		pTab = uintptr(0)
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	return *(*int32)(unsafe.Pointer(bp + 40 /* rc */))
}

// xOpen
func unionOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* unionvtab.c:1033:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCsr uintptr
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	_ = p // Suppress harmless warning
	pCsr = unionMalloc(tls, bp /* &rc */, int64(unsafe.Sizeof(UnionCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCsr /* &.base */)
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// xClose
func unionClose(tls *libc.TLS, cur uintptr) int32 { /* unionvtab.c:1045:12: */
	var pCsr uintptr = cur
	unionFinalizeCsrStmt(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

// This function does the work of the xNext() method. Except that, if it
// returns SQLITE_ROW, it should be called again within the same xNext()
// method call. See unionNext() for details.
func doUnionNext(tls *libc.TLS, pCsr uintptr) int32 { /* unionvtab.c:1057:12: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = SQLITE_OK

	if sqlite3.Xsqlite3_step(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt) != SQLITE_ROW {
		var pTab uintptr = (*UnionCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = unionFinalizeCsrStmt(tls, pCsr)
		if (*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == SQLITE_OK) && ((*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0) {
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiTab++
			if (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc {
				var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*48)
				if (*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid >= (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin {
					// It is necessary to scan the next table.
					*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = unionOpenDatabase(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab, (pTab /* &.base */ + 8 /* &.zErrMsg */))
					(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = unionPreparePrintf(tls, bp+24 /* &rc */, (pTab /* &.base */ + 8 /* &.zErrMsg */), (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb,
						ts+8719, /* "SELECT rowid, * ..." */
						libc.VaList(bp, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab,
							func() uintptr {
								if (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax > (*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid {
									return ts + 8751 /* "WHERE _rowid_ <=" */
								}
								return ts + 8768 /* "-- " */
							}(),
							(*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid))
					if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == SQLITE_OK {

						unionIncrRefcount(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)
						*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = SQLITE_ROW
					}
				}
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp + 24 /* rc */))
}

// xNext
func unionNext(tls *libc.TLS, cur uintptr) int32 { /* unionvtab.c:1092:12: */
	var rc int32
	for ok := true; ok; ok = (rc == SQLITE_ROW) {
		rc = doUnionNext(tls, cur)
	}
	return rc
}

// xColumn
func unionColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* unionvtab.c:1103:12: */
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt, (i+1)))
	return SQLITE_OK
}

// xRowid
func unionRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* unionvtab.c:1116:12: */
	var pCsr uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt, 0)
	return SQLITE_OK
}

// xEof
func unionEof(tls *libc.TLS, cur uintptr) int32 { /* unionvtab.c:1125:12: */
	var pCsr uintptr = cur
	return (libc.Bool32((*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0)))
}

// xFilter
func unionFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* unionvtab.c:1133:12: */
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var pCsr uintptr = pVtabCursor
	*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = SQLITE_OK
	var i int32
	var zSql uintptr = uintptr(0)
	var bZero int32 = 0

	var iMin sqlite3_int64 = ((int64(-1)) - (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)))
	var iMax sqlite3_int64 = (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32))

	_ = idxStr // Suppress harmless warning

	if idxNum == SQLITE_INDEX_CONSTRAINT_EQ {

		iMin = libc.AssignInt64(&iMax, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
	} else {

		if (idxNum & (SQLITE_INDEX_CONSTRAINT_LE | SQLITE_INDEX_CONSTRAINT_LT)) != 0 {

			iMax = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if (idxNum & SQLITE_INDEX_CONSTRAINT_LT) != 0 {
				if iMax == ((int64(-1)) - (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32))) {
					bZero = 1
				} else {
					iMax--
				}
			}
		}

		if (idxNum & (SQLITE_INDEX_CONSTRAINT_GE | SQLITE_INDEX_CONSTRAINT_GT)) != 0 {

			iMin = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((argc-1))*4)))
			if (idxNum & SQLITE_INDEX_CONSTRAINT_GT) != 0 {
				if iMin == (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)) {
					bZero = 1
				} else {
					iMin++
				}
			}
		}
	}

	unionFinalizeCsrStmt(tls, pCsr)
	if bZero != 0 {
		return SQLITE_OK
	}

	for i = 0; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
		var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(i)*48)
		if (iMin > (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax) || (iMax < (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin) {
			continue
		}

		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+8772 /* "%z%sSELECT rowid..." */, libc.VaList(bp, zSql, func() uintptr {
			if zSql != 0 {
				return ts + 8806 /* " UNION ALL " */
			}
			return ts + 489 /* "" */
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return ts + 5485 /* "'" */
			}
			return ts + 489 /* "" */
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb
			}
			return ts + 489 /* "" */
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return ts + 5487 /* "'." */
			}
			return ts + 489 /* "" */
		}(), (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab))
		if zSql == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = SQLITE_NOMEM
			break
		}

		if iMin == iMax {
			zSql = sqlite3.Xsqlite3_mprintf(tls, ts+8818 /* "%z WHERE rowid=%..." */, libc.VaList(bp+48, zSql, iMin))
		} else {
			var zWhere uintptr = ts + 8838 /* "WHERE" */
			if (iMin != ((int64(-1)) - (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)))) && (iMin > (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin) {
				zSql = sqlite3.Xsqlite3_mprintf(tls, ts+8844 /* "%z WHERE rowid>=..." */, libc.VaList(bp+64, zSql, iMin))
				zWhere = ts + 8865 /* "AND" */
			}
			if (iMax != (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32))) && (iMax < (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax) {
				zSql = sqlite3.Xsqlite3_mprintf(tls, ts+8869 /* "%z %s rowid<=%ll..." */, libc.VaList(bp+80, zSql, zWhere, iMax))
			}
		}

		if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiTab = i
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid = iMax
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = unionOpenDatabase(tls, pTab, i, (pTab /* &.base */ + 8 /* &.zErrMsg */))
			break
		}
	}

	if zSql == uintptr(0) {
		return *(*int32)(unsafe.Pointer(bp + 104 /* rc */))
	} else {
		var db uintptr = func() uintptr {
			if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
				return (*UnionSrc)(unsafe.Pointer(((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*48))).Fdb
			}
			return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
		}()
		(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = unionPrepare(tls, bp+104 /* &rc */, db, zSql, (pTab /* &.base */ + 8 /* &.zErrMsg */))
		if (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt != 0 {
			unionIncrRefcount(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)
		}
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	if *(*int32)(unsafe.Pointer(bp + 104 /* rc */)) != SQLITE_OK {
		return *(*int32)(unsafe.Pointer(bp + 104 /* rc */))
	}
	return unionNext(tls, pVtabCursor)
}

// xBestIndex.
//
// This implementation searches for constraints on the rowid field. EQ,
// LE, LT, GE and GT are handled.
//
// If there is an EQ comparison, then idxNum is set to INDEX_CONSTRAINT_EQ.
// In this case the only argument passed to xFilter is the rhs of the ==
// operator.
//
// Otherwise, if an LE or LT constraint is found, then the INDEX_CONSTRAINT_LE
// or INDEX_CONSTRAINT_LT (but not both) bit is set in idxNum. The first
// argument to xFilter is the rhs of the <= or < operator.  Similarly, if
// an GE or GT constraint is found, then the INDEX_CONSTRAINT_GE or
// INDEX_CONSTRAINT_GT bit is set in idxNum. The rhs of the >= or > operator
// is passed as either the first or second argument to xFilter, depending
// on whether or not there is also a LT|LE constraint.
func unionBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* unionvtab.c:1266:12: */
	var pTab uintptr = tab
	var iEq int32 = -1
	var iLt int32 = -1
	var iGt int32 = -1
	var i int32

	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var p uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)
		if ((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0) && (((*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn < 0) || ((*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == (*UnionTab)(unsafe.Pointer(pTab)).FiPK)) {
			switch int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) {
			case SQLITE_INDEX_CONSTRAINT_EQ:
				iEq = i
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LE:
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LT:
				iLt = i
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GE:
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GT:
				iGt = i
				break
			}
		}
	}

	if iEq >= 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxFlags = SQLITE_INDEX_SCAN_UNIQUE
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 3.0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = SQLITE_INDEX_CONSTRAINT_EQ
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iEq)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iEq)*8)).Fomit = uint8(1)
	} else {
		var iCons int32 = 1
		var idxNum int32 = 0
		var nRow sqlite3_int64 = int64(1000000)
		if iLt >= 0 {
			nRow = (nRow / int64(2))
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLt)*8)).FargvIndex = libc.PostIncInt32(&iCons, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLt)*8)).Fomit = uint8(1)
			idxNum = idxNum | (int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(iLt)*12)).Fop))
		}
		if iGt >= 0 {
			nRow = (nRow / int64(2))
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iGt)*8)).FargvIndex = libc.PostIncInt32(&iCons, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iGt)*8)).Fomit = uint8(1)
			idxNum = idxNum | (int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(iGt)*12)).Fop))
		}
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = nRow
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = (3.0 * float64(nRow))
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	}

	return SQLITE_OK
}

// Register the unionvtab virtual table module with database handle db.
func createUnionVtab(tls *libc.TLS, db uintptr) int32 { /* unionvtab.c:1329:12: */
	var rc int32

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+8367 /* "unionvtab" */, uintptr(unsafe.Pointer(&unionModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+8357 /* "swarmvtab" */, uintptr(unsafe.Pointer(&unionModule)), db)
	}
	return rc
}

var unionModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0, // xBestIndex - query planner
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xShadowName
} /* unionvtab.c:1330:25 */

func sqlite3_unionvtab_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* unionvtab.c:1370:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Suppress harmless warning
	rc = createUnionVtab(tls, db)
	return rc
}

// A wholenumber cursor object
type wholenumber_cursor1 = struct {
	Fbase    sqlite3_vtab_cursor
	_        [4]byte
	FiValue  sqlite3_int64
	FmxValue sqlite3_int64
} /* wholenumber.c:34:9 */

// A wholenumber cursor object
type wholenumber_cursor = wholenumber_cursor1 /* wholenumber.c:34:35 */

// Methods for the wholenumber module
func wholenumberConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* wholenumber.c:42:12: */
	var pNew uintptr
	pNew = libc.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
	if pNew == uintptr(0) {
		return SQLITE_NOMEM
	}
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+8887 /* "CREATE TABLE x(v..." */)
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(sqlite3_vtab{})))
	return SQLITE_OK
}

// Note that for this virtual table, the xCreate and xConnect
// methods are identical.

func wholenumberDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* wholenumber.c:60:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// The xDisconnect and xDestroy methods are also the same

// Open a new wholenumber cursor.
func wholenumberOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* wholenumber.c:70:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(wholenumber_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(wholenumber_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Close a wholenumber cursor.
func wholenumberClose(tls *libc.TLS, cur uintptr) int32 { /* wholenumber.c:82:12: */
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

// Advance a cursor to its next row of output
func wholenumberNext(tls *libc.TLS, cur uintptr) int32 { /* wholenumber.c:91:12: */
	var pCur uintptr = cur
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue++
	return SQLITE_OK
}

// Return the value associated with a wholenumber.
func wholenumberColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* wholenumber.c:100:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_result_int64(tls, ctx, (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue)
	return SQLITE_OK
}

// The rowid.
func wholenumberRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* wholenumber.c:113:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue
	return SQLITE_OK
}

// When the wholenumber_cursor.rLimit value is 0 or less, that is a signal
// that the cursor has nothing more to output.
func wholenumberEof(tls *libc.TLS, cur uintptr) int32 { /* wholenumber.c:123:12: */
	var pCur uintptr = cur
	return (libc.Bool32(((*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue > (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue) || ((*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue == int64(0))))
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any wholenumberColumn, wholenumberRowid, or wholenumberEof call.
//
//    idxNum   Constraints
//    ------   ---------------------
//      0      (none)
//      1      value > $argv0
//      2      value >= $argv0
//      4      value < $argv0
//      8      value <= $argv0
//
//      5      value > $argv0 AND value < $argv1
//      6      value >= $argv0 AND value < $argv1
//      9      value > $argv0 AND value <= $argv1
//     10      value >= $argv0 AND value <= $argv1
func wholenumberFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* wholenumber.c:146:12: */
	var pCur uintptr = pVtabCursor
	var v sqlite3_int64
	var i int32 = 0
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue = int64(1)
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0xffffffff) // 4294967295
	if (idxNum & 3) != 0 {
		v = (sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))) + (sqlite3_int64(idxNum & 1)))
		if (v > (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue) && (v <= (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue) {
			(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue = v
		}
		i++
	}
	if (idxNum & 12) != 0 {
		v = (sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))) - (sqlite3_int64((idxNum >> 2) & 1)))
		if (v >= (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue) && (v < (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue) {
			(*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue = v
		}
	}
	return SQLITE_OK
}

// Search for terms of these forms:
//
//  (1)  value > $value
//  (2)  value >= $value
//  (4)  value < $value
//  (8)  value <= $value
//
// idxNum is an ORed combination of 1 or 2 with 4 or 8.
func wholenumberBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* wholenumber.c:178:12: */
	var i int32
	var idxNum int32 = 0
	var argvIdx int32 = 1
	var ltIdx int32 = -1
	var gtIdx int32 = -1
	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if ((idxNum & 3) == 0) && (int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_GT) {
			idxNum = idxNum | (1)
			ltIdx = i
		}
		if ((idxNum & 3) == 0) && (int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_GE) {
			idxNum = idxNum | (2)
			ltIdx = i
		}
		if ((idxNum & 12) == 0) && (int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT) {
			idxNum = idxNum | (4)
			gtIdx = i
		}
		if ((idxNum & 12) == 0) && (int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE) {
			idxNum = idxNum | (8)
			gtIdx = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	if ltIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ltIdx)*8)).FargvIndex = libc.PostIncInt32(&argvIdx, 1)
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ltIdx)*8)).Fomit = uint8(1)
	}
	if gtIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(gtIdx)*8)).FargvIndex = argvIdx
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(gtIdx)*8)).Fomit = uint8(1)
	}
	if ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) &&
		(int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0) {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	if (idxNum & 12) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e99
	} else if (idxNum & 3) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(5)
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1)
	}
	return SQLITE_OK
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var wholenumberModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* wholenumber.c:236:23 */

func sqlite3_wholenumber_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* wholenumber.c:264:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+8909 /* "wholenumber" */, uintptr(unsafe.Pointer(&wholenumberModule)), uintptr(0))
	return rc
}

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Type whose alignment is supported in every context and is at least
//    as great as that of any standard type not using alignment
//    specifiers.
type max_align_t = struct {
	F__max_align_ll int64
	F__max_align_ld float64
} /* stddef.h:437:3 */

type z_size_t = size_t /* zconf.h:248:21 */

// Maximum value for memLevel in deflateInit2

// Maximum value for windowBits in deflateInit2 and inflateInit2.
// WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
// created by gzip. (Files created by minigzip can still be extracted by
// gzip.)

// The memory requirements for deflate are (in bytes):
//             (1 << (windowBits+2)) +  (1 << (memLevel+9))
//  that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
//  plus a few kilobytes for small objects. For example, if you want to reduce
//  the default memory requirements from 256K to 128K, compile with
//      make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
//  Of course this will generally degrade compression (there's no free lunch).
//
//    The memory requirements for inflate are (in bytes) 1 << windowBits
//  that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
//  for small objects.

// Type declarations

// The following definitions for FAR are needed only for MSDOS mixed
// model programming (small or medium model with some far allocations).
// This was tested only with MSC; for other MSDOS compilers you may have
// to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
// just define FAR to be empty.

type Byte = uint8   /* zconf.h:391:24 */ // 8 bits
type uInt = uint32  /* zconf.h:393:24 */ // 16 bits or more
type uLong = uint32 /* zconf.h:394:24 */ // 32 bits or more

type Bytef = Byte   /* zconf.h:400:22 */
type charf = int8   /* zconf.h:402:19 */
type intf = int32   /* zconf.h:403:19 */
type uIntf = uInt   /* zconf.h:404:19 */
type uLongf = uLong /* zconf.h:405:19 */

type voidpc = uintptr /* zconf.h:408:23 */
type voidpf = uintptr /* zconf.h:409:23 */
type voidp = uintptr  /* zconf.h:410:23 */

// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Use "..." so that we find syslimits.h only in this same directory.
// syslimits.h stands for the system's own limits.h file.
//    If we can use it ok unmodified, then we install this text.
//    If fixincludes fixes it, then the fixed version is installed
//    instead of this text.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Maximum length of any multibyte character in any locale.
//    We define this value here since the gcc header does not define
//    the correct value.

// If we are not using GNU CC we have to define all the symbols ourself.
//    Otherwise use gcc's definitions (see below).

// Get the compiler's limits.h, which defines almost all the ISO constants.
//
//     We put this #include_next outside the double inclusion check because
//     it should be possible to include this file more than once and still get
//     the definitions from gcc's header.

// The <limits.h> files in some gcc versions don't define LLONG_MIN,
//    LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
//    ages are available.

// The integer width macros are not defined by GCC's <limits.h> before
//    GCC 7, or if _GNU_SOURCE rather than
//    __STDC_WANT_IEC_60559_BFP_EXT__ is used to enable this feature.

// POSIX adds things to <limits.h>.
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
//
//	Never include this file directly; use <limits.h> instead.

// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// These are the standard-mandated minimum values.

// Minimum number of operations in one list I/O call.

// Minimal number of outstanding asynchronous I/O operations.

// Maximum length of arguments to `execve', including environment.

// Maximum simultaneous processes per real user ID.

// Minimal number of timer expiration overruns.

// Maximum length of a host name (not including the terminating null)
//    as returned from the GETHOSTNAME function.

// Maximum link count of a file.

// Maximum length of login name.

// Number of bytes in a terminal canonical input queue.

// Number of bytes for which space will be
//    available in a terminal input queue.

// Maximum number of message queues open for a process.

// Maximum number of supported message priorities.

// Number of bytes in a filename.

// Number of simultaneous supplementary group IDs per process.

// Number of files one process can have open at once.

// Number of bytes in a pathname.

// Number of bytes than can be written atomically to a pipe.

// The number of repeated occurrences of a BRE permitted by the
//    REGEXEC and REGCOMP functions when using the interval notation.

// Minimal number of realtime signals reserved for the application.

// Number of semaphores a process can have.

// Maximal value of a semaphore.

// Number of pending realtime signals.

// Largest value of a `ssize_t'.

// Number of streams a process can have open at once.

// The number of bytes in a symbolic link.

// The number of symbolic links that can be traversed in the
//    resolution of a pathname in the absence of a loop.

// Number of timer for a process.

// Maximum number of characters in a tty name.

// Maximum length of a timezone name (element of `tzname').

// Maximum clock resolution in nanoseconds.

// Get the implementation-specific values for the above.
// Minimum guaranteed maximum values for system limits.  Linux version.
//    Copyright (C) 1993-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public License as
//    published by the Free Software Foundation; either version 2.1 of the
//    License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; see the file COPYING.LIB.  If
//    not, see <http://www.gnu.org/licenses/>.

// The kernel header pollutes the namespace with the NR_OPEN symbol
//    and defines LINK_MAX although filesystems have different maxima.  A
//    similar thing is true for OPEN_MAX: the limit can be changed at
//    runtime and therefore the macro must not be defined.  Remove this
//    after including the header if necessary.

// The kernel sources contain a file with all the needed information.
// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// Have to remove NR_OPEN?
// Have to remove LINK_MAX?
// Have to remove OPEN_MAX?
// Have to remove ARG_MAX?

// The number of data keys per process.
// This is the value this implementation supports.

// Controlling the iterations of destructors for thread-specific data.
// Number of iterations this implementation does.

// The number of threads per process.
// We have no predefined limit on the number of threads.

// Maximum amount by which a process can descrease its asynchronous I/O
//    priority level.

// Minimum size for a thread.  We are free to choose a reasonable value.

// Maximum number of timer expiration overruns.

// Maximum tty name length.

// Maximum login name length.  This is arbitrary.

// Maximum host name length.

// Maximum message queue priority level.

// Maximum value the semaphore can have.

// ssize_t is not formally required to be the signed type
//    corresponding to size_t, but it is for all configurations supported
//    by glibc.

// This value is a guaranteed minimum maximum.
//    The current maximum can be got from `sysconf'.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; include <limits.h> instead.

// The maximum `ibase' and `obase' values allowed by the `bc' utility.

// The maximum number of elements allowed in an array by the `bc' utility.

// The maximum `scale' value allowed by the `bc' utility.

// The maximum length of a string constant accepted by the `bc' utility.

// The maximum number of weights that can be assigned to an entry of
//    the LC_COLLATE `order' keyword in the locale definition file.

// The maximum number of expressions that can be nested
//    within parentheses by the `expr' utility.

// The maximum length, in bytes, of an input line.

// The maximum number of repeated occurrences of a regular expression
//    permitted when using the interval notation `\{M,N\}'.

// The maximum number of bytes in a character class name.  We have no
//    fixed limit, 2048 is a high number.

// These values are implementation-specific,
//    and may vary within the implementation.
//    Their precise values can be obtained from sysconf.

// This value is defined like this in regex.h.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// Number of bits in a `char'.

// Maximum length of a multibyte character.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0).

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long int' can hold.
//    (Same as `int').

// Maximum value an `unsigned long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// This administrivia gets added to the end of limits.h
//    if the system has its own version of limits.h.

type z_crc_t = uint32 /* zconf.h:429:17 */

// Define some macros helping to catch buffer overflows.

// MVS linker does not support external names larger than 8 bytes

//
//     The 'zlib' compression library provides in-memory compression and
//   decompression functions, including integrity checks of the uncompressed data.
//   This version of the library supports only one compression method (deflation)
//   but other algorithms will be added later and will have the same stream
//   interface.
//
//     Compression can be done in a single step if the buffers are large enough,
//   or can be done by repeated calls of the compression function.  In the latter
//   case, the application must provide more input and/or consume the output
//   (providing more output space) before each call.
//
//     The compressed data format used by default by the in-memory functions is
//   the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
//   around a deflate stream, which is itself documented in RFC 1951.
//
//     The library also supports reading and writing files in gzip (.gz) format
//   with an interface similar to that of stdio using the functions that start
//   with "gz".  The gzip format is different from the zlib format.  gzip is a
//   gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
//
//     This library can optionally read and write gzip and raw deflate streams in
//   memory as well.
//
//     The zlib format was designed to be compact and fast for use in memory
//   and on communications channels.  The gzip format was designed for single-
//   file compression on file systems, has a larger header than zlib to maintain
//   directory information, and uses a different, slower check method than zlib.
//
//     The library does not install any signal handler.  The decoder checks
//   the consistency of the compressed data, so the library should never crash
//   even in the case of corrupted input.

type alloc_func = uintptr /* zlib.h:81:16 */
type free_func = uintptr  /* zlib.h:82:16 */

type z_stream_s = struct {
	Fnext_in   uintptr
	Favail_in  uInt
	Ftotal_in  uLong
	Fnext_out  uintptr
	Favail_out uInt
	Ftotal_out uLong
	Fmsg       uintptr
	Fstate     uintptr
	Fzalloc    alloc_func
	Fzfree     free_func
	Fopaque    voidpf
	Fdata_type int32
	Fadler     uLong
	Freserved  uLong
} /* zlib.h:86:9 */

type z_stream = z_stream_s /* zlib.h:106:3 */

type z_streamp = uintptr /* zlib.h:108:22 */

//
//      gzip header information passed to and from zlib routines.  See RFC 1952
//   for more details on the meanings of these fields.
type gz_header_s = struct {
	Ftext      int32
	Ftime      uLong
	Fxflags    int32
	Fos        int32
	Fextra     uintptr
	Fextra_len uInt
	Fextra_max uInt
	Fname      uintptr
	Fname_max  uInt
	Fcomment   uintptr
	Fcomm_max  uInt
	Fhcrc      int32
	Fdone      int32
} /* zlib.h:114:9 */

//
//      gzip header information passed to and from zlib routines.  See RFC 1952
//   for more details on the meanings of these fields.
type gz_header = gz_header_s /* zlib.h:129:3 */

type gz_headerp = uintptr /* zlib.h:131:23 */
//
//      inflateGetHeader() requests that gzip header information be stored in the
//    provided gz_header structure.  inflateGetHeader() may be called after
//    inflateInit2() or inflateReset(), and before the first call of inflate().
//    As inflate() processes the gzip stream, head->done is zero until the header
//    is completed, at which time head->done is set to one.  If a zlib stream is
//    being decoded, then head->done is set to -1 to indicate that there will be
//    no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
//    used to force inflate() to return immediately after header processing is
//    complete and before any actual data is decompressed.
//
//      The text, time, xflags, and os fields are filled in with the gzip header
//    contents.  hcrc is set to true if there is a header CRC.  (The header CRC
//    was valid if done is set to one.) If extra is not Z_NULL, then extra_max
//    contains the maximum number of bytes to write to extra.  Once done is true,
//    extra_len contains the actual extra field length, and extra contains the
//    extra field, or that field truncated if extra_max is less than extra_len.
//    If name is not Z_NULL, then up to name_max characters are written there,
//    terminated with a zero unless the length is greater than name_max.  If
//    comment is not Z_NULL, then up to comm_max characters are written there,
//    terminated with a zero unless the length is greater than comm_max.  When any
//    of extra, name, or comment are not Z_NULL and the respective field is not
//    present in the header, then that field is set to Z_NULL to signal its
//    absence.  This allows the use of deflateSetHeader() with the returned
//    structure to duplicate the header.  However if those fields are set to
//    allocated memory, then the application will need to save those pointers
//    elsewhere so that they can be eventually freed.
//
//      If inflateGetHeader is not used, then the header information is simply
//    discarded.  The header is always checked for validity, including the header
//    CRC if present.  inflateReset() will reset the process to discard the header
//    information.  The application would need to call inflateGetHeader() again to
//    retrieve the header from the next gzip stream.
//
//      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
//    stream state was inconsistent.

//
// ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
//                                         unsigned char FAR *window));
//
//      Initialize the internal stream state for decompression using inflateBack()
//    calls.  The fields zalloc, zfree and opaque in strm must be initialized
//    before the call.  If zalloc and zfree are Z_NULL, then the default library-
//    derived memory allocation routines are used.  windowBits is the base two
//    logarithm of the window size, in the range 8..15.  window is a caller
//    supplied buffer of that size.  Except for special applications where it is
//    assured that deflate was used with small window sizes, windowBits must be 15
//    and a 32K byte window must be supplied to be able to decompress general
//    deflate streams.
//
//      See inflateBack() for the usage of these routines.
//
//      inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
//    the parameters are invalid, Z_MEM_ERROR if the internal state could not be
//    allocated, or Z_VERSION_ERROR if the version of the library does not match
//    the version of the header file.

type in_func = uintptr  /* zlib.h:1092:18 */
type out_func = uintptr /* zlib.h:1094:13 */
//
//      Same as uncompress, except that sourceLen is a pointer, where the
//    length of the source is *sourceLen.  On return, *sourceLen is the number of
//    source bytes consumed.

// gzip file access functions

//
//      This library supports reading and writing files in gzip (.gz) format with
//    an interface similar to that of stdio, using the functions that start with
//    "gz".  The gzip format is different from the zlib format.  gzip is a gzip
//    wrapper, documented in RFC 1952, wrapped around a deflate stream.

type gzFile_s = struct {
	Fhave uint32
	Fnext uintptr
	Fpos  off_t
} /* zlib.h:1300:9 */

//
//      Same as uncompress, except that sourceLen is a pointer, where the
//    length of the source is *sourceLen.  On return, *sourceLen is the number of
//    source bytes consumed.

// gzip file access functions

//
//      This library supports reading and writing files in gzip (.gz) format with
//    an interface similar to that of stdio, using the functions that start with
//    "gz".  The gzip format is different from the zlib format.  gzip is a gzip
//    wrapper, documented in RFC 1952, wrapped around a deflate stream.

type gzFile = uintptr /* zlib.h:1300:25 */ // 2-byte unsigned integer

// Definitions for mode bitmasks S_IFDIR, S_IFREG and S_IFLNK.
//
// In some ways it would be better to obtain these values from system
// header files. But, the dependency is undesirable and (a) these
// have been stable for decades, (b) the values are part of POSIX and
// are also made explicit in [man stat], and (c) are part of the
// file format for zip archives.

var ZIPFILE_SCHEMA =

// 0: Name of file in zip archive
// 1: POSIX mode for file
// 2: Last modification time (secs since 1970)
// 3: Size of object
// 4: Raw data
// 5: Uncompressed data
// 6: Compression method (integer)
// 7: Name of zip file
*(*[91]int8)(unsafe.Pointer(ts + 8921 /* "CREATE TABLE y(n..." */)) /* zipfile.c:91:19 */

// Magic numbers used to read and write zip files.
//
// ZIPFILE_NEWENTRY_MADEBY:
//   Use this value for the "version-made-by" field in new zip file
//   entries. The upper byte indicates "unix", and the lower byte
//   indicates that the zip file matches pkzip specification 3.0.
//   This is what info-zip seems to do.
//
// ZIPFILE_NEWENTRY_REQUIRED:
//   Value for "version-required-to-extract" field of new entries.
//   Version 2.0 is required to support folders and deflate compression.
//
// ZIPFILE_NEWENTRY_FLAGS:
//   Value for "general-purpose-bit-flags" field of new entries. Bit
//   11 means "utf-8 filename and comment".
//
// ZIPFILE_SIGNATURE_CDS:
//   First 4 bytes of a valid CDS record.
//
// ZIPFILE_SIGNATURE_LFH:
//   First 4 bytes of a valid LFH record.
//
// ZIPFILE_SIGNATURE_EOCD
//   First 4 bytes of a valid EOCD record.

// The sizes of the fixed-size part of each of the three main data
// structures in a zip archive.

// 4.3.16  End of central directory record:
//
//   end of central dir signature    4 bytes  (0x06054b50)
//   number of this disk             2 bytes
//   number of the disk with the
//   start of the central directory  2 bytes
//   total number of entries in the
//   central directory on this disk  2 bytes
//   total number of entries in
//   the central directory           2 bytes
//   size of the central directory   4 bytes
//   offset of start of central
//   directory with respect to
//   the starting disk number        4 bytes
//   .ZIP file comment length        2 bytes
//   .ZIP file comment       (variable size)
type ZipfileEOCD1 = struct {
	FiDisk       u16
	FiFirstDisk  u16
	FnEntry      u16
	FnEntryTotal u16
	FnSize       u32
	FiOffset     u32
} /* zipfile.c:167:9 */

// Magic numbers used to read and write zip files.
//
// ZIPFILE_NEWENTRY_MADEBY:
//   Use this value for the "version-made-by" field in new zip file
//   entries. The upper byte indicates "unix", and the lower byte
//   indicates that the zip file matches pkzip specification 3.0.
//   This is what info-zip seems to do.
//
// ZIPFILE_NEWENTRY_REQUIRED:
//   Value for "version-required-to-extract" field of new entries.
//   Version 2.0 is required to support folders and deflate compression.
//
// ZIPFILE_NEWENTRY_FLAGS:
//   Value for "general-purpose-bit-flags" field of new entries. Bit
//   11 means "utf-8 filename and comment".
//
// ZIPFILE_SIGNATURE_CDS:
//   First 4 bytes of a valid CDS record.
//
// ZIPFILE_SIGNATURE_LFH:
//   First 4 bytes of a valid LFH record.
//
// ZIPFILE_SIGNATURE_EOCD
//   First 4 bytes of a valid EOCD record.

// The sizes of the fixed-size part of each of the three main data
// structures in a zip archive.

// 4.3.16  End of central directory record:
//
//   end of central dir signature    4 bytes  (0x06054b50)
//   number of this disk             2 bytes
//   number of the disk with the
//   start of the central directory  2 bytes
//   total number of entries in the
//   central directory on this disk  2 bytes
//   total number of entries in
//   the central directory           2 bytes
//   size of the central directory   4 bytes
//   offset of start of central
//   directory with respect to
//   the starting disk number        4 bytes
//   .ZIP file comment length        2 bytes
//   .ZIP file comment       (variable size)
type ZipfileEOCD = ZipfileEOCD1 /* zipfile.c:167:28 */

// 4.3.12  Central directory structure:
//
// ...
//
//   central file header signature   4 bytes  (0x02014b50)
//   version made by                 2 bytes
//   version needed to extract       2 bytes
//   general purpose bit flag        2 bytes
//   compression method              2 bytes
//   last mod file time              2 bytes
//   last mod file date              2 bytes
//   crc-32                          4 bytes
//   compressed size                 4 bytes
//   uncompressed size               4 bytes
//   file name length                2 bytes
//   extra field length              2 bytes
//   file comment length             2 bytes
//   disk number start               2 bytes
//   internal file attributes        2 bytes
//   external file attributes        4 bytes
//   relative offset of local header 4 bytes
type ZipfileCDS1 = struct {
	FiVersionMadeBy  u16
	FiVersionExtract u16
	Fflags           u16
	FiCompression    u16
	FmTime           u16
	FmDate           u16
	Fcrc32           u32
	FszCompressed    u32
	FszUncompressed  u32
	FnFile           u16
	FnExtra          u16
	FnComment        u16
	FiDiskStart      u16
	FiInternalAttr   u16
	_                [2]byte
	FiExternalAttr   u32
	FiOffset         u32
	FzFile           uintptr
} /* zipfile.c:200:9 */

// 4.3.12  Central directory structure:
//
// ...
//
//   central file header signature   4 bytes  (0x02014b50)
//   version made by                 2 bytes
//   version needed to extract       2 bytes
//   general purpose bit flag        2 bytes
//   compression method              2 bytes
//   last mod file time              2 bytes
//   last mod file date              2 bytes
//   crc-32                          4 bytes
//   compressed size                 4 bytes
//   uncompressed size               4 bytes
//   file name length                2 bytes
//   extra field length              2 bytes
//   file comment length             2 bytes
//   disk number start               2 bytes
//   internal file attributes        2 bytes
//   external file attributes        4 bytes
//   relative offset of local header 4 bytes
type ZipfileCDS = ZipfileCDS1 /* zipfile.c:200:27 */

// 4.3.7  Local file header:
//
//   local file header signature     4 bytes  (0x04034b50)
//   version needed to extract       2 bytes
//   general purpose bit flag        2 bytes
//   compression method              2 bytes
//   last mod file time              2 bytes
//   last mod file date              2 bytes
//   crc-32                          4 bytes
//   compressed size                 4 bytes
//   uncompressed size               4 bytes
//   file name length                2 bytes
//   extra field length              2 bytes
//
type ZipfileLFH1 = struct {
	FiVersionExtract u16
	Fflags           u16
	FiCompression    u16
	FmTime           u16
	FmDate           u16
	_                [2]byte
	Fcrc32           u32
	FszCompressed    u32
	FszUncompressed  u32
	FnFile           u16
	FnExtra          u16
} /* zipfile.c:237:9 */

// 4.3.7  Local file header:
//
//   local file header signature     4 bytes  (0x04034b50)
//   version needed to extract       2 bytes
//   general purpose bit flag        2 bytes
//   compression method              2 bytes
//   last mod file time              2 bytes
//   last mod file date              2 bytes
//   crc-32                          4 bytes
//   compressed size                 4 bytes
//   uncompressed size               4 bytes
//   file name length                2 bytes
//   extra field length              2 bytes
//
type ZipfileLFH = ZipfileLFH1 /* zipfile.c:237:27 */

type ZipfileEntry1 = struct {
	Fcds       ZipfileCDS
	FmUnixTime u32
	FaExtra    uintptr
	FiDataOff  i64
	FaData     uintptr
	FpNext     uintptr
} /* zipfile.c:251:9 */

type ZipfileEntry = ZipfileEntry1 /* zipfile.c:251:29 */

// Cursor type for zipfile tables.
type ZipfileCsr1 = struct {
	Fbase       sqlite3_vtab_cursor
	_           [4]byte
	FiId        i64
	FbEof       u8
	FbNoop      u8
	_           [2]byte
	FpFile      uintptr
	FiNextOff   i64
	Feocd       ZipfileEOCD
	FpFreeEntry uintptr
	FpCurrent   uintptr
	FpCsrNext   uintptr
	_           [4]byte
} /* zipfile.c:264:9 */

// Cursor type for zipfile tables.
type ZipfileCsr = ZipfileCsr1 /* zipfile.c:264:27 */

type ZipfileTab1 = struct {
	Fbase        sqlite3_vtab
	FzFile       uintptr
	Fdb          uintptr
	FaBuffer     uintptr
	FpCsrList    uintptr
	_            [4]byte
	FiNextCsrid  i64
	FpFirstEntry uintptr
	FpLastEntry  uintptr
	FpWriteFd    uintptr
	_            [4]byte
	FszCurrent   i64
	FszOrig      i64
} /* zipfile.c:281:9 */

type ZipfileTab = ZipfileTab1 /* zipfile.c:281:27 */

// Set the error message contained in context ctx to the results of
// vprintf(zFmt, ...).
func zipfileCtxErrorMsg(tls *libc.TLS, ctx uintptr, zFmt uintptr, va uintptr) { /* zipfile.c:303:13: */
	var zMsg uintptr = uintptr(0)
	var ap va_list
	_ = ap
	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	sqlite3.Xsqlite3_result_error(tls, ctx, zMsg, -1)
	sqlite3.Xsqlite3_free(tls, zMsg)
	_ = ap
}

// If string zIn is quoted, dequote it in place. Otherwise, if the string
// is not quoted, do nothing.
func zipfileDequote(tls *libc.TLS, zIn uintptr) { /* zipfile.c:317:13: */
	var q int8 = *(*int8)(unsafe.Pointer(zIn))
	if (((int32(q) == '"') || (int32(q) == '\'')) || (int32(q) == '`')) || (int32(q) == '[') {
		var iIn int32 = 1
		var iOut int32 = 0
		if int32(q) == '[' {
			q = int8(']')
		}
		for *(*int8)(unsafe.Pointer(zIn + uintptr(iIn))) != 0 {
			var c int8 = *(*int8)(unsafe.Pointer(zIn + uintptr(libc.PostIncInt32(&iIn, 1))))
			if (int32(c) == int32(q)) && (int32(*(*int8)(unsafe.Pointer(zIn + uintptr(libc.PostIncInt32(&iIn, 1))))) != int32(q)) {
				break
			}
			*(*int8)(unsafe.Pointer(zIn + uintptr(libc.PostIncInt32(&iOut, 1)))) = c
		}
		*(*int8)(unsafe.Pointer(zIn + uintptr(iOut))) = int8(0)
	}
}

// Construct a new ZipfileTab virtual table object.
//
//   argv[0]   -> module name  ("zipfile")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> "column name" and other module argument fields.
func zipfileConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* zipfile.c:340:12: */
	var nByte int32 = (int32(uint32(unsafe.Sizeof(ZipfileTab{})) + (uint32(64 * 1024))))
	var nFile int32 = 0
	var zFile uintptr = uintptr(0)
	var pNew uintptr = uintptr(0)
	var rc int32

	// If the table name is not "zipfile", require that the argument be
	// specified. This stops zipfile tables from being created as:
	//
	//   CREATE VIRTUAL TABLE zzz USING zipfile();
	//
	// It does not prevent:
	//
	//   CREATE VIRTUAL TABLE zipfile USING zipfile();

	if ((0 != sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), ts+9012 /* "zipfile" */)) && (argc < 4)) || (argc > 4) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9020 /* "zipfile construc..." */, 0)
		return SQLITE_ERROR
	}

	if argc > 3 {
		zFile = *(*uintptr)(unsafe.Pointer(argv + 3*4))
		nFile = (int32(libc.Xstrlen(tls, zFile)) + 1)
	}

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db, uintptr(unsafe.Pointer(&ZIPFILE_SCHEMA)))
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc64(tls, (uint64(sqlite3_int64(nByte) + sqlite3_int64(nFile))))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, (uint32(nByte + nFile)))
		(*ZipfileTab)(unsafe.Pointer(pNew)).Fdb = db
		(*ZipfileTab)(unsafe.Pointer(pNew)).FaBuffer = (pNew + 1*72)
		if zFile != 0 {
			(*ZipfileTab)(unsafe.Pointer(pNew)).FzFile = ((*ZipfileTab)(unsafe.Pointer(pNew)).FaBuffer + 65536)
			libc.Xmemcpy(tls, (*ZipfileTab)(unsafe.Pointer(pNew)).FzFile, zFile, uint32(nFile))
			zipfileDequote(tls, (*ZipfileTab)(unsafe.Pointer(pNew)).FzFile)
		}
	}
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_DIRECTONLY, 0)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc
}

// Free the ZipfileEntry structure indicated by the only argument.
func zipfileEntryFree(tls *libc.TLS, p uintptr) { /* zipfile.c:394:13: */
	if p != 0 {
		sqlite3.Xsqlite3_free(tls, (*ZipfileEntry)(unsafe.Pointer(p)).Fcds.FzFile)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Release resources that should be freed at the end of a write
// transaction.
func zipfileCleanupTransaction(tls *libc.TLS, pTab uintptr) { /* zipfile.c:405:13: */
	var pEntry uintptr
	var pNext uintptr

	if (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd != 0 {
		libc.Xfclose(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd)
		(*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd = uintptr(0)
	}
	for pEntry = (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry; pEntry != 0; pEntry = pNext {
		pNext = (*ZipfileEntry)(unsafe.Pointer(pEntry)).FpNext
		zipfileEntryFree(tls, pEntry)
	}
	(*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry = uintptr(0)
	(*ZipfileTab)(unsafe.Pointer(pTab)).FpLastEntry = uintptr(0)
	(*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent = int64(0)
	(*ZipfileTab)(unsafe.Pointer(pTab)).FszOrig = int64(0)
}

// This method is the destructor for zipfile vtab objects.
func zipfileDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* zipfile.c:426:12: */
	zipfileCleanupTransaction(tls, pVtab)
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// Constructor for a new ZipfileCsr object.
func zipfileOpen(tls *libc.TLS, p uintptr, ppCsr uintptr) int32 { /* zipfile.c:435:12: */
	var pTab uintptr = p
	var pCsr uintptr
	pCsr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(ZipfileCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCsr)) = pCsr
	if pCsr == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCsr, 0, uint32(unsafe.Sizeof(ZipfileCsr{})))
	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FiId = libc.PreIncInt64(&(*ZipfileTab)(unsafe.Pointer(pTab)).FiNextCsrid, 1)
	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCsrNext = (*ZipfileTab)(unsafe.Pointer(pTab)).FpCsrList
	(*ZipfileTab)(unsafe.Pointer(pTab)).FpCsrList = pCsr
	return SQLITE_OK
}

// Reset a cursor back to the state it was in when first returned
// by zipfileOpen().
func zipfileResetCursor(tls *libc.TLS, pCsr uintptr) { /* zipfile.c:454:13: */
	var p uintptr
	var pNext uintptr

	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbEof = u8(0)
	if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile != 0 {
		libc.Xfclose(tls, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile)
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile = uintptr(0)
		zipfileEntryFree(tls, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = uintptr(0)
	}

	for p = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFreeEntry; p != 0; p = pNext {
		pNext = (*ZipfileEntry)(unsafe.Pointer(p)).FpNext
		zipfileEntryFree(tls, p)
	}
}

// Destructor for an ZipfileCsr.
func zipfileClose(tls *libc.TLS, cur uintptr) int32 { /* zipfile.c:475:12: */
	var pCsr uintptr = cur
	var pTab uintptr = (*ZipfileCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
	var pp uintptr
	zipfileResetCursor(tls, pCsr)

	// Remove this cursor from the ZipfileTab.pCsrList list.
	for pp = (pTab + 24 /* &.pCsrList */); *(*uintptr)(unsafe.Pointer(pp)) != pCsr; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 56 /* &.pCsrNext */) {
	}
	*(*uintptr)(unsafe.Pointer(pp)) = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCsrNext

	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

// Set the error message for the virtual table associated with cursor
// pCsr to the results of vprintf(zFmt, ...).
func zipfileTableErr(tls *libc.TLS, pTab uintptr, zFmt uintptr, va uintptr) { /* zipfile.c:493:13: */
	var ap va_list
	_ = ap
	ap = va
	sqlite3.Xsqlite3_free(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg)
	(*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	_ = ap
}

func zipfileCursorErr(tls *libc.TLS, pCsr uintptr, zFmt uintptr, va uintptr) { /* zipfile.c:500:13: */
	var ap va_list
	_ = ap
	ap = va
	sqlite3.Xsqlite3_free(tls, (*sqlite3_vtab)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab)).FzErrMsg)
	(*sqlite3_vtab)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab)).FzErrMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	_ = ap
}

// Read nRead bytes of data from offset iOff of file pFile into buffer
// aRead[]. Return SQLITE_OK if successful, or an SQLite error code
// otherwise.
//
// If an error does occur, output variable (*pzErrmsg) may be set to point
// to an English language error message. It is the responsibility of the
// caller to eventually free this buffer using
// sqlite3_free().
func zipfileReadData(tls *libc.TLS, pFile uintptr, aRead uintptr, nRead int32, iOff i64, pzErrmsg uintptr) int32 { /* zipfile.c:518:12: */
	var n size_t
	libc.Xfseek(tls, pFile, int32(iOff), SEEK_SET)
	n = libc.Xfread(tls, aRead, uint32(1), uint32(nRead), pFile)
	if int32(n) != nRead {
		*(*uintptr)(unsafe.Pointer(pzErrmsg)) = sqlite3.Xsqlite3_mprintf(tls, ts+9062 /* "error in fread()" */, 0)
		return SQLITE_ERROR
	}
	return SQLITE_OK
}

func zipfileAppendData(tls *libc.TLS, pTab uintptr, aWrite uintptr, nWrite int32) int32 { /* zipfile.c:535:12: */
	if nWrite > 0 {
		var n size_t = size_t(nWrite)
		libc.Xfseek(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd, int32((*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent), SEEK_SET)
		n = libc.Xfwrite(tls, aWrite, uint32(1), uint32(nWrite), (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd)
		if int32(n) != nWrite {
			(*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+9079 /* "error in fwrite(..." */, 0)
			return SQLITE_ERROR
		}
		*(*i64)(unsafe.Pointer(pTab + 56 /* &.szCurrent */)) += (i64(nWrite))
	}
	return SQLITE_OK
}

// Read and return a 16-bit little-endian unsigned integer from buffer aBuf.
func zipfileGetU16(tls *libc.TLS, aBuf uintptr) u16 { /* zipfile.c:556:12: */
	return (u16((int32(*(*u8)(unsafe.Pointer(aBuf + 1))) << 8) + int32(*(*u8)(unsafe.Pointer(aBuf)))))
}

// Read and return a 32-bit little-endian unsigned integer from buffer aBuf.
func zipfileGetU32(tls *libc.TLS, aBuf uintptr) u32 { /* zipfile.c:563:12: */
	return (((((u32(*(*u8)(unsafe.Pointer(aBuf + 3)))) << 24) +
		((u32(*(*u8)(unsafe.Pointer(aBuf + 2)))) << 16)) +
		((u32(*(*u8)(unsafe.Pointer(aBuf + 1)))) << 8)) +
		((u32(*(*u8)(unsafe.Pointer(aBuf)))) << 0))
}

// Write a 16-bit little endiate integer into buffer aBuf.
func zipfilePutU16(tls *libc.TLS, aBuf uintptr, val u16) { /* zipfile.c:573:13: */
	*(*u8)(unsafe.Pointer(aBuf)) = (u8(int32(val) & 0xFF))
	*(*u8)(unsafe.Pointer(aBuf + 1)) = (u8((int32(val) >> 8) & 0xFF))
}

// Write a 32-bit little endiate integer into buffer aBuf.
func zipfilePutU32(tls *libc.TLS, aBuf uintptr, val u32) { /* zipfile.c:581:13: */
	*(*u8)(unsafe.Pointer(aBuf)) = (u8(val & u32(0xFF)))
	*(*u8)(unsafe.Pointer(aBuf + 1)) = (u8((val >> 8) & u32(0xFF)))
	*(*u8)(unsafe.Pointer(aBuf + 2)) = (u8((val >> 16) & u32(0xFF)))
	*(*u8)(unsafe.Pointer(aBuf + 3)) = (u8((val >> 24) & u32(0xFF)))
}

// Magic numbers used to read CDS records.

// Decode the CDS record in buffer aBuf into (*pCDS). Return SQLITE_ERROR
// if the record is not well-formed, or SQLITE_OK otherwise.
func zipfileReadCDS(tls *libc.TLS, aBuf uintptr, pCDS uintptr) int32 { /* zipfile.c:604:12: */
	var aRead uintptr = aBuf
	var sig u32 = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()
	var rc int32 = SQLITE_OK
	if sig != u32(ZIPFILE_SIGNATURE_CDS) {
		rc = SQLITE_ERROR
	} else {
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiVersionMadeBy = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiVersionExtract = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).Fflags = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FmTime = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FmDate = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).Fcrc32 = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FszCompressed = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FszUncompressed = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()

		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FnFile = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FnExtra = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FnComment = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiDiskStart = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiInternalAttr = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiExternalAttr = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiOffset = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()

	}

	return rc
}

// Decode the LFH record in buffer aBuf into (*pLFH). Return SQLITE_ERROR
// if the record is not well-formed, or SQLITE_OK otherwise.
func zipfileReadLFH(tls *libc.TLS, aBuffer uintptr, pLFH uintptr) int32 { /* zipfile.c:638:12: */
	var aRead uintptr = aBuffer
	var rc int32 = SQLITE_OK

	var sig u32 = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()
	if sig != u32(ZIPFILE_SIGNATURE_LFH) {
		rc = SQLITE_ERROR
	} else {
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FiVersionExtract = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).Fflags = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FiCompression = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FmTime = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FmDate = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).Fcrc32 = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FszCompressed = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FszUncompressed = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FnFile = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FnExtra = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
	}
	return rc
}

// Buffer aExtra (size nExtra bytes) contains zip archive "extra" fields.
// Scan through this buffer to find an "extra-timestamp" field. If one
// exists, extract the 32-bit modification-timestamp from it and store
// the value in output parameter *pmTime.
//
// Zero is returned if no extra-timestamp record could be found (and so
// *pmTime is left unchanged), or non-zero otherwise.
//
// The general format of an extra field is:
//
//   Header ID    2 bytes
//   Data Size    2 bytes
//   Data         N bytes
func zipfileScanExtra(tls *libc.TLS, aExtra uintptr, nExtra int32, pmTime uintptr) int32 { /* zipfile.c:679:12: */
	var ret int32 = 0
	var p uintptr = aExtra
	var pEnd uintptr = (aExtra + uintptr(nExtra))

	for p < pEnd {
		var id u16 = func() u16 { p += uintptr(2); return zipfileGetU16(tls, (p - uintptr(2))) }()
		var nByte u16 = func() u16 { p += uintptr(2); return zipfileGetU16(tls, (p - uintptr(2))) }()

		switch int32(id) {
		case ZIPFILE_EXTRA_TIMESTAMP:
			{
				var b u8 = *(*u8)(unsafe.Pointer(p))
				if (int32(b) & 0x01) != 0 { // 0x01 -> modtime is present
					*(*u32)(unsafe.Pointer(pmTime)) = zipfileGetU32(tls, (p + 1))
					ret = 1
				}
				break

			}
		}

		p += uintptr(nByte)
	}
	return ret
}

// Convert the standard MS-DOS timestamp stored in the mTime and mDate
// fields of the CDS structure passed as the only argument to a 32-bit
// UNIX seconds-since-the-epoch timestamp. Return the result.
//
// "Standard" MS-DOS time format:
//
//   File modification time:
//     Bits 00-04: seconds divided by 2
//     Bits 05-10: minute
//     Bits 11-15: hour
//   File modification date:
//     Bits 00-04: day
//     Bits 05-08: month (1-12)
//     Bits 09-15: years from 1980
//
// https://msdn.microsoft.com/en-us/library/9kkf9tah.aspx
func zipfileMtime(tls *libc.TLS, pCDS uintptr) u32 { /* zipfile.c:722:12: */
	var Y int32
	var M int32
	var D int32
	var X1 int32
	var X2 int32
	var A int32
	var B int32
	var sec int32
	var min int32
	var hr int32
	var JDsec i64
	Y = (1980 + ((int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmDate) >> 9) & 0x7F))
	M = ((int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmDate) >> 5) & 0x0F)
	D = (int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmDate) & 0x1F)
	sec = ((int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmTime) & 0x1F) * 2)
	min = ((int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmTime) >> 5) & 0x3F)
	hr = ((int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmTime) >> 11) & 0x1F)
	if M <= 2 {
		Y--
		M = M + (12)
	}
	X1 = ((36525 * (Y + 4716)) / 100)
	X2 = ((306001 * (M + 1)) / 10000)
	A = (Y / 100)
	B = ((2 - A) + (A / 4))
	JDsec = ((((i64(((float64(((X1 + X2) + D) + B)) - 1524.5) * float64(86400))) + (i64(hr * 3600))) + (i64(min * 60))) + i64(sec))
	return (u32(JDsec - (int64(24405875) * int64(8640))))
}

// The opposite of zipfileMtime(). This function populates the mTime and
// mDate fields of the CDS structure passed as the first argument according
// to the UNIX timestamp value passed as the second.
func zipfileMtimeToDos(tls *libc.TLS, pCds uintptr, mUnixTime u32) { /* zipfile.c:748:13: */
	// Convert unix timestamp to JD (2440588 is noon on 1/1/1970)
	var JD i64 = (int64(2440588) + (i64(mUnixTime / (u32((24 * 60) * 60)))))
	var A int32
	var B int32
	var C int32
	var D int32
	var E int32
	var yr int32
	var mon int32
	var day int32
	var hr int32
	var min int32
	var sec int32

	A = (int32((float64(JD) - 1867216.25) / 36524.25))
	A = (int32(((JD + int64(1)) + i64(A)) - (i64(A / 4))))
	B = (A + 1524)
	C = (int32((float64(B) - 122.1) / 365.25))
	D = ((36525 * (C & 32767)) / 100)
	E = (int32((float64(B - D)) / 30.6001))

	day = ((B - D) - (int32(30.6001 * float64(E))))
	mon = func() int32 {
		if E < 14 {
			return (E - 1)
		}
		return (E - 13)
	}()
	if mon > 2 {
		yr = (C - 4716)
	} else {
		yr = (C - 4715)
	}

	hr = (int32((mUnixTime % (u32((24 * 60) * 60))) / (u32(60 * 60))))
	min = (int32((mUnixTime % (u32(60 * 60))) / u32(60)))
	sec = (int32(mUnixTime % u32(60)))

	if yr >= 1980 {
		(*ZipfileCDS)(unsafe.Pointer(pCds)).FmDate = (u16((day + (mon << 5)) + ((yr - 1980) << 9)))
		(*ZipfileCDS)(unsafe.Pointer(pCds)).FmTime = (u16(((sec / 2) + (min << 5)) + (hr << 11)))
	} else {
		(*ZipfileCDS)(unsafe.Pointer(pCds)).FmDate = libc.AssignPtrUint16(pCds+8 /* &.mTime */, u16(0))
	}

}

// If aBlob is not NULL, then it is a pointer to a buffer (nBlob bytes in
// size) containing an entire zip archive image. Or, if aBlob is NULL,
// then pFile is a file-handle open on a zip file. In either case, this
// function creates a ZipfileEntry object based on the zip archive entry
// for which the CDS record is at offset iOff.
//
// If successful, SQLITE_OK is returned and (*ppEntry) set to point to
// the new object. Otherwise, an SQLite error code is returned and the
// final value of (*ppEntry) undefined.
func zipfileGetEntry(tls *libc.TLS, pTab uintptr, aBlob uintptr, nBlob int32, pFile uintptr, iOff i64, ppEntry uintptr) int32 { /* zipfile.c:796:12: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var aRead uintptr
	var pzErr uintptr = (pTab /* &.base */ + 8 /* &.zErrMsg */)
	var rc int32 = SQLITE_OK

	if aBlob == uintptr(0) {
		aRead = (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer
		rc = zipfileReadData(tls, pFile, aRead, ZIPFILE_CDS_FIXED_SZ, iOff, pzErr)
	} else {
		aRead = (aBlob + uintptr(iOff))
	}

	if rc == SQLITE_OK {
		var nAlloc sqlite3_int64
		var pNew uintptr

		var nFile int32 = int32(zipfileGetU16(tls, (aRead + 28)))
		var nExtra int32 = int32(zipfileGetU16(tls, (aRead + 30)))
		nExtra = nExtra + (int32(zipfileGetU16(tls, (aRead + 32))))

		nAlloc = (sqlite3_int64(uint32(unsafe.Sizeof(ZipfileEntry{})) + uint32(nExtra)))
		if aBlob != 0 {
			nAlloc = nAlloc + (sqlite3_int64(zipfileGetU32(tls, (aRead + 20))))
		}

		pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(nAlloc))
		if pNew == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(ZipfileEntry{})))
			rc = zipfileReadCDS(tls, aRead, (pNew /* &.cds */))
			if rc != SQLITE_OK {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9097 /* "failed to read C..." */, libc.VaList(bp, iOff))
			} else if aBlob == uintptr(0) {
				rc = zipfileReadData(tls,
					pFile, aRead, (nExtra + nFile), (iOff + int64(ZIPFILE_CDS_FIXED_SZ)), pzErr)
			} else {
				aRead = (aBlob + uintptr((iOff + int64(ZIPFILE_CDS_FIXED_SZ))))
			}
		}

		if rc == SQLITE_OK {
			var pt uintptr = (pNew + 48 /* &.mUnixTime */)
			(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FzFile = sqlite3.Xsqlite3_mprintf(tls, ts+9131 /* "%.*s" */, libc.VaList(bp+8, nFile, aRead))
			(*ZipfileEntry)(unsafe.Pointer(pNew)).FaExtra = (pNew + 1*72)
			libc.Xmemcpy(tls, (*ZipfileEntry)(unsafe.Pointer(pNew)).FaExtra, (aRead + uintptr(nFile)), uint32(nExtra))
			if (*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FzFile == uintptr(0) {
				rc = SQLITE_NOMEM
			} else if 0 == zipfileScanExtra(tls, (aRead+uintptr(nFile)), int32((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FnExtra), pt) {
				(*ZipfileEntry)(unsafe.Pointer(pNew)).FmUnixTime = zipfileMtime(tls, (pNew /* &.cds */))
			}
		}

		if rc == SQLITE_OK {
			// var lfh ZipfileLFH at bp+32, 28

			if pFile != 0 {
				rc = zipfileReadData(tls, pFile, aRead, szFix, int64((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiOffset), pzErr)
			} else {
				aRead = (aBlob + uintptr((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiOffset))
			}

			rc = zipfileReadLFH(tls, aRead, bp+32 /* &lfh */)
			if rc == SQLITE_OK {
				(*ZipfileEntry)(unsafe.Pointer(pNew)).FiDataOff = (i64((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiOffset + u32(ZIPFILE_LFH_FIXED_SZ)))
				*(*i64)(unsafe.Pointer(pNew + 56 /* &.iDataOff */)) += (i64(int32((*ZipfileLFH)(unsafe.Pointer(bp+32 /* &lfh */)).FnFile) + int32((*ZipfileLFH)(unsafe.Pointer(bp+32 /* &lfh */)).FnExtra)))
				if (aBlob != 0) && ((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FszCompressed != 0) {
					(*ZipfileEntry)(unsafe.Pointer(pNew)).FaData = ((*ZipfileEntry)(unsafe.Pointer(pNew)).FaExtra + uintptr(nExtra))
					libc.Xmemcpy(tls, (*ZipfileEntry)(unsafe.Pointer(pNew)).FaData, (aBlob + uintptr((*ZipfileEntry)(unsafe.Pointer(pNew)).FiDataOff)), (*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FszCompressed)
				}
			} else {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9136, /* "failed to read L..." */
					libc.VaList(bp+24, int32((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiOffset)))
			}
		}

		if rc != SQLITE_OK {
			zipfileEntryFree(tls, pNew)
		} else {
			*(*uintptr)(unsafe.Pointer(ppEntry)) = pNew
		}
	}

	return rc
}

var szFix int32 = ZIPFILE_LFH_FIXED_SZ /* zipfile.c:858:24 */

// Advance an ZipfileCsr to its next row of output.
func zipfileNext(tls *libc.TLS, cur uintptr) int32 { /* zipfile.c:894:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCsr uintptr = cur
	var rc int32 = SQLITE_OK

	if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile != 0 {
		var iEof i64 = (i64((*ZipfileCsr)(unsafe.Pointer(pCsr)).Feocd.FiOffset + (*ZipfileCsr)(unsafe.Pointer(pCsr)).Feocd.FnSize))
		zipfileEntryFree(tls, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = uintptr(0)
		if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FiNextOff >= iEof {
			(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbEof = u8(1)
		} else {
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = uintptr(0)
			var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
			rc = zipfileGetEntry(tls, pTab, uintptr(0), 0, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FiNextOff, bp /* &p */)
			if rc == SQLITE_OK {
				*(*i64)(unsafe.Pointer(pCsr + 24 /* &.iNextOff */)) += (int64(ZIPFILE_CDS_FIXED_SZ))
				*(*i64)(unsafe.Pointer(pCsr + 24 /* &.iNextOff */)) += (i64((int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fcds.FnExtra) + int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fcds.FnFile)) + int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fcds.FnComment)))
			}
			(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = *(*uintptr)(unsafe.Pointer(bp /* p */))
		}
	} else {
		if !(int32((*ZipfileCsr)(unsafe.Pointer(pCsr)).FbNoop) != 0) {
			(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = (*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FpNext
		}
		if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent == uintptr(0) {
			(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbEof = u8(1)
		}
	}

	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbNoop = u8(0)
	return rc
}

func zipfileFree(tls *libc.TLS, p uintptr) { /* zipfile.c:927:13: */
	sqlite3.Xsqlite3_free(tls, p)
}

// Buffer aIn (size nIn bytes) contains compressed data. Uncompressed, the
// size is nOut bytes. This function uncompresses the data and sets the
// return value in context pCtx to the result (a blob).
//
// If an error occurs, an error code is left in pCtx instead.
func zipfileInflate(tls *libc.TLS, pCtx uintptr, aIn uintptr, nIn int32, nOut int32) { /* zipfile.c:938:13: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var aRes uintptr = sqlite3.Xsqlite3_malloc(tls, nOut)
	if aRes == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		var err int32
		// var str z_stream at bp+16, 56

		libc.Xmemset(tls, bp+16 /* &str */, 0, uint32(unsafe.Sizeof(z_stream{})))

		(*z_stream)(unsafe.Pointer(bp + 16 /* &str */)).Fnext_in = aIn
		(*z_stream)(unsafe.Pointer(bp + 16 /* &str */)).Favail_in = uInt(nIn)
		(*z_stream)(unsafe.Pointer(bp + 16 /* &str */)).Fnext_out = aRes
		(*z_stream)(unsafe.Pointer(bp + 16 /* &str */)).Favail_out = uInt(nOut)

		err = tcl.XinflateInit2_(tls, bp+16 /* &str */, -15, ts+9168 /* "1.2.11" */, int32(unsafe.Sizeof(z_stream{})))
		if err != Z_OK {
			zipfileCtxErrorMsg(tls, pCtx, ts+9175 /* "inflateInit2() f..." */, libc.VaList(bp, err))
		} else {
			err = tcl.Xinflate(tls, bp+16 /* &str */, Z_NO_FLUSH)
			if err != Z_STREAM_END {
				zipfileCtxErrorMsg(tls, pCtx, ts+9202 /* "inflate() failed..." */, libc.VaList(bp+8, err))
			} else {
				sqlite3.Xsqlite3_result_blob(tls, pCtx, aRes, nOut, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{zipfileFree})))
				aRes = uintptr(0)
			}
		}
		sqlite3.Xsqlite3_free(tls, aRes)
		tcl.XinflateEnd(tls, bp+16 /* &str */)
	}
}

// Buffer aIn (size nIn bytes) contains uncompressed data. This function
// compresses it and sets (*ppOut) to point to a buffer containing the
// compressed data. The caller is responsible for eventually calling
// sqlite3_free() to release buffer (*ppOut). Before returning, (*pnOut)
// is set to the size of buffer (*ppOut) in bytes.
//
// If no error occurs, SQLITE_OK is returned. Otherwise, an SQLite error
// code is returned and an error message left in virtual-table handle
// pTab. The values of (*ppOut) and (*pnOut) are left unchanged in this
// case.
func zipfileDeflate(tls *libc.TLS, aIn uintptr, nIn int32, ppOut uintptr, pnOut uintptr, pzErr uintptr) int32 { /* zipfile.c:986:12: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var rc int32 = SQLITE_OK
	var nAlloc sqlite3_int64
	// var str z_stream at bp, 56

	var aOut uintptr

	libc.Xmemset(tls, bp /* &str */, 0, uint32(unsafe.Sizeof(z_stream{})))
	(*z_stream)(unsafe.Pointer(bp /* &str */)).Fnext_in = aIn
	(*z_stream)(unsafe.Pointer(bp /* &str */)).Favail_in = uInt(nIn)
	tcl.XdeflateInit2_(tls, bp /* &str */, 9, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY, ts+9168 /* "1.2.11" */, int32(unsafe.Sizeof(z_stream{})))

	nAlloc = sqlite3_int64(tcl.XdeflateBound(tls, bp /* &str */, uint32(nIn)))
	aOut = sqlite3.Xsqlite3_malloc64(tls, uint64(nAlloc))
	if aOut == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var res int32
		(*z_stream)(unsafe.Pointer(bp /* &str */)).Fnext_out = aOut
		(*z_stream)(unsafe.Pointer(bp /* &str */)).Favail_out = uInt(nAlloc)
		res = tcl.Xdeflate(tls, bp /* &str */, Z_FINISH)
		if res == Z_STREAM_END {
			*(*uintptr)(unsafe.Pointer(ppOut)) = aOut
			*(*int32)(unsafe.Pointer(pnOut)) = int32((*z_stream)(unsafe.Pointer(bp /* &str */)).Ftotal_out)
		} else {
			sqlite3.Xsqlite3_free(tls, aOut)
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9224 /* "zipfile: deflate..." */, 0)
			rc = SQLITE_ERROR
		}
		tcl.XdeflateEnd(tls, bp /* &str */)
	}

	return rc
}

// Return values of columns for the row at which the series_cursor
// is currently pointing.
func zipfileColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* zipfile.c:1029:12: */
	var pCsr uintptr = cur
	var pCDS uintptr = ((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent /* &.cds */)
	var rc int32 = SQLITE_OK
	switch i {
	case 0: // name
		sqlite3.Xsqlite3_result_text(tls, ctx, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FzFile, -1, libc.UintptrFromInt32(-1))
		break
	case 1: // mode
		// TODO: Whether or not the following is correct surely depends on
		// the platform on which the archive was created.
		sqlite3.Xsqlite3_result_int(tls, ctx, (int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FiExternalAttr >> 16)))
		break
	case 2:
		{ // mtime
			sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FmUnixTime))
			break

		}
	case 3:
		{ // sz
			if sqlite3.Xsqlite3_vtab_nochange(tls, ctx) == 0 {
				sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*ZipfileCDS)(unsafe.Pointer(pCDS)).FszUncompressed))
			}
			break

		}
	case 4: // rawdata
		if sqlite3.Xsqlite3_vtab_nochange(tls, ctx) != 0 {
			break
		}
		fallthrough
	case 5:
		{ // data
			if ((i == 4) || (int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression) == 0)) || (int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression) == 8) {
				var sz int32 = int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FszCompressed)
				var szFinal int32 = int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FszUncompressed)
				if szFinal > 0 {
					var aBuf uintptr
					var aFree uintptr = uintptr(0)
					if (*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FaData != 0 {
						aBuf = (*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FaData
					} else {
						aBuf = libc.AssignUintptr(&aFree, sqlite3.Xsqlite3_malloc64(tls, uint64(sz)))
						if aBuf == uintptr(0) {
							rc = SQLITE_NOMEM
						} else {
							var pFile uintptr = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile
							if pFile == uintptr(0) {
								pFile = (*ZipfileTab)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab)).FpWriteFd
							}
							rc = zipfileReadData(tls, pFile, aBuf, sz, (*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FiDataOff,
								((*ZipfileCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab + 8 /* &.zErrMsg */))
						}
					}
					if rc == SQLITE_OK {
						if (i == 5) && ((*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression != 0) {
							zipfileInflate(tls, ctx, aBuf, sz, szFinal)
						} else {
							sqlite3.Xsqlite3_result_blob(tls, ctx, aBuf, sz, libc.UintptrFromInt32(-1))
						}
					}
					sqlite3.Xsqlite3_free(tls, aFree)
				} else {
					// Figure out if this is a directory or a zero-sized file. Consider
					// it to be a directory either if the mode suggests so, or if
					// the final character in the name is '/'.
					var mode u32 = ((*ZipfileCDS)(unsafe.Pointer(pCDS)).FiExternalAttr >> 16)
					if !((mode & u32(S_IFDIR)) != 0) && (int32(*(*int8)(unsafe.Pointer((*ZipfileCDS)(unsafe.Pointer(pCDS)).FzFile + uintptr((int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FnFile) - 1))))) != '/') {
						sqlite3.Xsqlite3_result_blob(tls, ctx, ts+489 /* "" */, 0, uintptr(0))
					}
				}
			}
			break

		}
	case 6: // method
		sqlite3.Xsqlite3_result_int(tls, ctx, int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression))
		break
	default: // z

		sqlite3.Xsqlite3_result_int64(tls, ctx, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FiId)
		break
	}

	return rc
}

// Return TRUE if the cursor is at EOF.
func zipfileEof(tls *libc.TLS, cur uintptr) int32 { /* zipfile.c:1116:12: */
	var pCsr uintptr = cur
	return int32((*ZipfileCsr)(unsafe.Pointer(pCsr)).FbEof)
}

// If aBlob is not NULL, then it points to a buffer nBlob bytes in size
// containing an entire zip archive image. Or, if aBlob is NULL, then pFile
// is guaranteed to be a file-handle open on a zip file.
//
// This function attempts to locate the EOCD record within the zip archive
// and populate *pEOCD with the results of decoding it. SQLITE_OK is
// returned if successful. Otherwise, an SQLite error code is returned and
// an English language error message may be left in virtual-table pTab.
func zipfileReadEOCD(tls *libc.TLS, pTab uintptr, aBlob uintptr, nBlob int32, pFile uintptr, pEOCD uintptr) int32 { /* zipfile.c:1131:12: */
	var aRead uintptr = (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer // Temporary buffer
	var nRead int32                                                  // Bytes to read from file
	var rc int32 = SQLITE_OK

	if aBlob == uintptr(0) {
		var iOff i64   // Offset to read from
		var szFile i64 // Total size of file in bytes
		libc.Xfseek(tls, pFile, 0, SEEK_END)
		szFile = i64(libc.Xftell(tls, pFile))
		if szFile == int64(0) {
			libc.Xmemset(tls, pEOCD, 0, uint32(unsafe.Sizeof(ZipfileEOCD{})))
			return SQLITE_OK
		}
		nRead = func() int32 {
			if (szFile) < (int64(64 * 1024)) {
				return int32(szFile)
			}
			return (64 * 1024)
		}()
		iOff = (szFile - i64(nRead))
		rc = zipfileReadData(tls, pFile, aRead, nRead, iOff, (pTab /* &.base */ + 8 /* &.zErrMsg */))
	} else {
		nRead = func() int32 {
			if (nBlob) < (64 * 1024) {
				return nBlob
			}
			return (64 * 1024)
		}()
		aRead = (aBlob + uintptr((nBlob - nRead)))
	}

	if rc == SQLITE_OK {
		var i int32

		// Scan backwards looking for the signature bytes
		for i = (nRead - 20); i >= 0; i-- {
			if (((int32(*(*u8)(unsafe.Pointer(aRead + uintptr(i)))) == 0x50) && (int32(*(*u8)(unsafe.Pointer(aRead + uintptr((i + 1))))) == 0x4b)) &&
				(int32(*(*u8)(unsafe.Pointer(aRead + uintptr((i + 2))))) == 0x05)) && (int32(*(*u8)(unsafe.Pointer(aRead + uintptr((i + 3))))) == 0x06) {
				break
			}
		}
		if i < 0 {
			(*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
				ts+9249 /* "cannot find end ..." */, 0)
			return SQLITE_ERROR
		}

		aRead += (uintptr(i + 4))
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FiDisk = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FiFirstDisk = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FnEntry = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FnEntryTotal = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, (aRead - uintptr(2))) }()
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FnSize = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FiOffset = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, (aRead - uintptr(4))) }()
	}

	return rc
}

// Add object pNew to the linked list that begins at ZipfileTab.pFirstEntry
// and ends with pLastEntry. If argument pBefore is NULL, then pNew is added
// to the end of the list. Otherwise, it is added to the list immediately
// before pBefore (which is guaranteed to be a part of said list).
func zipfileAddEntry(tls *libc.TLS, pTab uintptr, pBefore uintptr, pNew uintptr) { /* zipfile.c:1195:13: */

	if pBefore == uintptr(0) {
		if (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry == uintptr(0) {
			(*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry = libc.AssignPtrUintptr(pTab+44 /* &.pLastEntry */, pNew)
		} else {

			(*ZipfileEntry)(unsafe.Pointer((*ZipfileTab)(unsafe.Pointer(pTab)).FpLastEntry)).FpNext = pNew
			(*ZipfileTab)(unsafe.Pointer(pTab)).FpLastEntry = pNew
		}
	} else {
		var pp uintptr
		for pp = (pTab + 40 /* &.pFirstEntry */); *(*uintptr)(unsafe.Pointer(pp)) != pBefore; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 68 /* &.pNext */) {
		}
		(*ZipfileEntry)(unsafe.Pointer(pNew)).FpNext = pBefore
		*(*uintptr)(unsafe.Pointer(pp)) = pNew
	}
}

func zipfileLoadDirectory(tls *libc.TLS, pTab uintptr, aBlob uintptr, nBlob int32) int32 { /* zipfile.c:1218:12: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	// var eocd ZipfileEOCD at bp, 16

	var rc int32
	var i int32
	var iOff i64

	rc = zipfileReadEOCD(tls, pTab, aBlob, nBlob, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd, bp /* &eocd */)
	iOff = i64((*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FiOffset)
	for i = 0; (rc == SQLITE_OK) && (i < int32((*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnEntry)); i++ {
		*(*uintptr)(unsafe.Pointer(bp + 16 /* pNew */)) = uintptr(0)
		rc = zipfileGetEntry(tls, pTab, aBlob, nBlob, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd, iOff, bp+16 /* &pNew */)

		if rc == SQLITE_OK {
			zipfileAddEntry(tls, pTab, uintptr(0), *(*uintptr)(unsafe.Pointer(bp + 16 /* pNew */)))
			iOff = iOff + (int64(ZIPFILE_CDS_FIXED_SZ))
			iOff = iOff + (i64((int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* pNew */)))).Fcds.FnExtra) + int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* pNew */)))).Fcds.FnFile)) + int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* pNew */)))).Fcds.FnComment)))
		}
	}
	return rc
}

// xFilter callback.
func zipfileFilter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* zipfile.c:1242:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	var pCsr uintptr = cur
	var zFile uintptr = uintptr(0) // Zip file to scan
	var rc int32 = SQLITE_OK       // Return Code
	var bInMemory int32 = 0        // True for an in-memory zipfile

	zipfileResetCursor(tls, pCsr)

	if (*ZipfileTab)(unsafe.Pointer(pTab)).FzFile != 0 {
		zFile = (*ZipfileTab)(unsafe.Pointer(pTab)).FzFile
	} else if idxNum == 0 {
		zipfileCursorErr(tls, pCsr, ts+9293 /* "zipfile() functi..." */, 0)
		return SQLITE_ERROR
	} else if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_BLOB {
		var aBlob uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var nBlob int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))

		rc = zipfileLoadDirectory(tls, pTab, aBlob, nBlob)
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFreeEntry = (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry
		(*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry = libc.AssignPtrUintptr(pTab+44 /* &.pLastEntry */, uintptr(0))
		if rc != SQLITE_OK {
			return rc
		}
		bInMemory = 1
	} else {
		zFile = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	}

	if (uintptr(0) == (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd) && (0 == bInMemory) {
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile = libc.Xfopen(tls, zFile, ts+4263 /* "rb" */)
		if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile == uintptr(0) {
			zipfileCursorErr(tls, pCsr, ts+9333 /* "cannot open file..." */, libc.VaList(bp, zFile))
			rc = SQLITE_ERROR
		} else {
			rc = zipfileReadEOCD(tls, pTab, uintptr(0), 0, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile, (pCsr + 32 /* &.eocd */))
			if rc == SQLITE_OK {
				if int32((*ZipfileCsr)(unsafe.Pointer(pCsr)).Feocd.FnEntry) == 0 {
					(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbEof = u8(1)
				} else {
					(*ZipfileCsr)(unsafe.Pointer(pCsr)).FiNextOff = i64((*ZipfileCsr)(unsafe.Pointer(pCsr)).Feocd.FiOffset)
					rc = zipfileNext(tls, cur)
				}
			}
		}
	} else {
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbNoop = u8(1)
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = func() uintptr {
			if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFreeEntry != 0 {
				return (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFreeEntry
			}
			return (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry
		}()
		rc = zipfileNext(tls, cur)
	}

	return rc
}

// xBestIndex callback.
func zipfileBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* zipfile.c:1301:12: */
	var i int32
	var idx int32 = -1
	var unusable int32 = 0

	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var pCons uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)
		if (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn != ZIPFILE_F_COLUMN_IDX {
			continue
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable) == 0 {
			unusable = 1
		} else if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			idx = i
		}
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000.0
	if idx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
	} else if unusable != 0 {
		return SQLITE_CONSTRAINT
	}
	return SQLITE_OK
}

func zipfileNewEntry(tls *libc.TLS, zPath uintptr) uintptr { /* zipfile.c:1329:21: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pNew uintptr
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(ZipfileEntry{})))
	if pNew != 0 {
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(ZipfileEntry{})))
		(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FzFile = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zPath))
		if (*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FzFile == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, pNew)
			pNew = uintptr(0)
		}
	}
	return pNew
}

func zipfileSerializeLFH(tls *libc.TLS, pEntry uintptr, aBuf uintptr) int32 { /* zipfile.c:1343:12: */
	var pCds uintptr = (pEntry /* &.cds */)
	var a uintptr = aBuf

	(*ZipfileCDS)(unsafe.Pointer(pCds)).FnExtra = u16(9)

	/* Write the LFH itself */
	{
		zipfilePutU32(tls, a, uint32(ZIPFILE_SIGNATURE_LFH))
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FiVersionExtract)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).Fflags)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FiCompression)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FmTime)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FmDate)
		a += uintptr(2)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).Fcrc32)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FszCompressed)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FszUncompressed)
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FnFile)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FnExtra)
		a += uintptr(2)
	}

	// Add the file name
	libc.Xmemcpy(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FzFile, uint32(int32((*ZipfileCDS)(unsafe.Pointer(pCds)).FnFile)))
	a += uintptr(int32((*ZipfileCDS)(unsafe.Pointer(pCds)).FnFile))

	/* The "extra" data */
	{
		zipfilePutU16(tls, a, uint16(ZIPFILE_EXTRA_TIMESTAMP))
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, uint16(5))
		a += uintptr(2)
	}

	*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&a, 1))) = u8(0x01)
	{
		zipfilePutU32(tls, a, (*ZipfileEntry)(unsafe.Pointer(pEntry)).FmUnixTime)
		a += uintptr(4)
	}

	return ((int32(a) - int32(aBuf)) / 1)
}

func zipfileAppendEntry(tls *libc.TLS, pTab uintptr, pEntry uintptr, pData uintptr, nData int32) int32 { /* zipfile.c:1376:12: */
	var aBuf uintptr = (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer
	var nBuf int32
	var rc int32

	nBuf = zipfileSerializeLFH(tls, pEntry, aBuf)
	rc = zipfileAppendData(tls, pTab, aBuf, nBuf)
	if rc == SQLITE_OK {
		(*ZipfileEntry)(unsafe.Pointer(pEntry)).FiDataOff = (*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent
		rc = zipfileAppendData(tls, pTab, pData, nData)
	}

	return rc
}

func zipfileGetMode(tls *libc.TLS, pVal uintptr, bIsDir int32, pMode uintptr, pzErr uintptr) int32 { /* zipfile.c:1396:12: */
	bp := tls.Alloc(19)
	defer tls.Free(19)

	var z uintptr
	var mode u32
	// var zTemplate [11]int8 at bp+8, 11

	var i int32
	z = sqlite3.Xsqlite3_value_text(tls, pVal)
	mode = u32(0)
	if !(z == uintptr(0)) {
		goto __1
	}
	mode = func() uint32 {
		if bIsDir != 0 {
			return (uint32(S_IFDIR + 0755))
		}
		return (uint32(S_IFREG + 0644))
	}()
	goto __2
__1:
	if !((int32(*(*int8)(unsafe.Pointer(z))) >= '0') && (int32(*(*int8)(unsafe.Pointer(z))) <= '9')) {
		goto __3
	}
	mode = uint32(sqlite3.Xsqlite3_value_int(tls, pVal))
	goto __4
__3:
	*(*[11]int8)(unsafe.Pointer(bp + 8 /* zTemplate */)) = *(*[11]int8)(unsafe.Pointer(ts + 9354 /* "-rwxrwxrwx" */))
	if !(libc.Xstrlen(tls, z) != size_t(10)) {
		goto __5
	}
	goto parse_error
__5:
	;
	switch int32(*(*int8)(unsafe.Pointer(z))) {
	case '-':
		goto __7
	case 'd':
		goto __8
	case 'l':
		goto __9
	default:
		goto __10
	}
	goto __6
__7:
	mode = mode | (u32(S_IFREG))
	goto __6
__8:
	mode = mode | (u32(S_IFDIR))
	goto __6
__9:
	mode = mode | (u32(S_IFLNK))
	goto __6
__10:
	goto parse_error
__6:
	;
	i = 1
__11:
	if !(i < 10) {
		goto __13
	}
	if !(int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(bp + 8 /* &zTemplate[0] */ + uintptr(i))))) {
		goto __14
	}
	mode = mode | (u32(int32(1) << (9 - i)))
	goto __15
__14:
	if !(int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '-') {
		goto __16
	}
	goto parse_error
__16:
	;
__15:
	;
	goto __12
__12:
	i++
	goto __11
	goto __13
__13:
	;
__4:
	;
__2:
	;
	if !((libc.Bool32((mode & u32(S_IFDIR)) == u32(0))) == bIsDir) {
		goto __17
	}
	// The "mode" attribute is a directory, but data has been specified.
	// Or vice-versa - no data but "mode" is a file or symlink.
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9365 /* "zipfile: mode do..." */, 0)
	return SQLITE_CONSTRAINT
__17:
	;
	*(*u32)(unsafe.Pointer(pMode)) = mode
	return SQLITE_OK

parse_error:
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9399 /* "zipfile: parse e..." */, libc.VaList(bp, z))
	return SQLITE_ERROR
}

//
// Both (const char*) arguments point to nul-terminated strings. Argument
// nB is the value of strlen(zB). This function returns 0 if the strings are
// identical, ignoring any trailing '/' character in either path.
func zipfileComparePath(tls *libc.TLS, zA uintptr, zB uintptr, nB int32) int32 { /* zipfile.c:1441:12: */
	var nA int32 = int32(libc.Xstrlen(tls, zA))
	if (nA > 0) && (int32(*(*int8)(unsafe.Pointer(zA + uintptr((nA - 1))))) == '/') {
		nA--
	}
	if (nB > 0) && (int32(*(*int8)(unsafe.Pointer(zB + uintptr((nB - 1))))) == '/') {
		nB--
	}
	if (nA == nB) && (libc.Xmemcmp(tls, zA, zB, uint32(nA)) == 0) {
		return 0
	}
	return 1
}

func zipfileBegin(tls *libc.TLS, pVtab uintptr) int32 { /* zipfile.c:1449:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pTab uintptr = pVtab
	var rc int32 = SQLITE_OK

	if ((*ZipfileTab)(unsafe.Pointer(pTab)).FzFile == uintptr(0)) || (int32(*(*int8)(unsafe.Pointer((*ZipfileTab)(unsafe.Pointer(pTab)).FzFile))) == 0) {
		(*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+9432 /* "zipfile: missing..." */, 0)
		return SQLITE_ERROR
	}

	// Open a write fd on the file. Also load the entire central directory
	// structure into memory. During the transaction any new file data is
	// appended to the archive file, but the central directory is accumulated
	// in main-memory until the transaction is committed.
	(*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd = libc.Xfopen(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).FzFile, ts+9458 /* "ab+" */)
	if (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd == uintptr(0) {
		(*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
			ts+9462 /* "zipfile: failed ..." */, libc.VaList(bp, (*ZipfileTab)(unsafe.Pointer(pTab)).FzFile))
		rc = SQLITE_ERROR
	} else {
		libc.Xfseek(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd, 0, SEEK_END)
		(*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent = libc.AssignPtrInt64(pTab+64 /* &.szOrig */, i64(libc.Xftell(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd)))
		rc = zipfileLoadDirectory(tls, pTab, uintptr(0), 0)
	}

	if rc != SQLITE_OK {
		zipfileCleanupTransaction(tls, pTab)
	}

	return rc
}

// Return the current time as a 32-bit timestamp in UNIX epoch format (like
// time(2)).
func zipfileTime(tls *libc.TLS) u32 { /* zipfile.c:1486:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	var ret u32
	if pVfs == uintptr(0) {
		return u32(0)
	}
	if ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion >= 2) && ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxCurrentTimeInt64 != 0) {
		// var ms i64 at bp, 8

		(*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pVfs + 72 /* &.xCurrentTimeInt64 */))))(tls, pVfs, bp /* &ms */)
		ret = (u32((*(*i64)(unsafe.Pointer(bp /* ms */)) / int64(1000)) - (int64(24405875) * int64(8640))))
	} else {
		// var day float64 at bp+8, 8

		(*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pVfs + 64 /* &.xCurrentTime */))))(tls, pVfs, bp+8 /* &day */)
		ret = (u32((*(*float64)(unsafe.Pointer(bp + 8 /* day */)) - 2440587.5) * float64(86400)))
	}
	return ret
}

// Return a 32-bit timestamp in UNIX epoch format.
//
// If the value passed as the only argument is either NULL or an SQL NULL,
// return the current time. Otherwise, return the value stored in (*pVal)
// cast to a 32-bit unsigned integer.
func zipfileGetTime(tls *libc.TLS, pVal uintptr) u32 { /* zipfile.c:1509:12: */
	if (pVal == uintptr(0)) || (sqlite3.Xsqlite3_value_type(tls, pVal) == SQLITE_NULL) {
		return zipfileTime(tls)
	}
	return u32(sqlite3.Xsqlite3_value_int64(tls, pVal))
}

// Unless it is NULL, entry pOld is currently part of the pTab->pFirstEntry
// linked list.  Remove it from the list and free the object.
func zipfileRemoveEntryFromList(tls *libc.TLS, pTab uintptr, pOld uintptr) { /* zipfile.c:1520:13: */
	if pOld != 0 {
		var pp uintptr
		for pp = (pTab + 40 /* &.pFirstEntry */); (*(*uintptr)(unsafe.Pointer(pp))) != pOld; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 68 /* &.pNext */) {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = (*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pp)))).FpNext
		zipfileEntryFree(tls, pOld)
	}
}

// xUpdate method.
func zipfileUpdate(tls *libc.TLS, pVtab uintptr, nVal int32, apVal uintptr, pRowid uintptr) int32 { /* zipfile.c:1532:12: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var pTab uintptr
	var rc int32     // Return Code
	var pNew uintptr // New in-memory CDS entry

	// var mode u32 at bp+32, 4
	// Mode for new entry
	var mTime u32     // Modification time for new entry
	var sz i64        // Uncompressed size
	var zPath uintptr // Path for new entry
	var nPath int32   // strlen(zPath)
	var pData uintptr // Pointer to buffer containing content
	var nData int32   // Size of pData buffer in bytes
	var iMethod int32 // Compression method for new entry
	// var pFree uintptr at bp+24, 4
	// Free this
	var zFree uintptr // Also free this
	var pOld uintptr
	var pOld2 uintptr
	var bUpdate int32 // True for an update that modifies "name"
	var bIsDir int32
	var iCrc32 u32
	var zUpdate uintptr
	var zDelete uintptr
	var nDelete int32
	// var nCmp int32 at bp+28, 4

	// Value specified for "data", and possibly "method". This must be
	// a regular file or a symlink.
	var aIn uintptr
	var nIn int32
	var bAuto int32
	var p uintptr
	var pCsr uintptr
	pTab = pVtab
	rc = SQLITE_OK
	pNew = uintptr(0)
	*(*u32)(unsafe.Pointer(bp + 32 /* mode */)) = u32(0)
	mTime = u32(0)
	sz = int64(0)
	zPath = uintptr(0)
	nPath = 0
	pData = uintptr(0)
	nData = 0
	iMethod = 0
	*(*uintptr)(unsafe.Pointer(bp + 24 /* pFree */)) = uintptr(0)
	zFree = uintptr(0)
	pOld = uintptr(0)
	pOld2 = uintptr(0)
	bUpdate = 0
	bIsDir = 0
	iCrc32 = u32(0)

	if !((*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd == uintptr(0)) {
		goto __1
	}
	rc = zipfileBegin(tls, pVtab)
	if !(rc != SQLITE_OK) {
		goto __2
	}
	return rc
__2:
	;
__1:
	;

	// If this is a DELETE or UPDATE, find the archive entry to delete.
	if !(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal))) != SQLITE_NULL) {
		goto __3
	}
	zDelete = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	nDelete = int32(libc.Xstrlen(tls, zDelete))
	if !(nVal > 1) {
		goto __4
	}
	zUpdate = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + 1*4)))
	if !((zUpdate != 0) && (zipfileComparePath(tls, zUpdate, zDelete, nDelete) != 0)) {
		goto __5
	}
	bUpdate = 1
__5:
	;
__4:
	;
	pOld = (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry
__6:
	if !(1 != 0) {
		goto __8
	}
	if !(zipfileComparePath(tls, (*ZipfileEntry)(unsafe.Pointer(pOld)).Fcds.FzFile, zDelete, nDelete) == 0) {
		goto __9
	}
	goto __8
__9:
	;

	goto __7
__7:
	pOld = (*ZipfileEntry)(unsafe.Pointer(pOld)).FpNext
	goto __6
	goto __8
__8:
	;
__3:
	;

	if !(nVal > 1) {
		goto __10
	}
	// Check that "sz" and "rawdata" are both NULL:
	if !(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + 5*4))) != SQLITE_NULL) {
		goto __11
	}
	zipfileTableErr(tls, pTab, ts+9506 /* "sz must be NULL" */, 0)
	rc = SQLITE_CONSTRAINT
__11:
	;
	if !(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + 6*4))) != SQLITE_NULL) {
		goto __12
	}
	zipfileTableErr(tls, pTab, ts+9522 /* "rawdata must be ..." */, 0)
	rc = SQLITE_CONSTRAINT
__12:
	;

	if !(rc == SQLITE_OK) {
		goto __13
	}
	if !(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + 7*4))) == SQLITE_NULL) {
		goto __14
	}
	// data=NULL. A directory
	bIsDir = 1
	goto __15
__14:
	// Value specified for "data", and possibly "method". This must be
	// a regular file or a symlink.
	aIn = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(apVal + 7*4)))
	nIn = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + 7*4)))
	bAuto = (libc.Bool32(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + 8*4))) == SQLITE_NULL))

	iMethod = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(apVal + 8*4)))
	sz = i64(nIn)
	pData = aIn
	nData = nIn
	if !((iMethod != 0) && (iMethod != 8)) {
		goto __16
	}
	zipfileTableErr(tls, pTab, ts+9543 /* "unknown compress..." */, libc.VaList(bp, iMethod))
	rc = SQLITE_CONSTRAINT
	goto __17
__16:
	if !((bAuto != 0) || (iMethod != 0)) {
		goto __18
	}
	rc = zipfileDeflate(tls, aIn, nIn, bp+24 /* &pFree */, bp+28 /* &nCmp */, (pTab /* &.base */ + 8 /* &.zErrMsg */))
	if !(rc == SQLITE_OK) {
		goto __19
	}
	if !((iMethod != 0) || (*(*int32)(unsafe.Pointer(bp + 28 /* nCmp */)) < nIn)) {
		goto __20
	}
	iMethod = 8
	pData = *(*uintptr)(unsafe.Pointer(bp + 24 /* pFree */))
	nData = *(*int32)(unsafe.Pointer(bp + 28 /* nCmp */))
__20:
	;
__19:
	;
__18:
	;
	iCrc32 = u32(tcl.Xcrc32(tls, uint32(0), aIn, uint32(nIn)))
__17:
	;
__15:
	;
__13:
	;

	if !(rc == SQLITE_OK) {
		goto __21
	}
	rc = zipfileGetMode(tls, *(*uintptr)(unsafe.Pointer(apVal + 3*4)), bIsDir, bp+32 /* &mode */, (pTab /* &.base */ + 8 /* &.zErrMsg */))
__21:
	;

	if !(rc == SQLITE_OK) {
		goto __22
	}
	zPath = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + 2*4)))
	if !(zPath == uintptr(0)) {
		goto __23
	}
	zPath = ts + 489 /* "" */
__23:
	;
	nPath = int32(libc.Xstrlen(tls, zPath))
	mTime = zipfileGetTime(tls, *(*uintptr)(unsafe.Pointer(apVal + 4*4)))
__22:
	;

	if !((rc == SQLITE_OK) && (bIsDir != 0)) {
		goto __24
	}
	// For a directory, check that the last character in the path is a
	// '/'. This appears to be required for compatibility with info-zip
	// (the unzip command on unix). It does not create directories
	// otherwise.
	if !((nPath <= 0) || (int32(*(*int8)(unsafe.Pointer(zPath + uintptr((nPath - 1))))) != '/')) {
		goto __25
	}
	zFree = sqlite3.Xsqlite3_mprintf(tls, ts+9574 /* "%s/" */, libc.VaList(bp+8, zPath))
	zPath = zFree
	if !(zFree == uintptr(0)) {
		goto __26
	}
	rc = SQLITE_NOMEM
	nPath = 0
	goto __27
__26:
	nPath = int32(libc.Xstrlen(tls, zPath))
__27:
	;
__25:
	;
__24:
	;

	// Check that we're not inserting a duplicate entry -OR- updating an
	// entry with a path, thereby making it into a duplicate.
	if !(((pOld == uintptr(0)) || (bUpdate != 0)) && (rc == SQLITE_OK)) {
		goto __28
	}
	p = (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry
__29:
	if !(p != 0) {
		goto __31
	}
	if !(zipfileComparePath(tls, (*ZipfileEntry)(unsafe.Pointer(p)).Fcds.FzFile, zPath, nPath) == 0) {
		goto __32
	}
	switch sqlite3.Xsqlite3_vtab_on_conflict(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).Fdb) {
	case SQLITE_IGNORE:
		goto __34
	case SQLITE_REPLACE:
		goto __35
	default:
		goto __36
	}
	goto __33
__34:
	goto zipfile_update_done

__35:
	pOld2 = p
	goto __33

__36:
	zipfileTableErr(tls, pTab, ts+9578 /* "duplicate name: ..." */, libc.VaList(bp+16, zPath))
	rc = SQLITE_CONSTRAINT
	goto __33

__33:
	;
	goto __31
__32:
	;
	goto __30
__30:
	p = (*ZipfileEntry)(unsafe.Pointer(p)).FpNext
	goto __29
	goto __31
__31:
	;
__28:
	;

	if !(rc == SQLITE_OK) {
		goto __37
	}
	// Create the new CDS record.
	pNew = zipfileNewEntry(tls, zPath)
	if !(pNew == uintptr(0)) {
		goto __38
	}
	rc = SQLITE_NOMEM
	goto __39
__38:
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiVersionMadeBy = (u16((int32(3) << 8) + 30))
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiVersionExtract = u16(ZIPFILE_NEWENTRY_REQUIRED)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.Fflags = u16(ZIPFILE_NEWENTRY_FLAGS)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiCompression = u16(iMethod)
	zipfileMtimeToDos(tls, (pNew /* &.cds */), mTime)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.Fcrc32 = iCrc32
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FszCompressed = u32(nData)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FszUncompressed = u32(sz)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiExternalAttr = (*(*u32)(unsafe.Pointer(bp + 32 /* mode */)) << 16)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiOffset = u32((*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FnFile = u16(nPath)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).FmUnixTime = mTime
	rc = zipfileAppendEntry(tls, pTab, pNew, pData, nData)
	zipfileAddEntry(tls, pTab, pOld, pNew)
__39:
	;
__37:
	;
__10:
	;

	if !((rc == SQLITE_OK) && ((pOld != 0) || (pOld2 != 0))) {
		goto __40
	}
	pCsr = (*ZipfileTab)(unsafe.Pointer(pTab)).FpCsrList
__41:
	if !(pCsr != 0) {
		goto __43
	}
	if !(((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent != 0) && (((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent == pOld) || ((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent == pOld2))) {
		goto __44
	}
	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = (*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FpNext
	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbNoop = u8(1)
__44:
	;
	goto __42
__42:
	pCsr = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCsrNext
	goto __41
	goto __43
__43:
	;

	zipfileRemoveEntryFromList(tls, pTab, pOld)
	zipfileRemoveEntryFromList(tls, pTab, pOld2)
__40:
	;

zipfile_update_done:
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pFree */)))
	sqlite3.Xsqlite3_free(tls, zFree)
	return rc
}

func zipfileSerializeEOCD(tls *libc.TLS, p uintptr, aBuf uintptr) int32 { /* zipfile.c:1723:12: */
	var a uintptr = aBuf
	{
		zipfilePutU32(tls, a, uint32(ZIPFILE_SIGNATURE_EOCD))
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FiDisk)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FiFirstDisk)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FnEntry)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FnEntryTotal)
		a += uintptr(2)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FnSize)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FiOffset)
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, uint16(0))
		a += uintptr(2)
	}
	// Size of trailing comment in bytes

	return ((int32(a) - int32(aBuf)) / 1)
}

func zipfileAppendEOCD(tls *libc.TLS, pTab uintptr, p uintptr) int32 { /* zipfile.c:1737:12: */
	var nBuf int32 = zipfileSerializeEOCD(tls, p, (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer)

	return zipfileAppendData(tls, pTab, (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer, nBuf)
}

// Serialize the CDS structure into buffer aBuf[]. Return the number
// of bytes written.
func zipfileSerializeCDS(tls *libc.TLS, pEntry uintptr, aBuf uintptr) int32 { /* zipfile.c:1747:12: */
	var a uintptr = aBuf
	var pCDS uintptr = (pEntry /* &.cds */)

	if (*ZipfileEntry)(unsafe.Pointer(pEntry)).FaExtra == uintptr(0) {
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FnExtra = u16(9)
	}

	{
		zipfilePutU32(tls, a, uint32(ZIPFILE_SIGNATURE_CDS))
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiVersionMadeBy)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiVersionExtract)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).Fflags)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FmTime)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FmDate)
		a += uintptr(2)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).Fcrc32)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FszCompressed)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FszUncompressed)
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FnFile)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FnExtra)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FnComment)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiDiskStart)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiInternalAttr)
		a += uintptr(2)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiExternalAttr)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiOffset)
		a += uintptr(4)
	}

	libc.Xmemcpy(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FzFile, uint32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FnFile))
	a += uintptr((*ZipfileCDS)(unsafe.Pointer(pCDS)).FnFile)

	if (*ZipfileEntry)(unsafe.Pointer(pEntry)).FaExtra != 0 {
		var n int32 = (int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FnExtra) + int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FnComment))
		libc.Xmemcpy(tls, a, (*ZipfileEntry)(unsafe.Pointer(pEntry)).FaExtra, uint32(n))
		a += uintptr(n)
	} else {

		{
			zipfilePutU16(tls, a, uint16(ZIPFILE_EXTRA_TIMESTAMP))
			a += uintptr(2)
		}

		{
			zipfilePutU16(tls, a, uint16(5))
			a += uintptr(2)
		}

		*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&a, 1))) = u8(0x01)
		{
			zipfilePutU32(tls, a, (*ZipfileEntry)(unsafe.Pointer(pEntry)).FmUnixTime)
			a += uintptr(4)
		}

	}

	return ((int32(a) - int32(aBuf)) / 1)
}

func zipfileCommit(tls *libc.TLS, pVtab uintptr) int32 { /* zipfile.c:1792:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pTab uintptr = pVtab
	var rc int32 = SQLITE_OK
	if (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd != 0 {
		var iOffset i64 = (*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent
		var p uintptr
		// var eocd ZipfileEOCD at bp, 16

		var nEntry int32 = 0

		// Write out all entries
		for p = (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry; (rc == SQLITE_OK) && (p != 0); p = (*ZipfileEntry)(unsafe.Pointer(p)).FpNext {
			var n int32 = zipfileSerializeCDS(tls, p, (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer)
			rc = zipfileAppendData(tls, pTab, (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer, n)
			nEntry++
		}

		// Write out the EOCD record
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FiDisk = u16(0)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FiFirstDisk = u16(0)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnEntry = u16(nEntry)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnEntryTotal = u16(nEntry)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnSize = (u32((*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent - iOffset))
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FiOffset = u32(iOffset)
		rc = zipfileAppendEOCD(tls, pTab, bp /* &eocd */)

		zipfileCleanupTransaction(tls, pTab)
	}
	return rc
}

func zipfileRollback(tls *libc.TLS, pVtab uintptr) int32 { /* zipfile.c:1822:12: */
	return zipfileCommit(tls, pVtab)
}

func zipfileFindCursor(tls *libc.TLS, pTab uintptr, iId i64) uintptr { /* zipfile.c:1826:19: */
	var pCsr uintptr
	for pCsr = (*ZipfileTab)(unsafe.Pointer(pTab)).FpCsrList; pCsr != 0; pCsr = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCsrNext {
		if iId == (*ZipfileCsr)(unsafe.Pointer(pCsr)).FiId {
			break
		}
	}
	return pCsr
}

func zipfileFunctionCds(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* zipfile.c:1834:13: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var pCsr uintptr
	var pTab uintptr = sqlite3.Xsqlite3_user_data(tls, context)

	pCsr = zipfileFindCursor(tls, pTab, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
	if pCsr != 0 {
		var p uintptr = ((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent /* &.cds */)
		var zRes uintptr = sqlite3.Xsqlite3_mprintf(tls,

			ts+9599, /* "{\"version-made-b..." */
			libc.VaList(bp, u32((*ZipfileCDS)(unsafe.Pointer(p)).FiVersionMadeBy), u32((*ZipfileCDS)(unsafe.Pointer(p)).FiVersionExtract),
				u32((*ZipfileCDS)(unsafe.Pointer(p)).Fflags), u32((*ZipfileCDS)(unsafe.Pointer(p)).FiCompression),
				u32((*ZipfileCDS)(unsafe.Pointer(p)).FmTime), u32((*ZipfileCDS)(unsafe.Pointer(p)).FmDate),
				(*ZipfileCDS)(unsafe.Pointer(p)).Fcrc32, (*ZipfileCDS)(unsafe.Pointer(p)).FszCompressed,
				(*ZipfileCDS)(unsafe.Pointer(p)).FszUncompressed, u32((*ZipfileCDS)(unsafe.Pointer(p)).FnFile),
				u32((*ZipfileCDS)(unsafe.Pointer(p)).FnExtra), u32((*ZipfileCDS)(unsafe.Pointer(p)).FnComment),
				u32((*ZipfileCDS)(unsafe.Pointer(p)).FiDiskStart), u32((*ZipfileCDS)(unsafe.Pointer(p)).FiInternalAttr),
				(*ZipfileCDS)(unsafe.Pointer(p)).FiExternalAttr, (*ZipfileCDS)(unsafe.Pointer(p)).FiOffset))

		if zRes == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else {
			sqlite3.Xsqlite3_result_text(tls, context, zRes, -1, libc.UintptrFromInt32(-1))
			sqlite3.Xsqlite3_free(tls, zRes)
		}
	}
}

// xFindFunction method.
func zipfileFindFunction(tls *libc.TLS, pVtab uintptr, nArg int32, zName uintptr, pxFunc uintptr, ppArg uintptr) int32 { /* zipfile.c:1885:12: */
	if sqlite3.Xsqlite3_stricmp(tls, ts+9941 /* "zipfile_cds" */, zName) == 0 {
		*(*uintptr)(unsafe.Pointer(pxFunc)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{zipfileFunctionCds}))
		*(*uintptr)(unsafe.Pointer(ppArg)) = pVtab
		return 1
	}
	return 0
}

type ZipfileBuffer1 = struct {
	Fa      uintptr
	Fn      int32
	FnAlloc int32
} /* zipfile.c:1900:9 */

type ZipfileBuffer = ZipfileBuffer1 /* zipfile.c:1900:30 */

type ZipfileCtx1 = struct {
	FnEntry int32
	Fbody   ZipfileBuffer
	Fcds    ZipfileBuffer
} /* zipfile.c:1907:9 */

type ZipfileCtx = ZipfileCtx1 /* zipfile.c:1907:27 */

func zipfileBufferGrow(tls *libc.TLS, pBuf uintptr, nByte int32) int32 { /* zipfile.c:1914:12: */
	if ((*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fn + nByte) > (*ZipfileBuffer)(unsafe.Pointer(pBuf)).FnAlloc {
		var aNew uintptr
		var nNew sqlite3_int64
		if (*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fn != 0 {
			nNew = (int64((*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fn * 2))
		} else {
			nNew = int64(512)
		}
		var nReq int32 = ((*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fn + nByte)

		for nNew < sqlite3_int64(nReq) {
			nNew = (nNew * int64(2))
		}
		aNew = sqlite3.Xsqlite3_realloc64(tls, (*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fa, uint64(nNew))
		if aNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		(*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fa = aNew
		(*ZipfileBuffer)(unsafe.Pointer(pBuf)).FnAlloc = int32(nNew)
	}
	return SQLITE_OK
}

// xStep() callback for the zipfile() aggregate. This can be called in
// any of the following ways:
//
//   SELECT zipfile(name,data) ...
//   SELECT zipfile(name,mode,mtime,data) ...
//   SELECT zipfile(name,mode,mtime,data,method) ...
func zipfileStep(tls *libc.TLS, pCtx uintptr, nVal int32, apVal uintptr) { /* zipfile.c:1937:6: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var p uintptr // Aggregate function context
	// var e ZipfileEntry at bp+16, 72
	// New entry to add to zip archive

	var pName uintptr
	var pMode uintptr
	var pMtime uintptr
	var pData uintptr
	var pMethod uintptr
	var bIsDir int32
	// var mode u32 at bp+100, 4

	var rc int32
	// var zErr uintptr at bp+96, 4

	var iMethod int32 // Compression method to use (0 or 8)

	var aData uintptr        // Possibly compressed data for new entry
	var nData int32          // Size of aData[] in bytes
	var szUncompressed int32 // Size of data before compression
	// var aFree uintptr at bp+88, 4
	// Free this before returning
	var iCrc32 u32 // crc32 of uncompressed data

	var zName uintptr // Path (name) of new entry
	var nName int32   // Size of zName in bytes
	var zFree uintptr // Free this before returning
	var nByte int32
	// var nOut int32 at bp+92, 4
	pName = uintptr(0)
	pMode = uintptr(0)
	pMtime = uintptr(0)
	pData = uintptr(0)
	pMethod = uintptr(0)
	bIsDir = 0
	rc = SQLITE_OK
	*(*uintptr)(unsafe.Pointer(bp + 96 /* zErr */)) = uintptr(0)
	iMethod = -1
	aData = uintptr(0)
	nData = 0
	szUncompressed = 0
	*(*uintptr)(unsafe.Pointer(bp + 88 /* aFree */)) = uintptr(0)
	iCrc32 = u32(0)
	zName = uintptr(0)
	nName = 0
	zFree = uintptr(0)

	libc.Xmemset(tls, bp+16 /* &e */, 0, uint32(unsafe.Sizeof(ZipfileEntry{})))
	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, int32(unsafe.Sizeof(ZipfileCtx{})))
	if !(p == uintptr(0)) {
		goto __1
	}
	return
__1:
	;

	// Martial the arguments into stack variables
	if !(((nVal != 2) && (nVal != 4)) && (nVal != 5)) {
		goto __2
	}
	*(*uintptr)(unsafe.Pointer(bp + 96 /* zErr */)) = sqlite3.Xsqlite3_mprintf(tls, ts+9953 /* "wrong number of ..." */, 0)
	rc = SQLITE_ERROR
	goto zipfile_step_out
__2:
	;
	pName = *(*uintptr)(unsafe.Pointer(apVal))
	if !(nVal == 2) {
		goto __3
	}
	pData = *(*uintptr)(unsafe.Pointer(apVal + 1*4))
	goto __4
__3:
	pMode = *(*uintptr)(unsafe.Pointer(apVal + 1*4))
	pMtime = *(*uintptr)(unsafe.Pointer(apVal + 2*4))
	pData = *(*uintptr)(unsafe.Pointer(apVal + 3*4))
	if !(nVal == 5) {
		goto __5
	}
	pMethod = *(*uintptr)(unsafe.Pointer(apVal + 4*4))
__5:
	;
__4:
	;

	// Check that the 'name' parameter looks ok.
	zName = sqlite3.Xsqlite3_value_text(tls, pName)
	nName = sqlite3.Xsqlite3_value_bytes(tls, pName)
	if !(zName == uintptr(0)) {
		goto __6
	}
	*(*uintptr)(unsafe.Pointer(bp + 96 /* zErr */)) = sqlite3.Xsqlite3_mprintf(tls, ts+10001 /* "first argument t..." */, 0)
	rc = SQLITE_ERROR
	goto zipfile_step_out
__6:
	;

	// Inspect the 'method' parameter. This must be either 0 (store), 8 (use
	// deflate compression) or NULL (choose automatically).
	if !((pMethod != 0) && (SQLITE_NULL != sqlite3.Xsqlite3_value_type(tls, pMethod))) {
		goto __7
	}
	iMethod = int32(sqlite3.Xsqlite3_value_int64(tls, pMethod))
	if !((iMethod != 0) && (iMethod != 8)) {
		goto __8
	}
	*(*uintptr)(unsafe.Pointer(bp + 96 /* zErr */)) = sqlite3.Xsqlite3_mprintf(tls, ts+10046 /* "illegal method v..." */, libc.VaList(bp, iMethod))
	rc = SQLITE_ERROR
	goto zipfile_step_out
__8:
	;
__7:
	;

	// Now inspect the data. If this is NULL, then the new entry must be a
	// directory.  Otherwise, figure out whether or not the data should
	// be deflated or simply stored in the zip archive.
	if !(sqlite3.Xsqlite3_value_type(tls, pData) == SQLITE_NULL) {
		goto __9
	}
	bIsDir = 1
	iMethod = 0
	goto __10
__9:
	aData = sqlite3.Xsqlite3_value_blob(tls, pData)
	szUncompressed = libc.AssignInt32(&nData, sqlite3.Xsqlite3_value_bytes(tls, pData))
	iCrc32 = u32(tcl.Xcrc32(tls, uint32(0), aData, uint32(nData)))
	if !((iMethod < 0) || (iMethod == 8)) {
		goto __11
	}
	*(*int32)(unsafe.Pointer(bp + 92 /* nOut */)) = 0
	rc = zipfileDeflate(tls, aData, nData, bp+88 /* &aFree */, bp+92 /* &nOut */, bp+96 /* &zErr */)
	if !(rc != SQLITE_OK) {
		goto __12
	}
	goto zipfile_step_out
__12:
	;
	if !((iMethod == 8) || (*(*int32)(unsafe.Pointer(bp + 92 /* nOut */)) < nData)) {
		goto __13
	}
	aData = *(*uintptr)(unsafe.Pointer(bp + 88 /* aFree */))
	nData = *(*int32)(unsafe.Pointer(bp + 92 /* nOut */))
	iMethod = 8
	goto __14
__13:
	iMethod = 0
__14:
	;
__11:
	;
__10:
	;

	// Decode the "mode" argument.
	rc = zipfileGetMode(tls, pMode, bIsDir, bp+100 /* &mode */, bp+96 /* &zErr */)
	if !(rc != 0) {
		goto __15
	}
	goto zipfile_step_out
__15:
	;

	// Decode the "mtime" argument.
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).FmUnixTime = zipfileGetTime(tls, pMtime)

	// If this is a directory entry, ensure that there is exactly one '/'
	// at the end of the path. Or, if this is not a directory and the path
	// ends in '/' it is an error.
	if !(bIsDir == 0) {
		goto __16
	}
	if !((nName > 0) && (int32(*(*int8)(unsafe.Pointer(zName + uintptr((nName - 1))))) == '/')) {
		goto __18
	}
	*(*uintptr)(unsafe.Pointer(bp + 96 /* zErr */)) = sqlite3.Xsqlite3_mprintf(tls, ts+10071 /* "non-directory na..." */, 0)
	rc = SQLITE_ERROR
	goto zipfile_step_out
__18:
	;
	goto __17
__16:
	if !((nName == 0) || (int32(*(*int8)(unsafe.Pointer(zName + uintptr((nName - 1))))) != '/')) {
		goto __19
	}
	zName = libc.AssignUintptr(&zFree, sqlite3.Xsqlite3_mprintf(tls, ts+9574 /* "%s/" */, libc.VaList(bp+8, zName)))
	if !(zName == uintptr(0)) {
		goto __21
	}
	rc = SQLITE_NOMEM
	goto zipfile_step_out
__21:
	;
	nName = int32(libc.Xstrlen(tls, zName))
	goto __20
__19:
__22:
	if !((nName > 1) && (int32(*(*int8)(unsafe.Pointer(zName + uintptr((nName - 2))))) == '/')) {
		goto __23
	}
	nName--
	goto __22
__23:
	;
__20:
	;
__17:
	;

	// Assemble the ZipfileEntry object for the new zip archive entry
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FiVersionMadeBy = (u16((int32(3) << 8) + 30))
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FiVersionExtract = u16(ZIPFILE_NEWENTRY_REQUIRED)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.Fflags = u16(ZIPFILE_NEWENTRY_FLAGS)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FiCompression = u16(iMethod)
	zipfileMtimeToDos(tls, (bp + 16 /* &e */ /* &.cds */), (*ZipfileEntry)(unsafe.Pointer(bp+16 /* &e */)).FmUnixTime)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.Fcrc32 = iCrc32
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FszCompressed = u32(nData)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FszUncompressed = u32(szUncompressed)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FiExternalAttr = (*(*u32)(unsafe.Pointer(bp + 100 /* mode */)) << 16)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FiOffset = u32((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FnFile = u16(nName)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FzFile = zName

	// Append the LFH to the body of the new archive
	nByte = ((ZIPFILE_LFH_FIXED_SZ + int32((*ZipfileEntry)(unsafe.Pointer(bp+16 /* &e */)).Fcds.FnFile)) + 9)
	if !(libc.AssignInt32(&rc, zipfileBufferGrow(tls, (p+4 /* &.body */), nByte)) != 0) {
		goto __24
	}
	goto zipfile_step_out
__24:
	;
	*(*int32)(unsafe.Pointer(p + 4 /* &.body */ + 4 /* &.n */)) += (zipfileSerializeLFH(tls, bp+16 /* &e */, ((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fa + uintptr((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn))))

	// Append the data to the body of the new archive
	if !(nData > 0) {
		goto __25
	}
	if !(libc.AssignInt32(&rc, zipfileBufferGrow(tls, (p+4 /* &.body */), nData)) != 0) {
		goto __26
	}
	goto zipfile_step_out
__26:
	;
	libc.Xmemcpy(tls, ((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fa + uintptr((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn)), aData, uint32(nData))
	*(*int32)(unsafe.Pointer(p + 4 /* &.body */ + 4 /* &.n */)) += (nData)
__25:
	;

	// Append the CDS record to the directory of the new archive
	nByte = ((ZIPFILE_CDS_FIXED_SZ + int32((*ZipfileEntry)(unsafe.Pointer(bp+16 /* &e */)).Fcds.FnFile)) + 9)
	if !(libc.AssignInt32(&rc, zipfileBufferGrow(tls, (p+16 /* &.cds */), nByte)) != 0) {
		goto __27
	}
	goto zipfile_step_out
__27:
	;
	*(*int32)(unsafe.Pointer(p + 16 /* &.cds */ + 4 /* &.n */)) += (zipfileSerializeCDS(tls, bp+16 /* &e */, ((*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fa + uintptr((*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fn))))

	// Increment the count of entries in the archive
	(*ZipfileCtx)(unsafe.Pointer(p)).FnEntry++

zipfile_step_out:
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* aFree */)))
	sqlite3.Xsqlite3_free(tls, zFree)
	if !(rc != 0) {
		goto __28
	}
	if !(*(*uintptr)(unsafe.Pointer(bp + 96 /* zErr */)) != 0) {
		goto __29
	}
	sqlite3.Xsqlite3_result_error(tls, pCtx, *(*uintptr)(unsafe.Pointer(bp + 96 /* zErr */)), -1)
	goto __30
__29:
	sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
__30:
	;
__28:
	;
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 96 /* zErr */)))
}

// xFinalize() callback for zipfile aggregate function.
func zipfileFinal(tls *libc.TLS, pCtx uintptr) { /* zipfile.c:2112:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var p uintptr
	// var eocd ZipfileEOCD at bp, 16

	var nZip sqlite3_int64
	var aZip uintptr

	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, int32(unsafe.Sizeof(ZipfileCtx{})))
	if p == uintptr(0) {
		return
	}
	if (*ZipfileCtx)(unsafe.Pointer(p)).FnEntry > 0 {
		libc.Xmemset(tls, bp /* &eocd */, 0, uint32(unsafe.Sizeof(ZipfileEOCD{})))
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnEntry = u16((*ZipfileCtx)(unsafe.Pointer(p)).FnEntry)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnEntryTotal = u16((*ZipfileCtx)(unsafe.Pointer(p)).FnEntry)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnSize = u32((*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fn)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FiOffset = u32((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn)

		nZip = (sqlite3_int64(((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn + (*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fn) + ZIPFILE_EOCD_FIXED_SZ))
		aZip = sqlite3.Xsqlite3_malloc64(tls, uint64(nZip))
		if aZip == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		} else {
			libc.Xmemcpy(tls, aZip, (*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fa, uint32((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn))
			libc.Xmemcpy(tls, (aZip + uintptr((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn)), (*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fa, uint32((*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fn))
			zipfileSerializeEOCD(tls, bp /* &eocd */, (aZip + uintptr(((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn + (*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fn))))
			sqlite3.Xsqlite3_result_blob(tls, pCtx, aZip, int32(nZip), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{zipfileFree})))
		}
	}

	sqlite3.Xsqlite3_free(tls, (*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fa)
	sqlite3.Xsqlite3_free(tls, (*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fa)
}

// Register the "zipfile" virtual table.
func zipfileRegister(tls *libc.TLS, db uintptr) int32 { /* zipfile.c:2147:12: */

	var rc int32 = sqlite3.Xsqlite3_create_module(tls, db, ts+9012 /* "zipfile" */, uintptr(unsafe.Pointer(&zipfileModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_overload_function(tls, db, ts+9941 /* "zipfile_cds" */, -1)
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+9012 /* "zipfile" */, -1, SQLITE_UTF8, uintptr(0), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{zipfileStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{zipfileFinal})))
	}

	return rc
}

var zipfileModule = sqlite3_module{
	FiVersion:      1, // iVersion
	FxCreate:       0, // xCreate
	FxConnect:      0, // xConnect
	FxBestIndex:    0, // xBestIndex
	FxDisconnect:   0, // xDisconnect
	FxDestroy:      0, // xDestroy
	FxOpen:         0, // xOpen - open a cursor
	FxClose:        0, // xClose - close a cursor
	FxFilter:       0, // xFilter - configure scan constraints
	FxNext:         0, // xNext - advance a cursor
	FxEof:          0, // xEof - check for end of scan
	FxColumn:       0, // xRowid - read data
	FxUpdate:       0, // xUpdate
	FxBegin:        0, // xSync
	FxCommit:       0, // xCommit
	FxRollback:     0, // xRollback
	FxFindFunction: 0, // xRename
} /* zipfile.c:2148:25 */

func sqlite3_zipfile_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* zipfile.c:2191:5: */
	_ = pApi

	_ = pzErrMsg // Unused parameter
	return zipfileRegister(tls, db)
}

func test_rbu_delta(tls *libc.TLS, pCtx uintptr, nArg int32, apVal uintptr) { /* test_rbu.c:34:6: */
	var interp uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var pScript uintptr
	var i int32

	pScript = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, ts+10110 /* "rbu_delta" */, -1))
	for i = 0; i < nArg; i++ {
		var pIn uintptr = *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))
		var z uintptr = sqlite3.Xsqlite3_value_text(tls, pIn)
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, z, -1))
	}

	if TCL_OK == tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_GLOBAL_ONLY) {
		var z uintptr = tcl.XTcl_GetStringResult(tls, interp)
		sqlite3.Xsqlite3_result_text(tls, pCtx, z, -1, libc.UintptrFromInt32(-1))
	} else {
		tcl.XTcl_BackgroundError(tls, interp)
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func test_sqlite3rbu_cmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:59:26: */
	bp := tls.Alloc(296)
	defer tls.Free(296)

	var ret int32 = TCL_OK
	var pRbu uintptr = clientData
	*(*[14]RbuCmd)(unsafe.Pointer(bp + 24 /* aCmd */)) = [14]RbuCmd{
		{FzName: ts + 10120 /* "step" */, FnArg: 2, FzUsage: ts + 489 /* "" */},                   // 0
		{FzName: ts + 10125 /* "close" */, FnArg: 2, FzUsage: ts + 489 /* "" */},                  // 1
		{FzName: ts + 10131 /* "create_rbu_delta" */, FnArg: 2, FzUsage: ts + 489 /* "" */},       // 2
		{FzName: ts + 10148 /* "savestate" */, FnArg: 2, FzUsage: ts + 489 /* "" */},              // 3
		{FzName: ts + 10158 /* "dbMain_eval" */, FnArg: 3, FzUsage: ts + 10170 /* "SQL" */},       // 4
		{FzName: ts + 10174 /* "bp_progress" */, FnArg: 2, FzUsage: ts + 489 /* "" */},            // 5
		{FzName: ts + 10186 /* "db" */, FnArg: 3, FzUsage: ts + 10189 /* "RBU" */},                // 6
		{FzName: ts + 10193 /* "state" */, FnArg: 2, FzUsage: ts + 489 /* "" */},                  // 7
		{FzName: ts + 10199 /* "progress" */, FnArg: 2, FzUsage: ts + 489 /* "" */},               // 8
		{FzName: ts + 10208 /* "close_no_error" */, FnArg: 2, FzUsage: ts + 489 /* "" */},         // 9
		{FzName: ts + 10223 /* "temp_size_limit" */, FnArg: 3, FzUsage: ts + 10239 /* "LIMIT" */}, // 10
		{FzName: ts + 10245 /* "temp_size" */, FnArg: 2, FzUsage: ts + 489 /* "" */},              // 11
		{FzName: ts + 10255 /* "dbRbu_eval" */, FnArg: 3, FzUsage: ts + 10170 /* "SQL" */},        // 12
		{},
	}
	// var iCmd int32 at bp+192, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10266 /* "METHOD" */)
		return TCL_ERROR
	}
	ret = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+24 /* &aCmd[0] */, int32(unsafe.Sizeof(RbuCmd{})), ts+10273 /* "method" */, 0, bp+192 /* &iCmd */)
	if ret != 0 {
		return TCL_ERROR
	}
	if objc != (*RbuCmd)(unsafe.Pointer(bp+24 /* &aCmd */ +uintptr(*(*int32)(unsafe.Pointer(bp + 192 /* iCmd */)))*12)).FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, (*RbuCmd)(unsafe.Pointer(bp+24 /* &aCmd */ +uintptr(*(*int32)(unsafe.Pointer(bp + 192 /* iCmd */)))*12)).FzUsage)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp + 192 /* iCmd */)) {
	case 0: /* step */
		{
			var rc int32 = sqlite3.Xsqlite3rbu_step(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			break

		}

	case 9:
		fallthrough /* close_no_error */
	case 1: /* close */
		{
			*(*uintptr)(unsafe.Pointer(bp + 196 /* zErrmsg */)) = uintptr(0)
			var rc int32
			tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
			if *(*int32)(unsafe.Pointer(bp + 192 /* iCmd */)) == 1 {
				rc = sqlite3.Xsqlite3rbu_close(tls, pRbu, bp+196 /* &zErrmsg */)
			} else {
				rc = sqlite3.Xsqlite3rbu_close(tls, pRbu, uintptr(0))
			}
			if (rc == SQLITE_OK) || (rc == SQLITE_DONE) {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))

			} else {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
				if *(*uintptr)(unsafe.Pointer(bp + 196 /* zErrmsg */)) != 0 {
					tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+10280 /* " - " */, *(*uintptr)(unsafe.Pointer(bp + 196 /* zErrmsg */)), 0))
					sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 196 /* zErrmsg */)))
				}
				ret = TCL_ERROR
			}
			break

		}

	case 2: /* create_rbu_delta */
		{
			var db uintptr = sqlite3.Xsqlite3rbu_db(tls, pRbu, 0)
			var rc int32 = sqlite3.Xsqlite3_create_function(tls,
				db, ts+10110 /* "rbu_delta" */, -1, SQLITE_UTF8, interp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{test_rbu_delta})), uintptr(0), uintptr(0))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			ret = func() int32 {
				if rc == SQLITE_OK {
					return TCL_OK
				}
				return TCL_ERROR
			}()
			break

		}

	case 3: /* savestate */
		{
			var rc int32 = sqlite3.Xsqlite3rbu_savestate(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			ret = func() int32 {
				if rc == SQLITE_OK {
					return TCL_OK
				}
				return TCL_ERROR
			}()
			break

		}

	case 12:
		fallthrough /* dbRbu_eval */
	case 4: /* dbMain_eval */
		{
			var db uintptr = sqlite3.Xsqlite3rbu_db(tls, pRbu, (libc.Bool32(*(*int32)(unsafe.Pointer(bp + 192 /* iCmd */)) == 12)))
			var rc int32 = sqlite3.Xsqlite3_exec(tls, db, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), uintptr(0), uintptr(0), uintptr(0))
			if rc != SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, db), -1))
				ret = TCL_ERROR
			}
			break

		}

	case 5: /* bp_progress */
		{
			// var one int32 at bp+200, 4

			// var two int32 at bp+204, 4

			var pObj uintptr
			sqlite3.Xsqlite3rbu_bp_progress(tls, pRbu, bp+200 /* &one */, bp+204 /* &two */)

			pObj = tcl.XTcl_NewObj(tls)
			tcl.XTcl_ListObjAppendElement(tls, interp, pObj, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 200 /* one */))))
			tcl.XTcl_ListObjAppendElement(tls, interp, pObj, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 204 /* two */))))
			tcl.XTcl_SetObjResult(tls, interp, pObj)
			break

		}

	case 6: /* db */
		{
			// var bArg int32 at bp+208, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+208 /* &bArg */) != 0 {
				ret = TCL_ERROR
			} else {
				// var zBuf [50]int8 at bp+212, 50

				var db uintptr = sqlite3.Xsqlite3rbu_db(tls, pRbu, *(*int32)(unsafe.Pointer(bp + 208 /* bArg */)))
				if sqlite3TestMakePointerStr(tls, interp, bp+212 /* &zBuf[0] */, db) != 0 {
					ret = TCL_ERROR
				} else {
					tcl.XTcl_SetResult(tls, interp, bp+212 /* &zBuf[0] */, uintptr(1))
				}
			}
			break

		}
	case 7: /* state */
		{
			*(*[6]uintptr)(unsafe.Pointer(bp + 264 /* aRes */)) = [6]uintptr{uintptr(0), ts + 10284 /* "oal" */, ts + 10288 /* "move" */, ts + 10293 /* "checkpoint" */, ts + 10304 /* "done" */, ts + 10309 /* "error" */}
			var eState int32 = sqlite3.Xsqlite3rbu_state(tls, pRbu)

			tcl.XTcl_SetResult(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 264 /* &aRes[0] */ + uintptr(eState)*4)), uintptr(0))
			break

		}
	case 8: /* progress */
		{
			var nStep sqlite3_int64 = sqlite3.Xsqlite3rbu_progress(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, nStep))
			break

		}

	case 10: /* temp_size_limit */
		{
			// var nLimit sqlite3_int64 at bp+288, 8

			if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+288 /* &nLimit */) != 0 {
				ret = TCL_ERROR
			} else {
				*(*sqlite3_int64)(unsafe.Pointer(bp + 288 /* nLimit */)) = sqlite3.Xsqlite3rbu_temp_size_limit(tls, pRbu, *(*sqlite3_int64)(unsafe.Pointer(bp + 288 /* nLimit */)))
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 288 /* nLimit */))))
			}
			break

		}
	case 11: /* temp_size */
		{
			var sz sqlite3_int64 = sqlite3.Xsqlite3rbu_temp_size(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, sz))
			break

		}

	default: // seems unlikely

		break
	}

	return ret
}

type RbuCmd = struct {
	FzName  uintptr
	FnArg   int32
	FzUsage uintptr
} /* test_rbu.c:67:3 */

// Tclcmd: sqlite3rbu CMD <target-db> <rbu-db> ?<state-db>?
func test_sqlite3rbu(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:228:26: */
	var pRbu uintptr = uintptr(0)
	var zCmd uintptr
	var zTarget uintptr
	var zRbu uintptr
	var zStateDb uintptr = uintptr(0)

	if (objc != 4) && (objc != 5) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10315 /* "NAME TARGET-DB R..." */)
		return TCL_ERROR
	}
	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zTarget = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	zRbu = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if objc == 5 {
		zStateDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
	}

	pRbu = sqlite3.Xsqlite3rbu_open(tls, zTarget, zRbu, zStateDb)
	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{test_sqlite3rbu_cmd})), pRbu, uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	return TCL_OK
}

// Tclcmd: sqlite3rbu_vacuum CMD <target-db> <state-db>
func test_sqlite3rbu_vacuum(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:258:26: */
	var pRbu uintptr = uintptr(0)
	var zCmd uintptr
	var zTarget uintptr
	var zStateDb uintptr = uintptr(0)

	if (objc != 3) && (objc != 4) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10348 /* "NAME TARGET-DB ?..." */)
		return TCL_ERROR
	}
	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zTarget = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if objc == 4 {
		zStateDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	}
	if (zStateDb != 0) && (int32(*(*int8)(unsafe.Pointer(zStateDb))) == 0) {
		zStateDb = uintptr(0)
	}

	pRbu = sqlite3.Xsqlite3rbu_vacuum(tls, zTarget, zStateDb)
	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{test_sqlite3rbu_cmd})), pRbu, uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	return TCL_OK
}

// Tclcmd: sqlite3rbu_create_vfs ?-default? NAME PARENT
func test_sqlite3rbu_create_vfs(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:287:26: */
	var zName uintptr
	var zParent uintptr
	var rc int32

	if (objc != 3) && (objc != 4) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10374 /* "?-default? NAME ..." */)
		return TCL_ERROR
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-2))*4)))
	zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*4)))
	if int32(*(*int8)(unsafe.Pointer(zParent))) == 0 {
		zParent = uintptr(0)
	}

	rc = sqlite3.Xsqlite3rbu_create_vfs(tls, zName, zParent)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else if objc == 4 {
		var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, zName)
		sqlite3.Xsqlite3_vfs_register(tls, pVfs, 1)
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

// Tclcmd: sqlite3rbu_destroy_vfs NAME
func test_sqlite3rbu_destroy_vfs(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:322:26: */
	var zName uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10397 /* "NAME" */)
		return TCL_ERROR
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	sqlite3.Xsqlite3rbu_destroy_vfs(tls, zName)
	return TCL_OK
}

// Tclcmd: sqlite3rbu_internal_test
func test_sqlite3rbu_internal_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:343:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var db uintptr

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	db = sqlite3.Xsqlite3rbu_db(tls, uintptr(0), 0)
	if db != uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+10402 /* "sqlite3rbu_db(0,..." */, 0))
		return TCL_ERROR
	}

	return TCL_OK
}

func SqliteRbu_Init(tls *libc.TLS, interp uintptr) int32 { /* test_rbu.c:365:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd[i].FzName, aObjCmd[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aObjCmd = [5]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 10425 /* "sqlite3rbu" */, FxProc: 0},
	{FzName: ts + 10436 /* "sqlite3rbu_vacuu..." */, FxProc: 0},
	{FzName: ts + 10454 /* "sqlite3rbu_creat..." */, FxProc: 0},
	{FzName: ts + 10476 /* "sqlite3rbu_destr..." */, FxProc: 0},
	{FzName: ts + 10499 /* "sqlite3rbu_inter..." */, FxProc: 0},
} /* test_rbu.c:369:5 */

// 2014-09-08
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// This file contains the bulk of the implementation of the
// user-authentication extension feature.  Some parts of the user-
// authentication code are contained within the SQLite core (in the
// src/ subdirectory of the main source code tree) but those parts
// that could reasonable be separated out are moved into this file.
//
// To compile with the user-authentication feature, append this file to
// end of an SQLite amalgamation, then add the SQLITE_USER_AUTHENTICATION
// compile-time option.  See the user-auth.txt file in the same source
// directory as this file for additional information.

// Used to get the current process ID
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.14 Signal handling <signal.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Signal number definitions.  Linux version.
//    Copyright (C) 1995-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Signal number constants.  Generic template.
//    Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Fake signal functions.

// We define here all the signal names listed in POSIX (1003.1-2008);
//    as of 1003.1-2013, no additional signals have been added by POSIX.
//    We also define here signal names that historically exist in every
//    real-world POSIX variant (e.g. SIGWINCH).
//
//    Signals in the 1-15 range are defined with their historical numbers.
//    For other signals, we use the BSD numbers.
//    There are two unallocated signal numbers in the 1-31 range: 7 and 29.
//    Signal number 0 is reserved for use as kill(pid, 0), to test whether
//    a process exists without sending it a signal.

// ISO C99 signals.

// Historical signals specified by POSIX.

// New(er) POSIX signals (1003.1-2008, 1003.1-2013).

// Nonstandard signals found in all modern POSIX systems
//    (including both BSD and Linux).

// Archaic names for compatibility.

// Not all systems support real-time signals.  bits/signum.h indicates
//    that they are supported by overriding __SIGRTMAX to a value greater
//    than __SIGRTMIN.  These constants give the kernel-level hard limits,
//    but some real-time signals may be used internally by glibc.  Do not
//    use these constants in application code; use SIGRTMIN and SIGRTMAX
//    (defined in signal.h) instead.

// Biggest signal number + 1 (including real-time signals).

// Adjustments and additions to the signal number constants for
//    most Linux systems.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// An integral type that can be modified atomically, without the
//    possibility of a signal arriving in the middle of the operation.
type sig_atomic_t = int32 /* sig_atomic_t.h:8:24 */

// We need `struct timespec' later on.
// NB: Include guard matches what <linux/time.h> uses.

// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define __sigval_t.
//    Copyright (C) 1997-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Type for data associated with a signal.
type sigval = struct{ Fsival_int int32 } /* __sigval_t.h:24:1 */

// Some fields of siginfo_t have architecture-specific variations.
// Architecture-specific adjustments to siginfo_t.

// This architecture has no adjustments to make to siginfo_t.

type siginfo_t = struct {
	Fsi_signo  int32
	Fsi_errno  int32
	Fsi_code   int32
	F_sifields struct{ F_pad [29]int32 }
} /* siginfo_t.h:124:5 */

// Architectures might also add architecture-specific constants.
//    These are all considered GNU extensions.

// Define __sigval_t.
//    Copyright (C) 1997-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// To avoid sigval_t (not a standard type name) having C++ name
//    mangling depending on whether the selected standard includes union
//    sigval, it should not be defined at all when using a standard for
//    which the sigval name is not reserved; in that case, headers should
//    not include <bits/types/sigval_t.h> and should use only the
//    internal __sigval_t name.

type sigval_t = sigval /* sigval_t.h:16:20 */

// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define __sigval_t.
//    Copyright (C) 1997-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Forward declaration.

// Structure to transport application-defined values with signals.
type sigevent_t = sigevent /* sigevent_t.h:42:5 */

// 4.4 BSD uses the name `sig_t' for this.
type sig_t = uintptr /* signal.h:190:24 */

// Get the system-specific definitions of `struct sigaction'
//    and the `SA_*' and `SIG_*'. constants.
// The proper definitions for Linux's sigaction.
//    Copyright (C) 1993-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Structure describing the action to be taken when a signal arrives.
type sigaction = struct {
	F__sigaction_handler struct{ Fsa_handler uintptr }
	Fsa_mask             struct{ F__val [32]uint32 }
	Fsa_flags            int32
	Fsa_restorer         uintptr
} /* sigaction.h:27:1 */

// Get machine-dependent `struct sigcontext' and signal subcodes.
// Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Kernel headers before 2.1.1 define a struct sigcontext_struct, but
//    we need sigcontext.

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// Signal context structure - contains all info to do with the state
// before the signal handler was invoked.  Note: only add new entries
// to the end of the structure.
type sigcontext = struct {
	Ftrap_no       uint32
	Ferror_code    uint32
	Foldmask       uint32
	Farm_r0        uint32
	Farm_r1        uint32
	Farm_r2        uint32
	Farm_r3        uint32
	Farm_r4        uint32
	Farm_r5        uint32
	Farm_r6        uint32
	Farm_r7        uint32
	Farm_r8        uint32
	Farm_r9        uint32
	Farm_r10       uint32
	Farm_fp        uint32
	Farm_ip        uint32
	Farm_sp        uint32
	Farm_lr        uint32
	Farm_pc        uint32
	Farm_cpsr      uint32
	Ffault_address uint32
} /* sigcontext.h:10:1 */

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Define stack_t.  Linux version.
//    Copyright (C) 1998-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Structure describing a signal stack.
type stack_t = struct {
	Fss_sp    uintptr
	Fss_flags int32
	Fss_size  size_t
} /* stack_t.h:31:5 */

// This will define `ucontext_t' and `mcontext_t'.
// Copyright (C) 1998-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library.  If not, see
//    <http://www.gnu.org/licenses/>.

// System V/ARM ABI compliant context switching support.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Define stack_t.  Linux version.
//    Copyright (C) 1998-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type greg_t = int32 /* ucontext.h:36:13 */

// Number of general registers.

// Container for all general registers.
type gregset_t = [18]greg_t /* ucontext.h:42:16 */

type _libc_fpstate = struct {
	Ffpregs [8]struct {
		_          [0]uint32
		Fsign1     uint32 /* unsigned sign1: 1, unsigned unused: 15, unsigned sign2: 1, unsigned exponent: 14, unsigned j: 1 */
		Fmantissa1 uint32 /* unsigned mantissa1: 31 */
		Fmantissa0 uint32 /* unsigned mantissa0: 32 */
	}
	Ffpsr      uint32 /* unsigned fpsr: 32 */
	Ffpcr      uint32 /* unsigned fpcr: 32 */
	Fftype     [8]uint8
	Finit_flag uint32
} /* ucontext.h:81:1 */

// Structure to describe FPU registers.
type fpregset_t = _libc_fpstate /* ucontext.h:99:30 */

// Context to describe whole processor state.  This only describes
//    the core registers; coprocessor registers get saved elsewhere
//    (e.g. in uc_regspace, or somewhere unspecified on the stack
//    during non-RT signal handlers).
type mcontext_t = struct {
	Ftrap_no       uint32
	Ferror_code    uint32
	Foldmask       uint32
	Farm_r0        uint32
	Farm_r1        uint32
	Farm_r2        uint32
	Farm_r3        uint32
	Farm_r4        uint32
	Farm_r5        uint32
	Farm_r6        uint32
	Farm_r7        uint32
	Farm_r8        uint32
	Farm_r9        uint32
	Farm_r10       uint32
	Farm_fp        uint32
	Farm_ip        uint32
	Farm_sp        uint32
	Farm_lr        uint32
	Farm_pc        uint32
	Farm_cpsr      uint32
	Ffault_address uint32
} /* ucontext.h:129:5 */

// Userlevel context.
type ucontext_t1 = struct {
	Fuc_flags    uint32
	Fuc_link     uintptr
	Fuc_stack    stack_t
	Fuc_mcontext mcontext_t
	Fuc_sigmask  sigset_t
	Fuc_regspace [128]uint32
} /* ucontext.h:132:9 */

// Userlevel context.
type ucontext_t = ucontext_t1 /* ucontext.h:140:5 */

// Define struct sigstack.
//    Copyright (C) 1998-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Structure describing a signal stack (obsolete).
type sigstack = struct {
	Fss_sp      uintptr
	Fss_onstack int32
} /* struct_sigstack.h:23:1 */

// Define some macros helping to catch buffer overflows.

// Windows needs to know which symbols to export.  Unix does not.
// BUILD_sqlite should be undefined for Unix.

// Forward declaration
type SqliteDb = struct {
	Fdb             uintptr
	Finterp         uintptr
	FzBusy          uintptr
	FzCommit        uintptr
	FzTrace         uintptr
	FzTraceV2       uintptr
	FzProfile       uintptr
	FzProgress      uintptr
	FzBindFallback  uintptr
	FzAuth          uintptr
	FdisableAuth    int32
	FzNull          uintptr
	FpFunc          uintptr
	FpUpdateHook    uintptr
	FpPreUpdateHook uintptr
	FpRollbackHook  uintptr
	FpWalHook       uintptr
	FpUnlockNotify  uintptr
	FpCollate       uintptr
	Frc             int32
	FpCollateNeeded uintptr
	FstmtList       uintptr
	FstmtLast       uintptr
	FmaxStmt        int32
	FnStmt          int32
	FpIncrblob      uintptr
	FnStep          int32
	FnSort          int32
	FnIndex         int32
	FnVMStep        int32
	FnTransaction   int32
	FopenFlags      int32
	FbLegacyPrepare int32
} /* tclsqlite.c:91:25 */

// New SQL functions can be created as TCL scripts.  Each such function
// is described by an instance of the following structure.
//
// Variable eType may be set to SQLITE_INTEGER, SQLITE_FLOAT, SQLITE_TEXT,
// SQLITE_BLOB or SQLITE_NULL. If it is SQLITE_NULL, then the implementation
// attempts to determine the type of the result based on the Tcl object.
// If it is SQLITE_TEXT or SQLITE_BLOB, then a text (sqlite3_result_text())
// or blob (sqlite3_result_blob()) is returned. If it is SQLITE_INTEGER
// or SQLITE_FLOAT, then an attempt is made to return an integer or float
// value, falling back to float and then text if this is not possible.
type SqlFunc1 = struct {
	Finterp      uintptr
	FpScript     uintptr
	FpDb         uintptr
	FuseEvalObjv int32
	FeType       int32
	FzName       uintptr
	FpNext       uintptr
} /* tclsqlite.c:105:9 */

// New SQL functions can be created as TCL scripts.  Each such function
// is described by an instance of the following structure.
//
// Variable eType may be set to SQLITE_INTEGER, SQLITE_FLOAT, SQLITE_TEXT,
// SQLITE_BLOB or SQLITE_NULL. If it is SQLITE_NULL, then the implementation
// attempts to determine the type of the result based on the Tcl object.
// If it is SQLITE_TEXT or SQLITE_BLOB, then a text (sqlite3_result_text())
// or blob (sqlite3_result_blob()) is returned. If it is SQLITE_INTEGER
// or SQLITE_FLOAT, then an attempt is made to return an integer or float
// value, falling back to float and then text if this is not possible.
type SqlFunc = SqlFunc1 /* tclsqlite.c:105:24 */

// New collation sequences function can be created as TCL scripts.  Each such
// function is described by an instance of the following structure.
type SqlCollate1 = struct {
	Finterp  uintptr
	FzScript uintptr
	FpNext   uintptr
} /* tclsqlite.c:120:9 */

// New collation sequences function can be created as TCL scripts.  Each such
// function is described by an instance of the following structure.
type SqlCollate = SqlCollate1 /* tclsqlite.c:120:27 */

// Prepared statements are cached for faster execution.  Each prepared
// statement is described by an instance of the following structure.
type SqlPreparedStmt1 = struct {
	FpNext  uintptr
	FpPrev  uintptr
	FpStmt  uintptr
	FnSql   int32
	FzSql   uintptr
	FnParm  int32
	FapParm uintptr
} /* tclsqlite.c:131:9 */

// Prepared statements are cached for faster execution.  Each prepared
// statement is described by an instance of the following structure.
type SqlPreparedStmt = SqlPreparedStmt1 /* tclsqlite.c:131:32 */

type IncrblobChannel1 = struct {
	FpBlob   uintptr
	FpDb     uintptr
	FiSeek   int32
	Fchannel Tcl_Channel
	FpNext   uintptr
	FpPrev   uintptr
} /* tclsqlite.c:142:9 */

type IncrblobChannel = IncrblobChannel1 /* tclsqlite.c:142:32 */

// Compute a string length that is limited to what can be stored in
// lower 30 bits of a 32-bit signed integer.
func strlen30(tls *libc.TLS, z uintptr) int32 { /* tclsqlite.c:202:12: */
	var z2 uintptr = z
	for *(*int8)(unsafe.Pointer(z2)) != 0 {
		z2++
	}
	return (0x3fffffff & ((int32(z2) - int32(z)) / 1))
}

// Close all incrblob channels opened using database connection pDb.
// This is called when shutting down the database connection.
func closeIncrblobChannels(tls *libc.TLS, pDb uintptr) { /* tclsqlite.c:214:13: */
	var p uintptr
	var pNext uintptr

	for p = (*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob; p != 0; p = pNext {
		pNext = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext

		// Note: Calling unregister here call Tcl_Close on the incrblob channel,
		// which deletes the IncrblobChannel structure at *p. So do not
		// call Tcl_Free() here.
		tcl.XTcl_UnregisterChannel(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel)
	}
}

// Close an incremental blob channel.
func incrblobClose(tls *libc.TLS, instanceData ClientData, interp uintptr) int32 { /* tclsqlite.c:232:26: */
	var p uintptr = instanceData
	var rc int32 = sqlite3.Xsqlite3_blob_close(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	var db uintptr = (*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).Fdb

	// Remove the channel from the SqliteDb.pIncrblob list.
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpNext != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpNext)).FpPrev = (*IncrblobChannel)(unsafe.Pointer(p)).FpPrev
	}
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpPrev != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpPrev)).FpNext = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext
	}
	if (*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).FpIncrblob == p {
		(*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).FpIncrblob = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext
	}

	// Free the IncrblobChannel structure
	tcl.XTcl_Free(tls, p)

	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, db), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

// Read data from an incremental blob channel.
func incrblobInput(tls *libc.TLS, instanceData ClientData, buf uintptr, bufSize int32, errorCodePtr uintptr) int32 { /* tclsqlite.c:264:26: */
	var p uintptr = instanceData
	var nRead int32 = bufSize // Number of bytes to read
	var nBlob int32           // Total size of the blob
	var rc int32              // sqlite error code

	nBlob = sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	if ((*IncrblobChannel)(unsafe.Pointer(p)).FiSeek + nRead) > nBlob {
		nRead = (nBlob - (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek)
	}
	if nRead <= 0 {
		return 0
	}

	rc = sqlite3.Xsqlite3_blob_read(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob, buf, nRead, (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek)
	if rc != SQLITE_OK {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = rc
		return -1
	}

	*(*int32)(unsafe.Pointer(p + 8 /* &.iSeek */)) += (nRead)
	return nRead
}

// Write data to an incremental blob channel.
func incrblobOutput(tls *libc.TLS, instanceData ClientData, buf uintptr, toWrite int32, errorCodePtr uintptr) int32 { /* tclsqlite.c:296:26: */
	var p uintptr = instanceData
	var nWrite int32 = toWrite // Number of bytes to write
	var nBlob int32            // Total size of the blob
	var rc int32               // sqlite error code

	nBlob = sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	if ((*IncrblobChannel)(unsafe.Pointer(p)).FiSeek + nWrite) > nBlob {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = EINVAL
		return -1
	}
	if nWrite <= 0 {
		return 0
	}

	rc = sqlite3.Xsqlite3_blob_write(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob, buf, nWrite, (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek)
	if rc != SQLITE_OK {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = EIO
		return -1
	}

	*(*int32)(unsafe.Pointer(p + 8 /* &.iSeek */)) += (nWrite)
	return nWrite
}

// Seek an incremental blob channel.
func incrblobSeek(tls *libc.TLS, instanceData ClientData, offset int32, seekMode int32, errorCodePtr uintptr) int32 { /* tclsqlite.c:329:26: */
	var p uintptr = instanceData

	switch seekMode {
	case SEEK_SET:
		(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = int32(offset)
		break
	case SEEK_CUR:
		*(*int32)(unsafe.Pointer(p + 8 /* &.iSeek */)) += int32((offset))
		break
	case SEEK_END:
		(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = (int32(int32(sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)) + offset))
		break

	default:
	}

	return (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek
}

func incrblobWatch(tls *libc.TLS, instanceData ClientData, mode int32) { /* tclsqlite.c:355:27: */
	// NO-OP
}

func incrblobHandle(tls *libc.TLS, instanceData ClientData, dir int32, hPtr uintptr) int32 { /* tclsqlite.c:361:26: */
	return TCL_ERROR
}

var IncrblobChannelType = Tcl_ChannelType{
	FtypeName:      ts + 10524,   /* "incrblob" */ // typeName
	Fversion:       uintptr(0x2), // version
	FcloseProc:     0,            // closeProc
	FinputProc:     0,            // inputProc
	FoutputProc:    0,            // outputProc
	FseekProc:      0,            // getOptionProc
	FwatchProc:     0,            // watchProc (this is a no-op)
	FgetHandleProc: 0,            // wideSeekProc
} /* tclsqlite.c:369:24 */

// Create a new incrblob channel.
func createIncrblobChannel(tls *libc.TLS, interp uintptr, pDb uintptr, zDb uintptr, zTable uintptr, zColumn uintptr, iRow sqlite_int64, isReadonly int32) int32 { /* tclsqlite.c:390:12: */
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var p uintptr
	var db uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Fdb
	// var pBlob uintptr at bp+8, 4

	var rc int32
	var flags int32 = ((int32(1) << 1) | (func() int32 {
		if isReadonly != 0 {
			return 0
		}
		return (int32(1) << 2)
	}()))
	// var zChannel [64]int8 at bp+12, 64

	rc = sqlite3.Xsqlite3_blob_open(tls, db, zDb, zTable, zColumn, iRow, libc.BoolInt32(!(isReadonly != 0)), bp+8 /* &pBlob */)
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
		return TCL_ERROR
	}

	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(IncrblobChannel{})))
	(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = 0
	(*IncrblobChannel)(unsafe.Pointer(p)).FpBlob = *(*uintptr)(unsafe.Pointer(bp + 8 /* pBlob */))

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+12 /* &zChannel[0] */, ts+10533 /* "incrblob_%d" */, libc.VaList(bp, libc.PreIncInt32(&count, 1)))
	(*IncrblobChannel)(unsafe.Pointer(p)).Fchannel = tcl.XTcl_CreateChannel(tls, uintptr(unsafe.Pointer(&IncrblobChannelType)), bp+12 /* &zChannel[0] */, p, flags)
	tcl.XTcl_RegisterChannel(tls, interp, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel)

	// Link the new channel into the SqliteDb.pIncrblob list.
	(*IncrblobChannel)(unsafe.Pointer(p)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob
	(*IncrblobChannel)(unsafe.Pointer(p)).FpPrev = uintptr(0)
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpNext != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpNext)).FpPrev = p
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob = p
	(*IncrblobChannel)(unsafe.Pointer(p)).FpDb = pDb

	tcl.XTcl_SetResult(tls, interp, tcl.XTcl_GetChannelName(tls, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel), uintptr(1))
	return TCL_OK
}

var count int32 = 0 /* tclsqlite.c:406:14 */

// Look at the script prefix in pCmd.  We will be executing this script
// after first appending one or more arguments.  This routine analyzes
// the script to see if it is safe to use Tcl_EvalObjv() on the script
// rather than the more general Tcl_EvalEx().  Tcl_EvalObjv() is much
// faster.
//
// Scripts that are safe to use with Tcl_EvalObjv() consists of a
// command name followed by zero or more arguments with no [...] or $
// or {...} or ; to be seen anywhere.  Most callback scripts consist
// of just a single procedure name and they meet this requirement.
func safeToUseEvalObjv(tls *libc.TLS, interp uintptr, pCmd uintptr) int32 { /* tclsqlite.c:451:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// We could try to do something with Tcl_Parse().  But we will instead
	// just do a search for forbidden characters.  If any of the forbidden
	// characters appear in pCmd, we will report the string as unsafe.
	var z uintptr
	// var n int32 at bp, 4

	z = tcl.XTcl_GetStringFromObj(tls, pCmd, bp /* &n */)
	for libc.PostDecInt32(&*(*int32)(unsafe.Pointer(bp /* n */)), 1) > 0 {
		var c int32 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
		if ((c == '$') || (c == '[')) || (c == ';') {
			return 0
		}
	}
	return 1
}

// Find an SqlFunc structure with the given name.  Or create a new
// one if an existing one cannot be found.  Return a pointer to the
// structure.
func findSqlFunc(tls *libc.TLS, pDb uintptr, zName uintptr) uintptr { /* tclsqlite.c:471:16: */
	var p uintptr
	var pNew uintptr
	var nName int32 = strlen30(tls, zName)
	pNew = tcl.XTcl_Alloc(tls, ((uint32(unsafe.Sizeof(SqlFunc{})) + uint32(nName)) + uint32(1)))
	(*SqlFunc)(unsafe.Pointer(pNew)).FzName = (pNew + 1*28)
	libc.Xmemcpy(tls, (*SqlFunc)(unsafe.Pointer(pNew)).FzName, zName, (uint32(nName + 1)))
	for p = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc; p != 0; p = (*SqlFunc)(unsafe.Pointer(p)).FpNext {
		if sqlite3.Xsqlite3_stricmp(tls, (*SqlFunc)(unsafe.Pointer(p)).FzName, (*SqlFunc)(unsafe.Pointer(pNew)).FzName) == 0 {
			tcl.XTcl_Free(tls, pNew)
			return p
		}
	}
	(*SqlFunc)(unsafe.Pointer(pNew)).Finterp = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp
	(*SqlFunc)(unsafe.Pointer(pNew)).FpDb = pDb
	(*SqlFunc)(unsafe.Pointer(pNew)).FpScript = uintptr(0)
	(*SqlFunc)(unsafe.Pointer(pNew)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc
	(*SqliteDb)(unsafe.Pointer(pDb)).FpFunc = pNew
	return pNew
}

// Free a single SqlPreparedStmt object.
func dbFreeStmt(tls *libc.TLS, pStmt uintptr) { /* tclsqlite.c:494:13: */
	if sqlite3.Xsqlite3_sql(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FpStmt) == uintptr(0) {
		tcl.XTcl_Free(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FzSql)
	}
	sqlite3.Xsqlite3_finalize(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FpStmt)
	tcl.XTcl_Free(tls, pStmt)
}

// Finalize and free a list of prepared statements
func flushStmtCache(tls *libc.TLS, pDb uintptr) { /* tclsqlite.c:507:13: */
	var pPreStmt uintptr
	var pNext uintptr

	for pPreStmt = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList; pPreStmt != 0; pPreStmt = pNext {
		pNext = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
		dbFreeStmt(tls, pPreStmt)
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt = 0
	(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = uintptr(0)
	(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = uintptr(0)
}

// TCL calls this procedure when an sqlite3 database command is
// deleted.
func DbDeleteCmd(tls *libc.TLS, db uintptr) { /* tclsqlite.c:524:27: */
	var pDb uintptr = db
	flushStmtCache(tls, pDb)
	closeIncrblobChannels(tls, pDb)
	sqlite3.Xsqlite3_close(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	for (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc != 0 {
		var pFunc uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc
		(*SqliteDb)(unsafe.Pointer(pDb)).FpFunc = (*SqlFunc)(unsafe.Pointer(pFunc)).FpNext

		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*SqlFunc)(unsafe.Pointer(pFunc)).FpScript
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		tcl.XTcl_Free(tls, pFunc)
	}
	for (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate != 0 {
		var pCollate uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate
		(*SqliteDb)(unsafe.Pointer(pDb)).FpCollate = (*SqlCollate)(unsafe.Pointer(pCollate)).FpNext
		tcl.XTcl_Free(tls, pCollate)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzNull != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook != 0 {
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook != 0 {
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook != 0 {
		for ok4 := true; ok4; ok4 = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded != 0 {
		for ok5 := true; ok5; ok5 = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	tcl.XTcl_Free(tls, pDb)
}

// This routine is called when a database file is locked while trying
// to execute SQL.
func DbBusyHandler(tls *libc.TLS, cd uintptr, nTries int32) int32 { /* tclsqlite.c:584:12: */
	bp := tls.Alloc(70)
	defer tls.Free(70)

	var pDb uintptr = cd
	var rc int32
	// var zVal [30]int8 at bp+40, 30

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+40 /* &zVal[0] */, ts+1238 /* "%d" */, libc.VaList(bp, nTries))
	rc = tcl.XTcl_VarEval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, libc.VaList(bp+8, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, ts+4755 /* " " */, bp+40 /* &zVal[0] */, uintptr(0)))
	if (rc != TCL_OK) || (libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0) {
		return 0
	}
	return 1
}

// This routine is invoked as the 'progress callback' for the database.
func DbProgressHandler(tls *libc.TLS, cd uintptr) int32 { /* tclsqlite.c:601:12: */
	var pDb uintptr = cd
	var rc int32

	rc = tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress)
	if (rc != TCL_OK) || (libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0) {
		return 1
	}
	return 0
}

// This routine is called by the SQLite trace handler whenever a new
// block of SQL is executed.  The TCL script in pDb->zTrace is executed.
func DbTraceHandler(tls *libc.TLS, cd uintptr, zSql uintptr) { /* tclsqlite.c:620:13: */
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var pDb uintptr = cd
	// var str Tcl_DString at bp, 212

	tcl.XTcl_DStringInit(tls, bp /* &str */)
	tcl.XTcl_DStringAppend(tls, bp /* &str */, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, -1)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, zSql)
	tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp /* &str */)).Fstring)
	tcl.XTcl_DStringFree(tls, bp /* &str */)
	tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
}

// This routine is called by the SQLite trace_v2 handler whenever a new
// supported event is generated.  Unsupported event types are ignored.
// The TCL script in pDb->zTraceV2 is executed, with the arguments for
// the event appended to it (as list elements).
func DbTraceV2Handler(tls *libc.TLS, type1 uint32, cd uintptr, pd uintptr, xd uintptr) int32 { /* tclsqlite.c:640:12: */
	var pDb uintptr = cd
	var pCmd uintptr

	switch type1 {
	case uint32(SQLITE_TRACE_STMT):
		{
			var pStmt uintptr = pd
			var zSql uintptr = xd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewStringObj(tls, zSql, -1))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	case uint32(SQLITE_TRACE_PROFILE):
		{
			var pStmt uintptr = pd
			var ns sqlite3_int64 = *(*sqlite3_int64)(unsafe.Pointer(xd))

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, ns))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for ok1 := true; ok1; ok1 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	case uint32(SQLITE_TRACE_ROW):
		{
			var pStmt uintptr = pd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for ok2 := true; ok2; ok2 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	case uint32(SQLITE_TRACE_CLOSE):
		{
			var db uintptr = pd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(db)))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for ok3 := true; ok3; ok3 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	}
	return SQLITE_OK
}

// This routine is called by the SQLite profile handler after a statement
// SQL has executed.  The TCL script in pDb->zProfile is evaluated.
func DbProfileHandler(tls *libc.TLS, cd uintptr, zSql uintptr, tm1 sqlite_uint64) { /* tclsqlite.c:715:13: */
	bp := tls.Alloc(320)
	defer tls.Free(320)

	var pDb uintptr = cd
	// var str Tcl_DString at bp+108, 212

	// var zTm [100]int8 at bp+8, 100

	sqlite3.Xsqlite3_snprintf(tls, (int32(uint32(unsafe.Sizeof([100]int8{})) - uint32(1))), bp+8 /* &zTm[0] */, ts+10545 /* "%lld" */, libc.VaList(bp, tm1))
	tcl.XTcl_DStringInit(tls, bp+108 /* &str */)
	tcl.XTcl_DStringAppend(tls, bp+108 /* &str */, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, -1)
	tcl.XTcl_DStringAppendElement(tls, bp+108 /* &str */, zSql)
	tcl.XTcl_DStringAppendElement(tls, bp+108 /* &str */, bp+8 /* &zTm[0] */)
	tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp+108 /* &str */)).Fstring)
	tcl.XTcl_DStringFree(tls, bp+108 /* &str */)
	tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
}

// This routine is called when a transaction is committed.  The
// TCL script in pDb->zCommit is executed.  If it returns non-zero or
// if it throws an exception, the transaction is rolled back instead
// of being committed.
func DbCommitHandler(tls *libc.TLS, cd uintptr) int32 { /* tclsqlite.c:737:12: */
	var pDb uintptr = cd
	var rc int32

	rc = tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit)
	if (rc != TCL_OK) || (libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0) {
		return 1
	}
	return 0
}

func DbRollbackHandler(tls *libc.TLS, clientData uintptr) { /* tclsqlite.c:748:13: */
	var pDb uintptr = clientData

	if TCL_OK != tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook, 0) {
		tcl.XTcl_BackgroundError(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	}
}

// This procedure handles wal_hook callbacks.
func DbWalHandler(tls *libc.TLS, clientData uintptr, db uintptr, zDb uintptr, nEntry int32) int32 { /* tclsqlite.c:759:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* ret */)) = SQLITE_OK
	var p uintptr
	var pDb uintptr = clientData
	var interp uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp

	p = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook)
	(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, p, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, p, tcl.XTcl_NewIntObj(tls, nEntry))
	if (TCL_OK != tcl.XTcl_EvalObjEx(tls, interp, p, 0)) ||
		(TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, tcl.XTcl_GetObjResult(tls, interp), bp /* &ret */)) {
		tcl.XTcl_BackgroundError(tls, interp)
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = p
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* ret */))
}

func setTestUnlockNotifyVars(tls *libc.TLS, interp uintptr, iArg int32, nArg int32) { /* tclsqlite.c:787:13: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var zBuf [64]int8 at bp+16, 64

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+16 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp, iArg))
	tcl.XTcl_SetVar2(tls, interp, ts+10550 /* "sqlite_unlock_no..." */, uintptr(0), bp+16 /* &zBuf[0] */, TCL_GLOBAL_ONLY)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+16 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+8, nArg))
	tcl.XTcl_SetVar2(tls, interp, ts+10575 /* "sqlite_unlock_no..." */, uintptr(0), bp+16 /* &zBuf[0] */, TCL_GLOBAL_ONLY)
}

func DbUnlockNotify(tls *libc.TLS, apArg uintptr, nArg int32) { /* tclsqlite.c:799:13: */
	var i int32
	for i = 0; i < nArg; i++ {
		var flags int32 = (TCL_EVAL_GLOBAL | TCL_EVAL_DIRECT)
		var pDb uintptr = *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*4))
		setTestUnlockNotifyVars(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, i, nArg)

		tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify, flags)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = uintptr(0)
	}
}

// Pre-update hook callback.
func DbPreUpdateHandler(tls *libc.TLS, p uintptr, db uintptr, op int32, zDb uintptr, zTbl uintptr, iKey1 sqlite_int64, iKey2 sqlite_int64) { /* tclsqlite.c:817:13: */
	var pDb uintptr = p
	var pCmd uintptr

	pCmd = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, azStr[((op-1)/9)], -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zTbl, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewWideIntObj(tls, iKey1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewWideIntObj(tls, iKey2))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

var azStr = [3]uintptr{ts + 10605 /* "DELETE" */, ts + 10612 /* "INSERT" */, ts + 10619 /* "UPDATE" */} /* tclsqlite.c:828:21 */

func DbUpdateHandler(tls *libc.TLS, p uintptr, op int32, zDb uintptr, zTbl uintptr, rowid sqlite_int64) { /* tclsqlite.c:849:13: */
	var pDb uintptr = p
	var pCmd uintptr

	pCmd = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, azStr1[((op-1)/9)], -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zTbl, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewWideIntObj(tls, rowid))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

var azStr1 = [3]uintptr{ts + 10605 /* "DELETE" */, ts + 10612 /* "INSERT" */, ts + 10619 /* "UPDATE" */} /* tclsqlite.c:858:21 */

func tclCollateNeeded(tls *libc.TLS, pCtx uintptr, db uintptr, enc int32, zName uintptr) { /* tclsqlite.c:877:13: */
	var pDb uintptr = pCtx
	var pScript uintptr = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zName, -1))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pScript, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

// This routine is called to evaluate an SQL collation function implemented
// using TCL script.
func tclSqlCollate(tls *libc.TLS, pCtx uintptr, nA int32, zA uintptr, nB int32, zB uintptr) int32 { /* tclsqlite.c:895:12: */
	var p uintptr = pCtx
	var pCmd uintptr

	pCmd = tcl.XTcl_NewStringObj(tls, (*SqlCollate)(unsafe.Pointer(p)).FzScript, -1)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, tcl.XTcl_NewStringObj(tls, zA, nA))
	tcl.XTcl_ListObjAppendElement(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, tcl.XTcl_NewStringObj(tls, zB, nB))
	tcl.XTcl_EvalObjEx(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, TCL_EVAL_DIRECT)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp))
}

// This routine is called to evaluate an SQL function implemented
// using TCL script.
func tclSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* tclsqlite.c:918:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var p uintptr = sqlite3.Xsqlite3_user_data(tls, context)
	var pCmd uintptr
	var i int32
	var rc int32

	if argc == 0 {
		// If there are no arguments to the function, call Tcl_EvalObjEx on the
		// script object directly.  This allows the TCL compiler to generate
		// bytecode for the command on the first invocation and thus make
		// subsequent invocations much faster.
		pCmd = (*SqlFunc)(unsafe.Pointer(p)).FpScript
		(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
		rc = tcl.XTcl_EvalObjEx(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, 0)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pCmd
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	} else {
		// If there are arguments to the function, make a shallow copy of the
		// script object, lappend the arguments, then evaluate the copy.
		//
		// By "shallow" copy, we mean only the outer list Tcl_Obj is duplicated.
		// The new Tcl_Obj contains pointers to the original list elements.
		// That way, when Tcl_EvalObjv() is run and shimmers the first element
		// of the list to tclCmdNameType, that alternate representation will
		// be preserved and reused on the next invocation.
		// var aArg uintptr at bp+4, 4

		// var nArg int32 at bp, 4

		if tcl.XTcl_ListObjGetElements(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, (*SqlFunc)(unsafe.Pointer(p)).FpScript, bp /* &nArg */, bp+4 /* &aArg */) != 0 {
			sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
			return
		}
		pCmd = tcl.XTcl_NewListObj(tls, *(*int32)(unsafe.Pointer(bp /* nArg */)), *(*uintptr)(unsafe.Pointer(bp + 4 /* aArg */)))
		(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
		for i = 0; i < argc; i++ {
			var pIn uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))
			var pVal uintptr

			// Set pVal to contain the i'th column of this row.
			switch sqlite3.Xsqlite3_value_type(tls, pIn) {
			case SQLITE_BLOB:
				{
					var bytes int32 = sqlite3.Xsqlite3_value_bytes(tls, pIn)
					pVal = tcl.XTcl_NewByteArrayObj(tls, sqlite3.Xsqlite3_value_blob(tls, pIn), bytes)
					break

				}
				fallthrough
			case SQLITE_INTEGER:
				{
					var v sqlite_int64 = sqlite3.Xsqlite3_value_int64(tls, pIn)
					if (v >= int64(-2147483647)) && (v <= int64(2147483647)) {
						pVal = tcl.XTcl_NewIntObj(tls, int32(v))
					} else {
						pVal = tcl.XTcl_NewWideIntObj(tls, v)
					}
					break

				}
				fallthrough
			case SQLITE_FLOAT:
				{
					var r float64 = sqlite3.Xsqlite3_value_double(tls, pIn)
					pVal = tcl.XTcl_NewDoubleObj(tls, r)
					break

				}
				fallthrough
			case SQLITE_NULL:
				{
					pVal = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer((*SqlFunc)(unsafe.Pointer(p)).FpDb)).FzNull, -1)
					break

				}
				fallthrough
			default:
				{
					var bytes int32 = sqlite3.Xsqlite3_value_bytes(tls, pIn)
					pVal = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, pIn), bytes)
					break

				}
			}
			rc = tcl.XTcl_ListObjAppendElement(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, pVal)
			if rc != 0 {
				for ok1 := true; ok1; ok1 = 0 != 0 {
					var _objPtr uintptr = pCmd
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
				return
			}
		}
		if !((*SqlFunc)(unsafe.Pointer(p)).FuseEvalObjv != 0) {
			// Tcl_EvalObjEx() will automatically call Tcl_EvalObjv() if pCmd
			// is a list without a string representation.  To prevent this from
			// happening, make sure pCmd has a valid string representation
			tcl.XTcl_GetString(tls, pCmd)
		}
		rc = tcl.XTcl_EvalObjEx(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, TCL_EVAL_DIRECT)
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = pCmd
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	if (rc != 0) && (rc != TCL_RETURN) {
		sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
	} else {
		var pVar uintptr = tcl.XTcl_GetObjResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp)
		// var n int32 at bp+8, 4

		var data uintptr
		var zType uintptr = func() uintptr {
			if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
				return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
			}
			return ts + 489 /* "" */
		}()
		var c int8 = *(*int8)(unsafe.Pointer(zType))
		var eType int32 = (*SqlFunc)(unsafe.Pointer(p)).FeType

		if eType == SQLITE_NULL {
			if ((int32(c) == 'b') && (libc.Xstrcmp(tls, zType, ts+2405 /* "bytearray" */) == 0)) && ((*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0)) {
				// Only return a BLOB type if the Tcl variable is a bytearray and
				// has no string representation.
				eType = SQLITE_BLOB
			} else if (((int32(c) == 'b') && (libc.Xstrcmp(tls, zType, ts+2415 /* "boolean" */) == 0)) ||
				((int32(c) == 'w') && (libc.Xstrcmp(tls, zType, ts+2430 /* "wideInt" */) == 0))) ||
				((int32(c) == 'i') && (libc.Xstrcmp(tls, zType, ts+2438 /* "int" */) == 0)) {
				eType = SQLITE_INTEGER
			} else if (int32(c) == 'd') && (libc.Xstrcmp(tls, zType, ts+2423 /* "double" */) == 0) {
				eType = SQLITE_FLOAT
			} else {
				eType = SQLITE_TEXT
			}
		}

		switch eType {
		case SQLITE_BLOB:
			{
				data = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+8 /* &n */)
				sqlite3.Xsqlite3_result_blob(tls, context, data, *(*int32)(unsafe.Pointer(bp + 8 /* n */)), libc.UintptrFromInt32(-1))
				break

			}
			fallthrough
		case SQLITE_INTEGER:
			{
				// var v Tcl_WideInt at bp+16, 8

				if TCL_OK == tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), pVar, bp+16 /* &v */) {
					sqlite3.Xsqlite3_result_int64(tls, context, *(*Tcl_WideInt)(unsafe.Pointer(bp + 16 /* v */)))
					break
				}
				// fall-through

			}
			fallthrough
		case SQLITE_FLOAT:
			{
				// var r float64 at bp+24, 8

				if TCL_OK == tcl.XTcl_GetDoubleFromObj(tls, uintptr(0), pVar, bp+24 /* &r */) {
					sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 24 /* r */)))
					break
				}
				// fall-through

			}
			fallthrough
		default:
			{
				data = tcl.XTcl_GetStringFromObj(tls, pVar, bp+8 /* &n */)
				sqlite3.Xsqlite3_result_text(tls, context, data, *(*int32)(unsafe.Pointer(bp + 8 /* n */)), libc.UintptrFromInt32(-1))
				break

			}
		}

	}
}

// This is the authentication function.  It appends the authentication
// type code and the two arguments to zCmd[] then invokes the result
// on the interpreter.  The reply is examined to determine if the
// authentication fails or succeeds.
func auth_callback(tls *libc.TLS, pArg uintptr, code int32, zArg1 uintptr, zArg2 uintptr, zArg3 uintptr, zArg4 uintptr) int32 { /* tclsqlite.c:1069:12: */
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var zCode uintptr
	// var str Tcl_DString at bp, 212

	var rc int32
	var zReply uintptr
	// EVIDENCE-OF: R-38590-62769 The first parameter to the authorizer
	// callback is a copy of the third parameter to the
	// sqlite3_set_authorizer() interface.
	var pDb uintptr = pArg
	if (*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth != 0 {
		return SQLITE_OK
	}

	// EVIDENCE-OF: R-56518-44310 The second parameter to the callback is an
	// integer action code that specifies the particular action to be
	// authorized.
	switch code {
	case SQLITE_COPY:
		zCode = ts + 10626 /* "SQLITE_COPY" */
		break
	case SQLITE_CREATE_INDEX:
		zCode = ts + 10638 /* "SQLITE_CREATE_IN..." */
		break
	case SQLITE_CREATE_TABLE:
		zCode = ts + 10658 /* "SQLITE_CREATE_TA..." */
		break
	case SQLITE_CREATE_TEMP_INDEX:
		zCode = ts + 10678 /* "SQLITE_CREATE_TE..." */
		break
	case SQLITE_CREATE_TEMP_TABLE:
		zCode = ts + 10703 /* "SQLITE_CREATE_TE..." */
		break
	case SQLITE_CREATE_TEMP_TRIGGER:
		zCode = ts + 10728 /* "SQLITE_CREATE_TE..." */
		break
	case SQLITE_CREATE_TEMP_VIEW:
		zCode = ts + 10755 /* "SQLITE_CREATE_TE..." */
		break
	case SQLITE_CREATE_TRIGGER:
		zCode = ts + 10779 /* "SQLITE_CREATE_TR..." */
		break
	case SQLITE_CREATE_VIEW:
		zCode = ts + 10801 /* "SQLITE_CREATE_VI..." */
		break
	case SQLITE_DELETE:
		zCode = ts + 10820 /* "SQLITE_DELETE" */
		break
	case SQLITE_DROP_INDEX:
		zCode = ts + 10834 /* "SQLITE_DROP_INDE..." */
		break
	case SQLITE_DROP_TABLE:
		zCode = ts + 10852 /* "SQLITE_DROP_TABL..." */
		break
	case SQLITE_DROP_TEMP_INDEX:
		zCode = ts + 10870 /* "SQLITE_DROP_TEMP..." */
		break
	case SQLITE_DROP_TEMP_TABLE:
		zCode = ts + 10893 /* "SQLITE_DROP_TEMP..." */
		break
	case SQLITE_DROP_TEMP_TRIGGER:
		zCode = ts + 10916 /* "SQLITE_DROP_TEMP..." */
		break
	case SQLITE_DROP_TEMP_VIEW:
		zCode = ts + 10941 /* "SQLITE_DROP_TEMP..." */
		break
	case SQLITE_DROP_TRIGGER:
		zCode = ts + 10963 /* "SQLITE_DROP_TRIG..." */
		break
	case SQLITE_DROP_VIEW:
		zCode = ts + 10983 /* "SQLITE_DROP_VIEW" */
		break
	case SQLITE_INSERT:
		zCode = ts + 11000 /* "SQLITE_INSERT" */
		break
	case SQLITE_PRAGMA:
		zCode = ts + 11014 /* "SQLITE_PRAGMA" */
		break
	case SQLITE_READ:
		zCode = ts + 11028 /* "SQLITE_READ" */
		break
	case SQLITE_SELECT:
		zCode = ts + 11040 /* "SQLITE_SELECT" */
		break
	case SQLITE_TRANSACTION:
		zCode = ts + 11054 /* "SQLITE_TRANSACTI..." */
		break
	case SQLITE_UPDATE:
		zCode = ts + 11073 /* "SQLITE_UPDATE" */
		break
	case SQLITE_ATTACH:
		zCode = ts + 11087 /* "SQLITE_ATTACH" */
		break
	case SQLITE_DETACH:
		zCode = ts + 11101 /* "SQLITE_DETACH" */
		break
	case SQLITE_ALTER_TABLE:
		zCode = ts + 11115 /* "SQLITE_ALTER_TAB..." */
		break
	case SQLITE_REINDEX:
		zCode = ts + 11134 /* "SQLITE_REINDEX" */
		break
	case SQLITE_ANALYZE:
		zCode = ts + 11149 /* "SQLITE_ANALYZE" */
		break
	case SQLITE_CREATE_VTABLE:
		zCode = ts + 11164 /* "SQLITE_CREATE_VT..." */
		break
	case SQLITE_DROP_VTABLE:
		zCode = ts + 11185 /* "SQLITE_DROP_VTAB..." */
		break
	case SQLITE_FUNCTION:
		zCode = ts + 11204 /* "SQLITE_FUNCTION" */
		break
	case SQLITE_SAVEPOINT:
		zCode = ts + 11220 /* "SQLITE_SAVEPOINT" */
		break
	case SQLITE_RECURSIVE:
		zCode = ts + 11237 /* "SQLITE_RECURSIVE" */
		break
	default:
		zCode = ts + 11254 /* "????" */
		break
	}
	tcl.XTcl_DStringInit(tls, bp /* &str */)
	tcl.XTcl_DStringAppend(tls, bp /* &str */, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, -1)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, zCode)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg1 != 0 {
			return zArg1
		}
		return ts + 489 /* "" */
	}())
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg2 != 0 {
			return zArg2
		}
		return ts + 489 /* "" */
	}())
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg3 != 0 {
			return zArg3
		}
		return ts + 489 /* "" */
	}())
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg4 != 0 {
			return zArg4
		}
		return ts + 489 /* "" */
	}())
	rc = tcl.XTcl_GlobalEval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp /* &str */)).Fstring)
	tcl.XTcl_DStringFree(tls, bp /* &str */)
	if rc == TCL_OK {
		zReply = tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	} else {
		zReply = ts + 11259 /* "SQLITE_DENY" */
	}
	if libc.Xstrcmp(tls, zReply, ts+1988 /* "SQLITE_OK" */) == 0 {
		rc = SQLITE_OK
	} else if libc.Xstrcmp(tls, zReply, ts+11259 /* "SQLITE_DENY" */) == 0 {
		rc = SQLITE_DENY
	} else if libc.Xstrcmp(tls, zReply, ts+11271 /* "SQLITE_IGNORE" */) == 0 {
		rc = SQLITE_IGNORE
	} else {
		rc = 999
	}
	return rc
}

// This routine reads a line of text from FILE in, stores
// the text in memory obtained from malloc() and returns a pointer
// to the text.  NULL is returned at end of file, or if malloc()
// fails.
//
// The interface is like "readline" but no command-line editing
// is done.
//
// copied from shell.c from '.import' command
func local_getline(tls *libc.TLS, zPrompt uintptr, in uintptr) uintptr { /* tclsqlite.c:1168:13: */
	var zLine uintptr
	var nLine int32
	var n int32

	nLine = 100
	zLine = libc.Xmalloc(tls, uint32(nLine))
	if zLine == uintptr(0) {
		return uintptr(0)
	}
	n = 0
	for 1 != 0 {
		if (n + 100) > nLine {
			nLine = ((nLine * 2) + 100)
			zLine = libc.Xrealloc(tls, zLine, uint32(nLine))
			if zLine == uintptr(0) {
				return uintptr(0)
			}
		}
		if libc.Xfgets(tls, (zLine+uintptr(n)), (nLine-n), in) == uintptr(0) {
			if n == 0 {
				libc.Xfree(tls, zLine)
				return uintptr(0)
			}
			*(*int8)(unsafe.Pointer(zLine + uintptr(n))) = int8(0)
			break
		}
		for *(*int8)(unsafe.Pointer(zLine + uintptr(n))) != 0 {
			n++
		}
		if (n > 0) && (int32(*(*int8)(unsafe.Pointer(zLine + uintptr((n - 1))))) == '\n') {
			n--
			*(*int8)(unsafe.Pointer(zLine + uintptr(n))) = int8(0)
			break
		}
	}
	zLine = libc.Xrealloc(tls, zLine, (uint32(n + 1)))
	return zLine
}

// This function is part of the implementation of the command:
//
//   $db transaction [-deferred|-immediate|-exclusive] SCRIPT
//
// It is invoked after evaluating the script SCRIPT to commit or rollback
// the transaction or savepoint opened by the [transaction] command.
func DbTransPostCmd(tls *libc.TLS, data uintptr, interp uintptr, result int32) int32 { /* tclsqlite.c:1211:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pDb uintptr = *(*ClientData)(unsafe.Pointer(data))
	var rc int32 = result
	var zEnd uintptr

	(*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction--
	zEnd = azEnd[(((libc.Bool32(rc == TCL_ERROR)) * 2) + (libc.Bool32((*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction == 0)))]

	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth++
	if sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zEnd, uintptr(0), uintptr(0), uintptr(0)) != 0 {
		// This is a tricky scenario to handle. The most likely cause of an
		// error is that the exec() above was an attempt to commit the
		// top-level transaction that returned SQLITE_BUSY. Or, less likely,
		// that an IO-error has occurred. In either case, throw a Tcl exception
		// and try to rollback the transaction.
		//
		// But it could also be that the user executed one or more BEGIN,
		// COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing
		// this method's logic. Not clear how this would be best handled.
		if rc != TCL_ERROR {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
			rc = TCL_ERROR
		}
		sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, ts+7270 /* "ROLLBACK" */, uintptr(0), uintptr(0), uintptr(0))
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth--

	return rc
}

var azEnd = [4]uintptr{
	ts + 11285, /* "RELEASE _tcl_tra..." */ // rc==TCL_ERROR, nTransaction!=0
	ts + 11310, /* "COMMIT" */              // rc!=TCL_ERROR, nTransaction==0
	ts + 11317, /* "ROLLBACK TO _tcl..." */
	ts + 7270,  /* "ROLLBACK" */ // rc==TCL_ERROR, nTransaction==0
} /* tclsqlite.c:1216:21 */

// Unless SQLITE_TEST is defined, this function is a simple wrapper around
// sqlite3_prepare_v2(). If SQLITE_TEST is defined, then it uses either
// sqlite3_prepare_v2() or legacy interface sqlite3_prepare(), depending
// on whether or not the [db_use_legacy_prepare] command has been used to
// configure the connection.
func dbPrepare(tls *libc.TLS, pDb uintptr, zSql uintptr, ppStmt uintptr, pzOut uintptr) int32 { /* tclsqlite.c:1259:12: */
	var prepFlags uint32 = uint32(0)
	if (*SqliteDb)(unsafe.Pointer(pDb)).FbLegacyPrepare != 0 {
		return sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, ppStmt, pzOut)
	}
	// If the statement cache is large, use the SQLITE_PREPARE_PERSISTENT
	// flags, which uses less lookaside memory.  But if the cache is small,
	// omit that flag to make full use of lookaside
	if (*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt > 5 {
		prepFlags = uint32(SQLITE_PREPARE_PERSISTENT)
	}

	return sqlite3.Xsqlite3_prepare_v3(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, prepFlags, ppStmt, pzOut)
}

// Search the cache for a prepared-statement object that implements the
// first SQL statement in the buffer pointed to by parameter zIn. If
// no such prepared-statement can be found, allocate and prepare a new
// one. In either case, bind the current values of the relevant Tcl
// variables to any $var, :var or @var variables in the statement. Before
// returning, set *ppPreStmt to point to the prepared-statement object.
//
// Output parameter *pzOut is set to point to the next SQL statement in
// buffer zIn, or to the '\0' byte at the end of zIn if there is no
// next statement.
//
// If successful, TCL_OK is returned. Otherwise, TCL_ERROR is returned
// and an error message loaded into interpreter pDb->interp.
func dbPrepareAndBind(tls *libc.TLS, pDb uintptr, zIn uintptr, pzOut uintptr, ppPreStmt uintptr) int32 { /* tclsqlite.c:1294:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zSql uintptr = zIn                                   // Pointer to first SQL statement in zIn
	*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0) // Prepared statement object
	var pPreStmt uintptr                                     // Pointer to cached statement
	var nSql int32                                           // Length of zSql in bytes
	var nVar int32 = 0                                       // Number of variables in statement
	var iParm int32 = 0                                      // Next free entry in apParm
	var c int8
	var i int32
	var needResultReset int32 = 0 // Need to invoke Tcl_ResetResult()
	var rc int32 = SQLITE_OK      // Value to return
	var interp uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp

	*(*uintptr)(unsafe.Pointer(ppPreStmt)) = uintptr(0)

	// Trim spaces from the start of zSql and calculate the remaining length.
	for ((((int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer(zSql))))) == ' ') || (int32(c) == '\t')) || (int32(c) == '\r')) || (int32(c) == '\n') {
		zSql++
	}
	nSql = strlen30(tls, zSql)

	for pPreStmt = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList; pPreStmt != 0; pPreStmt = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext {
		var n int32 = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql
		if ((nSql >= n) &&
			(libc.Xmemcmp(tls, (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql, zSql, uint32(n)) == 0)) &&
			((int32(*(*int8)(unsafe.Pointer(zSql + uintptr(n)))) == 0) || (int32(*(*int8)(unsafe.Pointer(zSql + uintptr((n - 1))))) == ';')) {
			*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt
			*(*uintptr)(unsafe.Pointer(pzOut)) = (zSql + uintptr((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))

			// When a prepared statement is found, unlink it from the
			// cache list.  It will later be added back to the beginning
			// of the cache list in order to implement LRU replacement.
			if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev != 0 {
				(*SqlPreparedStmt)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev)).FpNext = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
			} else {
				(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
			}
			if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext != 0 {
				(*SqlPreparedStmt)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext)).FpPrev = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev
			} else {
				(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev
			}
			(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt--
			nVar = sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
			break
		}
	}

	// If no prepared statement was found. Compile the SQL text. Also allocate
	// a new SqlPreparedStmt structure.
	if pPreStmt == uintptr(0) {
		var nByte int32

		if SQLITE_OK != dbPrepare(tls, pDb, zSql, bp /* &pStmt */, pzOut) {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
			return TCL_ERROR
		}
		if *(*uintptr)(unsafe.Pointer(bp /* pStmt */)) == uintptr(0) {
			if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb) {
				// A compile-time error in the statement.
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
				return TCL_ERROR
			} else {
				// The statement was a no-op.  Continue to the next statement
				// in the SQL string.
				return TCL_OK
			}
		}

		nVar = sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
		nByte = (int32(uint32(unsafe.Sizeof(SqlPreparedStmt{})) + (uint32(nVar) * uint32(unsafe.Sizeof(uintptr(0))))))
		pPreStmt = tcl.XTcl_Alloc(tls, uint32(nByte))
		libc.Xmemset(tls, pPreStmt, 0, uint32(nByte))

		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt = *(*uintptr)(unsafe.Pointer(bp /* pStmt */))
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql = ((int32(*(*uintptr)(unsafe.Pointer(pzOut))) - int32(zSql)) / 1)
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql = sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm = (pPreStmt + 1*28)
		if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql == uintptr(0) {
			var zCopy uintptr = tcl.XTcl_Alloc(tls, (uint32((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql + 1)))
			libc.Xmemcpy(tls, zCopy, zSql, uint32((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))
			*(*int8)(unsafe.Pointer(zCopy + uintptr((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))) = int8(0)
			(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql = zCopy
		}
	}

	// Bind values to parameters that begin with $ or :
	for i = 1; i <= nVar; i++ {
		var zVar uintptr = sqlite3.Xsqlite3_bind_parameter_name(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i)
		if (zVar != uintptr(0)) && (((int32(*(*int8)(unsafe.Pointer(zVar))) == '$') || (int32(*(*int8)(unsafe.Pointer(zVar))) == ':')) || (int32(*(*int8)(unsafe.Pointer(zVar))) == '@')) {
			var pVar uintptr = tcl.XTcl_GetVar2Ex(tls, interp, (zVar + 1), uintptr(0), 0)
			if (pVar == uintptr(0)) && ((*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != uintptr(0)) {
				var pCmd uintptr
				var rx int32
				pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, -1)
				(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
				tcl.XTcl_ListObjAppendElement(tls, interp, pCmd, tcl.XTcl_NewStringObj(tls, zVar, -1))
				if needResultReset != 0 {
					tcl.XTcl_ResetResult(tls, interp)
				}
				needResultReset = 1
				rx = tcl.XTcl_EvalObjEx(tls, interp, pCmd, TCL_EVAL_DIRECT)
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = pCmd
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				if rx == TCL_OK {
					pVar = tcl.XTcl_GetObjResult(tls, interp)
				} else if rx == TCL_ERROR {
					rc = TCL_ERROR
					break
				} else {
					pVar = uintptr(0)
				}
			}
			if pVar != 0 {
				// var n int32 at bp+4, 4

				var data uintptr
				var zType uintptr = func() uintptr {
					if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
						return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
					}
					return ts + 489 /* "" */
				}()
				c = *(*int8)(unsafe.Pointer(zType))
				if (int32(*(*int8)(unsafe.Pointer(zVar))) == '@') || (((int32(c) == 'b') && (libc.Xstrcmp(tls, zType, ts+2405 /* "bytearray" */) == 0)) && ((*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0))) {
					// Load a BLOB type if the Tcl variable is a bytearray and
					// it has no string representation or the host
					// parameter name begins with "@".
					data = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+4 /* &n */)
					sqlite3.Xsqlite3_bind_blob(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, data, *(*int32)(unsafe.Pointer(bp + 4 /* n */)), uintptr(0))
					(*Tcl_Obj)(unsafe.Pointer(pVar)).FrefCount++
					*(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(libc.PostIncInt32(&iParm, 1))*4)) = pVar
				} else if (int32(c) == 'b') && (libc.Xstrcmp(tls, zType, ts+2415 /* "boolean" */) == 0) {
					tcl.XTcl_GetIntFromObj(tls, interp, pVar, bp+4 /* &n */)
					sqlite3.Xsqlite3_bind_int(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, *(*int32)(unsafe.Pointer(bp + 4 /* n */)))
				} else if (int32(c) == 'd') && (libc.Xstrcmp(tls, zType, ts+2423 /* "double" */) == 0) {
					// var r float64 at bp+8, 8

					tcl.XTcl_GetDoubleFromObj(tls, interp, pVar, bp+8 /* &r */)
					sqlite3.Xsqlite3_bind_double(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, *(*float64)(unsafe.Pointer(bp + 8 /* r */)))
				} else if ((int32(c) == 'w') && (libc.Xstrcmp(tls, zType, ts+2430 /* "wideInt" */) == 0)) || ((int32(c) == 'i') && (libc.Xstrcmp(tls, zType, ts+2438 /* "int" */) == 0)) {
					// var v Tcl_WideInt at bp+16, 8

					tcl.XTcl_GetWideIntFromObj(tls, interp, pVar, bp+16 /* &v */)
					sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, *(*Tcl_WideInt)(unsafe.Pointer(bp + 16 /* v */)))
				} else {
					data = tcl.XTcl_GetStringFromObj(tls, pVar, bp+4 /* &n */)
					sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, data, *(*int32)(unsafe.Pointer(bp + 4 /* n */)), uintptr(0))
					(*Tcl_Obj)(unsafe.Pointer(pVar)).FrefCount++
					*(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(libc.PostIncInt32(&iParm, 1))*4)) = pVar
				}
			} else {
				sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i)
			}
			if needResultReset != 0 {
				tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			}
		}
	}
	(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm = iParm
	*(*uintptr)(unsafe.Pointer(ppPreStmt)) = pPreStmt
	if (needResultReset != 0) && (rc == TCL_OK) {
		tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	}

	return rc
}

// Release a statement reference obtained by calling dbPrepareAndBind().
// There should be exactly one call to this function for each call to
// dbPrepareAndBind().
//
// If the discard parameter is non-zero, then the statement is deleted
// immediately. Otherwise it is added to the LRU list and may be returned
// by a subsequent call to dbPrepareAndBind().
func dbReleaseStmt(tls *libc.TLS, pDb uintptr, pPreStmt uintptr, discard int32) { /* tclsqlite.c:1470:13: */
	var i int32

	// Free the bound string and blob parameters
	for i = 0; i < (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm; i++ {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(i)*4))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm = 0

	if ((*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt <= 0) || (discard != 0) {
		// If the cache is turned off, deallocated the statement
		dbFreeStmt(tls, pPreStmt)
	} else {
		// Add the prepared statement to the beginning of the cache list.
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev = uintptr(0)
		if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList != 0 {
			(*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtList)).FpPrev = pPreStmt
		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = pPreStmt
		if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast == uintptr(0) {

			(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = pPreStmt
		} else {

		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt++

		// If we have too many statement in cache, remove the surplus from
		// the end of the cache list.
		for (*SqliteDb)(unsafe.Pointer(pDb)).FnStmt > (*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt {
			var pLast uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast
			(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = (*SqlPreparedStmt)(unsafe.Pointer(pLast)).FpPrev
			(*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast)).FpNext = uintptr(0)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt--
			dbFreeStmt(tls, pLast)
		}
	}
}

// Structure used with dbEvalXXX() functions:
//
//   dbEvalInit()
//   dbEvalStep()
//   dbEvalFinalize()
//   dbEvalRowInfo()
//   dbEvalColumnValue()
type DbEvalContext1 = struct {
	FpDb       uintptr
	FpSql      uintptr
	FzSql      uintptr
	FpPreStmt  uintptr
	FnCol      int32
	FevalFlags int32
	FpArray    uintptr
	FapColName uintptr
} /* tclsqlite.c:1523:9 */

// Structure used with dbEvalXXX() functions:
//
//   dbEvalInit()
//   dbEvalStep()
//   dbEvalFinalize()
//   dbEvalRowInfo()
//   dbEvalColumnValue()
type DbEvalContext = DbEvalContext1 /* tclsqlite.c:1523:30 */

// Release any cache of column names currently held as part of
// the DbEvalContext structure passed as the first argument.
func dbReleaseColumnNames(tls *libc.TLS, p uintptr) { /* tclsqlite.c:1541:13: */
	if (*DbEvalContext)(unsafe.Pointer(p)).FapColName != 0 {
		var i int32
		for i = 0; i < (*DbEvalContext)(unsafe.Pointer(p)).FnCol; i++ {
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = *(*uintptr)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FapColName + uintptr(i)*4))
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		tcl.XTcl_Free(tls, (*DbEvalContext)(unsafe.Pointer(p)).FapColName)
		(*DbEvalContext)(unsafe.Pointer(p)).FapColName = uintptr(0)
	}
	(*DbEvalContext)(unsafe.Pointer(p)).FnCol = 0
}

// Initialize a DbEvalContext structure.
//
// If pArray is not NULL, then it contains the name of a Tcl array
// variable. The "*" member of this array is set to a list containing
// the names of the columns returned by the statement as part of each
// call to dbEvalStep(), in order from left to right. e.g. if the names
// of the returned columns are a, b and c, it does the equivalent of the
// tcl command:
//
//     set ${pArray}(*) {a b c}
func dbEvalInit(tls *libc.TLS, p uintptr, pDb uintptr, pSql uintptr, pArray uintptr, evalFlags int32) { /* tclsqlite.c:1565:13: */
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(DbEvalContext{})))
	(*DbEvalContext)(unsafe.Pointer(p)).FpDb = pDb
	(*DbEvalContext)(unsafe.Pointer(p)).FzSql = tcl.XTcl_GetString(tls, pSql)
	(*DbEvalContext)(unsafe.Pointer(p)).FpSql = pSql
	(*Tcl_Obj)(unsafe.Pointer(pSql)).FrefCount++
	if pArray != 0 {
		(*DbEvalContext)(unsafe.Pointer(p)).FpArray = pArray
		(*Tcl_Obj)(unsafe.Pointer(pArray)).FrefCount++
	}
	(*DbEvalContext)(unsafe.Pointer(p)).FevalFlags = evalFlags
}

// Obtain information about the row that the DbEvalContext passed as the
// first argument currently points to.
func dbEvalRowInfo(tls *libc.TLS, p uintptr, pnCol uintptr, papColName uintptr) { /* tclsqlite.c:1588:13: */
	// Compute column names
	if uintptr(0) == (*DbEvalContext)(unsafe.Pointer(p)).FapColName {
		var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt
		var i int32                        // Iterator variable
		var nCol int32                     // Number of columns returned by pStmt
		var apColName uintptr = uintptr(0) // Array of column names

		(*DbEvalContext)(unsafe.Pointer(p)).FnCol = libc.AssignInt32(&nCol, sqlite3.Xsqlite3_column_count(tls, pStmt))
		if (nCol > 0) && ((papColName != 0) || ((*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0)) {
			apColName = tcl.XTcl_Alloc(tls, (uint32(unsafe.Sizeof(uintptr(0))) * uint32(nCol)))
			for i = 0; i < nCol; i++ {
				*(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*4)) = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_column_name(tls, pStmt, i), -1)
				(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*4)))).FrefCount++
			}
			(*DbEvalContext)(unsafe.Pointer(p)).FapColName = apColName
		}

		// If results are being stored in an array variable, then create
		// the array(*) entry for that array
		if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
			var interp uintptr = (*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).Finterp
			var pColList uintptr = tcl.XTcl_NewObj(tls)
			var pStar uintptr = tcl.XTcl_NewStringObj(tls, ts+3701 /* "*" */, -1)

			for i = 0; i < nCol; i++ {
				tcl.XTcl_ListObjAppendElement(tls, interp, pColList, *(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*4)))
			}
			(*Tcl_Obj)(unsafe.Pointer(pStar)).FrefCount++
			tcl.XTcl_ObjSetVar2(tls, interp, (*DbEvalContext)(unsafe.Pointer(p)).FpArray, pStar, pColList, 0)
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = pStar
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
	}

	if papColName != 0 {
		*(*uintptr)(unsafe.Pointer(papColName)) = (*DbEvalContext)(unsafe.Pointer(p)).FapColName
	}
	if pnCol != 0 {
		*(*int32)(unsafe.Pointer(pnCol)) = (*DbEvalContext)(unsafe.Pointer(p)).FnCol
	}
}

// Return one of TCL_OK, TCL_BREAK or TCL_ERROR. If TCL_ERROR is
// returned, then an error message is stored in the interpreter before
// returning.
//
// A return value of TCL_OK means there is a row of data available. The
// data may be accessed using dbEvalRowInfo() and dbEvalColumnValue(). This
// is analogous to a return of SQLITE_ROW from sqlite3_step(). If TCL_BREAK
// is returned, then the SQL script has finished executing and there are
// no further rows available. This is similar to SQLITE_DONE.
func dbEvalStep(tls *libc.TLS, p uintptr) int32 { /* tclsqlite.c:1646:12: */
	var zPrevSql uintptr = uintptr(0) // Previous value of p->zSql

	for (*(*int8)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FzSql)) != 0) || ((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt != 0) {
		var rc int32
		if (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt == uintptr(0) {
			zPrevSql = func() uintptr {
				if (*DbEvalContext)(unsafe.Pointer(p)).FzSql == zPrevSql {
					return uintptr(0)
				}
				return (*DbEvalContext)(unsafe.Pointer(p)).FzSql
			}()
			rc = dbPrepareAndBind(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb, (*DbEvalContext)(unsafe.Pointer(p)).FzSql, (p + 8 /* &.zSql */), (p + 12 /* &.pPreStmt */))
			if rc != TCL_OK {
				return rc
			}
		} else {
			var rcs int32
			var pDb uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpDb
			var pPreStmt uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt
			var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt

			rcs = sqlite3.Xsqlite3_step(tls, pStmt)
			if rcs == SQLITE_ROW {
				return TCL_OK
			}
			if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
				dbEvalRowInfo(tls, p, uintptr(0), uintptr(0))
			}
			rcs = sqlite3.Xsqlite3_reset(tls, pStmt)

			(*SqliteDb)(unsafe.Pointer(pDb)).FnStep = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnSort = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_SORT, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnIndex = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_AUTOINDEX, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnVMStep = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_VM_STEP, 1)
			dbReleaseColumnNames(tls, p)
			(*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt = uintptr(0)

			if rcs != SQLITE_OK {
				// If a run-time error occurs, report the error and stop reading
				// the SQL.
				dbReleaseStmt(tls, pDb, pPreStmt, 1)
				if (((*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).FbLegacyPrepare != 0) && (rcs == SQLITE_SCHEMA)) && (zPrevSql != 0) {
					// If the runtime error was an SQLITE_SCHEMA, and the database
					// handle is configured to use the legacy sqlite3_prepare()
					// interface, retry prepare()/step() on the same SQL statement.
					// This only happens once. If there is a second SQLITE_SCHEMA
					// error, the error will be returned to the caller.
					(*DbEvalContext)(unsafe.Pointer(p)).FzSql = zPrevSql
					continue
				}
				tcl.XTcl_SetObjResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp,
					tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
				return TCL_ERROR
			} else {
				dbReleaseStmt(tls, pDb, pPreStmt, 0)
			}
		}
	}

	// Finished
	return TCL_BREAK
}

// Free all resources currently held by the DbEvalContext structure passed
// as the first argument. There should be exactly one call to this function
// for each call to dbEvalInit().
func dbEvalFinalize(tls *libc.TLS, p uintptr) { /* tclsqlite.c:1710:13: */
	if (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt != 0 {
		sqlite3.Xsqlite3_reset(tls, (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt)
		dbReleaseStmt(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb, (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt, 0)
		(*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt = uintptr(0)
	}
	if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpArray
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*DbEvalContext)(unsafe.Pointer(p)).FpArray = uintptr(0)
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpSql
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	dbReleaseColumnNames(tls, p)
}

// Return a pointer to a Tcl_Obj structure with ref-count 0 that contains
// the value for the iCol'th column of the row currently pointed to by
// the DbEvalContext structure passed as the first argument.
func dbEvalColumnValue(tls *libc.TLS, p uintptr, iCol int32) uintptr { /* tclsqlite.c:1729:16: */
	var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt
	switch sqlite3.Xsqlite3_column_type(tls, pStmt, iCol) {
	case SQLITE_BLOB:
		{
			var bytes int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, iCol)
			var zBlob uintptr = sqlite3.Xsqlite3_column_blob(tls, pStmt, iCol)
			if !(zBlob != 0) {
				bytes = 0
			}
			return tcl.XTcl_NewByteArrayObj(tls, zBlob, bytes)

		}
	case SQLITE_INTEGER:
		{
			var v sqlite_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, iCol)
			if (v >= int64(-2147483647)) && (v <= int64(2147483647)) {
				return tcl.XTcl_NewIntObj(tls, int32(v))
			} else {
				return tcl.XTcl_NewWideIntObj(tls, v)
			}

		}
		fallthrough
	case SQLITE_FLOAT:
		{
			return tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_column_double(tls, pStmt, iCol))

		}
	case SQLITE_NULL:
		{
			return tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).FzNull, -1)

		}
	}

	return tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_column_text(tls, pStmt, iCol), -1)
}

// If using Tcl version 8.6 or greater, use the NR functions to avoid
// recursive evalution of scripts by the [db eval] and [db trans]
// commands. Even if the headers used while compiling the extension
// are 8.6 or newer, the code still tests the Tcl version at runtime.
// This allows stubs-enabled builds to be used with older Tcl libraries.
func DbUseNre(tls *libc.TLS) int32 { /* tclsqlite.c:1766:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var major int32 at bp, 4

	// var minor int32 at bp+4, 4

	tcl.XTcl_GetVersion(tls, bp /* &major */, bp+4 /* &minor */, uintptr(0), uintptr(0))
	return (libc.Bool32(((*(*int32)(unsafe.Pointer(bp /* major */)) == 8) && (*(*int32)(unsafe.Pointer(bp + 4 /* minor */)) >= 6)) || (*(*int32)(unsafe.Pointer(bp /* major */)) > 8)))
}

// This function is part of the implementation of the command:
//
//   $db eval SQL ?ARRAYNAME? SCRIPT
func DbEvalNextCmd(tls *libc.TLS, data uintptr, interp uintptr, result int32) int32 { /* tclsqlite.c:1793:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = result // Return code

	// The first element of the data[] array is a pointer to a DbEvalContext
	// structure allocated using Tcl_Alloc(). The second element of data[]
	// is a pointer to a Tcl_Obj containing the script to run for each row
	// returned by the queries encapsulated in data[0].
	var p uintptr = *(*ClientData)(unsafe.Pointer(data))
	var pScript uintptr = *(*ClientData)(unsafe.Pointer(data + 1*4))
	var pArray uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpArray

	for ((rc == TCL_OK) || (rc == TCL_CONTINUE)) && (TCL_OK == (libc.AssignInt32(&rc, dbEvalStep(tls, p)))) {
		var i int32
		// var nCol int32 at bp, 4

		// var apColName uintptr at bp+4, 4

		dbEvalRowInfo(tls, p, bp /* &nCol */, bp+4 /* &apColName */)
		for i = 0; i < *(*int32)(unsafe.Pointer(bp /* nCol */)); i++ {
			if pArray == uintptr(0) {
				tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4 /* apColName */)) + uintptr(i)*4)), uintptr(0), dbEvalColumnValue(tls, p, i), 0)
			} else if (((*DbEvalContext)(unsafe.Pointer(p)).FevalFlags & SQLITE_EVAL_WITHOUTNULLS) != 0) &&
				(sqlite3.Xsqlite3_column_type(tls, (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt, i) == SQLITE_NULL) {
				tcl.XTcl_UnsetVar2(tls, interp, tcl.XTcl_GetString(tls, pArray),
					tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4 /* apColName */)) + uintptr(i)*4))), 0)
			} else {
				tcl.XTcl_ObjSetVar2(tls, interp, pArray, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4 /* apColName */)) + uintptr(i)*4)), dbEvalColumnValue(tls, p, i), 0)
			}
		}

		// The required interpreter variables are now populated with the data
		// from the current row. If using NRE, schedule callbacks to evaluate
		// script pScript, then to invoke this function again to fetch the next
		// row (or clean up if there is no next row or the script throws an
		// exception). After scheduling the callbacks, return control to the
		// caller.
		//
		// If not using NRE, evaluate pScript directly and continue with the
		// next iteration of this while(...) loop.
		if DbUseNre(tls) != 0 {
			tcl.XTcl_NRAddCallback(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			}{DbEvalNextCmd})), p, pScript, uintptr(0), uintptr(0))
			return tcl.XTcl_NREvalObj(tls, interp, pScript, 0)
		} else {
			rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
		}
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	dbEvalFinalize(tls, p)
	tcl.XTcl_Free(tls, p)

	if (rc == TCL_OK) || (rc == TCL_BREAK) {
		tcl.XTcl_ResetResult(tls, interp)
		rc = TCL_OK
	}
	return rc
}

// This function is used by the implementations of the following database
// handle sub-commands:
//
//   $db update_hook ?SCRIPT?
//   $db wal_hook ?SCRIPT?
//   $db commit_hook ?SCRIPT?
//   $db preupdate hook ?SCRIPT?
func DbHookCmd(tls *libc.TLS, interp uintptr, pDb uintptr, pArg uintptr, ppHook uintptr) { /* tclsqlite.c:1863:13: */
	var db uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Fdb

	if *(*uintptr)(unsafe.Pointer(ppHook)) != 0 {
		tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(ppHook)))
		if pArg != 0 {
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(ppHook))
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			*(*uintptr)(unsafe.Pointer(ppHook)) = uintptr(0)
		}
	}
	if pArg != 0 {

		if tcl.XTcl_GetCharLength(tls, pArg) > 0 {
			*(*uintptr)(unsafe.Pointer(ppHook)) = pArg
			(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ppHook)))).FrefCount++
		}
	}

	sqlite3.Xsqlite3_preupdate_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, sqlite_int64, sqlite_int64)
			}{DbPreUpdateHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_update_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr, sqlite_int64)
			}{DbUpdateHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_rollback_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{DbRollbackHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_wal_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
			}{DbWalHandler}))
		}
		return uintptr(0)
	}(), pDb)
}

// The "sqlite" command below creates a new Tcl command for each
// connection it opens to an SQLite database.  This routine is invoked
// whenever one of those connection-specific commands is executed
// in Tcl.  For example, if you run Tcl code like this:
//
//       sqlite3 db1  "my_database"
//       db1 close
//
// The first command opens a connection to the "my_database" database
// and calls that connection "db1".  The second command causes this
// subroutine to be invoked.
func DbObjCmd(tls *libc.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* tclsqlite.c:1907:26: */
	bp := tls.Alloc(1464)
	defer tls.Free(1464)
	*(*uintptr)(unsafe.Pointer(bp + 1348)) = cd

	var pDb uintptr
	// var choice int32 at bp+1016, 4

	var rc int32
	var zAuth uintptr
	// var len int32 at bp+1020, 4

	var zDestFile uintptr
	var zSrcDb uintptr
	// var pDest uintptr at bp+1024, 4

	var pBackup uintptr
	var zCallback uintptr
	// var len1 int32 at bp+1028, 4

	var zBusy uintptr
	// var len2 int32 at bp+1032, 4

	var subCmd uintptr
	// var n int32 at bp+1036, 4

	var pResult uintptr
	var pCollate uintptr
	var zName uintptr
	var zScript uintptr
	// var nScript int32 at bp+1040, 4

	var _objPtr uintptr
	var zCommit uintptr
	// var len3 int32 at bp+1044, 4

	var pResult1 uintptr
	var isComplete int32
	// var v int32 at bp+1048, 4

	var zOpt uintptr
	// var onoff int32 at bp+1052, 4

	// var v1 int32 at bp+1056, 4

	var pResult2 uintptr
	var ii int32
	var zErr uintptr
	var nErr int32
	var z uintptr
	var zTable uintptr    // Insert data into this table
	var zFile uintptr     // The file from which to extract data
	var zConflict uintptr // The conflict algorithm to use
	// var pStmt uintptr at bp+1060, 4
	// A statement
	var nCol int32  // Number of columns in the table
	var nByte int32 // Number of bytes in an SQL string
	var i int32
	var j int32          // Loop counters
	var nSep int32       // Number of bytes in zSep[]
	var nNull int32      // Number of bytes in zNull[]
	var zSql uintptr     // An SQL statement
	var zLine uintptr    // A single line of input from the file
	var azCol uintptr    // zLine[] broken up into columns
	var zCommit1 uintptr // How to commit changes
	var in uintptr       // The input file
	var lineno int32     // Line number of input file
	// var zLineNum [80]int8 at bp+1064, 80
	// Line number print buffer
	var pResult3 uintptr // interp result

	var zSep uintptr
	var zNull uintptr
	var z1 uintptr
	var flags int32
	var zSchema uintptr
	var pValue uintptr
	var pBA uintptr
	var pData uintptr
	// var len4 int32 at bp+1156, 4

	var xrc int32
	// var mxSize sqlite3_int64 at bp+1144, 8

	var i1 int32
	// var isReadonly int32 at bp+1152, 4

	var pResult4 uintptr
	// var sEval DbEvalContext at bp+1160, 32

	var i2 int32
	// var nCol1 int32 at bp+1224, 4

	var _objPtr1 uintptr
	// var sEval1 DbEvalContext at bp+1192, 32

	var pRet uintptr
	// var cd2 [2]ClientData at bp+1228, 8

	var p uintptr
	var pArray uintptr
	var pScript uintptr
	var evalFlags int32
	var zOpt1 uintptr
	// var azType [6]uintptr at bp+1240, 24

	var z2 uintptr
	var n1 int32
	var _objPtr2 uintptr
	var flags1 int32
	var pFunc uintptr
	var pScript1 uintptr
	var zName1 uintptr
	// var nArg int32 at bp+1236, 4

	var i3 int32
	// var eType int32 at bp+1264, 4

	var isReadonly1 int32
	var zDb uintptr
	var zTable1 uintptr
	var zColumn uintptr
	// var iRow Tcl_WideInt at bp+1272, 8

	// var len5 int32 at bp+1280, 4

	var zNull1 uintptr
	var pResult5 uintptr
	var rowid Tcl_WideInt
	var zProgress uintptr
	// var len6 int32 at bp+1288, 4

	// var N int32 at bp+1284, 4

	var zProfile uintptr
	// var len7 int32 at bp+1292, 4

	var zSrcFile uintptr
	var zDestDb uintptr
	// var pSrc uintptr at bp+1296, 4

	var pBackup1 uintptr
	var nTimeout int32
	var needFree int32
	var zSchema1 uintptr
	// var sz sqlite3_int64 at bp+1304, 8

	var pData1 uintptr
	var v2 int32
	var zOp uintptr
	// var ms int32 at bp+1312, 4

	var pResult6 uintptr
	var zTrace uintptr
	// var len8 int32 at bp+1316, 4

	var _objPtr3 uintptr
	var _objPtr4 uintptr
	// var wType Tcl_WideInt at bp+1336, 8

	var pError uintptr
	// var pObj uintptr at bp+1324, 4

	// var ttype int32 at bp+1328, 4

	var i4 int32
	var zTraceV2 uintptr
	// var len9 int32 at bp+1320, 4

	var wMask Tcl_WideInt
	// var ttype1 int32 at bp+1344, 4

	var pScript2 uintptr
	var zBegin uintptr
	var _objPtr5 uintptr
	var xNotify uintptr
	var pNotifyArg uintptr
	var nCol2 int32
	var pRet1 uintptr
	var pObj1 uintptr
	// var iIdx int32 at bp+1356, 4

	// var pValue1 uintptr at bp+1360, 4

	// var iSub int32 at bp+1352, 4

	// set ppHook to point at pUpdateHook or pRollbackHook, depending on
	// whether [$db update_hook] or [$db rollback_hook] was invoked.
	var ppHook uintptr
	// var zBuf [100]int8 at bp+1364, 100

	var zArg uintptr
	var i5 int32
	pDb = *(*uintptr)(unsafe.Pointer(bp + 1348 /* cd */))
	rc = TCL_OK
	// don't leave trailing commas on DB_enum, it confuses the AIX xlc compiler

	if !(objc < 2) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1860 /* "SUBCOMMAND ..." */)
	return TCL_ERROR
__1:
	;
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(unsafe.Pointer(&DB_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+11373 /* "option" */, 0, bp+1016 /* &choice */) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	switch uint32(*(*int32)(unsafe.Pointer(bp + 1016 /* choice */))) {

	// $db authorizer ?CALLBACK?
	//
	// Invoke the given callback to authorize each SQL operation as it is
	// compiled.  5 arguments are appended to the callback before it is
	// invoked:
	//
	//   (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...)
	//   (2) First descriptive name (depends on authorization type)
	//   (3) Second descriptive name
	//   (4) Name of the database (ex: "main", "temp")
	//   (5) Name of trigger that is doing the access
	//
	// The callback should return on of the following strings: SQLITE_OK,
	// SQLITE_IGNORE, or SQLITE_DENY.  Any other return value is an error.
	//
	// If this method is invoked with no arguments, the current authorization
	// callback string is returned.
	case uint32(0) /* DB_AUTHORIZER */ :
		goto __4

	// $db backup ?DATABASE? FILENAME
	//
	// Open or create a database file named FILENAME.  Transfer the
	// content of local database DATABASE (default: "main") into the
	// FILENAME database.
	case uint32(1) /* DB_BACKUP */ :
		goto __5

	// $db bind_fallback ?CALLBACK?
	//
	// When resolving bind parameters in an SQL statement, if the parameter
	// cannot be associated with a TCL variable then invoke CALLBACK with a
	// single argument that is the name of the parameter and use the return
	// value of the CALLBACK as the binding.  If CALLBACK returns something
	// other than TCL_OK or TCL_ERROR then bind a NULL.
	//
	// If CALLBACK is an empty string, then revert to the default behavior
	// which is to set the binding to NULL.
	//
	// If CALLBACK returns an error, that causes the statement execution to
	// abort.  Hence, to configure a connection so that it throws an error
	// on an attempt to bind an unknown variable, do something like this:
	//
	//     proc bind_error {name} {error "no such variable: $name"}
	//     db bind_fallback bind_error
	case uint32(2) /* DB_BIND_FALLBACK */ :
		goto __6

	// $db busy ?CALLBACK?
	//
	// Invoke the given callback if an SQL statement attempts to open
	// a locked database file.
	case uint32(3) /* DB_BUSY */ :
		goto __7

	// $db cache flush
	//     $db cache size n
	//
	// Flush the prepared statement cache, or set the maximum number of
	// cached statements.
	case uint32(4) /* DB_CACHE */ :
		goto __8

	// $db changes
	//
	// Return the number of rows that were modified, inserted, or deleted by
	// the most recent INSERT, UPDATE or DELETE statement, not including
	// any changes made by trigger programs.
	case uint32(5) /* DB_CHANGES */ :
		goto __9

	// $db close
	//
	// Shutdown the database
	case uint32(6) /* DB_CLOSE */ :
		goto __10

	//     $db collate NAME SCRIPT
	//
	// Create a new SQL collation function called NAME.  Whenever
	// that function is called, invoke SCRIPT to evaluate the function.
	case uint32(7) /* DB_COLLATE */ :
		goto __11

	//     $db collation_needed SCRIPT
	//
	// Create a new SQL collation function called NAME.  Whenever
	// that function is called, invoke SCRIPT to evaluate the function.
	case uint32(8) /* DB_COLLATION_NEEDED */ :
		goto __12

	// $db commit_hook ?CALLBACK?
	//
	// Invoke the given callback just before committing every SQL transaction.
	// If the callback throws an exception or returns non-zero, then the
	// transaction is aborted.  If CALLBACK is an empty string, the callback
	// is disabled.
	case uint32(9) /* DB_COMMIT_HOOK */ :
		goto __13

	// $db complete SQL
	//
	// Return TRUE if SQL is a complete SQL statement.  Return FALSE if
	// additional lines of input are needed.  This is similar to the
	// built-in "info complete" command of Tcl.
	case uint32(10) /* DB_COMPLETE */ :
		goto __14

	// $db config ?OPTION? ?BOOLEAN?
	//
	// Configure the database connection using the sqlite3_db_config()
	// interface.
	case uint32(11) /* DB_CONFIG */ :
		goto __15

	// $db copy conflict-algorithm table filename ?SEPARATOR? ?NULLINDICATOR?
	//
	// Copy data into table from filename, optionally using SEPARATOR
	// as column separators.  If a column contains a null string, or the
	// value of NULLINDICATOR, a NULL is inserted for the column.
	// conflict-algorithm is one of the sqlite conflict algorithms:
	//    rollback, abort, fail, ignore, replace
	// On success, return the number of lines processed, not necessarily same
	// as 'db changes' due to conflict-algorithm selected.
	//
	// This code is basically an implementation/enhancement of
	// the sqlite3 shell.c ".import" command.
	//
	// This command usage is equivalent to the sqlite2.x COPY statement,
	// which imports file data into a table using the PostgreSQL COPY file format:
	//   $db copy $conflit_algo $table_name $filename \t \\N
	case uint32(12) /* DB_COPY */ :
		goto __16

	//     $db deserialize ?-maxsize N? ?-readonly BOOL? ?DATABASE? VALUE
	//
	// Reopen DATABASE (default "main") using the content in $VALUE
	case uint32(13) /* DB_DESERIALIZE */ :
		goto __17

	//    $db enable_load_extension BOOLEAN
	//
	// Turn the extension loading feature on or off.  It if off by
	// default.
	case uint32(14) /* DB_ENABLE_LOAD_EXTENSION */ :
		goto __18

	//    $db errorcode
	//
	// Return the numeric error code that was returned by the most recent
	// call to sqlite3_exec().
	case uint32(15) /* DB_ERRORCODE */ :
		goto __19

	//    $db exists $sql
	//    $db onecolumn $sql
	//
	// The onecolumn method is the equivalent of:
	//     lindex [$db eval $sql] 0
	case uint32(17) /* DB_EXISTS */ :
		goto __20
	case uint32(23) /* DB_ONECOLUMN */ :
		goto __21

	//    $db eval ?options? $sql ?array? ?{  ...code... }?
	//
	// The SQL statement in $sql is evaluated.  For each row, the values are
	// placed in elements of the array named "array" and ...code... is executed.
	// If "array" and "code" are omitted, then no callback is every invoked.
	// If "array" is an empty string, then the values are placed in variables
	// that have the same name as the fields extracted by the query.
	case uint32(16) /* DB_EVAL */ :
		goto __22

	//     $db function NAME [OPTIONS] SCRIPT
	//
	// Create a new SQL function called NAME.  Whenever that function is
	// called, invoke SCRIPT to evaluate the function.
	//
	// Options:
	//         --argcount N           Function has exactly N arguments
	//         --deterministic        The function is pure
	//         --directonly           Prohibit use inside triggers and views
	//         --innocuous            Has no side effects or information leaks
	//         --returntype TYPE      Specify the return type of the function
	case uint32(18) /* DB_FUNCTION */ :
		goto __23

	//     $db incrblob ?-readonly? ?DB? TABLE COLUMN ROWID
	case uint32(19) /* DB_INCRBLOB */ :
		goto __24

	//     $db interrupt
	//
	// Interrupt the execution of the inner-most SQL interpreter.  This
	// causes the SQL statement to return an error of SQLITE_INTERRUPT.
	case uint32(20) /* DB_INTERRUPT */ :
		goto __25

	//     $db nullvalue ?STRING?
	//
	// Change text used when a NULL comes back from the database. If ?STRING?
	// is not present, then the current string used for NULL is returned.
	// If STRING is present, then STRING is returned.
	//
	case uint32(22) /* DB_NULLVALUE */ :
		goto __26

	//     $db last_insert_rowid
	//
	// Return an integer which is the ROWID for the most recent insert.
	case uint32(21) /* DB_LAST_INSERT_ROWID */ :
		goto __27

	// The DB_ONECOLUMN method is implemented together with DB_EXISTS.

	// $db progress ?N CALLBACK?
	//
	// Invoke the given callback every N virtual machine opcodes while executing
	// queries.
	case uint32(26) /* DB_PROGRESS */ :
		goto __28

	// $db profile ?CALLBACK?
	//
	// Make arrangements to invoke the CALLBACK routine after each SQL statement
	// that has run.  The text of the SQL and the amount of elapse time are
	// appended to CALLBACK before the script is run.
	case uint32(25) /* DB_PROFILE */ :
		goto __29

	//     $db rekey KEY
	//
	// Change the encryption key on the currently open database.
	case uint32(27) /* DB_REKEY */ :
		goto __30

	// $db restore ?DATABASE? FILENAME
	//
	// Open a database file named FILENAME.  Transfer the content
	// of FILENAME into the local database DATABASE (default: "main").
	case uint32(28) /* DB_RESTORE */ :
		goto __31

	//     $db serialize ?DATABASE?
	//
	// Return a serialization of a database.
	case uint32(30) /* DB_SERIALIZE */ :
		goto __32

	//     $db status (step|sort|autoindex|vmstep)
	//
	// Display SQLITE_STMTSTATUS_FULLSCAN_STEP or
	// SQLITE_STMTSTATUS_SORT for the most recent eval.
	case uint32(31) /* DB_STATUS */ :
		goto __33

	//     $db timeout MILLESECONDS
	//
	// Delay for the number of milliseconds specified when a file is locked.
	case uint32(32) /* DB_TIMEOUT */ :
		goto __34

	//     $db total_changes
	//
	// Return the number of rows that were modified, inserted, or deleted
	// since the database handle was created.
	case uint32(33) /* DB_TOTAL_CHANGES */ :
		goto __35

	// $db trace ?CALLBACK?
	//
	// Make arrangements to invoke the CALLBACK routine for each SQL statement
	// that is executed.  The text of the SQL is appended to CALLBACK before
	// it is executed.
	case uint32(34) /* DB_TRACE */ :
		goto __36

	// $db trace_v2 ?CALLBACK? ?MASK?
	//
	// Make arrangements to invoke the CALLBACK routine for each trace event
	// matching the mask that is generated.  The parameters are appended to
	// CALLBACK before it is executed.
	case uint32(35) /* DB_TRACE_V2 */ :
		goto __37

	// $db transaction [-deferred|-immediate|-exclusive] SCRIPT
	//
	// Start a new transaction (if we are not already in the midst of a
	// transaction) and execute the TCL script SCRIPT.  After SCRIPT
	// completes, either commit the transaction or roll it back if SCRIPT
	// throws an exception.  Or if no new transation was started, do nothing.
	// pass the exception on up the stack.
	//
	// This command was inspired by Dave Thomas's talk on Ruby at the
	// 2005 O'Reilly Open Source Convention (OSCON).
	case uint32(36) /* DB_TRANSACTION */ :
		goto __38

	//    $db unlock_notify ?script?
	case uint32(37) /* DB_UNLOCK_NOTIFY */ :
		goto __39

	//    $db preupdate_hook count
	//    $db preupdate_hook hook ?SCRIPT?
	//    $db preupdate_hook new INDEX
	//    $db preupdate_hook old INDEX
	case uint32(24) /* DB_PREUPDATE */ :
		goto __40

	//    $db wal_hook ?script?
	//    $db update_hook ?script?
	//    $db rollback_hook ?script?
	case uint32(40) /* DB_WAL_HOOK */ :
		goto __41
	case uint32(38) /* DB_UPDATE_HOOK */ :
		goto __42
	case uint32(29) /* DB_ROLLBACK_HOOK */ :
		goto __43

	// $db version
	//
	// Return the version string for this database.
	case uint32(39) /* DB_VERSION */ :
		goto __44
	}
	goto __3

	// $db authorizer ?CALLBACK?
	//
	// Invoke the given callback to authorize each SQL operation as it is
	// compiled.  5 arguments are appended to the callback before it is
	// invoked:
	//
	//   (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...)
	//   (2) First descriptive name (depends on authorization type)
	//   (3) Second descriptive name
	//   (4) Name of the database (ex: "main", "temp")
	//   (5) Name of trigger that is doing the access
	//
	// The callback should return on of the following strings: SQLITE_OK,
	// SQLITE_IGNORE, or SQLITE_DENY.  Any other return value is an error.
	//
	// If this method is invoked with no arguments, the current authorization
	// callback string is returned.
__4:
	if !(objc > 3) {
		goto __45
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11380 /* "?CALLBACK?" */)
	return TCL_ERROR
	goto __46
__45:
	if !(objc == 2) {
		goto __47
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0) {
		goto __49
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, uintptr(0)))
__49:
	;
	goto __48
__47:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0) {
		goto __50
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth)
__50:
	;
	zAuth = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1020 /* &len */)
	if !((zAuth != 0) && (*(*int32)(unsafe.Pointer(bp + 1020 /* len */)) > 0)) {
		goto __51
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzAuth = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1020 /* len */)) + 1)))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, zAuth, (uint32(*(*int32)(unsafe.Pointer(bp + 1020 /* len */)) + 1)))
	goto __52
__51:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzAuth = uintptr(0)
__52:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0) {
		goto __53
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_set_authorizer(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr, uintptr) int32
	}{auth_callback})), pDb)
	goto __54
__53:
	sqlite3.Xsqlite3_set_authorizer(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__54:
	;
__48:
	;
__46:
	;
	goto __3

	// $db backup ?DATABASE? FILENAME
	//
	// Open or create a database file named FILENAME.  Transfer the
	// content of local database DATABASE (default: "main") into the
	// FILENAME database.
__5:

	if !(objc == 3) {
		goto __55
	}
	zSrcDb = ts + 85 /* "main" */
	zDestFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	goto __56
__55:
	if !(objc == 4) {
		goto __57
	}
	zSrcDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	zDestFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	goto __58
__57:
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11391 /* "?DATABASE? FILEN..." */)
	return TCL_ERROR
__58:
	;
__56:
	;
	rc = sqlite3.Xsqlite3_open_v2(tls, zDestFile, bp+1024, /* &pDest */
		((SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE) | (*SqliteDb)(unsafe.Pointer(pDb)).FopenFlags), uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __59
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+11411, /* "cannot open targ..." */
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */))), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */)))
	return TCL_ERROR
__59:
	;
	pBackup = sqlite3.Xsqlite3_backup_init(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */)), ts+85 /* "main" */, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSrcDb)
	if !(pBackup == uintptr(0)) {
		goto __60
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+11441, /* "backup failed: " */
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */))), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */)))
	return TCL_ERROR
__60:
	;
__61:
	if !((libc.AssignInt32(&rc, sqlite3.Xsqlite3_backup_step(tls, pBackup, 100))) == SQLITE_OK) {
		goto __62
	}
	goto __61
__62:
	;
	sqlite3.Xsqlite3_backup_finish(tls, pBackup)
	if !(rc == SQLITE_DONE) {
		goto __63
	}
	rc = TCL_OK
	goto __64
__63:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, ts+11441, /* "backup failed: " */
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */))), uintptr(0)))
	rc = TCL_ERROR
__64:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */)))
	goto __3

	// $db bind_fallback ?CALLBACK?
	//
	// When resolving bind parameters in an SQL statement, if the parameter
	// cannot be associated with a TCL variable then invoke CALLBACK with a
	// single argument that is the name of the parameter and use the return
	// value of the CALLBACK as the binding.  If CALLBACK returns something
	// other than TCL_OK or TCL_ERROR then bind a NULL.
	//
	// If CALLBACK is an empty string, then revert to the default behavior
	// which is to set the binding to NULL.
	//
	// If CALLBACK returns an error, that causes the statement execution to
	// abort.  Hence, to configure a connection so that it throws an error
	// on an attempt to bind an unknown variable, do something like this:
	//
	//     proc bind_error {name} {error "no such variable: $name"}
	//     db bind_fallback bind_error
__6:
	if !(objc > 3) {
		goto __65
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11380 /* "?CALLBACK?" */)
	return TCL_ERROR
	goto __66
__65:
	if !(objc == 2) {
		goto __67
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0) {
		goto __69
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+88, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, uintptr(0)))
__69:
	;
	goto __68
__67:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0) {
		goto __70
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback)
__70:
	;
	zCallback = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1028 /* &len1 */)
	if !((zCallback != 0) && (*(*int32)(unsafe.Pointer(bp + 1028 /* len1 */)) > 0)) {
		goto __71
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1028 /* len1 */)) + 1)))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, zCallback, (uint32(*(*int32)(unsafe.Pointer(bp + 1028 /* len1 */)) + 1)))
	goto __72
__71:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback = uintptr(0)
__72:
	;
__68:
	;
__66:
	;
	goto __3

	// $db busy ?CALLBACK?
	//
	// Invoke the given callback if an SQL statement attempts to open
	// a locked database file.
__7:
	if !(objc > 3) {
		goto __73
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11457 /* "CALLBACK" */)
	return TCL_ERROR
	goto __74
__73:
	if !(objc == 2) {
		goto __75
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0) {
		goto __77
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+104, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, uintptr(0)))
__77:
	;
	goto __76
__75:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0) {
		goto __78
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy)
__78:
	;
	zBusy = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1032 /* &len2 */)
	if !((zBusy != 0) && (*(*int32)(unsafe.Pointer(bp + 1032 /* len2 */)) > 0)) {
		goto __79
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBusy = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1032 /* len2 */)) + 1)))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, zBusy, (uint32(*(*int32)(unsafe.Pointer(bp + 1032 /* len2 */)) + 1)))
	goto __80
__79:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBusy = uintptr(0)
__80:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0) {
		goto __81
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_busy_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{DbBusyHandler})), pDb)
	goto __82
__81:
	sqlite3.Xsqlite3_busy_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__82:
	;
__76:
	;
__74:
	;
	goto __3

	// $db cache flush
	//     $db cache size n
	//
	// Flush the prepared statement cache, or set the maximum number of
	// cached statements.
__8:

	if !(objc <= 2) {
		goto __83
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+11466 /* "cache option ?ar..." */)
	return TCL_ERROR
__83:
	;
	subCmd = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0))
	if !((int32(*(*int8)(unsafe.Pointer(subCmd))) == 'f') && (libc.Xstrcmp(tls, subCmd, ts+11485 /* "flush" */) == 0)) {
		goto __84
	}
	if !(objc != 3) {
		goto __86
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11485 /* "flush" */)
	return TCL_ERROR
	goto __87
__86:
	flushStmtCache(tls, pDb)
__87:
	;
	goto __85
__84:
	if !((int32(*(*int8)(unsafe.Pointer(subCmd))) == 's') && (libc.Xstrcmp(tls, subCmd, ts+11491 /* "size" */) == 0)) {
		goto __88
	}
	if !(objc != 4) {
		goto __90
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11496 /* "size n" */)
	return TCL_ERROR
	goto __91
__90:
	if !(TCL_ERROR == tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1036 /* &n */)) {
		goto __92
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+120, ts+11503, /* "cannot convert \"" */
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), uintptr(0)), ts+11520 /* "\" to integer" */, uintptr(0)))
	return TCL_ERROR
	goto __93
__92:
	if !(*(*int32)(unsafe.Pointer(bp + 1036 /* n */)) < 0) {
		goto __94
	}
	flushStmtCache(tls, pDb)
	*(*int32)(unsafe.Pointer(bp + 1036 /* n */)) = 0
	goto __95
__94:
	if !(*(*int32)(unsafe.Pointer(bp + 1036 /* n */)) > MAX_PREPARED_STMTS) {
		goto __96
	}
	*(*int32)(unsafe.Pointer(bp + 1036 /* n */)) = MAX_PREPARED_STMTS
__96:
	;
__95:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt = *(*int32)(unsafe.Pointer(bp + 1036 /* n */))
__93:
	;
__91:
	;
	goto __89
__88:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+152, ts+11533, /* "bad option \"" */
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0)), ts+11546, /* "\": must be flush..." */
		uintptr(0)))
	return TCL_ERROR
__89:
	;
__85:
	;
	goto __3

	// $db changes
	//
	// Return the number of rows that were modified, inserted, or deleted by
	// the most recent INSERT, UPDATE or DELETE statement, not including
	// any changes made by trigger programs.
__9:
	if !(objc != 2) {
		goto __97
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+489 /* "" */)
	return TCL_ERROR
__97:
	;
	pResult = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetIntObj(tls, pResult, sqlite3.Xsqlite3_changes(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
	goto __3

	// $db close
	//
	// Shutdown the database
__10:
	tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)))
	goto __3

	//     $db collate NAME SCRIPT
	//
	// Create a new SQL collation function called NAME.  Whenever
	// that function is called, invoke SCRIPT to evaluate the function.
__11:
	if !(objc != 4) {
		goto __98
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11571 /* "NAME SCRIPT" */)
	return TCL_ERROR
__98:
	;
	zName = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0))
	zScript = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1040 /* &nScript */)
	pCollate = tcl.XTcl_Alloc(tls, ((uint32(unsafe.Sizeof(SqlCollate{})) + uint32(*(*int32)(unsafe.Pointer(bp + 1040 /* nScript */)))) + uint32(1)))
	if !(pCollate == uintptr(0)) {
		goto __99
	}
	return TCL_ERROR
__99:
	;
	(*SqlCollate)(unsafe.Pointer(pCollate)).Finterp = interp
	(*SqlCollate)(unsafe.Pointer(pCollate)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate
	(*SqlCollate)(unsafe.Pointer(pCollate)).FzScript = (pCollate + 1*12)
	(*SqliteDb)(unsafe.Pointer(pDb)).FpCollate = pCollate
	libc.Xmemcpy(tls, (*SqlCollate)(unsafe.Pointer(pCollate)).FzScript, zScript, (uint32(*(*int32)(unsafe.Pointer(bp + 1040 /* nScript */)) + 1)))
	if !(sqlite3.Xsqlite3_create_collation(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zName, SQLITE_UTF8,
		pCollate, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{tclSqlCollate}))) != 0) {
		goto __100
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
	return TCL_ERROR
__100:
	;
	goto __3

	//     $db collation_needed SCRIPT
	//
	// Create a new SQL collation function called NAME.  Whenever
	// that function is called, invoke SCRIPT to evaluate the function.
__12:
	if !(objc != 3) {
		goto __101
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11583 /* "SCRIPT" */)
	return TCL_ERROR
__101:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded != 0) {
		goto __102
	}
__103:
	_objPtr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1) {
		goto __106
	}
	tcl.XTclFreeObj(tls, _objPtr)
__106:
	;
	goto __104
__104:
	if 0 != 0 {
		goto __103
	}
	goto __105
__105:
	;
__102:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	(*Tcl_Obj)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded)).FrefCount++
	sqlite3.Xsqlite3_collation_needed(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, pDb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr)
	}{tclCollateNeeded})))
	goto __3

	// $db commit_hook ?CALLBACK?
	//
	// Invoke the given callback just before committing every SQL transaction.
	// If the callback throws an exception or returns non-zero, then the
	// transaction is aborted.  If CALLBACK is an empty string, the callback
	// is disabled.
__13:
	if !(objc > 3) {
		goto __107
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11380 /* "?CALLBACK?" */)
	return TCL_ERROR
	goto __108
__107:
	if !(objc == 2) {
		goto __109
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0) {
		goto __111
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+184, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit, uintptr(0)))
__111:
	;
	goto __110
__109:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0) {
		goto __112
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit)
__112:
	;
	zCommit = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1044 /* &len3 */)
	if !((zCommit != 0) && (*(*int32)(unsafe.Pointer(bp + 1044 /* len3 */)) > 0)) {
		goto __113
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzCommit = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1044 /* len3 */)) + 1)))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit, zCommit, (uint32(*(*int32)(unsafe.Pointer(bp + 1044 /* len3 */)) + 1)))
	goto __114
__113:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzCommit = uintptr(0)
__114:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0) {
		goto __115
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_commit_hook(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{DbCommitHandler})), pDb)
	goto __116
__115:
	sqlite3.Xsqlite3_commit_hook(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__116:
	;
__110:
	;
__108:
	;
	goto __3

	// $db complete SQL
	//
	// Return TRUE if SQL is a complete SQL statement.  Return FALSE if
	// additional lines of input are needed.  This is similar to the
	// built-in "info complete" command of Tcl.
__14:
	if !(objc != 3) {
		goto __117
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+10170 /* "SQL" */)
	return TCL_ERROR
__117:
	;
	isComplete = sqlite3.Xsqlite3_complete(tls, tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0)))
	pResult1 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetIntObj(tls, pResult1, (libc.Bool32((isComplete) != 0)))
	goto __3

	// $db config ?OPTION? ?BOOLEAN?
	//
	// Configure the database connection using the sqlite3_db_config()
	// interface.
__15:
	if !(objc > 4) {
		goto __118
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11590 /* "?OPTION? ?BOOLEA..." */)
	return TCL_ERROR
__118:
	;
	if !(objc == 2) {
		goto __119
	}
	// With no arguments, list all configuration options and with the
	// current value
	pResult2 = tcl.XTcl_NewListObj(tls, 0, uintptr(0))
	ii = 0
__121:
	if !(uint32(ii) < (uint32(unsafe.Sizeof(aDbConfig)) / uint32(unsafe.Sizeof(DbConfigChoices{})))) {
		goto __123
	}
	*(*int32)(unsafe.Pointer(bp + 1048 /* v */)) = 0
	sqlite3.Xsqlite3_db_config(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, aDbConfig[ii].Fop, libc.VaList(bp+200, -1, bp+1048 /* &v */))
	tcl.XTcl_ListObjAppendElement(tls, interp, pResult2,
		tcl.XTcl_NewStringObj(tls, aDbConfig[ii].FzName, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pResult2,
		tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 1048 /* v */))))
	goto __122
__122:
	ii++
	goto __121
	goto __123
__123:
	;
	goto __120
__119:
	zOpt = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	*(*int32)(unsafe.Pointer(bp + 1052 /* onoff */)) = -1
	*(*int32)(unsafe.Pointer(bp + 1056 /* v1 */)) = 0
	if !(int32(*(*int8)(unsafe.Pointer(zOpt))) == '-') {
		goto __124
	}
	zOpt++
__124:
	;
	ii = 0
__125:
	if !(uint32(ii) < (uint32(unsafe.Sizeof(aDbConfig)) / uint32(unsafe.Sizeof(DbConfigChoices{})))) {
		goto __127
	}
	if !(libc.Xstrcmp(tls, aDbConfig[ii].FzName, zOpt) == 0) {
		goto __128
	}
	goto __127
__128:
	;
	goto __126
__126:
	ii++
	goto __125
	goto __127
__127:
	;
	if !(uint32(ii) >= (uint32(unsafe.Sizeof(aDbConfig)) / uint32(unsafe.Sizeof(DbConfigChoices{})))) {
		goto __129
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+216, ts+11609 /* "unknown config o..." */, zOpt,
		ts+11634 /* "\"" */, uintptr(0)))
	return TCL_ERROR
__129:
	;
	if !(objc == 4) {
		goto __130
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1052 /* &onoff */) != 0) {
		goto __131
	}
	return TCL_ERROR
__131:
	;
__130:
	;
	sqlite3.Xsqlite3_db_config(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, aDbConfig[ii].Fop, libc.VaList(bp+248, *(*int32)(unsafe.Pointer(bp + 1052 /* onoff */)), bp+1056 /* &v1 */))
	pResult2 = tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 1056 /* v1 */)))
__120:
	;
	tcl.XTcl_SetObjResult(tls, interp, pResult2)
	goto __3

	// $db copy conflict-algorithm table filename ?SEPARATOR? ?NULLINDICATOR?
	//
	// Copy data into table from filename, optionally using SEPARATOR
	// as column separators.  If a column contains a null string, or the
	// value of NULLINDICATOR, a NULL is inserted for the column.
	// conflict-algorithm is one of the sqlite conflict algorithms:
	//    rollback, abort, fail, ignore, replace
	// On success, return the number of lines processed, not necessarily same
	// as 'db changes' due to conflict-algorithm selected.
	//
	// This code is basically an implementation/enhancement of
	// the sqlite3 shell.c ".import" command.
	//
	// This command usage is equivalent to the sqlite2.x COPY statement,
	// which imports file data into a table using the PostgreSQL COPY file format:
	//   $db copy $conflit_algo $table_name $filename \t \\N
__16: // The input file
	lineno = 0
	if !((objc < 5) || (objc > 7)) {
		goto __132
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv,
		ts+11636 /* "CONFLICT-ALGORIT..." */)
	return TCL_ERROR
__132:
	;
	if !(objc >= 6) {
		goto __133
	}
	zSep = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 5*4)), uintptr(0))
	goto __134
__133:
	zSep = ts + 11698 /* "\t" */
__134:
	;
	if !(objc >= 7) {
		goto __135
	}
	zNull = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 6*4)), uintptr(0))
	goto __136
__135:
	zNull = ts + 489 /* "" */
__136:
	;
	zConflict = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0))
	zTable = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), uintptr(0))
	zFile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0))
	nSep = strlen30(tls, zSep)
	nNull = strlen30(tls, zNull)
	if !(nSep == 0) {
		goto __137
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+264, ts+11700, /* "Error: non-null ..." */
		uintptr(0)))
	return TCL_ERROR
__137:
	;
	if !(((((libc.Xstrcmp(tls, zConflict, ts+11744 /* "rollback" */) != 0) && (libc.Xstrcmp(tls, zConflict, ts+11753 /* "abort" */) != 0)) && (libc.Xstrcmp(tls, zConflict, ts+11759 /* "fail" */) != 0)) && (libc.Xstrcmp(tls, zConflict, ts+11764 /* "ignore" */) != 0)) && (libc.Xstrcmp(tls, zConflict, ts+11771 /* "replace" */) != 0)) {
		goto __138
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+280, ts+11779 /* "Error: \"" */, zConflict,

		ts+11788 /* "\", conflict-algo..." */, uintptr(0)))
	return TCL_ERROR
__138:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+11868 /* "SELECT * FROM '%..." */, libc.VaList(bp+312, zTable))
	if !(zSql == uintptr(0)) {
		goto __139
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+320, ts+11887 /* "Error: no such t..." */, zTable, uintptr(0)))
	return TCL_ERROR
__139:
	;
	nByte = strlen30(tls, zSql)
	rc = sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, bp+1060 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != 0) {
		goto __140
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+344, ts+11910 /* "Error: " */, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	nCol = 0
	goto __141
__140:
	nCol = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 1060 /* pStmt */)))
__141:
	;
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1060 /* pStmt */)))
	if !(nCol == 0) {
		goto __142
	}
	return TCL_ERROR
__142:
	;
	zSql = libc.Xmalloc(tls, (uint32((nByte + 50) + (nCol * 2))))
	if !(zSql == uintptr(0)) {
		goto __143
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+368, ts+11918 /* "Error: can't mal..." */, uintptr(0)))
	return TCL_ERROR
__143:
	;
	sqlite3.Xsqlite3_snprintf(tls, (nByte + 50), zSql, ts+11940, /* "INSERT OR %q INT..." */
		libc.VaList(bp+384, zConflict, zTable))
	j = strlen30(tls, zSql)
	i = 1
__144:
	if !(i < nCol) {
		goto __146
	}
	*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8(',')
	*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8('?')
	goto __145
__145:
	i++
	goto __144
	goto __146
__146:
	;
	*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8(')')
	*(*int8)(unsafe.Pointer(zSql + uintptr(j))) = int8(0)
	rc = sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, bp+1060 /* &pStmt */, uintptr(0))
	libc.Xfree(tls, zSql)
	if !(rc != 0) {
		goto __147
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+400, ts+11910 /* "Error: " */, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1060 /* pStmt */)))
	return TCL_ERROR
__147:
	;
	in = libc.Xfopen(tls, zFile, ts+4263 /* "rb" */)
	if !(in == uintptr(0)) {
		goto __148
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+424, ts+11972 /* "Error: cannot op..." */, zFile, uintptr(0)))
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1060 /* pStmt */)))
	return TCL_ERROR
__148:
	;
	azCol = libc.Xmalloc(tls, (uint32(unsafe.Sizeof(uintptr(0))) * (uint32(nCol + 1))))
	if !(azCol == uintptr(0)) {
		goto __149
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+448, ts+11918 /* "Error: can't mal..." */, uintptr(0)))
	libc.Xfclose(tls, in)
	return TCL_ERROR
__149:
	;
	sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, ts+11998 /* "BEGIN" */, uintptr(0), uintptr(0), uintptr(0))
	zCommit1 = ts + 11310 /* "COMMIT" */
__150:
	if !((libc.AssignUintptr(&zLine, local_getline(tls, uintptr(0), in))) != uintptr(0)) {
		goto __151
	}
	lineno++
	*(*uintptr)(unsafe.Pointer(azCol)) = zLine
	i = 0
	z = zLine
__152:
	if !(*(*int8)(unsafe.Pointer(z)) != 0) {
		goto __154
	}
	if !((int32(*(*int8)(unsafe.Pointer(z))) == int32(*(*int8)(unsafe.Pointer(zSep)))) && (libc.Xstrncmp(tls, z, zSep, uint32(nSep)) == 0)) {
		goto __155
	}
	*(*int8)(unsafe.Pointer(z)) = int8(0)
	i++
	if !(i < nCol) {
		goto __156
	}
	*(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*4)) = (z + uintptr(nSep))
	z += (uintptr(nSep - 1))
__156:
	;
__155:
	;
	goto __153
__153:
	z++
	goto __152
	goto __154
__154:
	;
	if !((i + 1) != nCol) {
		goto __157
	}
	nErr = (strlen30(tls, zFile) + 200)
	zErr = libc.Xmalloc(tls, uint32(nErr))
	if !(zErr != 0) {
		goto __158
	}
	sqlite3.Xsqlite3_snprintf(tls, nErr, zErr,
		ts+12004, /* "Error: %s line %..." */
		libc.VaList(bp+464, zFile, lineno, nCol, (i+1)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+496, zErr, uintptr(0)))
	libc.Xfree(tls, zErr)
__158:
	;
	zCommit1 = ts + 7270 /* "ROLLBACK" */
	goto __151
__157:
	;
	i = 0
__159:
	if !(i < nCol) {
		goto __161
	}
	// check for null data, if so, bind as null
	if !(((nNull > 0) && (libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*4)), zNull) == 0)) ||
		(strlen30(tls, *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*4))) == 0)) {
		goto __162
	}
	sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 1060 /* pStmt */)), (i + 1))
	goto __163
__162:
	sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 1060 /* pStmt */)), (i + 1), *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*4)), -1, uintptr(0))
__163:
	;
	goto __160
__160:
	i++
	goto __159
	goto __161
__161:
	;
	sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 1060 /* pStmt */)))
	rc = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 1060 /* pStmt */)))
	libc.Xfree(tls, zLine)
	if !(rc != SQLITE_OK) {
		goto __164
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+512, ts+11910 /* "Error: " */, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	zCommit1 = ts + 7270 /* "ROLLBACK" */
	goto __151
__164:
	;
	goto __150
__151:
	;
	libc.Xfree(tls, azCol)
	libc.Xfclose(tls, in)
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1060 /* pStmt */)))
	sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zCommit1, uintptr(0), uintptr(0), uintptr(0))

	if !(int32(*(*int8)(unsafe.Pointer(zCommit1))) == 'C') {
		goto __165
	}
	// success, set result as number of lines processed
	pResult3 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetIntObj(tls, pResult3, lineno)
	rc = TCL_OK
	goto __166
__165:
	// failure, append lineno where failed
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([80]int8{})), bp+1064 /* &zLineNum[0] */, ts+1238 /* "%d" */, libc.VaList(bp+536, lineno))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+544, ts+12064 /* ", failed while p..." */, bp+1064, /* &zLineNum[0] */
		uintptr(0)))
	rc = TCL_ERROR
__166:
	;
	goto __3

	//     $db deserialize ?-maxsize N? ?-readonly BOOL? ?DATABASE? VALUE
	//
	// Reopen DATABASE (default "main") using the content in $VALUE
__17:
	zSchema = uintptr(0)
	pValue = uintptr(0)
	*(*sqlite3_int64)(unsafe.Pointer(bp + 1144 /* mxSize */)) = int64(0)
	*(*int32)(unsafe.Pointer(bp + 1152 /* isReadonly */)) = 0

	if !(objc < 3) {
		goto __167
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12097 /* "?DATABASE? VALUE" */)
	rc = TCL_ERROR
	goto __3
__167:
	;
	i1 = 2
__168:
	if !(i1 < (objc - 1)) {
		goto __170
	}
	z1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i1)*4)))
	if !((libc.Xstrcmp(tls, z1, ts+12114 /* "-maxsize" */) == 0) && (i1 < (objc - 2))) {
		goto __171
	}
	rc = tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(libc.PreIncInt32(&i1, 1))*4)), bp+1144 /* &mxSize */)
	if !(rc != 0) {
		goto __172
	}
	goto deserialize_error
__172:
	;
	goto __169
__171:
	;
	if !((libc.Xstrcmp(tls, z1, ts+12123 /* "-readonly" */) == 0) && (i1 < (objc - 2))) {
		goto __173
	}
	rc = tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(libc.PreIncInt32(&i1, 1))*4)), bp+1152 /* &isReadonly */)
	if !(rc != 0) {
		goto __174
	}
	goto deserialize_error
__174:
	;
	goto __169
__173:
	;
	if !(((zSchema == uintptr(0)) && (i1 == (objc - 2))) && (int32(*(*int8)(unsafe.Pointer(z1))) != '-')) {
		goto __175
	}
	zSchema = z1
	goto __169
__175:
	;
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+568, ts+12133 /* "unknown option: " */, z1, uintptr(0)))
	rc = TCL_ERROR
	goto deserialize_error
	goto __169
__169:
	i1++
	goto __168
	goto __170
__170:
	;
	pValue = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*4))
	pBA = tcl.XTcl_GetByteArrayFromObj(tls, pValue, bp+1156 /* &len4 */)
	pData = sqlite3.Xsqlite3_malloc64(tls, uint64(*(*int32)(unsafe.Pointer(bp + 1156 /* len4 */))))
	if !((pData == uintptr(0)) && (*(*int32)(unsafe.Pointer(bp + 1156 /* len4 */)) > 0)) {
		goto __176
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+592, ts+1930 /* "out of memory" */, uintptr(0)))
	rc = TCL_ERROR
	goto __177
__176:
	if !(*(*int32)(unsafe.Pointer(bp + 1156 /* len4 */)) > 0) {
		goto __178
	}
	libc.Xmemcpy(tls, pData, pBA, uint32(*(*int32)(unsafe.Pointer(bp + 1156 /* len4 */))))
__178:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1152 /* isReadonly */)) != 0) {
		goto __179
	}
	flags = (SQLITE_DESERIALIZE_FREEONCLOSE | SQLITE_DESERIALIZE_READONLY)
	goto __180
__179:
	flags = (SQLITE_DESERIALIZE_FREEONCLOSE | SQLITE_DESERIALIZE_RESIZEABLE)
__180:
	;
	xrc = sqlite3.Xsqlite3_deserialize(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema, pData, int64(*(*int32)(unsafe.Pointer(bp + 1156 /* len4 */))), int64(*(*int32)(unsafe.Pointer(bp + 1156 /* len4 */))), uint32(flags))
	if !(xrc != 0) {
		goto __181
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+608, ts+12150 /* "unable to set ME..." */, uintptr(0)))
	rc = TCL_ERROR
__181:
	;
	if !(*(*sqlite3_int64)(unsafe.Pointer(bp + 1144 /* mxSize */)) > int64(0)) {
		goto __182
	}
	sqlite3.Xsqlite3_file_control(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema, SQLITE_FCNTL_SIZE_LIMIT, bp+1144 /* &mxSize */)
__182:
	;
__177:
	;
deserialize_error:
	goto __3

	//    $db enable_load_extension BOOLEAN
	//
	// Turn the extension loading feature on or off.  It if off by
	// default.
__18:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+624, ts+12178, /* "extension loadin..." */
		uintptr(0)))
	return TCL_ERROR

	//    $db errorcode
	//
	// Return the numeric error code that was returned by the most recent
	// call to sqlite3_exec().
__19:
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)))
	goto __3

	//    $db exists $sql
	//    $db onecolumn $sql
	//
	// The onecolumn method is the equivalent of:
	//     lindex [$db eval $sql] 0
__20:
__21:
	pResult4 = uintptr(0)
	if !(objc != 3) {
		goto __183
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+10170 /* "SQL" */)
	return TCL_ERROR
__183:
	;

	dbEvalInit(tls, bp+1160 /* &sEval */, pDb, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0), 0)
	rc = dbEvalStep(tls, bp+1160 /* &sEval */)
	if !(*(*int32)(unsafe.Pointer(bp + 1016 /* choice */)) == 23 /* DB_ONECOLUMN */) {
		goto __184
	}
	if !(rc == TCL_OK) {
		goto __186
	}
	pResult4 = dbEvalColumnValue(tls, bp+1160 /* &sEval */, 0)
	goto __187
__186:
	if !(rc == TCL_BREAK) {
		goto __188
	}
	tcl.XTcl_ResetResult(tls, interp)
__188:
	;
__187:
	;
	goto __185
__184:
	if !((rc == TCL_BREAK) || (rc == TCL_OK)) {
		goto __189
	}
	pResult4 = tcl.XTcl_NewIntObj(tls, (libc.Bool32((libc.Bool32(rc == TCL_OK)) != 0)))
__189:
	;
__185:
	;
	dbEvalFinalize(tls, bp+1160 /* &sEval */)
	if !(pResult4 != 0) {
		goto __190
	}
	tcl.XTcl_SetObjResult(tls, interp, pResult4)
__190:
	;

	if !(rc == TCL_BREAK) {
		goto __191
	}
	rc = TCL_OK
__191:
	;
	goto __3

	//    $db eval ?options? $sql ?array? ?{  ...code... }?
	//
	// The SQL statement in $sql is evaluated.  For each row, the values are
	// placed in elements of the array named "array" and ...code... is executed.
	// If "array" and "code" are omitted, then no callback is every invoked.
	// If "array" is an empty string, then the values are placed in variables
	// that have the same name as the fields extracted by the query.
__22:
	evalFlags = 0
__192:
	if !(((objc > 3) && ((libc.AssignUintptr(&zOpt1, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))))) != uintptr(0))) && (int32(*(*int8)(unsafe.Pointer(zOpt1))) == '-')) {
		goto __193
	}
	if !(libc.Xstrcmp(tls, zOpt1, ts+12226 /* "-withoutnulls" */) == 0) {
		goto __194
	}
	evalFlags = evalFlags | (SQLITE_EVAL_WITHOUTNULLS)
	goto __195
__194:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+640, ts+12240 /* "unknown option: ..." */, zOpt1, ts+11634 /* "\"" */, uintptr(0)))
	return TCL_ERROR
__195:
	;
	objc--
	objv += 4
	goto __192
__193:
	;
	if !((objc < 3) || (objc > 5)) {
		goto __196
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv,
		ts+12258 /* "?OPTIONS? SQL ?A..." */)
	return TCL_ERROR
__196:
	;

	if !(objc == 3) {
		goto __197
	}
	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
	dbEvalInit(tls, bp+1192 /* &sEval1 */, pDb, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0), 0)
__199:
	if !(TCL_OK == (libc.AssignInt32(&rc, dbEvalStep(tls, bp+1192 /* &sEval1 */)))) {
		goto __200
	}
	dbEvalRowInfo(tls, bp+1192 /* &sEval1 */, bp+1224 /* &nCol1 */, uintptr(0))
	i2 = 0
__201:
	if !(i2 < *(*int32)(unsafe.Pointer(bp + 1224 /* nCol1 */))) {
		goto __203
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, dbEvalColumnValue(tls, bp+1192 /* &sEval1 */, i2))
	goto __202
__202:
	i2++
	goto __201
	goto __203
__203:
	;
	goto __199
__200:
	;
	dbEvalFinalize(tls, bp+1192 /* &sEval1 */)
	if !(rc == TCL_BREAK) {
		goto __204
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	rc = TCL_OK
__204:
	;
__205:
	_objPtr1 = pRet
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr1))).FrefCount, 1) <= 1) {
		goto __208
	}
	tcl.XTclFreeObj(tls, _objPtr1)
__208:
	;
	goto __206
__206:
	if 0 != 0 {
		goto __205
	}
	goto __207
__207:
	;
	goto __198
__197:
	pArray = uintptr(0)

	if !((objc >= 5) && (*(*int8)(unsafe.Pointer(tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4))))) != 0)) {
		goto __209
	}
	pArray = *(*uintptr)(unsafe.Pointer(objv + 3*4))
__209:
	;
	pScript = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*4))
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++

	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(DbEvalContext{})))
	dbEvalInit(tls, p, pDb, *(*uintptr)(unsafe.Pointer(objv + 2*4)), pArray, evalFlags)

	*(*ClientData)(unsafe.Pointer(bp + 1228 /* &cd2[0] */)) = p
	*(*ClientData)(unsafe.Pointer(bp + 1228 /* &cd2[0] */ + 1*4)) = pScript
	rc = DbEvalNextCmd(tls, bp+1228 /* &cd2[0] */, interp, TCL_OK)
__198:
	;
	goto __3

	//     $db function NAME [OPTIONS] SCRIPT
	//
	// Create a new SQL function called NAME.  Whenever that function is
	// called, invoke SCRIPT to evaluate the function.
	//
	// Options:
	//         --argcount N           Function has exactly N arguments
	//         --deterministic        The function is pure
	//         --directonly           Prohibit use inside triggers and views
	//         --innocuous            Has no side effects or information leaks
	//         --returntype TYPE      Specify the return type of the function
__23:
	flags1 = SQLITE_UTF8
	*(*int32)(unsafe.Pointer(bp + 1236 /* nArg */)) = -1
	*(*int32)(unsafe.Pointer(bp + 1264 /* eType */)) = SQLITE_NULL
	if !(objc < 4) {
		goto __210
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12294 /* "NAME ?SWITCHES? ..." */)
	return TCL_ERROR
__210:
	;
	i3 = 3
__211:
	if !(i3 < (objc - 1)) {
		goto __213
	}
	z2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i3)*4)))
	n1 = strlen30(tls, z2)
	if !((n1 > 1) && (libc.Xstrncmp(tls, z2, ts+12317 /* "-argcount" */, uint32(n1)) == 0)) {
		goto __214
	}
	if !(i3 == (objc - 2)) {
		goto __216
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+672, ts+12327 /* "option requires ..." */, z2, uintptr(0)))
	return TCL_ERROR
__216:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i3+1))*4)), bp+1236 /* &nArg */) != 0) {
		goto __217
	}
	return TCL_ERROR
__217:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1236 /* nArg */)) < 0) {
		goto __218
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+696, ts+12357, /* "number of argume..." */
		uintptr(0)))
	return TCL_ERROR
__218:
	;
	i3++
	goto __215
__214:
	if !((n1 > 1) && (libc.Xstrncmp(tls, z2, ts+12398 /* "-deterministic" */, uint32(n1)) == 0)) {
		goto __219
	}
	flags1 = flags1 | (SQLITE_DETERMINISTIC)
	goto __220
__219:
	if !((n1 > 1) && (libc.Xstrncmp(tls, z2, ts+12413 /* "-directonly" */, uint32(n1)) == 0)) {
		goto __221
	}
	flags1 = flags1 | (SQLITE_DIRECTONLY)
	goto __222
__221:
	if !((n1 > 1) && (libc.Xstrncmp(tls, z2, ts+12425 /* "-innocuous" */, uint32(n1)) == 0)) {
		goto __223
	}
	flags1 = flags1 | (SQLITE_INNOCUOUS)
	goto __224
__223:
	if !((n1 > 1) && (libc.Xstrncmp(tls, z2, ts+12436 /* "-returntype" */, uint32(n1)) == 0)) {
		goto __225
	}
	*(*[6]uintptr)(unsafe.Pointer(bp + 1240 /* azType */)) = [6]uintptr{ts + 7916 /* "integer" */, ts + 12448 /* "real" */, ts + 12453 /* "text" */, ts + 12458 /* "blob" */, ts + 12463 /* "any" */, uintptr(0)}

	if !(i3 == (objc - 2)) {
		goto __227
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+712, ts+12327 /* "option requires ..." */, z2, uintptr(0)))
	return TCL_ERROR
__227:
	;
	i3++
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i3)*4)), bp+1240 /* &azType[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+12467 /* "type" */, 0, bp+1264 /* &eType */) != 0) {
		goto __228
	}
	return TCL_ERROR
__228:
	;
	*(*int32)(unsafe.Pointer(bp + 1264 /* eType */))++
	goto __226
__225:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+736, ts+11533 /* "bad option \"" */, z2,

		ts+12472 /* "\": must be -argc..." */, uintptr(0)))
	return TCL_ERROR
__226:
	;
__224:
	;
__222:
	;
__220:
	;
__215:
	;
	goto __212
__212:
	i3++
	goto __211
	goto __213
__213:
	;

	pScript1 = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*4))
	zName1 = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0))
	pFunc = findSqlFunc(tls, pDb, zName1)
	if !(pFunc == uintptr(0)) {
		goto __229
	}
	return TCL_ERROR
__229:
	;
	if !((*SqlFunc)(unsafe.Pointer(pFunc)).FpScript != 0) {
		goto __230
	}
__231:
	_objPtr2 = (*SqlFunc)(unsafe.Pointer(pFunc)).FpScript
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr2))).FrefCount, 1) <= 1) {
		goto __234
	}
	tcl.XTclFreeObj(tls, _objPtr2)
__234:
	;
	goto __232
__232:
	if 0 != 0 {
		goto __231
	}
	goto __233
__233:
	;
__230:
	;
	(*SqlFunc)(unsafe.Pointer(pFunc)).FpScript = pScript1
	(*Tcl_Obj)(unsafe.Pointer(pScript1)).FrefCount++
	(*SqlFunc)(unsafe.Pointer(pFunc)).FuseEvalObjv = safeToUseEvalObjv(tls, interp, pScript1)
	(*SqlFunc)(unsafe.Pointer(pFunc)).FeType = *(*int32)(unsafe.Pointer(bp + 1264 /* eType */))
	rc = sqlite3.Xsqlite3_create_function(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zName1, *(*int32)(unsafe.Pointer(bp + 1236 /* nArg */)), flags1,
		pFunc, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tclSqlFunc})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __235
	}
	rc = TCL_ERROR
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
__235:
	;
	goto __3

	//     $db incrblob ?-readonly? ?DB? TABLE COLUMN ROWID
__24:
	isReadonly1 = 0
	zDb = ts + 85 /* "main" */

	// Check for the -readonly option
	if !((objc > 3) && (libc.Xstrcmp(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), ts+12123 /* "-readonly" */) == 0)) {
		goto __236
	}
	isReadonly1 = 1
__236:
	;

	if !((objc != (5 + isReadonly1)) && (objc != (6 + isReadonly1))) {
		goto __237
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12550 /* "?-readonly? ?DB?..." */)
	return TCL_ERROR
__237:
	;

	if !(objc == (6 + isReadonly1)) {
		goto __238
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
__238:
	;
	zTable1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-3))*4)))
	zColumn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-2))*4)))
	rc = tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*4)), bp+1272 /* &iRow */)

	if !(rc == TCL_OK) {
		goto __239
	}
	rc = createIncrblobChannel(tls,
		interp, pDb, zDb, zTable1, zColumn, *(*Tcl_WideInt)(unsafe.Pointer(bp + 1272 /* iRow */)), isReadonly1)
__239:
	;
	goto __3

	//     $db interrupt
	//
	// Interrupt the execution of the inner-most SQL interpreter.  This
	// causes the SQL statement to return an error of SQLITE_INTERRUPT.
__25:
	sqlite3.Xsqlite3_interrupt(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	goto __3

	//     $db nullvalue ?STRING?
	//
	// Change text used when a NULL comes back from the database. If ?STRING?
	// is not present, then the current string used for NULL is returned.
	// If STRING is present, then STRING is returned.
	//
__26:
	if !((objc != 2) && (objc != 3)) {
		goto __240
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12586 /* "NULLVALUE" */)
	return TCL_ERROR
__240:
	;
	if !(objc == 3) {
		goto __241
	}
	zNull1 = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1280 /* &len5 */)
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzNull != 0) {
		goto __242
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull)
__242:
	;
	if !((zNull1 != 0) && (*(*int32)(unsafe.Pointer(bp + 1280 /* len5 */)) > 0)) {
		goto __243
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzNull = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1280 /* len5 */)) + 1)))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull, zNull1, uint32(*(*int32)(unsafe.Pointer(bp + 1280 /* len5 */))))
	*(*int8)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FzNull + uintptr(*(*int32)(unsafe.Pointer(bp + 1280 /* len5 */))))) = int8(0)
	goto __244
__243:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzNull = uintptr(0)
__244:
	;
__241:
	;
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull, -1))
	goto __3

	//     $db last_insert_rowid
	//
	// Return an integer which is the ROWID for the most recent insert.
__27:
	if !(objc != 2) {
		goto __245
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+489 /* "" */)
	return TCL_ERROR
__245:
	;
	rowid = sqlite3.Xsqlite3_last_insert_rowid(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	pResult5 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetWideIntObj(tls, pResult5, rowid)
	goto __3

	// The DB_ONECOLUMN method is implemented together with DB_EXISTS.

	// $db progress ?N CALLBACK?
	//
	// Invoke the given callback every N virtual machine opcodes while executing
	// queries.
__28:
	if !(objc == 2) {
		goto __246
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0) {
		goto __248
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+768, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress, uintptr(0)))
__248:
	;
	goto __247
__246:
	if !(objc == 4) {
		goto __249
	}
	if !(TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1284 /* &N */)) {
		goto __251
	}
	return TCL_ERROR
__251:
	;

	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0) {
		goto __252
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress)
__252:
	;
	zProgress = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1288 /* &len6 */)
	if !((zProgress != 0) && (*(*int32)(unsafe.Pointer(bp + 1288 /* len6 */)) > 0)) {
		goto __253
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProgress = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1288 /* len6 */)) + 1)))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress, zProgress, (uint32(*(*int32)(unsafe.Pointer(bp + 1288 /* len6 */)) + 1)))
	goto __254
__253:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProgress = uintptr(0)
__254:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0) {
		goto __255
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_progress_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1284 /* N */)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{DbProgressHandler})), pDb)
	goto __256
__255:
	sqlite3.Xsqlite3_progress_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, 0, uintptr(0), uintptr(0))
__256:
	;
	goto __250
__249:
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12596 /* "N CALLBACK" */)
	return TCL_ERROR
__250:
	;
__247:
	;
	goto __3

	// $db profile ?CALLBACK?
	//
	// Make arrangements to invoke the CALLBACK routine after each SQL statement
	// that has run.  The text of the SQL and the amount of elapse time are
	// appended to CALLBACK before the script is run.
__29:
	if !(objc > 3) {
		goto __257
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11380 /* "?CALLBACK?" */)
	return TCL_ERROR
	goto __258
__257:
	if !(objc == 2) {
		goto __259
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0) {
		goto __261
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+784, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, uintptr(0)))
__261:
	;
	goto __260
__259:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0) {
		goto __262
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile)
__262:
	;
	zProfile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1292 /* &len7 */)
	if !((zProfile != 0) && (*(*int32)(unsafe.Pointer(bp + 1292 /* len7 */)) > 0)) {
		goto __263
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProfile = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1292 /* len7 */)) + 1)))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, zProfile, (uint32(*(*int32)(unsafe.Pointer(bp + 1292 /* len7 */)) + 1)))
	goto __264
__263:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProfile = uintptr(0)
__264:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0) {
		goto __265
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_profile(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, sqlite_uint64)
	}{DbProfileHandler})), pDb)
	goto __266
__265:
	sqlite3.Xsqlite3_profile(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__266:
	;
__260:
	;
__258:
	;
	goto __3

	//     $db rekey KEY
	//
	// Change the encryption key on the currently open database.
__30:
	if !(objc != 3) {
		goto __267
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12607 /* "KEY" */)
	return TCL_ERROR
__267:
	;
	goto __3

	// $db restore ?DATABASE? FILENAME
	//
	// Open a database file named FILENAME.  Transfer the content
	// of FILENAME into the local database DATABASE (default: "main").
__31:
	nTimeout = 0

	if !(objc == 3) {
		goto __268
	}
	zDestDb = ts + 85 /* "main" */
	zSrcFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	goto __269
__268:
	if !(objc == 4) {
		goto __270
	}
	zDestDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	zSrcFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	goto __271
__270:
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11391 /* "?DATABASE? FILEN..." */)
	return TCL_ERROR
__271:
	;
__269:
	;
	rc = sqlite3.Xsqlite3_open_v2(tls, zSrcFile, bp+1296, /* &pSrc */
		(SQLITE_OPEN_READONLY | (*SqliteDb)(unsafe.Pointer(pDb)).FopenFlags), uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __272
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+800, ts+12611, /* "cannot open sour..." */
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1296 /* pSrc */))), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1296 /* pSrc */)))
	return TCL_ERROR
__272:
	;
	pBackup1 = sqlite3.Xsqlite3_backup_init(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zDestDb, *(*uintptr)(unsafe.Pointer(bp + 1296 /* pSrc */)), ts+85 /* "main" */)
	if !(pBackup1 == uintptr(0)) {
		goto __273
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+824, ts+12641, /* "restore failed: " */
		sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1296 /* pSrc */)))
	return TCL_ERROR
__273:
	;
__274:
	if !(((libc.AssignInt32(&rc, sqlite3.Xsqlite3_backup_step(tls, pBackup1, 100))) == SQLITE_OK) ||
		(rc == SQLITE_BUSY)) {
		goto __275
	}
	if !(rc == SQLITE_BUSY) {
		goto __276
	}
	if !(libc.PostIncInt32(&nTimeout, 1) >= 3) {
		goto __277
	}
	goto __275
__277:
	;
	sqlite3.Xsqlite3_sleep(tls, 100)
__276:
	;
	goto __274
__275:
	;
	sqlite3.Xsqlite3_backup_finish(tls, pBackup1)
	if !(rc == SQLITE_DONE) {
		goto __278
	}
	rc = TCL_OK
	goto __279
__278:
	if !((rc == SQLITE_BUSY) || (rc == SQLITE_LOCKED)) {
		goto __280
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+848, ts+12658, /* "restore failed: ..." */
		uintptr(0)))
	rc = TCL_ERROR
	goto __281
__280:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+864, ts+12641, /* "restore failed: " */
		sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	rc = TCL_ERROR
__281:
	;
__279:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1296 /* pSrc */)))
	goto __3

	//     $db serialize ?DATABASE?
	//
	// Return a serialization of a database.
__32:
	if objc >= 3 {
		zSchema1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	} else {
		zSchema1 = ts + 85 /* "main" */
	}
	*(*sqlite3_int64)(unsafe.Pointer(bp + 1304 /* sz */)) = int64(0)
	if !((objc != 2) && (objc != 3)) {
		goto __282
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12695 /* "?DATABASE?" */)
	rc = TCL_ERROR
	goto __283
__282:
	pData1 = sqlite3.Xsqlite3_serialize(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema1, bp+1304 /* &sz */, uint32(SQLITE_SERIALIZE_NOCOPY))
	if !(pData1 != 0) {
		goto __284
	}
	needFree = 0
	goto __285
__284:
	pData1 = sqlite3.Xsqlite3_serialize(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema1, bp+1304 /* &sz */, uint32(0))
	needFree = 1
__285:
	;
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, pData1, int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 1304 /* sz */)))))
	if !(needFree != 0) {
		goto __286
	}
	sqlite3.Xsqlite3_free(tls, pData1)
__286:
	;
__283:
	;
	goto __3

	//     $db status (step|sort|autoindex|vmstep)
	//
	// Display SQLITE_STMTSTATUS_FULLSCAN_STEP or
	// SQLITE_STMTSTATUS_SORT for the most recent eval.
__33:
	if !(objc != 3) {
		goto __287
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12706 /* "(step|sort|autoi..." */)
	return TCL_ERROR
__287:
	;
	zOp = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if !(libc.Xstrcmp(tls, zOp, ts+10120 /* "step" */) == 0) {
		goto __288
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnStep
	goto __289
__288:
	if !(libc.Xstrcmp(tls, zOp, ts+12728 /* "sort" */) == 0) {
		goto __290
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnSort
	goto __291
__290:
	if !(libc.Xstrcmp(tls, zOp, ts+12733 /* "autoindex" */) == 0) {
		goto __292
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnIndex
	goto __293
__292:
	if !(libc.Xstrcmp(tls, zOp, ts+12743 /* "vmstep" */) == 0) {
		goto __294
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnVMStep
	goto __295
__294:
	tcl.XTcl_AppendResult(tls, interp,
		libc.VaList(bp+888, ts+12750, /* "bad argument: sh..." */
			uintptr(0)))
	return TCL_ERROR
__295:
	;
__293:
	;
__291:
	;
__289:
	;
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, v2))
	goto __3

	//     $db timeout MILLESECONDS
	//
	// Delay for the number of milliseconds specified when a file is locked.
__34:
	if !(objc != 3) {
		goto __296
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12806 /* "MILLISECONDS" */)
	return TCL_ERROR
__296:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1312 /* &ms */) != 0) {
		goto __297
	}
	return TCL_ERROR
__297:
	;
	sqlite3.Xsqlite3_busy_timeout(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1312 /* ms */)))
	goto __3

	//     $db total_changes
	//
	// Return the number of rows that were modified, inserted, or deleted
	// since the database handle was created.
__35:
	if !(objc != 2) {
		goto __298
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+489 /* "" */)
	return TCL_ERROR
__298:
	;
	pResult6 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetIntObj(tls, pResult6, sqlite3.Xsqlite3_total_changes(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
	goto __3

	// $db trace ?CALLBACK?
	//
	// Make arrangements to invoke the CALLBACK routine for each SQL statement
	// that is executed.  The text of the SQL is appended to CALLBACK before
	// it is executed.
__36:
	if !(objc > 3) {
		goto __299
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11380 /* "?CALLBACK?" */)
	return TCL_ERROR
	goto __300
__299:
	if !(objc == 2) {
		goto __301
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0) {
		goto __303
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+904, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, uintptr(0)))
__303:
	;
	goto __302
__301:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0) {
		goto __304
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace)
__304:
	;
	zTrace = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1316 /* &len8 */)
	if !((zTrace != 0) && (*(*int32)(unsafe.Pointer(bp + 1316 /* len8 */)) > 0)) {
		goto __305
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTrace = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1316 /* len8 */)) + 1)))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, zTrace, (uint32(*(*int32)(unsafe.Pointer(bp + 1316 /* len8 */)) + 1)))
	goto __306
__305:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTrace = uintptr(0)
__306:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0) {
		goto __307
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_trace(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{DbTraceHandler})), pDb)
	goto __308
__307:
	sqlite3.Xsqlite3_trace(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__308:
	;
__302:
	;
__300:
	;
	goto __3

	// $db trace_v2 ?CALLBACK? ?MASK?
	//
	// Make arrangements to invoke the CALLBACK routine for each trace event
	// matching the mask that is generated.  The parameters are appended to
	// CALLBACK before it is executed.
__37:
	if !(objc > 4) {
		goto __309
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12819 /* "?CALLBACK? ?MASK..." */)
	return TCL_ERROR
	goto __310
__309:
	if !(objc == 2) {
		goto __311
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0) {
		goto __313
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+920, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, uintptr(0)))
__313:
	;
	goto __312
__311:
	wMask = int64(0)
	if !(objc == 4) {
		goto __314
	}
	if !(TCL_OK != tcl.XTcl_ListObjLength(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1320 /* &len9 */)) {
		goto __316
	}
	return TCL_ERROR
__316:
	;
	i4 = 0
__317:
	if !(i4 < *(*int32)(unsafe.Pointer(bp + 1320 /* len9 */))) {
		goto __319
	}
	if !(TCL_OK != tcl.XTcl_ListObjIndex(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), i4, bp+1324 /* &pObj */)) {
		goto __320
	}
	return TCL_ERROR
__320:
	;
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 1324 /* pObj */)), uintptr(unsafe.Pointer(&TTYPE_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+12837 /* "trace type" */, 0, bp+1328 /* &ttype */) != TCL_OK) {
		goto __321
	}
	pError = tcl.XTcl_DuplicateObj(tls, tcl.XTcl_GetObjResult(tls, interp))
	(*Tcl_Obj)(unsafe.Pointer(pError)).FrefCount++
	if !(TCL_OK == tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 1324 /* pObj */)), bp+1336 /* &wType */)) {
		goto __323
	}
__325:
	_objPtr3 = pError
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr3))).FrefCount, 1) <= 1) {
		goto __328
	}
	tcl.XTclFreeObj(tls, _objPtr3)
__328:
	;
	goto __326
__326:
	if 0 != 0 {
		goto __325
	}
	goto __327
__327:
	;
	wMask = wMask | (*(*Tcl_WideInt)(unsafe.Pointer(bp + 1336 /* wType */)))
	goto __324
__323:
	tcl.XTcl_SetObjResult(tls, interp, pError)
__329:
	_objPtr4 = pError
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr4))).FrefCount, 1) <= 1) {
		goto __332
	}
	tcl.XTclFreeObj(tls, _objPtr4)
__332:
	;
	goto __330
__330:
	if 0 != 0 {
		goto __329
	}
	goto __331
__331:
	;
	return TCL_ERROR
__324:
	;
	goto __322
__321:
	switch uint32(*(*int32)(unsafe.Pointer(bp + 1328 /* ttype */))) {
	case uint32(0) /* TTYPE_STMT */ :
		goto __334
	case uint32(1) /* TTYPE_PROFILE */ :
		goto __335
	case uint32(2) /* TTYPE_ROW */ :
		goto __336
	case uint32(3) /* TTYPE_CLOSE */ :
		goto __337
	}
	goto __333
__334:
	wMask = wMask | (int64(SQLITE_TRACE_STMT))
	goto __333
__335:
	wMask = wMask | (int64(SQLITE_TRACE_PROFILE))
	goto __333
__336:
	wMask = wMask | (int64(SQLITE_TRACE_ROW))
	goto __333
__337:
	wMask = wMask | (int64(SQLITE_TRACE_CLOSE))
	goto __333
__333:
	;
__322:
	;
	goto __318
__318:
	i4++
	goto __317
	goto __319
__319:
	;
	goto __315
__314:
	wMask = int64(SQLITE_TRACE_STMT) // use the "legacy" default
__315:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0) {
		goto __338
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2)
__338:
	;
	zTraceV2 = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1320 /* &len9 */)
	if !((zTraceV2 != 0) && (*(*int32)(unsafe.Pointer(bp + 1320 /* len9 */)) > 0)) {
		goto __339
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1320 /* len9 */)) + 1)))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, zTraceV2, (uint32(*(*int32)(unsafe.Pointer(bp + 1320 /* len9 */)) + 1)))
	goto __340
__339:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 = uintptr(0)
__340:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0) {
		goto __341
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_trace_v2(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uint32(wMask), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uint32, uintptr, uintptr, uintptr) int32
	}{DbTraceV2Handler})), pDb)
	goto __342
__341:
	sqlite3.Xsqlite3_trace_v2(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uint32(0), uintptr(0), uintptr(0))
__342:
	;
__312:
	;
__310:
	;
	goto __3

	// $db transaction [-deferred|-immediate|-exclusive] SCRIPT
	//
	// Start a new transaction (if we are not already in the midst of a
	// transaction) and execute the TCL script SCRIPT.  After SCRIPT
	// completes, either commit the transaction or roll it back if SCRIPT
	// throws an exception.  Or if no new transation was started, do nothing.
	// pass the exception on up the stack.
	//
	// This command was inspired by Dave Thomas's talk on Ruby at the
	// 2005 O'Reilly Open Source Convention (OSCON).
__38:
	zBegin = ts + 12848 /* "SAVEPOINT _tcl_t..." */
	if !((objc != 3) && (objc != 4)) {
		goto __343
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12875 /* "[TYPE] SCRIPT" */)
	return TCL_ERROR
__343:
	;

	if !(((*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction == 0) && (objc == 4)) {
		goto __344
	}
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(unsafe.Pointer(&TTYPE_strs1)), int32(unsafe.Sizeof(uintptr(0))), ts+12889 /* "transaction type" */, 0, bp+1344 /* &ttype1 */) != 0) {
		goto __345
	}
	return TCL_ERROR
__345:
	;
	switch uint32(*(*int32)(unsafe.Pointer(bp + 1344 /* ttype1 */))) {
	case uint32(0) /* TTYPE_DEFERRED */ :
		goto __347
	case uint32(1) /* TTYPE_EXCLUSIVE */ :
		goto __348
	case uint32(2) /* TTYPE_IMMEDIATE */ :
		goto __349
	}
	goto __346
__347: /* no-op */
	;
	goto __346
__348:
	zBegin = ts + 12906 /* "BEGIN EXCLUSIVE" */
	goto __346
__349:
	zBegin = ts + 12922 /* "BEGIN IMMEDIATE" */
	goto __346
__346:
	;
__344:
	;
	pScript2 = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*4))

	// Run the SQLite BEGIN command to open a transaction or savepoint.
	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth++
	rc = sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zBegin, uintptr(0), uintptr(0), uintptr(0))
	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth--
	if !(rc != SQLITE_OK) {
		goto __350
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+936, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	return TCL_ERROR
__350:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction++

	// If using NRE, schedule a callback to invoke the script pScript, then
	// a second callback to commit (or rollback) the transaction or savepoint
	// opened above. If not using NRE, evaluate the script directly, then
	// call function DbTransPostCmd() to commit (or rollback) the transaction
	// or savepoint.
	if !(DbUseNre(tls) != 0) {
		goto __351
	}
	tcl.XTcl_NRAddCallback(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{DbTransPostCmd})), *(*uintptr)(unsafe.Pointer(bp + 1348 /* cd */)), uintptr(0), uintptr(0), uintptr(0))
	tcl.XTcl_NREvalObj(tls, interp, pScript2, 0)
	goto __352
__351:
	rc = DbTransPostCmd(tls, bp+1348 /* &cd */, interp, tcl.XTcl_EvalObjEx(tls, interp, pScript2, 0))
__352:
	;
	goto __3

	//    $db unlock_notify ?script?
__39:
	if !((objc != 2) && (objc != 3)) {
		goto __353
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12938 /* "?SCRIPT?" */)
	rc = TCL_ERROR
	goto __354
__353:
	xNotify = uintptr(0)
	pNotifyArg = uintptr(0)

	if !((*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify != 0) {
		goto __355
	}
__356:
	_objPtr5 = (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr5))).FrefCount, 1) <= 1) {
		goto __359
	}
	tcl.XTclFreeObj(tls, _objPtr5)
__359:
	;
	goto __357
__357:
	if 0 != 0 {
		goto __356
	}
	goto __358
__358:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = uintptr(0)
__355:
	;

	if !(objc == 3) {
		goto __360
	}
	xNotify = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32)
	}{DbUnlockNotify}))
	pNotifyArg = pDb
	(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = *(*uintptr)(unsafe.Pointer(objv + 2*4))
	(*Tcl_Obj)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify)).FrefCount++
__360:
	;

	if !(sqlite3.Xsqlite3_unlock_notify(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, xNotify, pNotifyArg) != 0) {
		goto __361
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+952, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	rc = TCL_ERROR
__361:
	;
__354:
	;
	goto __3

	//    $db preupdate_hook count
	//    $db preupdate_hook hook ?SCRIPT?
	//    $db preupdate_hook new INDEX
	//    $db preupdate_hook old INDEX
__40:

	if !(objc < 3) {
		goto __362
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12947 /* "SUB-COMMAND ?ARG..." */)
__362:
	;
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(unsafe.Pointer(&azSub)), int32(unsafe.Sizeof(uintptr(0))), ts+1875 /* "sub-command" */, 0, bp+1352 /* &iSub */) != 0) {
		goto __363
	}
	return TCL_ERROR
__363:
	;

	switch uint32(*(*int32)(unsafe.Pointer(bp + 1352 /* iSub */))) {
	case uint32(0) /* PRE_COUNT */ :
		goto __365

	case uint32(2) /* PRE_HOOK */ :
		goto __366

	case uint32(1) /* PRE_DEPTH */ :
		goto __367

	case uint32(3) /* PRE_NEW */ :
		goto __368
	case uint32(4) /* PRE_OLD */ :
		goto __369
	}
	goto __364
__365:
	nCol2 = sqlite3.Xsqlite3_preupdate_count(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nCol2))
	goto __364

__366:
	if !(objc > 4) {
		goto __370
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12966 /* "hook ?SCRIPT?" */)
	return TCL_ERROR
__370:
	;
	DbHookCmd(tls, interp, pDb, func() uintptr {
		if objc == 4 {
			return *(*uintptr)(unsafe.Pointer(objv + 3*4))
		}
		return uintptr(0)
	}(), (pDb + 56 /* &.pPreUpdateHook */))
	goto __364

__367:
	if !(objc != 3) {
		goto __371
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 3, objv, ts+489 /* "" */)
	return TCL_ERROR
__371:
	;
	pRet1 = tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_preupdate_depth(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
	tcl.XTcl_SetObjResult(tls, interp, pRet1)
	goto __364

__368:
__369:
	if !(objc != 4) {
		goto __372
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 3, objv, ts+12980 /* "INDEX" */)
	return TCL_ERROR
__372:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1356 /* &iIdx */) != 0) {
		goto __373
	}
	return TCL_ERROR
__373:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 1352 /* iSub */)) == 4 /* PRE_OLD */) {
		goto __374
	}
	rc = sqlite3.Xsqlite3_preupdate_old(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1356 /* iIdx */)), bp+1360 /* &pValue1 */)
	goto __375
__374:
	;
	rc = sqlite3.Xsqlite3_preupdate_new(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1356 /* iIdx */)), bp+1360 /* &pValue1 */)
__375:
	;

	if !(rc == SQLITE_OK) {
		goto __376
	}
	pObj1 = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(bp + 1360 /* pValue1 */))), -1)
	tcl.XTcl_SetObjResult(tls, interp, pObj1)
	goto __377
__376:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+968, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	return TCL_ERROR
__377:
	;

__364:
	;
	goto __3

	//    $db wal_hook ?script?
	//    $db update_hook ?script?
	//    $db rollback_hook ?script?
__41:
__42:
__43:
	// set ppHook to point at pUpdateHook or pRollbackHook, depending on
	// whether [$db update_hook] or [$db rollback_hook] was invoked.
	ppHook = uintptr(0)
	if !(*(*int32)(unsafe.Pointer(bp + 1016 /* choice */)) == 40 /* DB_WAL_HOOK */) {
		goto __378
	}
	ppHook = (pDb + 64 /* &.pWalHook */)
__378:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1016 /* choice */)) == 38 /* DB_UPDATE_HOOK */) {
		goto __379
	}
	ppHook = (pDb + 52 /* &.pUpdateHook */)
__379:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1016 /* choice */)) == 29 /* DB_ROLLBACK_HOOK */) {
		goto __380
	}
	ppHook = (pDb + 60 /* &.pRollbackHook */)
__380:
	;
	if !(objc > 3) {
		goto __381
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12938 /* "?SCRIPT?" */)
	return TCL_ERROR
__381:
	;

	DbHookCmd(tls, interp, pDb, func() uintptr {
		if objc == 3 {
			return *(*uintptr)(unsafe.Pointer(objv + 2*4))
		}
		return uintptr(0)
	}(), ppHook)
	goto __3

	// $db version
	//
	// Return the version string for this database.
__44:
	i5 = 2
__382:
	if !(i5 < objc) {
		goto __384
	}
	zArg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i5)*4)))
	// Optional arguments to $db version are used for testing purpose
	// $db version -use-legacy-prepare BOOLEAN
	//
	// Turn the use of legacy sqlite3_prepare() on or off.
	if !((libc.Xstrcmp(tls, zArg, ts+12986 /* "-use-legacy-prep..." */) == 0) && ((i5 + 1) < objc)) {
		goto __385
	}
	i5++
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i5)*4)), (pDb+128 /* &.bLegacyPrepare */)) != 0) {
		goto __387
	}
	return TCL_ERROR
__387:
	;
	goto __386
__385:

	// $db version -last-stmt-ptr
	//
	// Return a string which is a hex encoding of the pointer to the
	// most recent sqlite3_stmt in the statement cache.
	if !(libc.Xstrcmp(tls, zArg, ts+13006 /* "-last-stmt-ptr" */) == 0) {
		goto __388
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+1364 /* &zBuf[0] */, ts+13021, /* "%p" */
		libc.VaList(bp+984, func() uintptr {
			if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList != 0 {
				return (*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtList)).FpStmt
			}
			return uintptr(0)
		}()))
	tcl.XTcl_SetResult(tls, interp, bp+1364 /* &zBuf[0] */, uintptr(1))
	goto __389
__388:

	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+992, ts+13024 /* "unknown argument..." */, zArg, uintptr(0)))
	return TCL_ERROR
__389:
	;
__386:
	;
	goto __383
__383:
	i5++
	goto __382
	goto __384
__384:
	;
	if !(i5 == 2) {
		goto __390
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_libversion(tls), uintptr(0))
__390:
	;
	goto __3

__3:
	; // End of the SWITCH statement
	return rc
}

type DbConfigChoices = struct {
	FzName uintptr
	Fop    int32
} /* tclsqlite.c:2340:18 */

var DB_strs = [42]uintptr{
	ts + 13043 /* "authorizer" */, ts + 13054 /* "backup" */, ts + 13061, /* "bind_fallback" */
	ts + 13075 /* "busy" */, ts + 13080 /* "cache" */, ts + 13086, /* "changes" */
	ts + 10125 /* "close" */, ts + 13094 /* "collate" */, ts + 13102, /* "collation_needed" */
	ts + 13119 /* "commit_hook" */, ts + 13131 /* "complete" */, ts + 13140, /* "config" */
	ts + 13147 /* "copy" */, ts + 13152 /* "deserialize" */, ts + 13164, /* "enable_load_exte..." */
	ts + 13186 /* "errorcode" */, ts + 4757 /* "eval" */, ts + 13196, /* "exists" */
	ts + 13203 /* "function" */, ts + 10524 /* "incrblob" */, ts + 13212, /* "interrupt" */
	ts + 13222 /* "last_insert_rowi..." */, ts + 13240 /* "nullvalue" */, ts + 13250, /* "onecolumn" */
	ts + 13260 /* "preupdate" */, ts + 13270 /* "profile" */, ts + 10199, /* "progress" */
	ts + 13278 /* "rekey" */, ts + 13284 /* "restore" */, ts + 13292, /* "rollback_hook" */
	ts + 13306 /* "serialize" */, ts + 13316 /* "status" */, ts + 13323, /* "timeout" */
	ts + 13331 /* "total_changes" */, ts + 13345 /* "trace" */, ts + 13351, /* "trace_v2" */
	ts + 13360 /* "transaction" */, ts + 13372 /* "unlock_notify" */, ts + 13386, /* "update_hook" */
	ts + 13398 /* "version" */, ts + 13406 /* "wal_hook" */, uintptr(0),
} /* tclsqlite.c:1916:21 */
var aDbConfig = [16]DbConfigChoices{
	{FzName: ts + 13415 /* "defensive" */, Fop: SQLITE_DBCONFIG_DEFENSIVE},
	{FzName: ts + 13425 /* "dqs_ddl" */, Fop: SQLITE_DBCONFIG_DQS_DDL},
	{FzName: ts + 13433 /* "dqs_dml" */, Fop: SQLITE_DBCONFIG_DQS_DML},
	{FzName: ts + 13441 /* "enable_fkey" */, Fop: SQLITE_DBCONFIG_ENABLE_FKEY},
	{FzName: ts + 13453 /* "enable_qpsg" */, Fop: SQLITE_DBCONFIG_ENABLE_QPSG},
	{FzName: ts + 13465 /* "enable_trigger" */, Fop: SQLITE_DBCONFIG_ENABLE_TRIGGER},
	{FzName: ts + 13480 /* "enable_view" */, Fop: SQLITE_DBCONFIG_ENABLE_VIEW},
	{FzName: ts + 13492 /* "fts3_tokenizer" */, Fop: SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER},
	{FzName: ts + 13507 /* "legacy_alter_tab..." */, Fop: SQLITE_DBCONFIG_LEGACY_ALTER_TABLE},
	{FzName: ts + 13526 /* "legacy_file_form..." */, Fop: SQLITE_DBCONFIG_LEGACY_FILE_FORMAT},
	{FzName: ts + 13545 /* "load_extension" */, Fop: SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION},
	{FzName: ts + 13560 /* "no_ckpt_on_close" */, Fop: SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE},
	{FzName: ts + 13577 /* "reset_database" */, Fop: SQLITE_DBCONFIG_RESET_DATABASE},
	{FzName: ts + 13592 /* "trigger_eqp" */, Fop: SQLITE_DBCONFIG_TRIGGER_EQP},
	{FzName: ts + 13604 /* "trusted_schema" */, Fop: SQLITE_DBCONFIG_TRUSTED_SCHEMA},
	{FzName: ts + 13619 /* "writable_schema" */, Fop: SQLITE_DBCONFIG_WRITABLE_SCHEMA},
} /* tclsqlite.c:2343:7 */
var TTYPE_strs = [5]uintptr{
	ts + 13635 /* "statement" */, ts + 13270 /* "profile" */, ts + 13645 /* "row" */, ts + 10125 /* "close" */, uintptr(0),
} /* tclsqlite.c:3321:27 */
var TTYPE_strs1 = [4]uintptr{
	ts + 13649 /* "deferred" */, ts + 13658 /* "exclusive" */, ts + 13668 /* "immediate" */, uintptr(0),
}                                                                                                                                                              /* tclsqlite.c:3404:25 */
var azSub = [6]uintptr{ts + 1826 /* "count" */, ts + 13678 /* "depth" */, ts + 13684 /* "hook" */, ts + 13689 /* "new" */, ts + 13693 /* "old" */, uintptr(0)} /* tclsqlite.c:3496:23 */

// Adaptor that provides an objCmd interface to the NRE-enabled
// interface implementation.
func DbObjCmdAdaptor(tls *libc.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* tclsqlite.c:3647:26: */
	return tcl.XTcl_NRCallObjProc(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{DbObjCmd})), cd, objc, objv)
}

// Issue the usage message when the "sqlite3" command arguments are
// incorrect.
func sqliteCmdUsage(tls *libc.TLS, interp uintptr, objv uintptr) int32 { /* tclsqlite.c:3661:12: */
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,

		ts+13697 /* "HANDLE ?FILENAME..." */)
	return TCL_ERROR
}

//   sqlite3 DBNAME FILENAME ?-vfs VFSNAME? ?-key KEY? ?-readonly BOOLEAN?
//                           ?-create BOOLEAN? ?-nomutex BOOLEAN?
//                           ?-nofollow BOOLEAN?
//
// This is the main Tcl command.  When the "sqlite" Tcl command is
// invoked, this routine runs to process that command.
//
// The first argument, DBNAME, is an arbitrary name for a new
// database connection.  This command creates a new command named
// DBNAME that is used to control that connection.  The database
// connection is deleted when the DBNAME command is deleted.
//
// The second argument is the name of the database file.
//
func DbMain(tls *libc.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* tclsqlite.c:3689:26: */
	bp := tls.Alloc(328)
	defer tls.Free(328)

	var p uintptr
	var zArg uintptr
	var zErrMsg uintptr
	var i int32
	var zFile uintptr = uintptr(0)
	var zVfs uintptr = uintptr(0)
	var flags int32
	*(*int32)(unsafe.Pointer(bp + 112 /* bTranslateFileName */)) = 1
	// var translatedFilename Tcl_DString at bp+116, 212

	var rc int32

	// In normal use, each TCL interpreter runs in a single thread.  So
	// by default, we can turn off mutexing on SQLite database connections.
	// However, for testing purposes it is useful to have mutexes turned
	// on.  So, by default, mutexes default off.  But if compiled with
	// SQLITE_TCL_DEFAULT_FULLMUTEX then mutexes default on.
	flags = ((SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE) | SQLITE_OPEN_NOMUTEX)

	if objc == 1 {
		return sqliteCmdUsage(tls, interp, objv)
	}
	if objc == 2 {
		zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(0))
		if libc.Xstrcmp(tls, zArg, ts+13843 /* "-version" */) == 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_libversion(tls), uintptr(0)))
			return TCL_OK
		}
		if libc.Xstrcmp(tls, zArg, ts+13852 /* "-sourceid" */) == 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, sqlite3.Xsqlite3_sourceid(tls), uintptr(0)))
			return TCL_OK
		}
		if libc.Xstrcmp(tls, zArg, ts+13862 /* "-has-codec" */) == 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+13873 /* "0" */, uintptr(0)))
			return TCL_OK
		}
		if int32(*(*int8)(unsafe.Pointer(zArg))) == '-' {
			return sqliteCmdUsage(tls, interp, objv)
		}
	}
	for i = 2; i < objc; i++ {
		zArg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)))
		if int32(*(*int8)(unsafe.Pointer(zArg))) != '-' {
			if zFile != uintptr(0) {
				return sqliteCmdUsage(tls, interp, objv)
			}
			zFile = zArg
			continue
		}
		if i == (objc - 1) {
			return sqliteCmdUsage(tls, interp, objv)
		}
		i++
		if libc.Xstrcmp(tls, zArg, ts+13875 /* "-key" */) == 0 {
			// no-op
		} else if libc.Xstrcmp(tls, zArg, ts+13880 /* "-vfs" */) == 0 {
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)))
		} else if libc.Xstrcmp(tls, zArg, ts+12123 /* "-readonly" */) == 0 {
			// var b int32 at bp+88, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+88 /* &b */) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 88 /* b */)) != 0 {
				flags = flags & (libc.CplInt32((SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE)))
				flags = flags | (SQLITE_OPEN_READONLY)
			} else {
				flags = flags & (libc.CplInt32(SQLITE_OPEN_READONLY))
				flags = flags | (SQLITE_OPEN_READWRITE)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+13885 /* "-create" */) == 0 {
			// var b int32 at bp+92, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+92 /* &b */) != 0 {
				return TCL_ERROR
			}
			if (*(*int32)(unsafe.Pointer(bp + 92 /* b */)) != 0) && ((flags & SQLITE_OPEN_READONLY) == 0) {
				flags = flags | (SQLITE_OPEN_CREATE)
			} else {
				flags = flags & (libc.CplInt32(SQLITE_OPEN_CREATE))
			}
		} else if libc.Xstrcmp(tls, zArg, ts+13893 /* "-nofollow" */) == 0 {
			// var b int32 at bp+96, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+96 /* &b */) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 96 /* b */)) != 0 {
				flags = flags | (SQLITE_OPEN_NOFOLLOW)
			} else {
				flags = flags & (libc.CplInt32(SQLITE_OPEN_NOFOLLOW))
			}
		} else if libc.Xstrcmp(tls, zArg, ts+13903 /* "-nomutex" */) == 0 {
			// var b int32 at bp+100, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+100 /* &b */) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 100 /* b */)) != 0 {
				flags = flags | (SQLITE_OPEN_NOMUTEX)
				flags = flags & (libc.CplInt32(SQLITE_OPEN_FULLMUTEX))
			} else {
				flags = flags & (libc.CplInt32(SQLITE_OPEN_NOMUTEX))
			}
		} else if libc.Xstrcmp(tls, zArg, ts+13912 /* "-fullmutex" */) == 0 {
			// var b int32 at bp+104, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+104 /* &b */) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 104 /* b */)) != 0 {
				flags = flags | (SQLITE_OPEN_FULLMUTEX)
				flags = flags & (libc.CplInt32(SQLITE_OPEN_NOMUTEX))
			} else {
				flags = flags & (libc.CplInt32(SQLITE_OPEN_FULLMUTEX))
			}
		} else if libc.Xstrcmp(tls, zArg, ts+13923 /* "-uri" */) == 0 {
			// var b int32 at bp+108, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+108 /* &b */) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 108 /* b */)) != 0 {
				flags = flags | (SQLITE_OPEN_URI)
			} else {
				flags = flags & (libc.CplInt32(SQLITE_OPEN_URI))
			}
		} else if libc.Xstrcmp(tls, zArg, ts+13928 /* "-translatefilena..." */) == 0 {
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+112 /* &bTranslateFileName */) != 0 {
				return TCL_ERROR
			}
		} else {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+12133 /* "unknown option: " */, zArg, uintptr(0)))
			return TCL_ERROR
		}
	}
	zErrMsg = uintptr(0)
	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(SqliteDb{})))
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(SqliteDb{})))
	if zFile == uintptr(0) {
		zFile = ts + 489 /* "" */
	}
	if *(*int32)(unsafe.Pointer(bp + 112 /* bTranslateFileName */)) != 0 {
		zFile = tcl.XTcl_TranslateFileName(tls, interp, zFile, bp+116 /* &translatedFilename */)
	}
	rc = sqlite3.Xsqlite3_open_v2(tls, zFile, (p /* &.db */), flags, zVfs)
	if *(*int32)(unsafe.Pointer(bp + 112 /* bTranslateFileName */)) != 0 {
		tcl.XTcl_DStringFree(tls, bp+116 /* &translatedFilename */)
	}
	if (*SqliteDb)(unsafe.Pointer(p)).Fdb != 0 {
		if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb) {
			zErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+72, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb)))
			sqlite3.Xsqlite3_close(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb)
			(*SqliteDb)(unsafe.Pointer(p)).Fdb = uintptr(0)
		}
	} else {
		zErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+80, sqlite3.Xsqlite3_errstr(tls, rc)))
	}
	if (*SqliteDb)(unsafe.Pointer(p)).Fdb == uintptr(0) {
		tcl.XTcl_SetResult(tls, interp, zErrMsg, uintptr(1))
		tcl.XTcl_Free(tls, p)
		sqlite3.Xsqlite3_free(tls, zErrMsg)
		return TCL_ERROR
	}
	(*SqliteDb)(unsafe.Pointer(p)).FmaxStmt = NUM_PREPARED_STMTS
	(*SqliteDb)(unsafe.Pointer(p)).FopenFlags = (flags & SQLITE_OPEN_URI)
	(*SqliteDb)(unsafe.Pointer(p)).Finterp = interp
	zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(0))
	if DbUseNre(tls) != 0 {
		tcl.XTcl_NRCreateCommand(tls, interp, zArg, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmdAdaptor})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmd})),
			p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{DbDeleteCmd})))
	} else {
		tcl.XTcl_CreateObjCommand(tls, interp, zArg, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{DbDeleteCmd})))
	}
	return TCL_OK
}

// Provide a dummy Tcl_InitStubs if we are using this as a static
// library.

// Make sure we have a PACKAGE_VERSION macro defined.  This will be
// defined automatically by the TEA makefile.  But other makefiles
// do not define it.

// Initialize this module.
//
// This Tcl module contains only a single new Tcl command named "sqlite".
// (Hence there is no namespace.  There is no point in using a namespace
// if the extension only supplies one new name!)  The "sqlite" command is
// used to open a new SQLite database.  See the DbMain() routine above
// for additional information.
//
// The EXTERN macros are required by TCL in order to work on windows.
func Sqlite3_Init(tls *libc.TLS, interp uintptr) int32 { /* tclsqlite.c:3877:12: */
	var rc int32
	if 1 != 0 {
		rc = TCL_OK
	} else {
		rc = TCL_ERROR
	}
	if rc == TCL_OK {
		tcl.XTcl_CreateObjCommand(tls, interp, ts+13947 /* "sqlite3" */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbMain})), uintptr(0), uintptr(0))
		// The "sqlite" alias is undocumented.  It is here only to support
		// legacy scripts.  All new scripts should use only the "sqlite3"
		// command.
		tcl.XTcl_CreateObjCommand(tls, interp, ts+13955 /* "sqlite" */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbMain})), uintptr(0), uintptr(0))
		rc = tcl.XTcl_PkgProvideEx(tls, interp, ts+13947 /* "sqlite3" */, ts+13962 /* "3.36.0" */, uintptr(0))
	}
	return rc
}

func Tclsqlite3_Init(tls *libc.TLS, interp uintptr) int32 { /* tclsqlite.c:3891:12: */
	return Sqlite3_Init(tls, interp)
}

func Sqlite3_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3892:12: */
	return TCL_OK
}

func Tclsqlite3_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3893:12: */
	return TCL_OK
}

// Because it accesses the file-system and uses persistent state, SQLite
// is not considered appropriate for safe interpreters.  Hence, we cause
// the _SafeInit() interfaces return TCL_ERROR.
func Sqlite3_SafeInit(tls *libc.TLS, interp uintptr) int32 { /* tclsqlite.c:3899:12: */
	return TCL_ERROR
}

func Sqlite3_SafeUnload(tls *libc.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3900:12: */
	return TCL_ERROR
}

func Sqlite_Init(tls *libc.TLS, interp uintptr) int32 { /* tclsqlite.c:3905:5: */
	return Sqlite3_Init(tls, interp)
}

func Tclsqlite_Init(tls *libc.TLS, interp uintptr) int32 { /* tclsqlite.c:3906:5: */
	return Sqlite3_Init(tls, interp)
}

func Sqlite_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3907:5: */
	return TCL_OK
}

func Tclsqlite_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3908:5: */
	return TCL_OK
}

// If the TCLSH macro is defined, add code to make a stand-alone program.

// This is the main routine for an ordinary TCL shell.  If there are
// are arguments, run the first argument as a script.  Otherwise,
// read TCL commands from standard input
func tclsh_main_loop(tls *libc.TLS) uintptr { /* tclsqlite.c:3920:19: */
	return uintptr(unsafe.Pointer(&zMainloop))
}

var zMainloop = *(*[431]int8)(unsafe.Pointer(ts + 13969 /* "if {[llength $ar..." */)) /* tclsqlite.c:3921:21 */

func main1(tls *libc.TLS, argc int32, argv uintptr) int32 { /* tclsqlite.c:3953:18: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var interp uintptr
	var i int32
	var zScript uintptr = uintptr(0)
	// var zArgc [32]int8 at bp+32, 32

	if libc.Xgetenv(tls, ts+14400 /* "SQLITE_DEBUG_BRE..." */) != 0 {
		if (libc.Xisatty(tls, 0) != 0) && (libc.Xisatty(tls, 2) != 0) {
			libc.Xfprintf(tls, libc.Xstderr,
				ts+14419, /* "attach debugger ..." */
				libc.VaList(bp, libc.Xgetpid(tls)))
			libc.Xfgetc(tls, libc.Xstdin)
		} else {
			libc.Xraise(tls, SIGTRAP)
		}
	}

	// Call sqlite3_shutdown() once before doing anything else. This is to
	// test that sqlite3_shutdown() can be safely called by a process before
	// sqlite3_initialize() is.
	sqlite3.Xsqlite3_shutdown(tls)

	tcl.XTcl_FindExecutable(tls, *(*uintptr)(unsafe.Pointer(argv)))
	tcl.XTcl_SetSystemEncoding(tls, uintptr(0), ts+14481 /* "utf-8" */)
	interp = tcl.XTcl_CreateInterp(tls)
	Sqlite3_Init(tls, interp)

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([32]int8{})), bp+32 /* &zArgc[0] */, ts+1238 /* "%d" */, libc.VaList(bp+8, (argc-1)))
	tcl.XTcl_SetVar2(tls, interp, ts+14487 /* "argc" */, uintptr(0), bp+32 /* &zArgc[0] */, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+14492 /* "argv0" */, uintptr(0), *(*uintptr)(unsafe.Pointer(argv)), TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+14498 /* "argv" */, uintptr(0), ts+489 /* "" */, TCL_GLOBAL_ONLY)
	for i = 1; i < argc; i++ {
		tcl.XTcl_SetVar2(tls, interp, ts+14498 /* "argv" */, uintptr(0), *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), ((TCL_GLOBAL_ONLY | TCL_LIST_ELEMENT) | TCL_APPEND_VALUE))
	}
	zScript = sqlite3TestInit(tls, interp)
	if zScript == uintptr(0) {
		zScript = tclsh_main_loop(tls)
	}
	if tcl.XTcl_GlobalEval(tls, interp, zScript) != TCL_OK {
		var zInfo uintptr = tcl.XTcl_GetVar2(tls, interp, ts+14503 /* "errorInfo" */, uintptr(0), TCL_GLOBAL_ONLY)
		if zInfo == uintptr(0) {
			zInfo = tcl.XTcl_GetStringResult(tls, interp)
		}
		libc.Xfprintf(tls, libc.Xstderr, ts+14513 /* "%s: %s\n" */, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv)), zInfo))
		return 1
	}
	return 0
}

// CAPI3REF: Database Connection Handle
// KEYWORDS: {database connection} {database connections}
//
// Each open SQLite database is represented by a pointer to an instance of
// the opaque structure named "sqlite3".  It is useful to think of an sqlite3
// pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and
// [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]
// and [sqlite3_close_v2()] are its destructors.  There are many other
// interfaces (such as
// [sqlite3_prepare_v2()], [sqlite3_create_function()], and
// [sqlite3_busy_timeout()] to name but three) that are methods on an
// sqlite3 object.
type sqlite31 = sqlite32 /* sqlite3.h:249:24 */

// CAPI3REF: Dynamically Typed Value Object
// KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}
//
// SQLite uses the sqlite3_value object to represent all values
// that can be stored in a database table. SQLite uses dynamic typing
// for the values it stores.  ^Values stored in sqlite3_value objects
// can be integers, floating point values, strings, BLOBs, or NULL.
//
// An sqlite3_value object may be either "protected" or "unprotected".
// Some interfaces require a protected sqlite3_value.  Other interfaces
// will accept either a protected or an unprotected sqlite3_value.
// Every interface that accepts sqlite3_value arguments specifies
// whether or not it requires a protected sqlite3_value.  The
// [sqlite3_value_dup()] interface can be used to construct a new
// protected sqlite3_value from an unprotected sqlite3_value.
//
// The terms "protected" and "unprotected" refer to whether or not
// a mutex is held.  An internal mutex is held for a protected
// sqlite3_value object but no mutex is held for an unprotected
// sqlite3_value object.  If SQLite is compiled to be single-threaded
// (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)
// or if SQLite is run in one of reduced mutex modes
// [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]
// then there is no distinction between protected and unprotected
// sqlite3_value objects and they can be used interchangeably.  However,
// for maximum code portability it is recommended that applications
// still make the distinction between protected and unprotected
// sqlite3_value objects even when not strictly required.
//
// ^The sqlite3_value objects that are passed as parameters into the
// implementation of [application-defined SQL functions] are protected.
// ^The sqlite3_value object returned by
// [sqlite3_column_value()] is unprotected.
// Unprotected sqlite3_value objects may only be used as arguments
// to [sqlite3_result_value()], [sqlite3_bind_value()], and
// [sqlite3_value_dup()].
// The [sqlite3_value_blob | sqlite3_value_type()] family of
// interfaces require protected sqlite3_value objects.
type sqlite3_value = sqlite3_value1 /* sqlite3.h:4286:30 */

// CAPI3REF: SQL Function Context Object
//
// The context in which an SQL function executes is stored in an
// sqlite3_context object.  ^A pointer to an sqlite3_context object
// is always first parameter to [application-defined SQL functions].
// The application-defined SQL function implementation will pass this
// pointer through into calls to [sqlite3_result_int | sqlite3_result()],
// [sqlite3_aggregate_context()], [sqlite3_user_data()],
// [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],
// and/or [sqlite3_set_auxdata()].
type sqlite3_context = sqlite3_context1 /* sqlite3.h:4300:32 */

// CAPI3REF: Dynamic String Object
// KEYWORDS: {dynamic string}
//
// An instance of the sqlite3_str object contains a dynamically-sized
// string under construction.
//
// The lifecycle of an sqlite3_str object is as follows:
// <ol>
// <li> ^The sqlite3_str object is created using [sqlite3_str_new()].
// <li> ^Text is appended to the sqlite3_str object using various
// methods, such as [sqlite3_str_appendf()].
// <li> ^The sqlite3_str object is destroyed and the string it created
// is returned using the [sqlite3_str_finish()] interface.
// </ol>
type sqlite3_str = sqlite3_str1 /* sqlite3.h:7882:28 */

// Unsigned.
// Define uintN_t types.
//    Copyright (C) 2017-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type uint8_t = uint8   /* stdint-uintn.h:24:19 */
type uint16_t = uint16 /* stdint-uintn.h:25:20 */
type uint32_t = uint32 /* stdint-uintn.h:26:20 */
type uint64_t = uint64 /* stdint-uintn.h:27:20 */

// Small types.

// Signed.
type int_least8_t = int8   /* stdint.h:43:24 */
type int_least16_t = int16 /* stdint.h:44:25 */
type int_least32_t = int32 /* stdint.h:45:25 */
type int_least64_t = int64 /* stdint.h:46:25 */

// Unsigned.
type uint_least8_t = uint8   /* stdint.h:49:25 */
type uint_least16_t = uint16 /* stdint.h:50:26 */
type uint_least32_t = uint32 /* stdint.h:51:26 */
type uint_least64_t = uint64 /* stdint.h:52:26 */

// Fast types.

// Signed.
type int_fast8_t = int8   /* stdint.h:58:22 */
type int_fast16_t = int32 /* stdint.h:64:15 */
type int_fast32_t = int32 /* stdint.h:65:15 */

type int_fast64_t = int64 /* stdint.h:67:24 */

// Unsigned.
type uint_fast8_t = uint8   /* stdint.h:71:24 */
type uint_fast16_t = uint32 /* stdint.h:77:23 */
type uint_fast32_t = uint32 /* stdint.h:78:23 */

type uint_fast64_t = uint64 /* stdint.h:80:32 */
type uintptr_t = uint32     /* stdint.h:96:23 */

// Largest integral types.
type intmax_t = int64   /* stdint.h:101:21 */
type uintmax_t = uint64 /* stdint.h:102:22 */

// Macros for printing format specifiers.

// Decimal notation.

// Octal notation.

// Unsigned integers.

// lowercase hexadecimal notation.

// UPPERCASE hexadecimal notation.

// Macros for printing `intmax_t' and `uintmax_t'.

// Macros for printing `intptr_t' and `uintptr_t'.

// Macros for scanning format specifiers.

// Signed decimal notation.

// Signed decimal notation.

// Unsigned decimal notation.

// Octal notation.

// Hexadecimal notation.

// Macros for scanning `intmax_t' and `uintmax_t'.

// Macros for scaning `intptr_t' and `uintptr_t'.

// We have to define the `uintmax_t' type using `lldiv_t'.
type imaxdiv_t = struct {
	Fquot int64
	Frem  int64
} /* inttypes.h:284:5 */

// Is the sqlite3ErrName() function needed in the build?  Currently,
// it is needed by "mutex_w32.c" (when debugging), "os_win.c" (when
// OSTRACE is enabled), and by several "test*.c" files (which are
// compiled using SQLITE_TEST).

// SQLITE_ENABLE_EXPLAIN_COMMENTS is incompatible with SQLITE_OMIT_EXPLAIN

// Return true (non-zero) if the input is an integer that is too large
// to fit in 32-bits.  This macro is used inside of various testcase()
// macros to verify that we have tested SQLite for large-file support.

// The macro unlikely() is a hint that surrounds a boolean
// expression that is usually false.  Macro likely() surrounds
// a boolean expression that is usually true.  These hints could,
// in theory, be used by the compiler to generate better code, but
// currently they are just comments for human readers.

// 2001 September 22
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This is the header file for the generic hash-table implementation
// used in SQLite.

// Forward declarations of structures.
type Hash1 = struct {
	Fhtsize uint32
	Fcount  uint32
	Ffirst  uintptr
	Fht     uintptr
} /* sqlite3.h:249:9 */

// Is the sqlite3ErrName() function needed in the build?  Currently,
// it is needed by "mutex_w32.c" (when debugging), "os_win.c" (when
// OSTRACE is enabled), and by several "test*.c" files (which are
// compiled using SQLITE_TEST).

// SQLITE_ENABLE_EXPLAIN_COMMENTS is incompatible with SQLITE_OMIT_EXPLAIN

// Return true (non-zero) if the input is an integer that is too large
// to fit in 32-bits.  This macro is used inside of various testcase()
// macros to verify that we have tested SQLite for large-file support.

// The macro unlikely() is a hint that surrounds a boolean
// expression that is usually false.  Macro likely() surrounds
// a boolean expression that is usually true.  These hints could,
// in theory, be used by the compiler to generate better code, but
// currently they are just comments for human readers.

// 2001 September 22
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This is the header file for the generic hash-table implementation
// used in SQLite.

// Forward declarations of structures.
type Hash = Hash1 /* hash.h:19:21 */
type HashElem1 = struct {
	Fnext uintptr
	Fprev uintptr
	Fdata uintptr
	FpKey uintptr
} /* sqlite3.h:249:9 */

type HashElem = HashElem1 /* hash.h:20:25 */

// A complete hash table is an instance of the following structure.
// The internals of this structure are intended to be opaque -- client
// code should not attempt to access or modify the fields of this structure
// directly.  Change this structure only by using the routines below.
// However, some of the "procedures" and "functions" for modifying and
// accessing this structure are really macros, so we can't really make
// this structure opaque.
//
// All elements of the hash table are on a single doubly-linked list.
// Hash.first points to the head of this list.
//
// There are Hash.htsize buckets.  Each bucket points to a spot in
// the global doubly-linked list.  The contents of the bucket are the
// element pointed to plus the next _ht.count-1 elements in the list.
//
// Hash.htsize and Hash.ht may be zero.  In that case lookup is done
// by a linear search of the global list.  For small tables, the
// Hash.ht table is never allocated because if there are few elements
// in the table, it is faster to do a linear search than to manage
// the hash table.
type _ht = struct {
	Fcount uint32
	Fchain uintptr
} /* sqlite3.h:249:9 */

// The structure with the cookie function pointers.
//    The tag name of this struct is _IO_cookie_io_functions_t to
//    preserve historic C++ mangled names for functions taking
//    cookie_io_functions_t arguments.  That name should not be used in
//    new code.
type _IO_cookie_io_functions_t = struct {
	Fread  uintptr
	Fwrite uintptr
	Fseek  uintptr
	Fclose uintptr
} /* cookie_io_functions_t.h:55:9 */

// The structure with the cookie function pointers.
//    The tag name of this struct is _IO_cookie_io_functions_t to
//    preserve historic C++ mangled names for functions taking
//    cookie_io_functions_t arguments.  That name should not be used in
//    new code.
type cookie_io_functions_t = _IO_cookie_io_functions_t /* cookie_io_functions_t.h:61:3 */
type off64_t = int64                                   /* stdio.h:70:19 */
type fpos64_t = _G_fpos64_t                            /* stdio.h:89:20 */
type ino64_t = uint64                                  /* types.h:54:19 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set1 = struct{ Ffds_bits [32]int32 } /* select.h:70:5 */ // Type to count file system inodes.

type blkcnt64_t = int64    /* types.h:236:22 */ // Type to count number of disk blocks.
type fsblkcnt64_t = uint64 /* types.h:237:24 */ // Type to count file system blocks.
type fsfilcnt64_t = uint64 /* types.h:238:24 */

type comparison_fn_t = uintptr /* stdlib.h:808:23 */    // 2-byte unsigned integer
type i16 = int16_t             /* sqliteInt.h:795:20 */ // 1-byte unsigned integer
type i8 = int8_t               /* sqliteInt.h:797:19 */ // 1-byte signed integer

// SQLITE_MAX_U32 is a u64 constant that is the maximum u64 value
// that can be stored in a u32 without loss of data.  The value
// is 0x00000000ffffffff.  But because of quirks of some compilers, we
// have to specify the value in the less intuitive manner shown:

// The datatype used to store estimates of the number of rows in a
// table or index.  This is an unsigned integer type.  For 99.9% of
// the world, a 32-bit integer is sufficient.  But a 64-bit integer
// can be used at compile-time if desired.
type tRowcnt = u32 /* sqliteInt.h:816:14 */ // 32-bit is the default

// Estimated quantities used for query planning are stored as 16-bit
// logarithms.  For quantity X, the value stored is 10*log2(X).  This
// gives a possible range of values of approximately 1.0e986 to 1e-986.
// But the allowed values are "grainy".  Not every value is representable.
// For example, quantities 16 and 17 are both represented by a LogEst
// of 40.  However, since LogEst quantities are suppose to be estimates,
// not exact values, this imprecision is not a problem.
//
// "LogEst" is short for "Logarithmic Estimate".
//
// Examples:
//      1 -> 0              20 -> 43          10000 -> 132
//      2 -> 10             25 -> 46          25000 -> 146
//      3 -> 16            100 -> 66        1000000 -> 199
//      4 -> 20           1000 -> 99        1048576 -> 200
//     10 -> 33           1024 -> 100    4294967296 -> 320
//
// The LogEst can be negative to indicate fractional values.
// Examples:
//
//    0.5 -> -10           0.1 -> -33        0.0625 -> -40
type LogEst = int16_t /* sqliteInt.h:842:20 */

// Set the SQLITE_PTRSIZE macro to the number of bytes in a pointer

// The uptr type is an unsigned integer large enough to hold a pointer
type uptr = uintptr_t /* sqliteInt.h:862:21 */

// An instance of the following structure is used to store the busy-handler
// callback for a given sqlite handle.
//
// The sqlite.busyHandler member of the sqlite struct contains the busy
// callback for the database handle. Each pager opened via the sqlite
// handle is passed a pointer to sqlite.busyHandler. The busy-handler
// callback is currently invoked only from within pager.c.
type BusyHandler1 = struct {
	FxBusyHandler uintptr
	FpBusyArg     uintptr
	FnBusy        int32
} /* sqlite3.h:249:9 */

// An instance of the following structure is used to store the busy-handler
// callback for a given sqlite handle.
//
// The sqlite.busyHandler member of the sqlite struct contains the busy
// callback for the database handle. Each pager opened via the sqlite
// handle is passed a pointer to sqlite.busyHandler. The busy-handler
// callback is currently invoked only from within pager.c.
type BusyHandler = BusyHandler1 /* sqliteInt.h:1037:28 */

// Name of table that holds the database schema.

// The root-page of the schema table.

// The name of the schema table.  The name is different for TEMP.

// A convenience macro that returns the number of elements in
// an array.

// Determine if the argument is a power of two

// The following value as a destructor means to use sqlite3DbFree().
// The sqlite3DbFree() routine requires two parameters instead of the
// one parameter that destructors normally want.  So we have to introduce
// this magic value that the code knows to handle differently.  Any
// pointer will work here as long as it is distinct from SQLITE_STATIC
// and SQLITE_TRANSIENT.

// When SQLITE_OMIT_WSD is defined, it means that the target platform does
// not support Writable Static Data (WSD) such as global and static variables.
// All variables must either be on the stack or dynamically allocated from
// the heap.  When WSD is unsupported, the variable declarations scattered
// throughout the SQLite code must become constants instead.  The SQLITE_WSD
// macro is used for this purpose.  And instead of referencing the variable
// directly, we use its constant as a key to lookup the run-time allocated
// buffer that holds real variable.  The constant is also the initializer
// for the run-time allocated buffer.
//
// In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL
// macros become no-ops and have zero performance impact.

// The following macros are used to suppress compiler warnings and to
// make it clear to human readers when a function parameter is deliberately
// left unused within the body of a function. This usually happens when
// a function is called via a function pointer. For example the
// implementation of an SQL aggregate step callback may not use the
// parameter indicating the number of arguments passed to the aggregate,
// if it knows that this is enforced elsewhere.
//
// When a function parameter is not used at all within the body of a function,
// it is generally named "NotUsed" or "NotUsed2" to make things even clearer.
// However, these macros may also be used to suppress warnings related to
// parameters that may or may not be used depending on compilation options.
// For example those parameters only used in assert() statements. In these
// cases the parameters are named as per the usual conventions.

// Forward references to structures
type AggInfo1 = struct {
	FdirectMode     u8
	FuseSortingIdx  u8
	_               [2]byte
	FsortingIdx     int32
	FsortingIdxPTab int32
	FnSortingColumn int32
	FmnReg          int32
	FmxReg          int32
	FpGroupBy       uintptr
	FaCol           uintptr
	FnColumn        int32
	FnAccumulator   int32
	FaFunc          uintptr
	FnFunc          int32
	FselId          u32
} /* sqlite3.h:249:9 */

// Name of table that holds the database schema.

// The root-page of the schema table.

// The name of the schema table.  The name is different for TEMP.

// A convenience macro that returns the number of elements in
// an array.

// Determine if the argument is a power of two

// The following value as a destructor means to use sqlite3DbFree().
// The sqlite3DbFree() routine requires two parameters instead of the
// one parameter that destructors normally want.  So we have to introduce
// this magic value that the code knows to handle differently.  Any
// pointer will work here as long as it is distinct from SQLITE_STATIC
// and SQLITE_TRANSIENT.

// When SQLITE_OMIT_WSD is defined, it means that the target platform does
// not support Writable Static Data (WSD) such as global and static variables.
// All variables must either be on the stack or dynamically allocated from
// the heap.  When WSD is unsupported, the variable declarations scattered
// throughout the SQLite code must become constants instead.  The SQLITE_WSD
// macro is used for this purpose.  And instead of referencing the variable
// directly, we use its constant as a key to lookup the run-time allocated
// buffer that holds real variable.  The constant is also the initializer
// for the run-time allocated buffer.
//
// In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL
// macros become no-ops and have zero performance impact.

// The following macros are used to suppress compiler warnings and to
// make it clear to human readers when a function parameter is deliberately
// left unused within the body of a function. This usually happens when
// a function is called via a function pointer. For example the
// implementation of an SQL aggregate step callback may not use the
// parameter indicating the number of arguments passed to the aggregate,
// if it knows that this is enforced elsewhere.
//
// When a function parameter is not used at all within the body of a function,
// it is generally named "NotUsed" or "NotUsed2" to make things even clearer.
// However, these macros may also be used to suppress warnings related to
// parameters that may or may not be used depending on compilation options.
// For example those parameters only used in assert() statements. In these
// cases the parameters are named as per the usual conventions.

// Forward references to structures
type AggInfo = AggInfo1 /* sqliteInt.h:1133:24 */
type AuthContext1 = struct {
	FzAuthContext uintptr
	FpParse       uintptr
} /* sqliteInt.h:1134:9 */

type AuthContext = AuthContext1 /* sqliteInt.h:1134:28 */
type AutoincInfo1 = struct {
	FpNext  uintptr
	FpTab   uintptr
	FiDb    int32
	FregCtr int32
} /* sqlite3.h:249:9 */

type AutoincInfo = AutoincInfo1 /* sqliteInt.h:1135:28 */
type CollSeq1 = struct {
	FzName uintptr
	Fenc   u8
	_      [3]byte
	FpUser uintptr
	FxCmp  uintptr
	FxDel  uintptr
} /* sqlite3.h:249:9 */

type CollSeq = CollSeq1 /* sqliteInt.h:1137:24 */
type Column1 = struct {
	FzName    uintptr
	FpDflt    uintptr
	FzColl    uintptr
	FnotNull  u8
	Faffinity int8
	FszEst    u8
	FhName    u8
	FcolFlags u16
	_         [2]byte
} /* sqlite3.h:249:9 */

type Column = Column1 /* sqliteInt.h:1138:23 */
type Cte1 = struct {
	FzName   uintptr
	FpCols   uintptr
	FpSelect uintptr
	FzCteErr uintptr
	FpUse    uintptr
	FeM10d   u8
	_        [3]byte
} /* sqlite3.h:249:9 */

type Cte = Cte1 /* sqliteInt.h:1139:20 */
type CteUse1 = struct {
	FnUse    int32
	FaddrM9e int32
	FregRtn  int32
	FiCur    int32
	FnRowEst LogEst
	FeM10d   u8
	_        [1]byte
} /* sqlite3.h:249:9 */

type CteUse = CteUse1 /* sqliteInt.h:1140:23 */
type Db1 = struct {
	FzDbSName     uintptr
	FpBt          uintptr
	Fsafety_level u8
	FbSyncSet     u8
	_             [2]byte
	FpSchema      uintptr
} /* sqlite3.h:249:9 */

type Db = Db1 /* sqliteInt.h:1141:19 */
type DbFixer1 = struct {
	FpParse  uintptr
	Fw       Walker
	FpSchema uintptr
	FbTemp   u8
	_        [3]byte
	FzDb     uintptr
	FzType   uintptr
	FpName   uintptr
} /* sqliteInt.h:1142:9 */

type DbFixer = DbFixer1 /* sqliteInt.h:1142:24 */
type Schema1 = struct {
	Fschema_cookie int32
	FiGeneration   int32
	FtblHash       Hash
	FidxHash       Hash
	FtrigHash      Hash
	FfkeyHash      Hash
	FpSeqTab       uintptr
	Ffile_format   u8
	Fenc           u8
	FschemaFlags   u16
	Fcache_size    int32
} /* sqlite3.h:249:9 */

type Schema = Schema1 /* sqliteInt.h:1143:23 */
type Expr1 = struct {
	Fop              u8
	FaffExpr         int8
	Fop2             u8
	_                [1]byte
	Fflags           u32
	Fu               struct{ FzToken uintptr }
	FpLeft           uintptr
	FpRight          uintptr
	Fx               struct{ FpList uintptr }
	FnHeight         int32
	FiTable          int32
	FiColumn         ynVar
	FiAgg            i16
	FiRightJoinTable int32
	FpAggInfo        uintptr
	Fy               struct {
		FpTab uintptr
		_     [4]byte
	}
} /* sqlite3.h:249:9 */

type Expr = Expr1 /* sqliteInt.h:1144:21 */
type ExprList1 = struct {
	FnExpr  int32
	FnAlloc int32
	Fa      [1]struct {
		FpExpr     uintptr
		FzEName    uintptr
		FsortFlags u8
		_          [3]byte
		FeEName    uint8 /* unsigned eEName: 2, unsigned done: 1, unsigned reusable: 1, unsigned bSorterRef: 1, unsigned bNulls: 1 */
		_          [3]byte
		Fu         struct {
			_  [0]uint32
			Fx struct {
				FiOrderByCol u16
				FiAlias      u16
			}
		}
	}
} /* sqlite3.h:249:9 */

type ExprList = ExprList1 /* sqliteInt.h:1145:25 */
type FKey1 = struct {
	FpFrom      uintptr
	FpNextFrom  uintptr
	FzTo        uintptr
	FpNextTo    uintptr
	FpPrevTo    uintptr
	FnCol       int32
	FisDeferred u8
	FaAction    [2]u8
	_           [1]byte
	FapTrigger  [2]uintptr
	FaCol       [1]struct {
		FiFrom int32
		FzCol  uintptr
	}
} /* sqlite3.h:249:9 */

type FKey = FKey1 /* sqliteInt.h:1146:21 */
type FuncDestructor1 = struct {
	FnRef      int32
	FxDestroy  uintptr
	FpUserData uintptr
} /* sqliteInt.h:1147:9 */

type FuncDestructor = FuncDestructor1 /* sqliteInt.h:1147:31 */
type FuncDef1 = struct {
	FnArg      i8
	_          [3]byte
	FfuncFlags u32
	FpUserData uintptr
	FpNext     uintptr
	FxSFunc    uintptr
	FxFinalize uintptr
	FxValue    uintptr
	FxInverse  uintptr
	FzName     uintptr
	Fu         struct{ FpHash uintptr }
} /* sqlite3.h:249:9 */

type FuncDef = FuncDef1                      /* sqliteInt.h:1148:24 */
type FuncDefHash1 = struct{ Fa [23]uintptr } /* sqliteInt.h:1149:9 */

type FuncDefHash = FuncDefHash1 /* sqliteInt.h:1149:28 */
type IdList1 = struct {
	Fa   uintptr
	FnId int32
} /* sqlite3.h:249:9 */

type IdList = IdList1 /* sqliteInt.h:1150:23 */
type Index1 = struct {
	FzName         uintptr
	FaiColumn      uintptr
	FaiRowLogEst   uintptr
	FpTable        uintptr
	FzColAff       uintptr
	FpNext         uintptr
	FpSchema       uintptr
	FaSortOrder    uintptr
	FazColl        uintptr
	FpPartIdxWhere uintptr
	FaColExpr      uintptr
	Ftnum          Pgno
	FszIdxRow      LogEst
	FnKeyCol       u16
	FnColumn       u16
	FonError       u8
	_              [1]byte
	FidxType       uint16 /* unsigned idxType: 2, unsigned bUnordered: 1, unsigned uniqNotNull: 1, unsigned isResized: 1, unsigned isCovering: 1, unsigned noSkipScan: 1, unsigned hasStat1: 1, unsigned bNoQuery: 1, unsigned bAscKeyBug: 1, unsigned bHasVCol: 1 */
	_              [2]byte
	FnSample       int32
	FnSampleCol    int32
	FaAvgEq        uintptr
	FaSample       uintptr
	FaiRowEst      uintptr
	FnRowEst0      tRowcnt
	_              [4]byte
	FcolNotIdxed   Bitmask
} /* sqlite3.h:249:9 */

type Index = Index1 /* sqliteInt.h:1151:22 */
type IndexSample1 = struct {
	Fp     uintptr
	Fn     int32
	FanEq  uintptr
	FanLt  uintptr
	FanDLt uintptr
} /* sqlite3.h:249:9 */

type IndexSample = IndexSample1 /* sqliteInt.h:1152:28 */
type KeyInfo1 = struct {
	FnRef       u32
	Fenc        u8
	_           [1]byte
	FnKeyField  u16
	FnAllField  u16
	_           [2]byte
	Fdb         uintptr
	FaSortFlags uintptr
	FaColl      [1]uintptr
} /* sqlite3.h:249:9 */

type KeyInfo = KeyInfo1 /* sqliteInt.h:1154:24 */
type Lookaside1 = struct {
	FbDisable   u32
	Fsz         u16
	FszTrue     u16
	FbMalloced  u8
	_           [3]byte
	FnSlot      u32
	FanStat     [3]u32
	FpInit      uintptr
	FpFree      uintptr
	FpSmallInit uintptr
	FpSmallFree uintptr
	FpMiddle    uintptr
	FpStart     uintptr
	FpEnd       uintptr
} /* sqlite3.h:249:9 */

type Lookaside = Lookaside1                    /* sqliteInt.h:1155:26 */
type LookasideSlot1 = struct{ FpNext uintptr } /* sqlite3.h:249:9 */

type LookasideSlot = LookasideSlot1 /* sqliteInt.h:1156:30 */
type Module1 = struct {
	FpModule    uintptr
	FzName      uintptr
	FnRefModule int32
	FpAux       uintptr
	FxDestroy   uintptr
	FpEpoTab    uintptr
} /* sqlite3.h:249:9 */

type Module = Module1 /* sqliteInt.h:1157:23 */
type NameContext1 = struct {
	FpParse     uintptr
	FpSrcList   uintptr
	FuNC        struct{ FpEList uintptr }
	FpNext      uintptr
	FnRef       int32
	FnNcErr     int32
	FncFlags    int32
	FpWinSelect uintptr
} /* sqliteInt.h:1158:9 */

type NameContext = NameContext1 /* sqliteInt.h:1158:28 */
type Parse1 = struct {
	Fdb               uintptr
	FzErrMsg          uintptr
	FpVdbe            uintptr
	Frc               int32
	FcolNamesSet      u8
	FcheckSchema      u8
	Fnested           u8
	FnTempReg         u8
	FisMultiWrite     u8
	FmayAbort         u8
	FhasCompound      u8
	FokConstFactor    u8
	FdisableLookaside u8
	FdisableVtab      u8
	_                 [2]byte
	FnRangeReg        int32
	FiRangeReg        int32
	FnErr             int32
	FnTab             int32
	FnMem             int32
	FszOpAlloc        int32
	FiSelfTab         int32
	FnLabel           int32
	FnLabelAlloc      int32
	FaLabel           uintptr
	FpConstExpr       uintptr
	FconstraintName   Token
	FwriteMask        yDbMask
	FcookieMask       yDbMask
	FregRowid         int32
	FregRoot          int32
	FnMaxArg          int32
	FnSelect          int32
	FnTableLock       int32
	FaTableLock       uintptr
	FpAinc            uintptr
	FpToplevel        uintptr
	FpTriggerTab      uintptr
	FpParentParse     uintptr
	Fu1               struct{ FaddrCrTab int32 }
	FnQueryLoop       u32
	Foldmask          u32
	Fnewmask          u32
	FeTriggerOp       u8
	FbReturning       u8
	FeOrconf          u8
	FdisableTriggers  u8
	FaTempReg         [8]int32
	FsNameToken       Token
	FsLastToken       Token
	FnVar             ynVar
	FiPkSortOrder     u8
	Fexplain          u8
	FeParseMode       u8
	_                 [3]byte
	FnVtabLock        int32
	FnHeight          int32
	FaddrExplain      int32
	FpVList           uintptr
	FpReprepare       uintptr
	FzTail            uintptr
	FpNewTable        uintptr
	FpNewIndex        uintptr
	FpNewTrigger      uintptr
	FzAuthContext     uintptr
	FsArg             Token
	FapVtabLock       uintptr
	FpTriggerPrg      uintptr
	FpWith            uintptr
	FpCleanup         uintptr
	FpRename          uintptr
} /* sqlite3.h:249:9 */

type Parse = Parse1 /* sqliteInt.h:1159:22 */
type ParseCleanup1 = struct {
	FpNext    uintptr
	FpPtr     uintptr
	FxCleanup uintptr
} /* sqlite3.h:249:9 */

type ParseCleanup = ParseCleanup1 /* sqliteInt.h:1160:29 */
type PreUpdate1 = struct {
	Fv            uintptr
	FpCsr         uintptr
	Fop           int32
	FaRecord      uintptr
	Fkeyinfo      KeyInfo
	FpUnpacked    uintptr
	FpNewUnpacked uintptr
	FiNewReg      int32
	FiBlobWrite   int32
	FiKey1        i64
	FiKey2        i64
	FaNew         uintptr
	FpTab         uintptr
	FpPk          uintptr
	_             [4]byte
} /* sqlite3.h:249:9 */

type PreUpdate = PreUpdate1 /* sqliteInt.h:1161:26 */
type PrintfArguments1 = struct {
	FnArg  int32
	FnUsed int32
	FapArg uintptr
} /* sqliteInt.h:1162:9 */

type PrintfArguments = PrintfArguments1 /* sqliteInt.h:1162:32 */
type Returning1 = struct {
	FpParse    uintptr
	FpReturnEL uintptr
	FretTrig   Trigger
	FretTStep  TriggerStep
	FiRetCur   int32
	FnRetCol   int32
	FiRetReg   int32
} /* sqliteInt.h:1164:9 */

type Returning = Returning1 /* sqliteInt.h:1164:26 */
type Savepoint1 = struct {
	FzName            uintptr
	_                 [4]byte
	FnDeferredCons    i64
	FnDeferredImmCons i64
	FpNext            uintptr
	_                 [4]byte
} /* sqlite3.h:249:9 */

type Savepoint = Savepoint1 /* sqliteInt.h:1166:26 */
type Select1 = struct {
	Fop           u8
	_             [1]byte
	FnSelectRow   LogEst
	FselFlags     u32
	FiLimit       int32
	FiOffset      int32
	FselId        u32
	FaddrOpenEphm [2]int32
	FpEList       uintptr
	FpSrc         uintptr
	FpWhere       uintptr
	FpGroupBy     uintptr
	FpHaving      uintptr
	FpOrderBy     uintptr
	FpPrior       uintptr
	FpNext        uintptr
	FpLimit       uintptr
	FpWith        uintptr
	FpWin         uintptr
	FpWinDefn     uintptr
} /* sqlite3.h:249:9 */

type Select = Select1 /* sqliteInt.h:1167:23 */
type SelectDest1 = struct {
	FeDest    u8
	_         [3]byte
	FiSDParm  int32
	FiSDParm2 int32
	FiSdst    int32
	FnSdst    int32
	FzAffSdst uintptr
	FpOrderBy uintptr
} /* sqliteInt.h:1169:9 */

type SelectDest = SelectDest1 /* sqliteInt.h:1169:27 */
type SrcItem1 = struct {
	FpSchema     uintptr
	FzDatabase   uintptr
	FzName       uintptr
	FzAlias      uintptr
	FpTab        uintptr
	FpSelect     uintptr
	FaddrFillSub int32
	FregReturn   int32
	FregResult   int32
	Ffg          struct {
		_           [0]uint32
		Fjointype   u8
		_           [3]byte
		FnotIndexed uint16 /* unsigned notIndexed: 1, unsigned isIndexedBy: 1, unsigned isTabFunc: 1, unsigned isCorrelated: 1, unsigned viaCoroutine: 1, unsigned isRecursive: 1, unsigned fromDDL: 1, unsigned isCte: 1, unsigned notCte: 1 */
		_           [2]byte
	}
	FiCursor int32
	FpOn     uintptr
	FpUsing  uintptr
	FcolUsed Bitmask
	Fu1      struct{ FzIndexedBy uintptr }
	Fu2      struct{ FpIBIndex uintptr }
} /* sqlite3.h:249:9 */

type SrcItem = SrcItem1 /* sqliteInt.h:1170:24 */
type SrcList1 = struct {
	FnSrc   int32
	FnAlloc u32
	Fa      [1]SrcItem
} /* sqlite3.h:249:9 */

type SrcList = SrcList1      /* sqliteInt.h:1171:24 */
type StrAccum = sqlite3_str1 /* sqliteInt.h:1172:28 */ // Internal alias for sqlite3_str
type Table1 = struct {
	FzName        uintptr
	FaCol         uintptr
	FpIndex       uintptr
	FpSelect      uintptr
	FpFKey        uintptr
	FzColAff      uintptr
	FpCheck       uintptr
	Ftnum         Pgno
	FnTabRef      u32
	FtabFlags     u32
	FiPKey        i16
	FnCol         i16
	FnNVCol       i16
	FnRowLogEst   LogEst
	FszTabRow     LogEst
	FkeyConf      u8
	_             [1]byte
	FaddColOffset int32
	FnModuleArg   int32
	FazModuleArg  uintptr
	FpVTable      uintptr
	FpTrigger     uintptr
	FpSchema      uintptr
} /* sqlite3.h:249:9 */

// Internal alias for sqlite3_str
type Table = Table1 /* sqliteInt.h:1173:22 */
type Token1 = struct {
	Fz uintptr
	Fn uint32
} /* sqlite3.h:249:9 */

type Token = Token1 /* sqliteInt.h:1175:22 */
type Trigger1 = struct {
	FzName      uintptr
	Ftable      uintptr
	Fop         u8
	Ftr_tm      u8
	FbReturning u8
	_           [1]byte
	FpWhen      uintptr
	FpColumns   uintptr
	FpSchema    uintptr
	FpTabSchema uintptr
	Fstep_list  uintptr
	FpNext      uintptr
} /* sqlite3.h:249:9 */

type Trigger = Trigger1 /* sqliteInt.h:1177:24 */
type TriggerPrg1 = struct {
	FpTrigger uintptr
	FpNext    uintptr
	FpProgram uintptr
	Forconf   int32
	FaColmask [2]u32
} /* sqlite3.h:249:9 */

type TriggerPrg = TriggerPrg1 /* sqliteInt.h:1178:27 */
type TriggerStep1 = struct {
	Fop        u8
	Forconf    u8
	_          [2]byte
	FpTrig     uintptr
	FpSelect   uintptr
	FzTarget   uintptr
	FpFrom     uintptr
	FpWhere    uintptr
	FpExprList uintptr
	FpIdList   uintptr
	FpUpsert   uintptr
	FzSpan     uintptr
	FpNext     uintptr
	FpLast     uintptr
} /* sqlite3.h:249:9 */

type TriggerStep = TriggerStep1 /* sqliteInt.h:1179:28 */
type UnpackedRecord1 = struct {
	FpKeyInfo   uintptr
	FaMem       uintptr
	FnField     u16
	Fdefault_rc i8
	FerrCode    u8
	Fr1         i8
	Fr2         i8
	FeqSeen     u8
	_           [1]byte
} /* sqlite3.h:249:9 */

type UnpackedRecord = UnpackedRecord1 /* sqliteInt.h:1180:31 */
type Upsert1 = struct {
	FpUpsertTarget      uintptr
	FpUpsertTargetWhere uintptr
	FpUpsertSet         uintptr
	FpUpsertWhere       uintptr
	FpNextUpsert        uintptr
	FisDoUpdate         u8
	_                   [3]byte
	FpToFree            uintptr
	FpUpsertIdx         uintptr
	FpUpsertSrc         uintptr
	FregData            int32
	FiDataCur           int32
	FiIdxCur            int32
} /* sqlite3.h:249:9 */

type Upsert = Upsert1 /* sqliteInt.h:1181:23 */
type VTable1 = struct {
	Fdb          uintptr
	FpMod        uintptr
	FpVtab       uintptr
	FnRef        int32
	FbConstraint u8
	FeVtabRisk   u8
	_            [2]byte
	FiSavepoint  int32
	FpNext       uintptr
} /* sqlite3.h:249:9 */

type VTable = VTable1 /* sqliteInt.h:1182:23 */
type Walker1 = struct {
	FpParse           uintptr
	FxExprCallback    uintptr
	FxSelectCallback  uintptr
	FxSelectCallback2 uintptr
	FwalkerDepth      int32
	FeCode            u16
	_                 [2]byte
	Fu                struct{ FpNC uintptr }
} /* sqliteInt.h:1142:9 */

type Walker = Walker1 /* sqliteInt.h:1184:23 */
type Window1 = struct {
	FzName          uintptr
	FzBase          uintptr
	FpPartition     uintptr
	FpOrderBy       uintptr
	FeFrmType       u8
	FeStart         u8
	FeEnd           u8
	FbImplicitFrame u8
	FeExclude       u8
	_               [3]byte
	FpStart         uintptr
	FpEnd           uintptr
	FppThis         uintptr
	FpNextWin       uintptr
	FpFilter        uintptr
	FpFunc          uintptr
	FiEphCsr        int32
	FregAccum       int32
	FregResult      int32
	FcsrApp         int32
	FregApp         int32
	FregPart        int32
	FpOwner         uintptr
	FnBufferCol     int32
	FiArgCol        int32
	FregOne         int32
	FregStartRowid  int32
	FregEndRowid    int32
	FbExprArgs      u8
	_               [3]byte
} /* sqlite3.h:249:9 */

type Window = Window1 /* sqliteInt.h:1186:23 */
type With1 = struct {
	FnCte   int32
	FbView  int32
	FpOuter uintptr
	Fa      [1]Cte
} /* sqlite3.h:249:9 */

type With = With1 /* sqliteInt.h:1187:21 */

// The bitmask datatype defined below is used for various optimizations.
//
// Changing this from a 64-bit to a 32-bit type limits the number of
// tables in a join to 32 instead of 64.  But it also reduces the size
// of the library by 738 bytes on ix86.
type Bitmask = u64 /* sqliteInt.h:1200:15 */

// The number of bits in a Bitmask.  "BMS" means "BitMask Size".

// A bit in a Bitmask

// A VList object records a mapping between parameters/variables/wildcards
// in the SQL statement (such as $abc, @pqr, or :xyz) and the integer
// variable number associated with that parameter.  See the format description
// on the sqlite3VListAdd() routine for more information.  A VList is really
// just an array of integers.
type VList = int32 /* sqliteInt.h:1222:13 */

// Defer sourcing vdbe.h and btree.h until after the "u8" and
// "BusyHandler" typedefs. vdbe.h also requires a few of the opaque
// pointer types (i.e. FuncDef) defined above.
// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite page cache
// subsystem.  The page cache subsystem reads and writes a file a page
// at a time and provides a journal for rollback.

// Default maximum size for persistent journal files. A negative
// value means no limit. This value may be overridden using the
// sqlite3PagerJournalSizeLimit() API. See also "PRAGMA journal_size_limit".

// The type used to represent a page number.  The first page in a file
// is called page 1.  0 is used to represent "not a page".
type Pgno = u32 /* pager.h:33:13 */

// Handle type for pages.
type PgHdr1 = struct {
	FpPage      uintptr
	FpData      uintptr
	FpExtra     uintptr
	FpCache     uintptr
	FpDirty     uintptr
	FpPager     uintptr
	Fpgno       Pgno
	Fflags      u16
	FnRef       i16
	FpDirtyNext uintptr
	FpDirtyPrev uintptr
} /* pager.h:43:9 */

// Handle type for pages.
type DbPage = PgHdr1 /* pager.h:43:22 */

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite B-Tree file
// subsystem.  See comments in the source code for a detailed description
// of what each interface routine does.

// TODO: This definition is just included so other modules compile. It
// needs to be revisited.

// If defined as non-zero, auto-vacuum is enabled by default. Otherwise
// it must be turned on for each database using "PRAGMA auto_vacuum = 1".

// Forward declarations of structure
type Btree1 = struct {
	Fdb             uintptr
	FpBt            uintptr
	FinTrans        u8
	Fsharable       u8
	Flocked         u8
	FhasIncrblobCur u8
	FwantToLock     int32
	FnBackup        int32
	FiBDataVersion  u32
	FpNext          uintptr
	FpPrev          uintptr
	Flock           BtLock
} /* btree.h:39:9 */

type BtCursor1 = struct {
	FeState        u8
	FcurFlags      u8
	FcurPagerFlags u8
	Fhints         u8
	FskipNext      int32
	FpBtree        uintptr
	FaOverflow     uintptr
	FpKey          uintptr
	FpBt           uintptr
	FpNext         uintptr
	_              [4]byte
	Finfo          CellInfo
	FnKey          i64
	FpgnoRoot      Pgno
	FiPage         i8
	FcurIntKey     u8
	Fix            u16
	FaiIdx         [19]u16
	_              [2]byte
	FpKeyInfo      uintptr
	FpPage         uintptr
	FapPage        [19]uintptr
	_              [4]byte
} /* btree.h:39:9 */

type BtShared1 = struct {
	FpPager          uintptr
	Fdb              uintptr
	FpCursor         uintptr
	FpPage1          uintptr
	FopenFlags       u8
	FautoVacuum      u8
	FincrVacuum      u8
	FbDoTruncate     u8
	FinTransaction   u8
	Fmax1bytePayload u8
	FnReserveWanted  u8
	_                [1]byte
	FbtsFlags        u16
	FmaxLocal        u16
	FminLocal        u16
	FmaxLeaf         u16
	FminLeaf         u16
	_                [2]byte
	FpageSize        u32
	FusableSize      u32
	FnTransaction    int32
	FnPage           u32
	FpSchema         uintptr
	FxFreeSchema     uintptr
	Fmutex           uintptr
	FpHasContent     uintptr
	FnRef            int32
	FpNext           uintptr
	FpLock           uintptr
	FpWriter         uintptr
	FpTmpSpace       uintptr
	FnPreformatSize  int32
} /* btree.h:39:9 */

type BtreePayload1 = struct {
	FpKey  uintptr
	_      [4]byte
	FnKey  sqlite3_int64
	FpData uintptr
	FaMem  uintptr
	FnMem  u16
	_      [2]byte
	FnData int32
	FnZero int32
	_      [4]byte
} /* btree.h:42:9 */

type BtreePayload = BtreePayload1 /* btree.h:42:29 */

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Header file for the Virtual DataBase Engine (VDBE)
//
// This header defines the interface to the virtual database engine
// or VDBE.  The VDBE implements an abstract machine that runs a
// simple program to access and modify the underlying database.
// Define ISO C stdio on top of C++ iostreams.
//    Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// A single VDBE is an opaque structure named "Vdbe".  Only routines
// in the source file sqliteVdbe.c are allowed to see the insides
// of this structure.
type Vdbe1 = struct {
	Fdb                 uintptr
	FpPrev              uintptr
	FpNext              uintptr
	FpParse             uintptr
	FnVar               ynVar
	_                   [2]byte
	FiVdbeMagic         u32
	FnMem               int32
	FnCursor            int32
	FcacheCtr           u32
	Fpc                 int32
	Frc                 int32
	FnChange            int32
	FiStatement         int32
	_                   [4]byte
	FiCurrentTime       i64
	FnFkConstraint      i64
	FnStmtDefCons       i64
	FnStmtDefImmCons    i64
	FaMem               uintptr
	FapArg              uintptr
	FapCsr              uintptr
	FaVar               uintptr
	FaOp                uintptr
	FnOp                int32
	FnOpAlloc           int32
	FaColName           uintptr
	FpResultSet         uintptr
	FzErrMsg            uintptr
	FpVList             uintptr
	_                   [4]byte
	FstartTime          i64
	FnResColumn         u16
	FerrorAction        u8
	FminWriteFileFormat u8
	FprepFlags          u8
	FdoingRerun         u8
	_                   [2]byte
	Fexpired            uint16 /* bft expired: 2, bft explain: 2, bft changeCntOn: 1, bft runOnlyOnce: 1, bft usesStmtJournal: 1, bft readOnly: 1, bft bIsReader: 1 */
	_                   [2]byte
	FbtreeMask          yDbMask
	FlockMask           yDbMask
	FaCounter           [7]u32
	FzSql               uintptr
	FpFree              uintptr
	FpFrame             uintptr
	FpDelFrame          uintptr
	FnFrame             int32
	Fexpmask            u32
	FpProgram           uintptr
	FpAuxData           uintptr
} /* sqlite3.h:249:9 */

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Header file for the Virtual DataBase Engine (VDBE)
//
// This header defines the interface to the virtual database engine
// or VDBE.  The VDBE implements an abstract machine that runs a
// simple program to access and modify the underlying database.
// Define ISO C stdio on top of C++ iostreams.
//    Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// A single VDBE is an opaque structure named "Vdbe".  Only routines
// in the source file sqliteVdbe.c are allowed to see the insides
// of this structure.
type Vdbe = Vdbe1 /* vdbe.h:27:21 */

// The names of the following types declared in vdbeInt.h are required
// for the VdbeOp definition.
type Mem = sqlite3_value1 /* vdbe.h:33:30 */
type SubProgram1 = struct {
	FaOp   uintptr
	FnOp   int32
	FnMem  int32
	FnCsr  int32
	FaOnce uintptr
	Ftoken uintptr
	FpNext uintptr
} /* sqlite3.h:249:9 */

type SubProgram = SubProgram1 /* vdbe.h:34:27 */

// A single instruction of the virtual machine has an opcode
// and as many as three operands.  The instruction is recorded
// as an instance of the following structure:
type VdbeOp1 = struct {
	Fopcode   u8
	Fp4type   int8
	Fp5       u16
	Fp1       int32
	Fp2       int32
	Fp3       int32
	Fp4       struct{ Fi int32 }
	FzComment uintptr
} /* sqlite3.h:249:9 */

// A single instruction of the virtual machine has an opcode
// and as many as three operands.  The instruction is recorded
// as an instance of the following structure:
type p4union = struct{ Fi int32 } /* sqlite3.h:249:9 */

type VdbeOp = VdbeOp1 /* vdbe.h:80:23 */

// A smaller version of VdbeOp used for the VdbeAddOpList() function because
// it takes up less space.
type VdbeOpList1 = struct {
	Fopcode u8
	Fp1     int8
	Fp2     int8
	Fp3     int8
} /* vdbe.h:100:1 */

type VdbeOpList = VdbeOpList1 /* vdbe.h:106:27 */

type RecordCompare = uintptr /* vdbe.h:286:13 */

// The VdbeCoverage macros are used to set a coverage testing point
// for VDBE branch instructions.  The coverage testing points are line
// numbers in the sqlite3.c source file.  VDBE branch coverage testing
// only works with an amalagmation build.  That's ok since a VDBE branch
// coverage build designed for testing the test suite only.  No application
// should ever ship with VDBE branch coverage measuring turned on.
//
//    VdbeCoverage(v)                  // Mark the previously coded instruction
//                                     // as a branch
//
//    VdbeCoverageIf(v, conditional)   // Mark previous if conditional true
//
//    VdbeCoverageAlwaysTaken(v)       // Previous branch is always taken
//
//    VdbeCoverageNeverTaken(v)        // Previous branch is never taken
//
//    VdbeCoverageNeverNull(v)         // Previous three-way branch is only
//                                     // taken on the first two ways.  The
//                                     // NULL option is not possible
//
//    VdbeCoverageEqNe(v)              // Previous OP_Jump is only interested
//                                     // in distingishing equal and not-equal.
//
// Every VDBE branch operation must be tagged with one of the macros above.
// If not, then when "make test" is run with -DSQLITE_VDBE_COVERAGE and
// -DSQLITE_DEBUG then an ALWAYS() will fail in the vdbeTakeBranch()
// routine in vdbe.c, alerting the developer to the missed tag.
//
// During testing, the test application will invoke
// sqlite3_test_control(SQLITE_TESTCTRL_VDBE_COVERAGE,...) to set a callback
// routine that is invoked as each bytecode branch is taken.  The callback
// contains the sqlite3.c source line number ov the VdbeCoverage macro and
// flags to indicate whether or not the branch was taken.  The test application
// is responsible for keeping track of this and reporting byte-code branches
// that are never taken.
//
// See the VdbeBranchTaken() macro and vdbeTakeBranch() function in the
// vdbe.c source file for additional information.

// 2008 August 05
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite page cache
// subsystem.

type PgHdr = PgHdr1 /* pcache.h:18:22 */

// typedef for the authorization callback function.
type sqlite3_xauth = uintptr /* sqliteInt.h:1468:15 */

// This is an extra SQLITE_TRACE macro that indicates "legacy" tracing
// in the style of sqlite3_trace()

// Maximum number of sqlite3.aDb[] entries.  This is the number of attached
// databases plus 2 for "main" and "temp".

// Each database connection is an instance of the following structure.
type sqlite3InitInfo = struct {
	FnewTnum       Pgno
	FiDb           u8
	Fbusy          u8
	_              [2]byte
	ForphanTrigger uint8 /* unsigned orphanTrigger: 1, unsigned imposterTable: 1, unsigned reopenMemdb: 1 */
	_              [3]byte
	FazInit        uintptr
} /* sqlite3.h:249:9 */

// Allowed values for Table.tabFlags.
//
// TF_OOOHidden applies to tables or view that have hidden columns that are
// followed by non-hidden columns.  Example:  "CREATE VIRTUAL TABLE x USING
// vtab1(a HIDDEN, b);".  Since "b" is a non-hidden column but "a" is hidden,
// the TF_OOOHidden attribute would apply in this case.  Such tables require
// special handling during INSERT processing. The "OOO" means "Out Of Order".
//
// Constraints:
//
//         TF_HasVirtual == COLFLAG_VIRTUAL
//         TF_HasStored  == COLFLAG_STORED
//         TF_HasHidden  == COLFLAG_HIDDEN

// Test to see whether or not a table is a virtual table.  This is
// done as a macro so that it will be optimized out when virtual
// table support is omitted from the build.

// Macros to determine if a column is hidden.  IsOrdinaryHiddenColumn()
// only works for non-virtual tables (ordinary tables and views) and is
// always false unless SQLITE_ENABLE_HIDDEN_COLUMNS is defined.  The
// IsHiddenColumn() macro is general purpose.

// Does the table have a rowid

// Each foreign key constraint is an instance of the following structure.
//
// A foreign key is associated with two tables.  The "from" table is
// the table that contains the REFERENCES clause that creates the foreign
// key.  The "to" table is the table that is named in the REFERENCES clause.
// Consider this example:
//
//     CREATE TABLE ex1(
//       a INTEGER PRIMARY KEY,
//       b INTEGER CONSTRAINT fk1 REFERENCES ex2(x)
//     );
//
// For foreign key "fk1", the from-table is "ex1" and the to-table is "ex2".
// Equivalent names:
//
//     from-table == child-table
//       to-table == parent-table
//
// Each REFERENCES clause generates an instance of the following structure
// which is attached to the from-table.  The to-table need not exist when
// the from-table is created.  The existence of the to-table is not checked.
//
// The list of all parents for child Table X is held at X.pFKey.
//
// A list of all children for a table named Z (which might not even exist)
// is held in Schema.fkeyHash with a hash key of Z.
type sColMap = struct {
	FiFrom int32
	FzCol  uintptr
} /* sqlite3.h:249:9 */

// An instance of this structure contains information needed to generate
// code for a SELECT that contains aggregate functions.
//
// If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a
// pointer to this structure.  The Expr.iAgg field is the index in
// AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate
// code for that node.
//
// AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the
// original Select structure that describes the SELECT statement.  These
// fields do not need to be freed when deallocating the AggInfo structure.
type AggInfo_col = struct {
	FpTab          uintptr
	FpCExpr        uintptr
	FiTable        int32
	FiMem          int32
	FiColumn       i16
	FiSorterColumn i16
} /* sqlite3.h:249:9 */

// An instance of this structure contains information needed to generate
// code for a SELECT that contains aggregate functions.
//
// If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a
// pointer to this structure.  The Expr.iAgg field is the index in
// AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate
// code for that node.
//
// AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the
// original Select structure that describes the SELECT statement.  These
// fields do not need to be freed when deallocating the AggInfo structure.
type AggInfo_func = struct {
	FpFExpr    uintptr
	FpFunc     uintptr
	FiMem      int32
	FiDistinct int32
	FiDistAddr int32
} /* sqlite3.h:249:9 */

// The datatype ynVar is a signed integer, either 16-bit or 32-bit.
// Usually it is 16-bits.  But if SQLITE_MAX_VARIABLE_NUMBER is greater
// than 32767 we have to make it 32-bit.  16-bit is preferred because
// it uses less memory in the Expr object, which is a big memory user
// in systems with lots of prepared statements.  And few applications
// need more than about 10 or 20 variables.  But some extreme users want
// to have prepared statements with over 32766 variables, and for them
// the option is available (at compile-time).
type ynVar = i16 /* sqliteInt.h:2622:13 */

// The following are the meanings of bits in the Expr.flags field.
// Value restrictions:
//
//          EP_Agg == NC_HasAgg == SF_HasAgg
//          EP_Win == NC_HasWin
//   0x400000 // Available
//   0x80000000 // Available

// The EP_Propagate mask is a set of properties that automatically propagate
// upwards into parent nodes.

// These macros can be used to test, set, or clear bits in the
// Expr.flags field.

// Flags for use with Expr.vvaFlags

// The ExprSetVVAProperty() macro is used for Verification, Validation,
// and Accreditation only.  It works like ExprSetProperty() during VVA
// processes but is a no-op for delivery.

// Macros to determine the number of bytes required by a normal Expr
// struct, an Expr struct with the EP_Reduced flag set in Expr.flags
// and an Expr struct with the EP_TokenOnly flag set.

// Flags passed to the sqlite3ExprDup() function. See the header comment
// above sqlite3ExprDup() for details.

// True if the expression passed as an argument was a function with
// an OVER() clause (a window function).

// A list of expressions.  Each expression may optionally have a
// name.  An expr/name combination can be used in several ways, such
// as the list of "expr AS ID" fields following a "SELECT" or in the
// list of "ID = expr" items in an UPDATE.  A list of expressions can
// also be used as the argument to a function, in which case the a.zName
// field is not used.
//
// In order to try to keep memory usage down, the Expr.a.zEName field
// is used for multiple purposes:
//
//     eEName          Usage
//    ----------       -------------------------
//    ENAME_NAME       (1) the AS of result set column
//                     (2) COLUMN= of an UPDATE
//
//    ENAME_TAB        DB.TABLE.NAME used to resolve names
//                     of subqueries
//
//    ENAME_SPAN       Text of the original result set
//                     expression.
type ExprList_item = struct {
	FpExpr     uintptr
	FzEName    uintptr
	FsortFlags u8
	_          [3]byte
	FeEName    uint8 /* unsigned eEName: 2, unsigned done: 1, unsigned reusable: 1, unsigned bSorterRef: 1, unsigned bNulls: 1 */
	_          [3]byte
	Fu         struct {
		_  [0]uint32
		Fx struct {
			FiOrderByCol u16
			FiAlias      u16
		}
	}
} /* sqlite3.h:249:9 */

// Allowed values for Expr.a.eEName

// An instance of this structure can hold a simple list of identifiers,
// such as the list "a,b,c" in the following statements:
//
//      INSERT INTO t(a,b,c) VALUES ...;
//      CREATE INDEX idx ON t(a,b,c);
//      CREATE TRIGGER trig BEFORE UPDATE ON t(a,b,c) ...;
//
// The IdList.a.idx field is used when the IdList represents the list of
// column names after a table name in an INSERT statement.  In the statement
//
//     INSERT INTO t(a,b,c) ...
//
// If "a" is the k-th column of table "t", then IdList.a[0].idx==k.
type IdList_item = struct {
	FzName uintptr
	Fidx   int32
} /* sqlite3.h:249:9 */

// The yDbMask datatype for the bitmask of all attached databases.
type yDbMask = uint32 /* sqliteInt.h:3379:24 */

// A pointer to this structure is used to communicate information
// from sqlite3Init and OP_ParseSchema into the sqlite3InitCallback.
type InitData = struct {
	Fdb         uintptr
	FpzErrMsg   uintptr
	FiDb        int32
	Frc         int32
	FmInitFlags u32
	FnInitRow   u32
	FmxPage     Pgno
} /* sqliteInt.h:3737:3 */

// Allowed values for mInitFlags

// Tuning parameters are set using SQLITE_TESTCTRL_TUNE and are controlled
// on debug-builds of the CLI using ".testctrl tune ID VALUE".  Tuning
// parameters are for temporary use during development, to help find
// optimial values for parameters in the query planner.  The should not
// be used on trunk check-ins.  They are a temporary mechanism available
// for transient development builds only.
//
// Tuning parameters are numbered starting with 1.

// Structure containing global configuration data for the SQLite library.
//
// This structure also contains some state information.
type Sqlite3Config = struct {
	FbMemstat            int32
	FbCoreMutex          u8
	FbFullMutex          u8
	FbOpenUri            u8
	FbUseCis             u8
	FbSmallMalloc        u8
	FbExtraSchemaChecks  u8
	_                    [2]byte
	FmxStrlen            int32
	FneverCorrupt        int32
	FszLookaside         int32
	FnLookaside          int32
	FnStmtSpill          int32
	Fm                   sqlite3_mem_methods
	Fmutex               sqlite3_mutex_methods
	Fpcache2             sqlite3_pcache_methods2
	FpHeap               uintptr
	FnHeap               int32
	FmnReq               int32
	FmxReq               int32
	FszMmap              sqlite3_int64
	FmxMmap              sqlite3_int64
	FpPage               uintptr
	FszPage              int32
	FnPage               int32
	FmxParserStack       int32
	FsharedCacheEnabled  int32
	FszPma               u32
	FisInit              int32
	FinProgress          int32
	FisMutexInit         int32
	FisMallocInit        int32
	FisPCacheInit        int32
	FnRefInitMutex       int32
	FpInitMutex          uintptr
	FxLog                uintptr
	FpLogArg             uintptr
	_                    [4]byte
	FmxMemdbSize         sqlite3_int64
	FxTestCallback       uintptr
	FbLocaltimeFault     int32
	FiOnceResetThreshold int32
	FszSorterRef         u32
	FiPrngSeed           uint32
	_                    [4]byte
} /* sqliteInt.h:3766:1 */

// 2003 September 6
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This is the header file for information that is private to the
// VDBE.  This information used to all be at the top of the single
// source code file "vdbe.c".  When that file became too big (over
// 6000 lines long) it was split up into several smaller files and
// this header information was factored out.

// The maximum number of times that a statement will try to reparse
// itself before giving up and returning SQLITE_SCHEMA.

// VDBE_DISPLAY_P4 is true or false depending on whether or not the
// "explain" P4 display logic is enabled.

// SQL is translated into a sequence of instructions to be
// executed by a virtual machine.  Each instruction is an instance
// of the following structure.
type Op = VdbeOp1 /* vdbeInt.h:46:23 */

// Boolean values
type Bool = uint32 /* vdbeInt.h:51:18 */

// Elements of the linked list at Vdbe.pAuxData
type AuxData1 = struct {
	FiAuxOp     int32
	FiAuxArg    int32
	FpAux       uintptr
	FxDeleteAux uintptr
	FpNextAux   uintptr
} /* sqlite3.h:249:9 */

// Elements of the linked list at Vdbe.pAuxData
type AuxData = AuxData1 /* vdbeInt.h:57:24 */

// Types of VDBE cursors

// A VdbeCursor is an superclass (a wrapper) for various cursor objects:
//
//      * A b-tree cursor
//          -  In the main database or in an ephemeral database
//          -  On either an index or a table
//      * A sorter
//      * A virtual table
//      * A one-row "pseudotable" stored in a single register
type VdbeCursor1 = struct {
	FeCurType       u8
	FiDb            i8
	FnullRow        u8
	FdeferredMoveto u8
	FisTable        u8
	_               [3]byte
	FisEphemeral    uint8 /* Bool isEphemeral: 1, Bool useRandomRowid: 1, Bool isOrdered: 1, Bool hasBeenDuped: 1 */
	_               [1]byte
	FseekHit        u16
	FpBtx           uintptr
	FseqCount       i64
	FaAltMap        uintptr
	FcacheStatus    u32
	FseekResult     int32
	FpAltCursor     uintptr
	Fuc             struct{ FpCursor uintptr }
	FpKeyInfo       uintptr
	FiHdrOffset     u32
	FpgnoRoot       Pgno
	FnField         i16
	FnHdrParsed     u16
	_               [4]byte
	FmovetoTarget   i64
	FaOffset        uintptr
	FaRow           uintptr
	FpayloadSize    u32
	FszRow          u32
	FaType          [1]u32
	_               [4]byte
} /* sqlite3.h:249:9 */

// Types of VDBE cursors

// A VdbeCursor is an superclass (a wrapper) for various cursor objects:
//
//      * A b-tree cursor
//          -  In the main database or in an ephemeral database
//          -  On either an index or a table
//      * A sorter
//      * A virtual table
//      * A one-row "pseudotable" stored in a single register
type VdbeCursor = VdbeCursor1 /* vdbeInt.h:75:27 */

// A value for VdbeCursor.cacheStatus that means the cache is always invalid.

// When a sub-program is executed (OP_Program), a structure of this type
// is allocated to store the current value of the program counter, as
// well as the current memory cell array and various other frame specific
// values stored in the Vdbe struct. When the sub-program is finished,
// these values are copied back to the Vdbe from the VdbeFrame structure,
// restoring the state of the VM to as it was before the sub-program
// began executing.
//
// The memory for a VdbeFrame object is allocated and managed by a memory
// cell in the parent (calling) frame. When the memory cell is deleted or
// overwritten, the VdbeFrame object is not freed immediately. Instead, it
// is linked into the Vdbe.pDelFrame list. The contents of the Vdbe.pDelFrame
// list is deleted when the VM is reset in VdbeHalt(). The reason for doing
// this instead of deleting the VdbeFrame immediately is to avoid recursive
// calls to sqlite3VdbeMemRelease() when the memory cells belonging to the
// child frame are released.
//
// The currently executing frame is stored in Vdbe.pFrame. Vdbe.pFrame is
// set to NULL if the currently executing frame is the main program.
type VdbeFrame1 = struct {
	Fv         uintptr
	FpParent   uintptr
	FaOp       uintptr
	FanExec    uintptr
	FaMem      uintptr
	FapCsr     uintptr
	FaOnce     uintptr
	Ftoken     uintptr
	FlastRowid i64
	FpAuxData  uintptr
	FnCursor   int32
	Fpc        int32
	FnOp       int32
	FnMem      int32
	FnChildMem int32
	FnChildCsr int32
	FnChange   int32
	FnDbChange int32
	_          [4]byte
} /* sqlite3.h:249:9 */

// A value for VdbeCursor.cacheStatus that means the cache is always invalid.

// When a sub-program is executed (OP_Program), a structure of this type
// is allocated to store the current value of the program counter, as
// well as the current memory cell array and various other frame specific
// values stored in the Vdbe struct. When the sub-program is finished,
// these values are copied back to the Vdbe from the VdbeFrame structure,
// restoring the state of the VM to as it was before the sub-program
// began executing.
//
// The memory for a VdbeFrame object is allocated and managed by a memory
// cell in the parent (calling) frame. When the memory cell is deleted or
// overwritten, the VdbeFrame object is not freed immediately. Instead, it
// is linked into the Vdbe.pDelFrame list. The contents of the Vdbe.pDelFrame
// list is deleted when the VM is reset in VdbeHalt(). The reason for doing
// this instead of deleting the VdbeFrame immediately is to avoid recursive
// calls to sqlite3VdbeMemRelease() when the memory cells belonging to the
// child frame are released.
//
// The currently executing frame is stored in Vdbe.pFrame. Vdbe.pFrame is
// set to NULL if the currently executing frame is the main program.
type VdbeFrame = VdbeFrame1 /* vdbeInt.h:162:26 */

// Magic number for sanity checking on VdbeFrame objects

// Return a pointer to the array of registers allocated for use
// by a VdbeFrame.

// Internally, the vdbe manipulates nearly all SQL values as Mem
// structures. Each Mem struct may cache multiple representations (string,
// integer etc.) of the same value.
type MemValue = struct{ Fr float64 } /* sqlite3.h:249:9 */

// A bitfield type for use inside of structures.  Always follow with :N where
// N is the number of bits.
type bft = uint32 /* vdbeInt.h:345:18 */ // Bit Field Type

// The ScanStatus object holds a single value for the
// sqlite3_stmt_scanstatus() interface.
type ScanStatus1 = struct {
	FaddrExplain int32
	FaddrLoop    int32
	FaddrVisit   int32
	FiSelectID   int32
	FnEst        LogEst
	_            [2]byte
	FzName       uintptr
} /* vdbeInt.h:350:9 */

// Bit Field Type

// The ScanStatus object holds a single value for the
// sqlite3_stmt_scanstatus() interface.
type ScanStatus = ScanStatus1 /* vdbeInt.h:350:27 */

// The DblquoteStr object holds the text of a double-quoted
// string for a prepared statement.  A linked list of these objects
// is constructed during statement parsing and is held on Vdbe.pDblStr.
// When computing a normalized SQL statement for an SQL statement, that
// list is consulted for each double-quoted identifier to see if the
// identifier should really be a string literal.
type DblquoteStr1 = struct {
	FpNextStr uintptr
	Fz        [8]int8
} /* vdbeInt.h:367:9 */

// The DblquoteStr object holds the text of a double-quoted
// string for a prepared statement.  A linked list of these objects
// is constructed during statement parsing and is held on Vdbe.pDblStr.
// When computing a normalized SQL statement for an SQL statement, that
// list is consulted for each double-quoted identifier to see if the
// identifier should really be a string literal.
type DblquoteStr = DblquoteStr1 /* vdbeInt.h:367:28 */

// Convert text generated by the "%p" conversion format back into
// a pointer.
func testHexToInt(tls *libc.TLS, h int32) int32 { /* test1.c:44:12: */
	if (h >= '0') && (h <= '9') {
		return (h - '0')
	} else if (h >= 'a') && (h <= 'f') {
		return ((h - 'a') + 10)
	} else {

		return ((h - 'A') + 10)
	}
	return int32(0)
}

func sqlite3TestTextToPtr(tls *libc.TLS, z uintptr) uintptr { /* test1.c:54:6: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	// var p uintptr at bp, 4

	// var v u64 at bp+8, 8

	// var v2 u32 at bp+16, 4

	if (int32(*(*int8)(unsafe.Pointer(z))) == '0') && (int32(*(*int8)(unsafe.Pointer(z + 1))) == 'x') {
		z += uintptr(2)
	}
	*(*u64)(unsafe.Pointer(bp + 8 /* v */)) = uint64(0)
	for *(*int8)(unsafe.Pointer(z)) != 0 {
		*(*u64)(unsafe.Pointer(bp + 8 /* v */)) = ((*(*u64)(unsafe.Pointer(bp + 8 /* v */)) << 4) + u64(testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(z))))))
		z++
	}
	if uint32(unsafe.Sizeof(uintptr(0))) == uint32(unsafe.Sizeof(u64(0))) {
		libc.Xmemcpy(tls, bp /* &p */, bp+8 /* &v */, uint32(unsafe.Sizeof(uintptr(0))))
	} else {

		*(*u32)(unsafe.Pointer(bp + 16 /* v2 */)) = u32(*(*u64)(unsafe.Pointer(bp + 8 /* v */)))
		libc.Xmemcpy(tls, bp /* &p */, bp+16 /* &v2 */, uint32(unsafe.Sizeof(uintptr(0))))
	}
	return *(*uintptr)(unsafe.Pointer(bp /* p */))
}

// A TCL command that returns the address of the sqlite* pointer
// for an sqlite connection instance.  Bad things happen if the
// input is not an sqlite connection.
func get_sqlite_pointer(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:82:26: */
	bp := tls.Alloc(180)
	defer tls.Free(180)

	var p uintptr
	// var cmdInfo Tcl_CmdInfo at bp+48, 32

	// var zBuf [100]int8 at bp+80, 100

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+14521 /* "SQLITE-CONNECTIO..." */)
		return TCL_ERROR
	}
	if !(tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48 /* &cmdInfo */) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14539, /* "command not foun..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	p = (*Tcl_CmdInfo)(unsafe.Pointer(bp + 48 /* &cmdInfo */)).FobjClientData
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+80 /* &zBuf[0] */, ts+13021 /* "%p" */, libc.VaList(bp+24, (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+80 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Decode a pointer to an sqlite3 object.
func getDbPointer(tls *libc.TLS, interp uintptr, zA uintptr, ppDb uintptr) int32 { /* test1.c:109:5: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var p uintptr
	// var cmdInfo Tcl_CmdInfo at bp, 32

	if tcl.XTcl_GetCommandInfo(tls, interp, zA, bp /* &cmdInfo */) != 0 {
		p = (*Tcl_CmdInfo)(unsafe.Pointer(bp /* &cmdInfo */)).FobjClientData
		*(*uintptr)(unsafe.Pointer(ppDb)) = (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb
	} else {
		*(*uintptr)(unsafe.Pointer(ppDb)) = sqlite3TestTextToPtr(tls, zA)
	}
	return TCL_OK
}

// Convert an sqlite3_stmt* into an sqlite3*.  This depends on the
// fact that the sqlite3* is the first field in the Vdbe structure.

// Check a return value to make sure it agrees with the results
// from sqlite3_errcode.
func sqlite3TestErrCode(tls *libc.TLS, interp uintptr, db uintptr, rc int32) int32 { /* test1.c:144:5: */
	bp := tls.Alloc(248)
	defer tls.Free(248)

	if (((sqlite3.Xsqlite3_threadsafe(tls) == 0) && (rc != SQLITE_MISUSE)) && (rc != SQLITE_OK)) &&
		(sqlite3.Xsqlite3_errcode(tls, db) != rc) {
		// var zBuf [200]int8 at bp+48, 200

		var r2 int32 = sqlite3.Xsqlite3_errcode(tls, db)
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+48, /* &zBuf[0] */
			ts+14559, /* "error code %s (%..." */
			libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), rc, sqlite3.Xsqlite3ErrName(tls, r2), r2))
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+48 /* &zBuf[0] */, 0))
		return 1
	}
	return 0
}

// Decode a pointer to an sqlite3_stmt object.
func getStmtPointer(tls *libc.TLS, interp uintptr, zArg uintptr, ppStmt uintptr) int32 { /* test1.c:162:12: */
	*(*uintptr)(unsafe.Pointer(ppStmt)) = sqlite3TestTextToPtr(tls, zArg)
	return TCL_OK
}

// Generate a text representation of a pointer that can be understood
// by the getDbPointer and getVmPointer routines above.
//
// The problem is, on some machines (Solaris) if you do a printf with
// "%p" you cannot turn around and do a scanf with the same "%p" and
// get your pointer back.  You have to prepend a "0x" before it will
// work.  Or at least that is what is reported to me (drh).  But this
// behavior varies from machine to machine.  The solution used her is
// to test the string right after it is generated to see if it can be
// understood by scanf, and if not, try prepending an "0x" to see if
// that helps.  If nothing works, a fatal error is generated.
func sqlite3TestMakePointerStr(tls *libc.TLS, interp uintptr, zPtr uintptr, p uintptr) int32 { /* test1.c:184:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_snprintf(tls, 100, zPtr, ts+13021 /* "%p" */, libc.VaList(bp, p))
	return TCL_OK
}

// The callback routine for sqlite3_exec_printf().
func exec_printf_cb(tls *libc.TLS, pArg uintptr, argc int32, argv uintptr, name uintptr) int32 { /* test1.c:192:12: */
	var str uintptr = pArg
	var i int32

	if ((*Tcl_DString)(unsafe.Pointer(str)).Flength) == 0 {
		for i = 0; i < argc; i++ {
			tcl.XTcl_DStringAppendElement(tls, str, func() uintptr {
				if *(*uintptr)(unsafe.Pointer(name + uintptr(i)*4)) != 0 {
					return *(*uintptr)(unsafe.Pointer(name + uintptr(i)*4))
				}
				return ts + 5707 /* "NULL" */
			}())
		}
	}
	for i = 0; i < argc; i++ {
		tcl.XTcl_DStringAppendElement(tls, str, func() uintptr {
			if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)) != 0 {
				return *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))
			}
			return ts + 5707 /* "NULL" */
		}())
	}
	return 0
}

// The I/O tracing callback.

// Usage:  io_trace FILENAME
//
// Turn I/O tracing on or off.  If FILENAME is not an empty string,
// I/O tracing begins going into FILENAME. If FILENAME is an empty
// string, I/O tracing is turned off.
func test_io_trace(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:228:26: */
	return TCL_OK
}

// Usage:  clang_sanitize_address
//
// Returns true if the program was compiled using clang with the
// -fsanitize=address switch on the command line. False otherwise.
//
// Also return true if the OMIT_MISUSE environment variable exists.
func clang_sanitize_address(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:269:26: */
	var res int32 = 0
	if (res == 0) && (libc.Xgetenv(tls, ts+14617 /* "OMIT_MISUSE" */) != uintptr(0)) {
		res = 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
	return TCL_OK
}

// Usage:  sqlite3_exec_printf  DB  FORMAT  STRING
//
// Invoke the sqlite3_exec_printf() interface using the open database
// DB.  The SQL is the string FORMAT.  The format string should contain
// one %s or %q.  STRING is the value inserted into %s or %q.
func test_exec_printf(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:296:26: */
	bp := tls.Alloc(298)
	defer tls.Free(298)

	// var db uintptr at bp+48, 4

	// var str Tcl_DString at bp+52, 212

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 264 /* zErr */)) = uintptr(0)
	var zSql uintptr
	// var zBuf [30]int8 at bp+268, 30

	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14655 /* " DB FORMAT STRIN..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_DStringInit(tls, bp+52 /* &str */)
	zSql = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 3*4))))
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+52 /* &str */, bp+264 /* &zErr */)
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+268 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+268 /* &zBuf[0] */)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == SQLITE_OK {
			return (*Tcl_DString)(unsafe.Pointer(bp + 52 /* &str */)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 264 /* zErr */))
	}())
	tcl.XTcl_DStringFree(tls, bp+52 /* &str */)
	if *(*uintptr)(unsafe.Pointer(bp + 264 /* zErr */)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 264 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_exec_hex  DB  HEX
//
// Invoke the sqlite3_exec() on a string that is obtained by translating
// HEX into ASCII.  Most characters are translated as is.  %HH becomes
// a hex character.
func test_exec_hex(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:334:26: */
	bp := tls.Alloc(794)
	defer tls.Free(794)

	// var db uintptr at bp+40, 4

	// var str Tcl_DString at bp+548, 212

	var rc int32
	var i int32
	var j int32
	*(*uintptr)(unsafe.Pointer(bp + 760 /* zErr */)) = uintptr(0)
	var zHex uintptr
	// var zSql [501]int8 at bp+44, 501

	// var zBuf [30]int8 at bp+764, 30

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14673 /* " DB HEX" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+40 /* &db */) != 0 {
		return TCL_ERROR
	}
	zHex = *(*uintptr)(unsafe.Pointer(argv + 2*4))
	i = libc.AssignInt32(&j, 0)
__1:
	if !((uint32(i) < (uint32(unsafe.Sizeof([501]int8{})) - uint32(1))) && (*(*int8)(unsafe.Pointer(zHex + uintptr(j))) != 0)) {
		goto __3
	}
	{
		if ((int32(*(*int8)(unsafe.Pointer(zHex + uintptr(j)))) == '%') && (*(*int8)(unsafe.Pointer(zHex + uintptr((j + 2)))) != 0)) && (*(*int8)(unsafe.Pointer(zHex + uintptr((j + 2)))) != 0) {
			*(*int8)(unsafe.Pointer(bp + 44 /* &zSql[0] */ + uintptr(i))) = (int8((testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zHex + uintptr((j + 1)))))) << 4) + testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zHex + uintptr((j + 2))))))))
			j = j + (2)
		} else {
			*(*int8)(unsafe.Pointer(bp + 44 /* &zSql[0] */ + uintptr(i))) = *(*int8)(unsafe.Pointer(zHex + uintptr(j)))
		}

	}
	goto __2
__2:
	i++
	j++
	goto __1
	goto __3
__3:
	;
	*(*int8)(unsafe.Pointer(bp + 44 /* &zSql[0] */ + uintptr(i))) = int8(0)
	tcl.XTcl_DStringInit(tls, bp+548 /* &str */)
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* db */)), bp+44 /* &zSql[0] */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+548 /* &str */, bp+760 /* &zErr */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+764 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+32, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+764 /* &zBuf[0] */)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == SQLITE_OK {
			return (*Tcl_DString)(unsafe.Pointer(bp + 548 /* &str */)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 760 /* zErr */))
	}())
	tcl.XTcl_DStringFree(tls, bp+548 /* &str */)
	if *(*uintptr)(unsafe.Pointer(bp + 760 /* zErr */)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 760 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 40 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  db_enter DB
//         db_leave DB
//
// Enter or leave the mutex on a database connection.
func db_enter(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:380:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
	return TCL_OK
}

func db_leave(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:396:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
	return TCL_OK
}

// Usage:  sqlite3_exec  DB  SQL
//
// Invoke the sqlite3_exec interface using the open database DB
func test_exec(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:418:26: */
	bp := tls.Alloc(298)
	defer tls.Free(298)

	// var db uintptr at bp+48, 4

	// var str Tcl_DString at bp+52, 212

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 264 /* zErr */)) = uintptr(0)
	var zSql uintptr
	var i int32
	var j int32
	// var zBuf [30]int8 at bp+268, 30

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14685 /* " DB SQL" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_DStringInit(tls, bp+52 /* &str */)
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	for i = libc.AssignInt32(&j, 0); *(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0; {
		if int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i)))) == '%' {
			*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = (int8((testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zSql + uintptr((i + 1)))))) << 4) + testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zSql + uintptr((i + 2))))))))
			i = i + (3)
		} else {
			*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&i, 1))))
		}
	}
	*(*int8)(unsafe.Pointer(zSql + uintptr(j))) = int8(0)
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+52 /* &str */, bp+264 /* &zErr */)
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+268 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+268 /* &zBuf[0] */)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == SQLITE_OK {
			return (*Tcl_DString)(unsafe.Pointer(bp + 52 /* &str */)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 264 /* zErr */))
	}())
	tcl.XTcl_DStringFree(tls, bp+52 /* &str */)
	if *(*uintptr)(unsafe.Pointer(bp + 264 /* zErr */)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 264 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_exec_nr  DB  SQL
//
// Invoke the sqlite3_exec interface using the open database DB.  Discard
// all results
func test_exec_nr(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:465:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 4

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 36 /* zErr */)) = uintptr(0)
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14685 /* " DB SQL" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(argv + 2*4)), uintptr(0), uintptr(0), bp+36 /* &zErr */)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_mprintf_z_test  SEPARATOR  ARG0  ARG1 ...
//
// Test the %z format of sqlite_mprintf().  Use multiple mprintf() calls to
// concatenate arg0 through argn using separator as the separator.
// Return the result.
func test_mprintf_z(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:492:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zResult uintptr = uintptr(0)
	var i int32

	for i = 2; (i < argc) && ((i == 2) || (zResult != 0)); i++ {
		zResult = sqlite3.Xsqlite3_mprintf(tls, ts+14693 /* "%z%s%s" */, libc.VaList(bp, zResult, *(*uintptr)(unsafe.Pointer(argv + 1*4)), *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, zResult, 0))
	sqlite3.Xsqlite3_free(tls, zResult)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_n_test  STRING
//
// Test the %n format of sqlite_mprintf().  Return the length of the
// input string.
func test_mprintf_n(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:515:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var zStr uintptr
	*(*int32)(unsafe.Pointer(bp + 16 /* n */)) = 0
	zStr = sqlite3.Xsqlite3_mprintf(tls, ts+14700 /* "%s%n" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+16 /* &n */))
	sqlite3.Xsqlite3_free(tls, zStr)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 16 /* n */))))
	return TCL_OK
}

// Usage:  sqlite3_snprintf_int  SIZE FORMAT  INT
//
// Test the of sqlite3_snprintf() routine.  SIZE is the size of the
// output buffer in bytes.  The maximum size is 100.  FORMAT is the
// format string.  INT is a single integer argument.  The FORMAT
// string must require no more than this one integer argument.  If
// You pass in a format string that requires more than one argument,
// bad things will happen.
func test_snprintf_int(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:539:26: */
	bp := tls.Alloc(124)
	defer tls.Free(124)

	// var zStr [100]int8 at bp+24, 100

	var n int32 = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	var zFormat uintptr = *(*uintptr)(unsafe.Pointer(argv + 2*4))
	var a1 int32 = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
	if uint32(n) > uint32(unsafe.Sizeof([100]int8{})) {
		n = int32(unsafe.Sizeof([100]int8{}))
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+24 /* &zStr[0] */, ts+14705 /* "abcdefghijklmnop..." */, 0)
	sqlite3.Xsqlite3_snprintf(tls, n, bp+24 /* &zStr[0] */, zFormat, libc.VaList(bp, a1))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+8, bp+24 /* &zStr[0] */, 0))
	return TCL_OK
}

// Usage:  sqlite3_get_table_printf  DB  FORMAT  STRING  ?--no-counts?
//
// Invoke the sqlite3_get_table_printf() interface using the open database
// DB.  The SQL is the string FORMAT.  The format string should contain
// one %s or %q.  STRING is the value inserted into %s or %q.
func test_get_table_printf(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:565:26: */
	bp := tls.Alloc(330)
	defer tls.Free(330)

	// var db uintptr at bp+68, 4

	// var str Tcl_DString at bp+72, 212

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 288 /* zErr */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 292 /* nRow */)) = 0
	*(*int32)(unsafe.Pointer(bp + 296 /* nCol */)) = 0
	// var aResult uintptr at bp+284, 4

	var i int32
	// var zBuf [30]int8 at bp+300, 30

	var zSql uintptr
	*(*int32)(unsafe.Pointer(bp + 64 /* resCount */)) = -1
	if argc == 5 {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*4)), bp+64 /* &resCount */) != 0 {
			return TCL_ERROR
		}
	}
	if (argc != 4) && (argc != 5) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14732 /* " DB FORMAT STRIN..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+68 /* &db */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_DStringInit(tls, bp+72 /* &str */)
	zSql = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 3*4))))
	if argc == 5 {
		rc = sqlite3.Xsqlite3_get_table(tls, *(*uintptr)(unsafe.Pointer(bp + 68 /* db */)), zSql, bp+284 /* &aResult */, uintptr(0), uintptr(0), bp+288 /* &zErr */)
	} else {
		rc = sqlite3.Xsqlite3_get_table(tls, *(*uintptr)(unsafe.Pointer(bp + 68 /* db */)), zSql, bp+284 /* &aResult */, bp+292 /* &nRow */, bp+296 /* &nCol */, bp+288 /* &zErr */)
		*(*int32)(unsafe.Pointer(bp + 64 /* resCount */)) = ((*(*int32)(unsafe.Pointer(bp + 292 /* nRow */)) + 1) * *(*int32)(unsafe.Pointer(bp + 296 /* nCol */)))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+300 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+300 /* &zBuf[0] */)
	if rc == SQLITE_OK {
		if argc == 4 {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+300 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 292 /* nRow */))))
			tcl.XTcl_AppendElement(tls, interp, bp+300 /* &zBuf[0] */)
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+300 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+56, *(*int32)(unsafe.Pointer(bp + 296 /* nCol */))))
			tcl.XTcl_AppendElement(tls, interp, bp+300 /* &zBuf[0] */)
		}
		for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* resCount */)); i++ {
			tcl.XTcl_AppendElement(tls, interp, func() uintptr {
				if *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 284 /* aResult */)) + uintptr(i)*4)) != 0 {
					return *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 284 /* aResult */)) + uintptr(i)*4))
				}
				return ts + 5707 /* "NULL" */
			}())
		}
	} else {
		tcl.XTcl_AppendElement(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 288 /* zErr */)))
	}
	sqlite3.Xsqlite3_free_table(tls, *(*uintptr)(unsafe.Pointer(bp + 284 /* aResult */)))
	if *(*uintptr)(unsafe.Pointer(bp + 288 /* zErr */)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 288 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 68 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_last_insert_rowid DB
//
// Returns the integer ROWID of the most recent insert.
func test_last_rowid(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:628:26: */
	bp := tls.Alloc(90)
	defer tls.Free(90)

	// var db uintptr at bp+56, 4

	// var zBuf [30]int8 at bp+60, 30

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)), ts+14758 /* " DB\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+56 /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+60 /* &zBuf[0] */, ts+10545 /* "%lld" */, libc.VaList(bp+32, sqlite3.Xsqlite3_last_insert_rowid(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+60 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// Usage:  sqlite3_key DB KEY
//
// Set the codec key.
func test_key(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:652:26: */
	return TCL_OK
}

// Usage:  sqlite3_rekey DB KEY
//
// Change the codec key.
func test_rekey(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:666:26: */
	return TCL_OK
}

// Usage:  sqlite3_close DB
//
// Closes the database opened by sqlite3_open.
func sqlite_test_close(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:680:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14763 /* " FILENAME\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage:  sqlite3_close_v2 DB
//
// Closes the database opened by sqlite3_open.
func sqlite_test_close_v2(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:704:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14763 /* " FILENAME\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_close_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Implementation of the x_coalesce() function.
// Return the first argument non-NULL argument.
func t1_ifnullFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:727:13: */
	var i int32
	for i = 0; i < argc; i++ {
		if SQLITE_NULL != sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))) {
			var n int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			sqlite3.Xsqlite3_result_text(tls, context, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))),
				n, libc.UintptrFromInt32(-1))
			break
		}
	}
}

// These are test functions.    hex8() interprets its argument as
// UTF8 and returns a hex encoding.  hex16le() interprets its argument
// as UTF16le and returns a hex encoding.
func hex8Func(tls *libc.TLS, p uintptr, argc int32, argv uintptr) { /* test1.c:748:13: */
	bp := tls.Alloc(208)
	defer tls.Free(208)

	var z uintptr
	var i int32
	// var zBuf [200]int8 at bp+8, 200

	z = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	for i = 0; (uint32(i) < ((uint32(unsafe.Sizeof([200]int8{})) / uint32(2)) - uint32(2))) && (*(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0); i++ {
		sqlite3.Xsqlite3_snprintf(tls, (int32(uint32(unsafe.Sizeof([200]int8{})) - (uint32(i * 2)))), (bp + 8 /* &zBuf */ + uintptr((i * 2))), ts+14774 /* "%02x" */, libc.VaList(bp, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))))
	}
	*(*int8)(unsafe.Pointer(bp + 8 /* &zBuf[0] */ + uintptr((i * 2)))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, p, bp+8 /* zBuf */, -1, libc.UintptrFromInt32(-1))
}

func hex16Func(tls *libc.TLS, p uintptr, argc int32, argv uintptr) { /* test1.c:760:13: */
	bp := tls.Alloc(408)
	defer tls.Free(408)

	var z uintptr
	var i int32
	// var zBuf [400]int8 at bp+8, 400

	z = sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	for i = 0; (uint32(i) < ((uint32(unsafe.Sizeof([400]int8{})) / uint32(4)) - uint32(4))) && (*(*uint16)(unsafe.Pointer(z + uintptr(i)*2)) != 0); i++ {
		sqlite3.Xsqlite3_snprintf(tls, (int32(uint32(unsafe.Sizeof([400]int8{})) - (uint32(i * 4)))), (bp + 8 /* &zBuf */ + uintptr((i * 4))), ts+14779 /* "%04x" */, libc.VaList(bp, (int32(*(*uint16)(unsafe.Pointer(z + uintptr(i)*2)))&0xff)))
	}
	*(*int8)(unsafe.Pointer(bp + 8 /* &zBuf[0] */ + uintptr((i * 4)))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, p, bp+8 /* zBuf */, -1, libc.UintptrFromInt32(-1))
}

// A structure into which to accumulate text.
type dstr = struct {
	FnAlloc int32
	FnUsed  int32
	Fz      uintptr
} /* test1.c:776:1 */

// Append text to a dstr
func dstrAppend(tls *libc.TLS, p uintptr, z uintptr, divider int32) { /* test1.c:785:13: */
	var n int32 = int32(libc.Xstrlen(tls, z))
	if (((*dstr)(unsafe.Pointer(p)).FnUsed + n) + 2) > (*dstr)(unsafe.Pointer(p)).FnAlloc {
		var zNew uintptr
		(*dstr)(unsafe.Pointer(p)).FnAlloc = ((((*dstr)(unsafe.Pointer(p)).FnAlloc * 2) + n) + 200)
		zNew = sqlite3.Xsqlite3_realloc(tls, (*dstr)(unsafe.Pointer(p)).Fz, (*dstr)(unsafe.Pointer(p)).FnAlloc)
		if zNew == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*dstr)(unsafe.Pointer(p)).Fz)
			libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(dstr{})))
			return
		}
		(*dstr)(unsafe.Pointer(p)).Fz = zNew
	}
	if (divider != 0) && ((*dstr)(unsafe.Pointer(p)).FnUsed > 0) {
		*(*int8)(unsafe.Pointer((*dstr)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*dstr)(unsafe.Pointer(p)).FnUsed, 1)))) = int8(divider)
	}
	libc.Xmemcpy(tls, ((*dstr)(unsafe.Pointer(p)).Fz + uintptr((*dstr)(unsafe.Pointer(p)).FnUsed)), z, (uint32(n + 1)))
	*(*int32)(unsafe.Pointer(p + 4 /* &.nUsed */)) += (n)
}

// Invoked for each callback from sqlite3ExecFunc
func execFuncCallback(tls *libc.TLS, pData uintptr, argc int32, argv uintptr, NotUsed uintptr) int32 { /* test1.c:808:12: */
	var p uintptr = pData
	var i int32
	for i = 0; i < argc; i++ {
		if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)) == uintptr(0) {
			dstrAppend(tls, p, ts+5707 /* "NULL" */, ' ')
		} else {
			dstrAppend(tls, p, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), ' ')
		}
	}
	return 0
}

// Implementation of the x_sqlite_exec() function.  This function takes
// a single argument and attempts to execute that argument as SQL code.
// This is illegal and should set the SQLITE_MISUSE flag on the database.
//
// 2004-Jan-07:  We have changed this to make it legal to call sqlite3_exec()
// from within a function call.
//
// This routine simulates the effect of having two threads attempt to
// use the same database at the same time.
func sqlite3ExecFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:832:13: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var x dstr at bp, 12

	libc.Xmemset(tls, bp /* &x */, 0, uint32(unsafe.Sizeof(dstr{})))
	sqlite3.Xsqlite3_exec(tls, sqlite3.Xsqlite3_user_data(tls, context),
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
		}{execFuncCallback})), bp /* &x */, uintptr(0))
	sqlite3.Xsqlite3_result_text(tls, context, (*dstr)(unsafe.Pointer(bp /* &x */)).Fz, (*dstr)(unsafe.Pointer(bp /* &x */)).FnUsed, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_free(tls, (*dstr)(unsafe.Pointer(bp /* &x */)).Fz)
}

// Implementation of tkt2213func(), a scalar function that takes exactly
// one argument. It has two interesting features:
//
// * It calls sqlite3_value_text() 3 times on the argument sqlite3_value*.
//   If the three pointers returned are not the same an SQL error is raised.
//
// * Otherwise it returns a copy of the text representation of its
//   argument in such a way as the VDBE representation is a Mem* cell
//   with the MEM_Term flag clear.
//
// Ticket #2213 can therefore be tested by evaluating the following
// SQL expression:
//
//   tkt2213func(tkt2213func('a string'));
func tkt2213Function(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:862:13: */
	var nText int32
	var zText1 uintptr
	var zText2 uintptr
	var zText3 uintptr

	nText = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zText1 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zText2 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zText3 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))

	if (zText1 != zText2) || (zText2 != zText3) {
		sqlite3.Xsqlite3_result_error(tls, context, ts+14784 /* "tkt2213 is not f..." */, -1)
	} else {
		var zCopy uintptr = sqlite3.Xsqlite3_malloc(tls, nText)
		libc.Xmemcpy(tls, zCopy, zText1, uint32(nText))
		sqlite3.Xsqlite3_result_text(tls, context, zCopy, nText, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

// The following SQL function takes 4 arguments.  The 2nd and
// 4th argument must be one of these strings:  'text', 'text16',
// or 'blob' corresponding to API functions
//
//      sqlite3_value_text()
//      sqlite3_value_text16()
//      sqlite3_value_blob()
//
// The third argument is a string, either 'bytes' or 'bytes16' or 'noop',
// corresponding to APIs:
//
//      sqlite3_value_bytes()
//      sqlite3_value_bytes16()
//      noop
//
// The APIs designated by the 2nd through 4th arguments are applied
// to the first argument in order.  If the pointers returned by the
// second and fourth are different, this routine returns 1.  Otherwise,
// this routine returns 0.
//
// This function is used to test to see when returned pointers from
// the _text(), _text16() and _blob() APIs become invalidated.
func ptrChngFunction(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:910:13: */
	var p1 uintptr
	var p2 uintptr
	var zCmd uintptr
	if argc != 4 {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if zCmd == uintptr(0) {
		return
	}
	if libc.Xstrcmp(tls, zCmd, ts+12453 /* "text" */) == 0 {
		p1 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+14805 /* "text16" */) == 0 {
		p1 = sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+12458 /* "blob" */) == 0 {
		p1 = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	if zCmd == uintptr(0) {
		return
	}
	if libc.Xstrcmp(tls, zCmd, ts+14812 /* "bytes" */) == 0 {
		sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+14818 /* "bytes16" */) == 0 {
		sqlite3.Xsqlite3_value_bytes16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+14826 /* "noop" */) == 0 {
		// do nothing
	} else {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
	if zCmd == uintptr(0) {
		return
	}
	if libc.Xstrcmp(tls, zCmd, ts+12453 /* "text" */) == 0 {
		p2 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+14805 /* "text16" */) == 0 {
		p2 = sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+12458 /* "blob" */) == 0 {
		p2 = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else {
		return
	}
	sqlite3.Xsqlite3_result_int(tls, context, (libc.Bool32(p1 != p2)))
}

// This SQL function returns a different answer each time it is called, even if
// the arguments are the same.
func nondeterministicFunction(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:964:13: */
	sqlite3.Xsqlite3_result_int(tls, context, libc.PostIncInt32(&cnt, 1))
}

var cnt int32 = 0 /* test1.c:969:14 */

// This SQL function returns the integer value of its argument as a MEM_IntReal
// value.
func intrealFunction(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:977:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var v sqlite3_int64 = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_int64(tls, context, v)
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_RESULT_INTREAL, libc.VaList(bp, context))
}

// Usage:  sqlite3_create_function DB
//
// Call the sqlite3_create_function API on the given database in order
// to create a function named "x_coalesce".  This function does the same thing
// as the "coalesce" function.  This function also registers an SQL function
// named "x_sqlite_exec" that invokes sqlite3_exec().  Invoking sqlite3_exec()
// in this way is illegal recursion and should raise an SQLITE_MISUSE error.
// The effect is similar to trying to use the same database connection from
// two threads at the same time.
//
// The original motivation for this routine was to be able to call the
// sqlite3_create_function function while a query is in progress in order
// to test the SQLITE_MISUSE detection logic.
func test_create_function(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1002:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32
	// var db uintptr at bp+32, 4

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14758 /* " DB\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14831 /* "x_coalesce" */, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{t1_ifnullFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14842 /* "hex8" */, 1, (SQLITE_UTF8 | SQLITE_DETERMINISTIC),
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{hex8Func})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14847 /* "hex16" */, 1, (SQLITE_UTF16 | SQLITE_DETERMINISTIC),
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{hex16Func})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14853 /* "tkt2213func" */, 1, SQLITE_ANY, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{tkt2213Function})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14865 /* "pointer_change" */, 4, SQLITE_ANY, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{ptrChngFunction})), uintptr(0), uintptr(0))
	}

	// Functions counter1() and counter2() have the same implementation - they
	// both return an ascending integer with each call.  But counter1() is marked
	// as non-deterministic and counter2() is marked as deterministic.
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14880 /* "counter1" */, -1, SQLITE_UTF8,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nondeterministicFunction})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14889 /* "counter2" */, -1, (SQLITE_UTF8 | SQLITE_DETERMINISTIC),
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nondeterministicFunction})), uintptr(0), uintptr(0))
	}

	// The intreal() function converts its argument to an integer and returns
	// it as a MEM_IntReal.
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14898 /* "intreal" */, 1, SQLITE_UTF8,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{intrealFunction})), uintptr(0), uintptr(0))
	}

	// Use the sqlite3_create_function16() API here. Mainly for fun, but also
	// because it is not tested anywhere else.
	if rc == SQLITE_OK {
		var zUtf16 uintptr
		var pVal uintptr
		sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
		pVal = sqlite3.Xsqlite3ValueNew(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, ts+14906 /* "x_sqlite_exec" */, uint8(SQLITE_UTF8), uintptr(0))
		zUtf16 = sqlite3.Xsqlite3ValueText(tls, pVal, uint8(SQLITE_UTF16LE))
		if (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).FmallocFailed != 0 {
			rc = SQLITE_NOMEM
		} else {
			rc = sqlite3.Xsqlite3_create_function16(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), zUtf16,
				1, SQLITE_UTF16, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{sqlite3ExecFunc})), uintptr(0), uintptr(0))
		}
		sqlite3.Xsqlite3ValueFree(tls, pVal)
		sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
	}

	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage:  sqlite3_drop_modules DB ?NAME ...?
//
// Invoke the sqlite3_drop_modules(D,L) interface on database
// connection DB, in order to drop all modules except those named in
// the argument.
func test_drop_modules(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1092:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14758 /* " DB\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_drop_modules(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), func() uintptr {
		if argc > 2 {
			return (argv + uintptr(2)*4)
		}
		return uintptr(0)
	}())
	return TCL_OK
}

// Routines to implement the x_count() aggregate function.
//
// x_count() counts the number of non-null arguments.  But there are
// some twists for testing purposes.
//
// If the argument to x_count() is 40 then a UTF-8 error is reported
// on the step function.  If x_count(41) is seen, then a UTF-16 error
// is reported on the step function.  If the total count is 42, then
// a UTF-8 error is reported on the finalize function.
type t1CountCtx1 = struct{ Fn int32 } /* test1.c:1123:9 */

// Routines to implement the x_count() aggregate function.
//
// x_count() counts the number of non-null arguments.  But there are
// some twists for testing purposes.
//
// If the argument to x_count() is 40 then a UTF-8 error is reported
// on the step function.  If x_count(41) is seen, then a UTF-16 error
// is reported on the step function.  If the total count is 42, then
// a UTF-8 error is reported on the finalize function.
type t1CountCtx = t1CountCtx1 /* test1.c:1123:27 */

func t1CountStep(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:1127:13: */
	bp := tls.Alloc(9)
	defer tls.Free(9)

	var p uintptr
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(t1CountCtx{})))
	if ((argc == 0) || (SQLITE_NULL != sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))))) && (p != 0) {
		(*t1CountCtx)(unsafe.Pointer(p)).Fn++
	}
	if argc > 0 {
		var v int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
		if v == 40 {
			sqlite3.Xsqlite3_result_error(tls, context, ts+14920 /* "value of 40 hand..." */, -1)
		} else if v == 41 {
			*(*[9]int8)(unsafe.Pointer(bp /* zUtf16ErrMsg */)) = [9]int8{int8(0), int8(0x61), int8(0), int8(0x62), int8(0), int8(0x63), int8(0), int8(0), int8(0)}
			sqlite3.Xsqlite3_result_error16(tls, context, (bp /* &zUtf16ErrMsg */ + 1), -1)
		}
	}
}

func t1CountFinalize(tls *libc.TLS, context uintptr) { /* test1.c:1149:13: */
	var p uintptr
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(t1CountCtx{})))
	if p != 0 {
		if (*t1CountCtx)(unsafe.Pointer(p)).Fn == 42 {
			sqlite3.Xsqlite3_result_error(tls, context, ts+14950 /* "x_count totals t..." */, -1)
		} else {
			sqlite3.Xsqlite3_result_int(tls, context, func() int32 {
				if p != 0 {
					return (*t1CountCtx)(unsafe.Pointer(p)).Fn
				}
				return 0
			}())
		}
	}
}

func legacyCountStep(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:1162:13: */
	// no-op
}

func legacyCountFinalize(tls *libc.TLS, context uintptr) { /* test1.c:1170:13: */
	sqlite3.Xsqlite3_result_int(tls, context, sqlite3.Xsqlite3_aggregate_count(tls, context))
}

// Usage:  sqlite3_create_aggregate DB
//
// Call the sqlite3_create_function API on the given database in order
// to create a function named "x_count".  This function is similar
// to the built-in count() function, with a few special quirks
// for testing the sqlite3_result_error() APIs.
//
// The original motivation for this routine was to be able to call the
// sqlite3_create_aggregate function while a query is in progress in order
// to test the SQLITE_MISUSE detection logic.  See misuse.test.
//
// This routine was later extended to test the use of sqlite3_result_error()
// within aggregate functions.
//
// Later: It is now also extended to register the aggregate function
// "legacy_count()" with the supplied database handle. This is used
// to test the deprecated sqlite3_aggregate_count() API.
func test_create_aggregate(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1194:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14763 /* " FILENAME\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14971 /* "x_count" */, 0, SQLITE_UTF8, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{t1CountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{t1CountFinalize})))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14971 /* "x_count" */, 1, SQLITE_UTF8, uintptr(0), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{t1CountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{t1CountFinalize})))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+14979 /* "legacy_count" */, 0, SQLITE_ANY, uintptr(0), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{legacyCountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{legacyCountFinalize})))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage:  printf TEXT
//
// Send output to printf.  Use this rather than puts to merge the output
// in the correct sequence with debugging printfs inserted into C code.
// Puts uses a separate buffer and debugging statements will be out of
// sequence if it is used.
func test_printf(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1235:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14992 /* " TEXT\"" */, 0))
		return TCL_ERROR
	}
	libc.Xprintf(tls, ts+294 /* "%s\n" */, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	return TCL_OK
}

// Usage:  sqlite3_mprintf_int FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three integer arguments
func sqlite3_mprintf_int(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1257:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	// var a [3]int32 at bp+72, 12

	var i int32
	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14999 /* " FORMAT INT INT ..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), (bp+72 /* &a */ +uintptr((i-2))*4)) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + 1*4)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + 2*4))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_int64 FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three 64-bit integer arguments
func sqlite3_mprintf_int64(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1284:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var i int32
	// var a [3]sqlite_int64 at bp+88, 24

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14999 /* " FORMAT INT INT ..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 5; i++ {
		if sqlite3.Xsqlite3Atoi64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), (bp+88 /* &a */ +uintptr((i-2))*8), sqlite3.Xsqlite3Strlen30(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))), uint8(SQLITE_UTF8)) != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+15020 /* "argument is not ..." */, 0))
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+48, *(*sqlite_int64)(unsafe.Pointer(bp + 88 /* &a[0] */)), *(*sqlite_int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + 1*8)), *(*sqlite_int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + 2*8))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_long FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three long integer arguments.   This might be the
// same as sqlite3_mprintf_int or sqlite3_mprintf_int64, depending on
// platform.
func sqlite3_mprintf_long(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1317:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var i int32
	// var a [3]int32 at bp+84, 12

	// var b [3]int32 at bp+72, 12

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14999 /* " FORMAT INT INT ..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), (bp+72 /* &b */ +uintptr((i-2))*4)) != 0 {
			return TCL_ERROR
		}
		*(*int32)(unsafe.Pointer(bp + 84 /* &a[0] */ + uintptr((i-2))*4)) = int32(*(*int32)(unsafe.Pointer(bp + 72 /* &b[0] */ + uintptr((i-2))*4)))
		*(*int32)(unsafe.Pointer(bp + 84 /* &a */ + uintptr((i-2))*4)) &= libc.Int32FromUint64(((u64((uint64(1))) << (uint32(unsafe.Sizeof(int32(0))) * uint32(8))) - uint64(1)))
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 84 /* &a[0] */)), *(*int32)(unsafe.Pointer(bp + 84 /* &a[0] */ + 1*4)), *(*int32)(unsafe.Pointer(bp + 84 /* &a[0] */ + 2*4))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_str FORMAT INTEGER INTEGER STRING
//
// Call mprintf with two integer arguments and one string argument
func sqlite3_mprintf_str(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1348:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	// var a [3]int32 at bp+72, 12

	var i int32
	var z uintptr
	if (argc < 4) || (argc > 5) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15059 /* " FORMAT INT INT ..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), (bp+72 /* &a */ +uintptr((i-2))*4)) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + 1*4)), func() uintptr {
		if argc > 4 {
			return *(*uintptr)(unsafe.Pointer(argv + 4*4))
		}
		return uintptr(0)
	}()))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_snprintf_str INTEGER FORMAT INTEGER INTEGER STRING
//
// Call mprintf with two integer arguments and one string argument
func sqlite3_snprintf_str(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1375:26: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var a [3]int32 at bp+92, 12

	var i int32
	// var n int32 at bp+88, 4

	var z uintptr
	if (argc < 5) || (argc > 6) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15085 /* " INT FORMAT INT ..." */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+88 /* &n */) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 88 /* n */)) < 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+15115 /* "N must be non-ne..." */, 0))
		return TCL_ERROR
	}
	for i = 3; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), (bp+92 /* &a */ +uintptr((i-3))*4)) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_malloc(tls, (*(*int32)(unsafe.Pointer(bp + 88 /* n */)) + 1))
	sqlite3.Xsqlite3_snprintf(tls, *(*int32)(unsafe.Pointer(bp + 88 /* n */)), z, *(*uintptr)(unsafe.Pointer(argv + 2*4)), libc.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 92 /* &a[0] */)), *(*int32)(unsafe.Pointer(bp + 92 /* &a[0] */ + 1*4)), func() uintptr {
		if argc > 4 {
			return *(*uintptr)(unsafe.Pointer(argv + 5*4))
		}
		return uintptr(0)
	}()))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_double FORMAT INTEGER INTEGER DOUBLE
//
// Call mprintf with two integer arguments and one double argument
func sqlite3_mprintf_double(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1409:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// var a [3]int32 at bp+72, 12

	var i int32
	// var r float64 at bp+88, 8

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15138 /* " FORMAT INT INT ..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), (bp+72 /* &a */ +uintptr((i-2))*4)) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetDouble(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*4)), bp+88 /* &r */) != 0 {
		return TCL_ERROR
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + 1*4)), *(*float64)(unsafe.Pointer(bp + 88 /* r */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_scaled FORMAT DOUBLE DOUBLE
//
// Call mprintf with a single double argument which is the product of the
// two arguments given above.  This is used to generate overflow and underflow
// doubles to test that they are converted properly.
func sqlite3_mprintf_scaled(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1440:26: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var i int32
	// var r [2]float64 at bp+56, 16

	var z uintptr
	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15162 /* " FORMAT DOUBLE D..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetDouble(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), (bp+56 /* &r */ +uintptr((i-2))*8)) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, (*(*float64)(unsafe.Pointer(bp + 56 /* &r[0] */))**(*float64)(unsafe.Pointer(bp + 56 /* &r[0] */ + 1*8)))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_stronly FORMAT STRING
//
// Call mprintf with a single double argument which is the product of the
// two arguments given above.  This is used to generate overflow and underflow
// doubles to test that they are converted properly.
func sqlite3_mprintf_stronly(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1470:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var z uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15185 /* " FORMAT STRING\"" */, 0))
		return TCL_ERROR
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_hexdouble FORMAT HEX
//
// Call mprintf with a single double argument which is derived from the
// hexadecimal encoding of an IEEE double.
func sqlite3_mprintf_hexdouble(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1494:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var z uintptr
	// var r float64 at bp+96, 8

	// var x1 uint32 at bp+92, 4

	// var x2 uint32 at bp+88, 4

	// var d sqlite_uint64 at bp+104, 8

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15185 /* " FORMAT STRING\"" */, 0))
		return TCL_ERROR
	}
	if libc.Xsscanf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), ts+15201 /* "%08x%08x" */, libc.VaList(bp+32, bp+88 /* &x2 */, bp+92 /* &x1 */)) != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+15210 /* "2nd argument sho..." */, 0))
		return TCL_ERROR
	}
	*(*sqlite_uint64)(unsafe.Pointer(bp + 104 /* d */)) = sqlite_uint64(*(*uint32)(unsafe.Pointer(bp + 88 /* x2 */)))
	*(*sqlite_uint64)(unsafe.Pointer(bp + 104 /* d */)) = ((*(*sqlite_uint64)(unsafe.Pointer(bp + 104 /* d */)) << 32) + sqlite_uint64(*(*uint32)(unsafe.Pointer(bp + 92 /* x1 */))))
	libc.Xmemcpy(tls, bp+96 /* &r */, bp+104 /* &d */, uint32(unsafe.Sizeof(float64(0))))
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+64, *(*float64)(unsafe.Pointer(bp + 96 /* r */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage: sqlite3_enable_shared_cache ?BOOLEAN?
//
func test_enable_shared(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1527:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	// var enable int32 at bp, 4

	var ret int32 = 0

	if (objc != 2) && (objc != 1) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15254 /* "?BOOLEAN?" */)
		return TCL_ERROR
	}
	ret = sqlite3.Xsqlite3Config.FsharedCacheEnabled

	if objc == 2 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &enable */) != 0 {
			return TCL_ERROR
		}
		rc = sqlite3.Xsqlite3_enable_shared_cache(tls, *(*int32)(unsafe.Pointer(bp /* enable */)))
		if rc != SQLITE_OK {
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, rc), uintptr(0))
			return TCL_ERROR
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (libc.Bool32((ret) != 0))))
	return TCL_OK
}

// Usage: sqlite3_extended_result_codes   DB    BOOLEAN
//
func test_extended_result_codes(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1564:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var enable int32 at bp+4, 4

	// var db uintptr at bp, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15264 /* "DB BOOLEAN" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &enable */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_extended_result_codes(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*int32)(unsafe.Pointer(bp + 4 /* enable */)))
	return TCL_OK
}

// Usage: sqlite3_libversion_number
//
func test_libversion_number(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1587:26: */
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_libversion_number(tls)))
	return TCL_OK
}

// Usage: sqlite3_table_column_metadata DB dbname tblname colname
//
func test_table_column_metadata(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1601:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+16, 4

	var zDb uintptr
	var zTbl uintptr
	var zCol uintptr
	var rc int32
	var pRet uintptr
	// var zDatatype uintptr at bp+20, 4

	// var zCollseq uintptr at bp+24, 4

	// var notnull int32 at bp+28, 4

	// var primarykey int32 at bp+32, 4

	// var autoincrement int32 at bp+36, 4

	if (objc != 5) && (objc != 4) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15275 /* "DB dbname tblnam..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16 /* &db */) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	zTbl = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if objc == 5 {
		zCol = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
	} else {
		zCol = uintptr(0)
	}

	if libc.Xstrlen(tls, zDb) == size_t(0) {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_table_column_metadata(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zDb, zTbl, zCol,
		bp+20 /* &zDatatype */, bp+24 /* &zCollseq */, bp+28 /* &notnull */, bp+32 /* &primarykey */, bp+36 /* &autoincrement */)

	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */))), 0))
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* zDatatype */)), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* zCollseq */)), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 28 /* notnull */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 32 /* primarykey */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 36 /* autoincrement */))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return TCL_OK
}

func blobHandleFromObj(tls *libc.TLS, interp uintptr, pObj uintptr, ppBlob uintptr) int32 { /* test1.c:1652:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	// var n int32 at bp, 4

	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp /* &n */)
	if *(*int32)(unsafe.Pointer(bp /* n */)) == 0 {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = uintptr(0)
	} else {
		// var notUsed int32 at bp+4, 4

		var channel Tcl_Channel
		var instanceData ClientData

		channel = tcl.XTcl_GetChannel(tls, interp, z, bp+4 /* &notUsed */)
		if !(channel != 0) {
			return TCL_ERROR
		}

		tcl.XTcl_Flush(tls, channel)
		tcl.XTcl_Seek(tls, channel, int64(0), SEEK_SET)

		instanceData = tcl.XTcl_GetChannelInstanceData(tls, channel)
		*(*uintptr)(unsafe.Pointer(ppBlob)) = *(*uintptr)(unsafe.Pointer(instanceData))
	}

	return TCL_OK
}

func test_blob_reopen(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1681:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var iRowid Tcl_WideInt at bp+8, 8

	// var pBlob uintptr at bp, 4

	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15301 /* "CHANNEL ROWID" */)
		return TCL_ERROR
	}

	if blobHandleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &pBlob */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+8 /* &iRowid */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_blob_reopen(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)), *(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* iRowid */)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}

	return func() int32 {
		if rc == SQLITE_OK {
			return TCL_OK
		}
		return TCL_ERROR
	}()
}

// Usage: sqlite3_create_collation_v2 DB-HANDLE NAME CMP-PROC DEL-PROC
//
//   This Tcl proc is used for testing the experimental
//   sqlite3_create_collation_v2() interface.
type TestCollationX1 = struct {
	Finterp uintptr
	FpCmp   uintptr
	FpDel   uintptr
} /* test1.c:1715:1 */

type TestCollationX = TestCollationX1 /* test1.c:1720:31 */

func testCreateCollationDel(tls *libc.TLS, pCtx uintptr) { /* test1.c:1721:13: */
	var p uintptr = pCtx

	var rc int32 = tcl.XTcl_EvalObjEx(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, (*TestCollationX)(unsafe.Pointer(p)).FpDel, (TCL_EVAL_DIRECT | TCL_EVAL_GLOBAL))
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp)
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*TestCollationX)(unsafe.Pointer(p)).FpCmp
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = (*TestCollationX)(unsafe.Pointer(p)).FpDel
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func testCreateCollationCmp(tls *libc.TLS, pCtx uintptr, nLeft int32, zLeft uintptr, nRight int32, zRight uintptr) int32 { /* test1.c:1733:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	var pScript uintptr = tcl.XTcl_DuplicateObj(tls, (*TestCollationX)(unsafe.Pointer(p)).FpCmp)
	*(*int32)(unsafe.Pointer(bp /* iRes */)) = 0

	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zLeft, nLeft))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zRight, nRight))

	if (TCL_OK != tcl.XTcl_EvalObjEx(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, pScript, (TCL_EVAL_DIRECT|TCL_EVAL_GLOBAL))) ||
		(TCL_OK != tcl.XTcl_GetIntFromObj(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetObjResult(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp), bp /* &iRes */)) {
		tcl.XTcl_BackgroundError(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp)
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* iRes */))
}

func test_create_collation_v2(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1757:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr
	// var db uintptr at bp+16, 4

	var rc int32

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15315 /* "DB-HANDLE NAME C..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16 /* &db */) != 0 {
		return TCL_ERROR
	}

	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(TestCollationX{})))
	(*TestCollationX)(unsafe.Pointer(p)).FpCmp = *(*uintptr)(unsafe.Pointer(objv + 3*4))
	(*TestCollationX)(unsafe.Pointer(p)).FpDel = *(*uintptr)(unsafe.Pointer(objv + 4*4))
	(*TestCollationX)(unsafe.Pointer(p)).Finterp = interp
	(*Tcl_Obj)(unsafe.Pointer((*TestCollationX)(unsafe.Pointer(p)).FpCmp)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestCollationX)(unsafe.Pointer(p)).FpDel)).FrefCount++

	rc = sqlite3.Xsqlite3_create_collation_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), 16,
		p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{testCreateCollationCmp})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testCreateCollationDel})))
	if rc != SQLITE_MISUSE {
		tcl.XTcl_AppendResult(tls, interp,
			libc.VaList(bp, ts+15348 /* "sqlite3_create_c..." */, uintptr(0)))
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_collation_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), SQLITE_UTF8,
		p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{testCreateCollationCmp})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testCreateCollationDel})))
	return TCL_OK
}

// USAGE: sqlite3_create_function_v2 DB NAME NARG ENC ?SWITCHES?
//
// Available switches are:
//
//   -func    SCRIPT
//   -step    SCRIPT
//   -final   SCRIPT
//   -destroy SCRIPT
type CreateFunctionV21 = struct {
	Finterp   uintptr
	FpFunc    uintptr
	FpStep    uintptr
	FpFinal   uintptr
	FpDestroy uintptr
} /* test1.c:1804:9 */

// USAGE: sqlite3_create_function_v2 DB NAME NARG ENC ?SWITCHES?
//
// Available switches are:
//
//   -func    SCRIPT
//   -step    SCRIPT
//   -final   SCRIPT
//   -destroy SCRIPT
type CreateFunctionV2 = CreateFunctionV21 /* test1.c:1804:33 */

func cf2Func(tls *libc.TLS, ctx uintptr, nArg int32, aArg uintptr) { /* test1.c:1812:13: */
}

func cf2Step(tls *libc.TLS, ctx uintptr, nArg int32, aArg uintptr) { /* test1.c:1814:13: */
}

func cf2Final(tls *libc.TLS, ctx uintptr) { /* test1.c:1816:13: */
}

func cf2Destroy(tls *libc.TLS, pUser uintptr) { /* test1.c:1818:13: */
	var p uintptr = pUser

	if ((*CreateFunctionV2)(unsafe.Pointer(p)).Finterp != 0) && ((*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0) {
		var rc int32 = tcl.XTcl_EvalObjEx(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).Finterp, (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy, 0)
		if rc != TCL_OK {
			tcl.XTcl_BackgroundError(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).Finterp)
		}
	}

	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func test_create_function_v2(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1832:26: */
	bp := tls.Alloc(100)
	defer tls.Free(100)

	// var db uintptr at bp+16, 4

	var zFunc uintptr
	// var nArg int32 at bp+20, 4

	// var enc int32 at bp+72, 4

	var p uintptr
	var i int32
	var rc int32

	*(*[6]EncTable)(unsafe.Pointer(bp + 24 /* aEnc */)) = [6]EncTable{
		{FzEnc: ts + 15413 /* "utf8" */, Fenc: SQLITE_UTF8},
		{FzEnc: ts + 15418 /* "utf16" */, Fenc: SQLITE_UTF16},
		{FzEnc: ts + 15424 /* "utf16le" */, Fenc: SQLITE_UTF16LE},
		{FzEnc: ts + 15432 /* "utf16be" */, Fenc: SQLITE_UTF16BE},
		{FzEnc: ts + 12463 /* "any" */, Fenc: SQLITE_ANY},
		{FzEnc: ts + 13873 /* "0" */},
	}

	if (objc < 5) || ((objc % 2) == 0) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15440 /* "DB NAME NARG ENC..." */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16 /* &db */) != 0 {
		return TCL_ERROR
	}
	zFunc = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+20 /* &nArg */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+24 /* &aEnc[0] */, int32(unsafe.Sizeof(EncTable{})),
		ts+15469 /* "encoding" */, 0, bp+72 /* &enc */) != 0 {
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 72 /* enc */)) = (*EncTable)(unsafe.Pointer(bp + 24 /* &aEnc */ + uintptr(*(*int32)(unsafe.Pointer(bp + 72 /* enc */)))*8)).Fenc

	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(CreateFunctionV2{})))

	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(CreateFunctionV2{})))
	(*CreateFunctionV2)(unsafe.Pointer(p)).Finterp = interp

	for i = 5; i < objc; i = i + (2) {
		// var iSwitch int32 at bp+96, 4

		*(*[5]uintptr)(unsafe.Pointer(bp + 76 /* azSwitch */)) = [5]uintptr{ts + 15478 /* "-func" */, ts + 15484 /* "-step" */, ts + 15490 /* "-final" */, ts + 15497 /* "-destroy" */, uintptr(0)}
		if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+76 /* &azSwitch[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+15506 /* "switch" */, 0, bp+96 /* &iSwitch */) != 0 {
			sqlite3.Xsqlite3_free(tls, p)
			return TCL_ERROR
		}

		switch *(*int32)(unsafe.Pointer(bp + 96 /* iSwitch */)) {
		case 0:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc = *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4))
			break
		case 1:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpStep = *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4))
			break
		case 2:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal = *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4))
			break
		case 3:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy = *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4))
			break
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpStep = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy)
	}

	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpStep)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy)).FrefCount++
	}

	rc = sqlite3.Xsqlite3_create_function_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zFunc, *(*int32)(unsafe.Pointer(bp + 20 /* nArg */)), *(*int32)(unsafe.Pointer(bp + 72 /* enc */)), p,
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{cf2Func}))
			}
			return uintptr(0)
		}(),
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{cf2Step}))
			}
			return uintptr(0)
		}(),
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{cf2Final}))
			}
			return uintptr(0)
		}(),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{cf2Destroy})))
	if rc != SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

type EncTable = struct {
	FzEnc uintptr
	Fenc  int32
} /* test1.c:1846:3 */

// Usage: sqlite3_load_extension DB-HANDLE FILE ?PROC?
func test_load_extension(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1920:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var cmdInfo Tcl_CmdInfo at bp+24, 32

	var db uintptr
	_ = db
	var rc int32
	var zDb uintptr
	var zFile uintptr
	_ = zFile
	var zProc uintptr = uintptr(0)
	_ = zProc
	var zErr uintptr = uintptr(0)

	if (objc != 4) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15513 /* "DB-HANDLE FILE ?..." */)
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if objc == 4 {
		zProc = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	}

	// Extract the C database handle from the Tcl command name
	if !(tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+24 /* &cmdInfo */) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14539 /* "command not foun..." */, zDb, uintptr(0)))
		return TCL_ERROR
	}
	db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24 /* &cmdInfo */)).FobjClientData)).Fdb

	// Call the underlying C function. If an error occurs, set rc to
	// TCL_ERROR and load any error string into the interpreter. If no
	// error occurs, set rc to TCL_OK.
	rc = SQLITE_ERROR
	zErr = sqlite3.Xsqlite3_mprintf(tls, ts+15535 /* "this build omits..." */, 0)
	_ = zProc
	_ = zFile
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, func() uintptr {
			if zErr != 0 {
				return zErr
			}
			return ts + 489 /* "" */
		}(), uintptr(1))
		rc = TCL_ERROR
	} else {
		rc = TCL_OK
	}
	sqlite3.Xsqlite3_free(tls, zErr)

	return rc
}

// Usage: sqlite3_enable_load_extension DB-HANDLE ONOFF
func test_enable_load(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1978:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	// var cmdInfo Tcl_CmdInfo at bp+32, 32

	var db uintptr
	_ = db
	var zDb uintptr
	// var onoff int32 at bp+64, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15577 /* "DB-HANDLE ONOFF" */)
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))

	// Extract the C database handle from the Tcl command name
	if !(tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+32 /* &cmdInfo */) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14539 /* "command not foun..." */, zDb, uintptr(0)))
		return TCL_ERROR
	}
	db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 32 /* &cmdInfo */)).FobjClientData)).Fdb

	// Get the onoff parameter
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+64 /* &onoff */) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+15535 /* "this build omits..." */))
	return TCL_ERROR
}

// Usage:  sqlite_abort
//
// Shutdown the process immediately.  This is not a clean shutdown.
// This command is used to test the recoverability of a database in
// the event of a program crash.
func sqlite_abort(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:2024:26: */
	libc.Xexit(tls, 255)
	// This will always fail
	return TCL_OK
}

// The following routine is a user-defined SQL function whose purpose
// is to test the sqlite_set_result() API.
func testFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:2045:13: */
	var zArg0 uintptr
__1:
	if !(argc >= 2) {
		goto __2
	}
	zArg0 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if !(zArg0 != 0) {
		goto __3
	}
	if !(0 == sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+2438 /* "int" */)) {
		goto __5
	}
	sqlite3.Xsqlite3_result_int(tls, context, sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	goto __6
__5:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+3834 /* "int64" */) == 0) {
		goto __7
	}
	sqlite3.Xsqlite3_result_int64(tls, context, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	goto __8
__7:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+15593 /* "string" */) == 0) {
		goto __9
	}
	sqlite3.Xsqlite3_result_text(tls, context, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))), -1,
		libc.UintptrFromInt32(-1))
	goto __10
__9:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+2423 /* "double" */) == 0) {
		goto __11
	}
	sqlite3.Xsqlite3_result_double(tls, context, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	goto __12
__11:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+7385 /* "null" */) == 0) {
		goto __13
	}
	sqlite3.Xsqlite3_result_null(tls, context)
	goto __14
__13:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+15600 /* "value" */) == 0) {
		goto __15
	}
	sqlite3.Xsqlite3_result_value(tls, context, *(*uintptr)(unsafe.Pointer(argv + uintptr(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))*4)))
	goto __16
__15:
	goto error_out
__16:
	;
__14:
	;
__12:
	;
__10:
	;
__8:
	;
__6:
	;
	goto __4
__3:
	goto error_out
__4:
	;
	argc = argc - (2)
	argv += 4 * (uintptr(2))
	goto __1
__2:
	;
	return

error_out:
	sqlite3.Xsqlite3_result_error(tls, context,
		ts+15606 /* "first argument s..." */, -1)
}

// Usage:   sqlite_register_test_function  DB  NAME
//
// Register the test SQL function on the database DB under the name NAME.
func test_register_func(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:2083:26: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// var db uintptr at bp+48, 4

	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15674 /* " DB FUNCTION-NAM..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), *(*uintptr)(unsafe.Pointer(argv + 2*4)), -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testFunc})), uintptr(0), uintptr(0))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return TCL_ERROR
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_finalize  STMT
//
// Finalize a statement handle.
func test_finalize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2112:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var pStmt uintptr at bp+32, 4

	var rc int32
	var db uintptr = uintptr(0)

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+15692 /* " <STMT>" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) != 0 {
		db = sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	}
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	if (db != 0) && (sqlite3TestErrCode(tls, interp, db, rc) != 0) {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_stmt_status  STMT  CODE  RESETFLAG
//
// Get the value of a status counter from a statement.
func test_stmt_status(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2144:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var iValue int32
	var i int32
	*(*int32)(unsafe.Pointer(bp + 4 /* op */)) = 0
	// var resetFlag int32 at bp+8, 4

	var zOpName uintptr
	// var pStmt uintptr at bp, 4

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15700 /* "STMT PARAMETER R..." */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	for i = 0; i < (int32(uint32(unsafe.Sizeof(aOp)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{})))); i++ {
		if libc.Xstrcmp(tls, aOp[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp + 4 /* op */)) = aOp[i].Fop
			break
		}
	}
	if i >= (int32(uint32(unsafe.Sizeof(aOp)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{})))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &op */) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+8 /* &resetFlag */) != 0 {
		return TCL_ERROR
	}
	iValue = sqlite3.Xsqlite3_stmt_status(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 4 /* op */)), *(*int32)(unsafe.Pointer(bp + 8 /* resetFlag */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iValue))
	return TCL_OK
}

var aOp = [7]struct {
	FzName uintptr
	Fop    int32
}{
	{FzName: ts + 15725 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_FULLSCAN_STEP},
	{FzName: ts + 15757 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_SORT},
	{FzName: ts + 15780 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_AUTOINDEX},
	{FzName: ts + 15808 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_VM_STEP},
	{FzName: ts + 15834 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_REPREPARE},
	{FzName: ts + 15862 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_RUN},
	{FzName: ts + 15884 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_MEMUSED},
} /* test1.c:2158:5 */

// Usage:  sqlite3_config_sorterref
//
// Set the SQLITE_CONFIG_SORTERREF_SIZE configuration option
func test_config_sorterref(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2285:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var iVal int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15910 /* "NBYTE" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8 /* &iVal */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_SORTERREF_SIZE, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* iVal */))))
	return TCL_OK
}

// Usage: vfs_current_time_int64
//
// Return the value returned by the default VFS's xCurrentTimeInt64 method.
func vfsCurrentTimeInt64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2306:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var t i64 at bp, 8

	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}
	(*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pVfs + 72 /* &.xCurrentTimeInt64 */))))(tls, pVfs, bp /* &t */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*i64)(unsafe.Pointer(bp /* t */))))
	return TCL_OK
}

// Usage: sqlite3_snapshot_get DB DBNAME
func test_snapshot_get(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2327:26: */
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var rc int32
	// var db uintptr at bp, 4

	var zName uintptr
	*(*uintptr)(unsafe.Pointer(bp + 4 /* pSnapshot */)) = uintptr(0)

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15916 /* "DB DBNAME" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))

	rc = sqlite3.Xsqlite3_snapshot_get(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName, bp+4 /* &pSnapshot */)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else {
		// var zBuf [100]int8 at bp+8, 100

		if sqlite3TestMakePointerStr(tls, interp, bp+8 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 4 /* pSnapshot */))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+8 /* &zBuf[0] */, -1))
	}
	return TCL_OK
}

// Usage: sqlite3_snapshot_recover DB DBNAME
func test_snapshot_recover(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2362:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	// var db uintptr at bp, 4

	var zName uintptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15916 /* "DB DBNAME" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))

	rc = sqlite3.Xsqlite3_snapshot_recover(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else {
		tcl.XTcl_ResetResult(tls, interp)
	}
	return TCL_OK
}

// Usage: sqlite3_snapshot_open DB DBNAME SNAPSHOT
func test_snapshot_open(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2394:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	// var db uintptr at bp, 4

	var zName uintptr
	var pSnapshot uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15926 /* "DB DBNAME SNAPSH..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	pSnapshot = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4))))

	rc = sqlite3.Xsqlite3_snapshot_open(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName, pSnapshot)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else {
		tcl.XTcl_ResetResult(tls, interp)
	}
	return TCL_OK
}

// Usage: sqlite3_snapshot_free SNAPSHOT
func test_snapshot_free(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2428:26: */
	var pSnapshot uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15945 /* "SNAPSHOT" */)
		return TCL_ERROR
	}
	pSnapshot = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	sqlite3.Xsqlite3_snapshot_free(tls, pSnapshot)
	return TCL_OK
}

// Usage: sqlite3_snapshot_cmp SNAPSHOT1 SNAPSHOT2
func test_snapshot_cmp(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2449:26: */
	var res int32
	var p1 uintptr
	var p2 uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15954 /* "SNAPSHOT1 SNAPSH..." */)
		return TCL_ERROR
	}
	p1 = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	p2 = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))))
	res = sqlite3.Xsqlite3_snapshot_cmp(tls, p1, p2)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
	return TCL_OK
}

// Usage: sqlite3_snapshot_get_blob DB DBNAME
func test_snapshot_get_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2474:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var db uintptr at bp, 4

	var zName uintptr
	*(*uintptr)(unsafe.Pointer(bp + 4 /* pSnapshot */)) = uintptr(0)

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15916 /* "DB DBNAME" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))

	rc = sqlite3.Xsqlite3_snapshot_get(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName, bp+4 /* &pSnapshot */)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else {
		tcl.XTcl_SetObjResult(tls, interp,
			tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 4 /* pSnapshot */)), int32(unsafe.Sizeof(sqlite3_snapshot{}))))
		sqlite3.Xsqlite3_snapshot_free(tls, *(*uintptr)(unsafe.Pointer(bp + 4 /* pSnapshot */)))
	}
	return TCL_OK
}

// Usage: sqlite3_snapshot_open_blob DB DBNAME SNAPSHOT
func test_snapshot_open_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2510:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	// var db uintptr at bp+16, 4

	var zName uintptr
	var pBlob uintptr
	// var nBlob int32 at bp+20, 4

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15926 /* "DB DBNAME SNAPSH..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16 /* &db */) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	pBlob = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+20 /* &nBlob */)
	if (uint32(*(*int32)(unsafe.Pointer(bp + 20 /* nBlob */))) != uint32(unsafe.Sizeof(sqlite3_snapshot{}))) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15974 /* "bad SNAPSHOT" */, 0))
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_snapshot_open(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zName, pBlob)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage: sqlite3_snapshot_cmp_blob SNAPSHOT1 SNAPSHOT2
func test_snapshot_cmp_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2546:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var res int32
	var p1 uintptr
	var p2 uintptr
	// var n1 int32 at bp+16, 4

	// var n2 int32 at bp+20, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15954 /* "SNAPSHOT1 SNAPSH..." */)
		return TCL_ERROR
	}

	p1 = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16 /* &n1 */)
	p2 = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+20 /* &n2 */)

	if (uint32(*(*int32)(unsafe.Pointer(bp + 16 /* n1 */))) != uint32(unsafe.Sizeof(sqlite3_snapshot{}))) || (*(*int32)(unsafe.Pointer(bp + 16 /* n1 */)) != *(*int32)(unsafe.Pointer(bp + 20 /* n2 */))) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15974 /* "bad SNAPSHOT" */, 0))
		return TCL_ERROR
	}

	res = sqlite3.Xsqlite3_snapshot_cmp(tls, p1, p2)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
	return TCL_OK
}

// in test_delete.c
func test_delete_database(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2581:26: */
	var rc int32
	var zFile uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15987 /* "FILE" */)
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	rc = sqlite3_delete_database(tls, zFile)

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return TCL_OK
}

// Usage: atomic_batch_write PATH
func test_atomic_batch_write(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2603:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zFile uintptr = uintptr(0)                              // Path to file to test
	*(*uintptr)(unsafe.Pointer(bp + 16 /* db */)) = uintptr(0)  // Database handle
	*(*uintptr)(unsafe.Pointer(bp + 20 /* pFd */)) = uintptr(0) // SQLite fd open on zFile
	var bRes int32 = 0                                          // Integer result of this command
	var dc int32 = 0                                            // Device-characteristics mask
	var rc int32                                                // sqlite3_open() return code

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15992 /* "PATH" */)
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))

	rc = sqlite3.Xsqlite3_open(tls, zFile, bp+16 /* &db */)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */))), 0))
		sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)))
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+85 /* "main" */, SQLITE_FCNTL_FILE_POINTER, bp+20 /* &pFd */)
	dc = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20 /* pFd */)))).FpMethods + 48 /* &.xDeviceCharacteristics */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pFd */)))
	if (dc & SQLITE_IOCAP_BATCH_ATOMIC) != 0 {
		bRes = 1
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, bRes))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)))
	return TCL_OK
}

// Usage:  sqlite3_next_stmt  DB  STMT
//
// Return the next statment in sequence after STMT.
func test_next_stmt(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2645:26: */
	bp := tls.Alloc(106)
	defer tls.Free(106)

	// var pStmt uintptr at bp+52, 4

	*(*uintptr)(unsafe.Pointer(bp + 48 /* db */)) = uintptr(0)
	// var zBuf [50]int8 at bp+56, 50

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+15997 /* " DB STMT" */, 0))
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+52 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	*(*uintptr)(unsafe.Pointer(bp + 52 /* pStmt */)) = sqlite3.Xsqlite3_next_stmt(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), *(*uintptr)(unsafe.Pointer(bp + 52 /* pStmt */)))
	if *(*uintptr)(unsafe.Pointer(bp + 52 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+56 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 52 /* pStmt */))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+56 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

// Usage:  sqlite3_stmt_readonly  STMT
//
// Return true if STMT is a NULL pointer or a pointer to a statement
// that is guaranteed to leave the database unmodified.
func test_stmt_readonly(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2677:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var pStmt uintptr at bp+32, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16006 /* " STMT" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_stmt_readonly(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (libc.Bool32((rc) != 0))))
	return TCL_OK
}

// Usage:  sqlite3_stmt_isexplain  STMT
//
// Return 1, 2, or 0 respectively if STMT is an EXPLAIN statement, an
// EXPLAIN QUERY PLAN statement or an ordinary statement or NULL pointer.
func test_stmt_isexplain(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2704:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var pStmt uintptr at bp+32, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16006 /* " STMT" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_stmt_isexplain(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// Usage:  sqlite3_stmt_busy  STMT
//
// Return true if STMT is a non-NULL pointer to a statement
// that has been stepped but not to completion.
func test_stmt_busy(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2731:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var pStmt uintptr at bp+32, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16006 /* " STMT" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_stmt_busy(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (libc.Bool32((rc) != 0))))
	return TCL_OK
}

// Usage:  uses_stmt_journal  STMT
//
// Return true if STMT uses a statement journal.
func uses_stmt_journal(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2757:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var pStmt uintptr at bp+32, 4

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16006 /* " STMT" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_stmt_readonly(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (libc.Bool32((int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) + 152 /* &.usesStmtJournal */))&0x40>>6)) != 0))))
	return TCL_OK
}

// Usage:  sqlite3_reset  STMT
//
// Reset a statement handle.
func test_reset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2783:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var pStmt uintptr at bp+32, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+15692 /* " <STMT>" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	if (*(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) != 0) && (sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */))), rc) != 0) {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	//
	//   if( rc ){
	//     return TCL_ERROR;
	//   }
	return TCL_OK
}

// Usage:  sqlite3_expired STMT
//
// Return TRUE if a recompilation of the statement is recommended.
func test_expired(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2818:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var pStmt uintptr at bp+32, 4

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+15692 /* " <STMT>" */, 0))
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (libc.Bool32((sqlite3.Xsqlite3_expired(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))) != 0))))
	return TCL_OK
}

// Usage:  sqlite3_transfer_bindings FROMSTMT TOSTMT
//
// Transfer all bindings from FROMSTMT over to TOSTMT
func test_transfer_bind(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2842:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt1 uintptr at bp+32, 4

	// var pStmt2 uintptr at bp+36, 4

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16012 /* " FROM-STMT TO-ST..." */, 0))
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt1 */) != 0 {
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+36 /* &pStmt2 */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_transfer_bindings(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt1 */)), *(*uintptr)(unsafe.Pointer(bp + 36 /* pStmt2 */)))))
	return TCL_OK
}

// Usage:  sqlite3_changes DB
//
// Return the number of changes made to the database by the last SQL
// execution.
func test_changes(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2869:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_changes(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))))
	return TCL_OK
}

// This is the "static_bind_value" that variables are bound to when
// the FLAG option of sqlite3_bind is "static"
var sqlite_static_bind_value uintptr = uintptr(0) /* test1.c:2890:13 */
var sqlite_static_bind_nbyte int32 = 0            /* test1.c:2891:12 */

// Usage:  sqlite3_bind  VM  IDX  VALUE  FLAGS
//
// Sets the value of the IDX-th occurrence of "?" in the original SQL
// string.  VALUE is the new value.  If FLAGS=="null" then VALUE is
// ignored and the value is set to NULL.  If FLAGS=="static" then
// the value is set to the value of a static variable named
// "sqlite_static_bind_value".  If FLAGS=="normal" then a copy
// of the VALUE is made.  If FLAGS=="blob10" then a VALUE is ignored
// an a 10-byte blob "abc\000xyz\000pq" is inserted.
func test_bind(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:2904:26: */
	bp := tls.Alloc(138)
	defer tls.Free(138)

	// var pStmt uintptr at bp+80, 4

	var rc int32
	// var idx int32 at bp+84, 4

	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16031 /* " VM IDX VALUE (n..." */, 0))
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+80 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+84 /* &idx */) != 0 {
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)), ts+7385 /* "null" */) == 0 {
		rc = sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 84 /* idx */)))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)), ts+16067 /* "static" */) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 84 /* idx */)), sqlite_static_bind_value, -1, uintptr(0))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)), ts+16074 /* "static-nbytes" */) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 84 /* idx */)), sqlite_static_bind_value,
			sqlite_static_bind_nbyte, uintptr(0))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)), ts+16088 /* "normal" */) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 84 /* idx */)), *(*uintptr)(unsafe.Pointer(argv + 3*4)), -1, libc.UintptrFromInt32(-1))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)), ts+16095 /* "blob10" */) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 84 /* idx */)), ts+16102 /* "abc\x00xyz\x00pq" */, 10, uintptr(0))
	} else {
		tcl.XTcl_AppendResult(tls, interp,
			libc.VaList(bp+32, ts+16113 /* "4th argument sho..." */, 0))
		return TCL_ERROR
	}
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != 0 {
		// var zBuf [50]int8 at bp+88, 50

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+88 /* &zBuf[0] */, ts+16167 /* "(%d) " */, libc.VaList(bp+48, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+88 /* &zBuf[0] */, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage: add_test_collate <db ptr> <utf8> <utf16le> <utf16be>
//
// This function is used to test that SQLite selects the correct collation
// sequence callback when multiple versions (for different text encodings)
// are available.
//
// Calling this routine registers the collation sequence "test_collate"
// with database handle <db>. The second argument must be a list of three
// boolean values. If the first is true, then a version of test_collate is
// registered for UTF-8, if the second is true, a version is registered for
// UTF-16le, if the third is true, a UTF-16be version is available.
// Previous versions of test_collate are deleted.
//
// The collation sequence test_collate is implemented by calling the
// following TCL script:
//
//   "test_collate <enc> <lhs> <rhs>"
//
// The <lhs> and <rhs> are the two values being compared, encoded in UTF-8.
// The <enc> parameter is the encoding of the collation function that
// SQLite selected to call. The TCL test script implements the
// "test_collate" proc.
//
// Note that this will only work with one interpreter at a time, as the
// interp pointer to use when evaluating the TCL script is stored in
// pTestCollateInterp.
var pTestCollateInterp uintptr /* test1.c:2975:18: */

func test_collate_func(tls *libc.TLS, pCtx uintptr, nA int32, zA uintptr, nB int32, zB uintptr) int32 { /* test1.c:2976:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i uintptr = pTestCollateInterp
	var encin int32 = int32(pCtx)
	// var res int32 at bp, 4

	var n int32
	var pVal uintptr
	var pX uintptr

	pX = tcl.XTcl_NewStringObj(tls, ts+16173 /* "test_collate" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++

	switch encin {
	case SQLITE_UTF8:
		tcl.XTcl_ListObjAppendElement(tls, i, pX, tcl.XTcl_NewStringObj(tls, ts+16186 /* "UTF-8" */, -1))
		break
	case SQLITE_UTF16LE:
		tcl.XTcl_ListObjAppendElement(tls, i, pX, tcl.XTcl_NewStringObj(tls, ts+16192 /* "UTF-16LE" */, -1))
		break
	case SQLITE_UTF16BE:
		tcl.XTcl_ListObjAppendElement(tls, i, pX, tcl.XTcl_NewStringObj(tls, ts+16201 /* "UTF-16BE" */, -1))
		break
	default:

	}

	sqlite3.Xsqlite3BeginBenignMalloc(tls)
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	if pVal != 0 {
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, nA, zA, uint8(encin), uintptr(0))
		n = sqlite3.Xsqlite3_value_bytes(tls, pVal)
		tcl.XTcl_ListObjAppendElement(tls, i, pX,
			tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, pVal), n))
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, nB, zB, uint8(encin), uintptr(0))
		n = sqlite3.Xsqlite3_value_bytes(tls, pVal)
		tcl.XTcl_ListObjAppendElement(tls, i, pX,
			tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, pVal), n))
		sqlite3.Xsqlite3ValueFree(tls, pVal)
	}
	sqlite3.Xsqlite3EndBenignMalloc(tls)

	tcl.XTcl_EvalObjEx(tls, i, pX, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_GetIntFromObj(tls, i, tcl.XTcl_GetObjResult(tls, i), bp /* &res */)
	return *(*int32)(unsafe.Pointer(bp /* res */))
}

func test_collate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3026:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+48, 4

	// var val int32 at bp+52, 4

	var pVal uintptr
	var rc int32
	var zUtf16 uintptr

	if !(objc != 5) {
		goto __1
	}
	goto bad_args
__1:
	;
	pTestCollateInterp = interp
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48 /* &db */) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+52 /* &val */)) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), ts+16173 /* "test_collate" */, SQLITE_UTF8,
		uintptr(SQLITE_UTF8), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 52 /* val */)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
				}{test_collate_func}))
			}
			return uintptr(0)
		}())
	if !(rc == SQLITE_OK) {
		goto __4
	}
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+52 /* &val */)) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), ts+16173 /* "test_collate" */, SQLITE_UTF16LE,
		uintptr(SQLITE_UTF16LE), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 52 /* val */)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
				}{test_collate_func}))
			}
			return uintptr(0)
		}())
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+52 /* &val */)) {
		goto __6
	}
	return TCL_ERROR
__6:
	;

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))).Fmutex)
	pVal = sqlite3.Xsqlite3ValueNew(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, ts+16173 /* "test_collate" */, uint8(SQLITE_UTF8), uintptr(0))
	zUtf16 = sqlite3.Xsqlite3ValueText(tls, pVal, uint8(SQLITE_UTF16LE))
	if !((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))).FmallocFailed != 0) {
		goto __7
	}
	rc = SQLITE_NOMEM
	goto __8
__7:
	rc = sqlite3.Xsqlite3_create_collation16(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zUtf16, SQLITE_UTF16BE,
		uintptr(SQLITE_UTF16BE), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 52 /* val */)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
				}{test_collate_func}))
			}
			return uintptr(0)
		}())
__8:
	;
	sqlite3.Xsqlite3ValueFree(tls, pVal)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))).Fmutex)
__4:
	;
	if !(sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), rc) != 0) {
		goto __9
	}
	return TCL_ERROR
__9:
	;

	if !(rc != SQLITE_OK) {
		goto __10
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_ERROR
__10:
	;
	return TCL_OK

bad_args:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+14629, /* "wrong # args: sh..." */
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16210 /* " <DB> <utf8> <ut..." */, 0))
	return TCL_ERROR
}

// Usage: add_test_utf16bin_collate <db ptr>
//
// Add a utf-16 collation sequence named "utf16bin" to the database
// handle. This collation sequence compares arguments in the same way as the
// built-in collation "binary".
func test_utf16bin_collate_func(tls *libc.TLS, pCtx uintptr, nA int32, zA uintptr, nB int32, zB uintptr) int32 { /* test1.c:3090:12: */
	var nCmp int32 = func() int32 {
		if nA > nB {
			return nB
		}
		return nA
	}()
	var res int32 = libc.Xmemcmp(tls, zA, zB, uint32(nCmp))
	if res == 0 {
		res = (nA - nB)
	}
	return res
}

func test_utf16bin_collate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3100:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32

	if !(objc != 2) {
		goto __1
	}
	goto bad_args
__1:
	;
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+16243 /* "utf16bin" */, SQLITE_UTF16, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{test_utf16bin_collate_func})))
	if !(sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp /* db */)), rc) != 0) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	return TCL_OK

bad_args:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
	return TCL_ERROR
}

// When the collation needed callback is invoked, record the name of
// the requested collating function here.  The recorded name is linked
// to a TCL variable and used to make sure that the requested collation
// name is correct.
var zNeededCollation [200]int8    /* test1.c:3129:13: */
var pzNeededCollation uintptr = 0 /* test1.c:3130:13 */

// Called when a collating sequence is needed.  Registered using
// sqlite3_collation_needed16().
func test_collate_needed_cb(tls *libc.TLS, pCtx uintptr, db uintptr, eTextRep int32, pName uintptr) { /* test1.c:3137:13: */
	var enc int32 = int32((*sqlite31)(unsafe.Pointer(db)).Fenc)
	var i int32
	var z uintptr
	z = pName
	i = 0
	for ; (*(*int8)(unsafe.Pointer(z)) != 0) || (*(*int8)(unsafe.Pointer(z + 1)) != 0); z++ {
		if *(*int8)(unsafe.Pointer(z)) != 0 {
			zNeededCollation[libc.PostIncInt32(&i, 1)] = *(*int8)(unsafe.Pointer(z))
		}
	}
	zNeededCollation[i] = int8(0)
	sqlite3.Xsqlite3_create_collation(tls,
		db, ts+16173 /* "test_collate" */, int32((*sqlite31)(unsafe.Pointer(db)).Fenc), uintptr(enc), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{test_collate_func})))
}

// Usage: add_test_collate_needed DB
func test_collate_needed(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3157:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32

	if !(objc != 2) {
		goto __1
	}
	goto bad_args
__1:
	;
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	rc = sqlite3.Xsqlite3_collation_needed16(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr)
	}{test_collate_needed_cb})))
	zNeededCollation[0] = int8(0)
	if !(sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp /* db */)), rc) != 0) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	return TCL_OK

bad_args:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
	return TCL_ERROR
}

// tclcmd:   add_alignment_test_collations  DB
//
// Add two new collating sequences to the database DB
//
//     utf16_aligned
//     utf16_unaligned
//
// Both collating sequences use the same sort order as BINARY.
// The only difference is that the utf16_aligned collating
// sequence is declared with the SQLITE_UTF16_ALIGNED flag.
// Both collating functions increment the unaligned utf16 counter
// whenever they see a string that begins on an odd byte boundary.
var unaligned_string_counter int32 = 0 /* test1.c:3192:12 */

func alignmentCollFunc(tls *libc.TLS, NotUsed uintptr, nKey1 int32, pKey1 uintptr, nKey2 int32, pKey2 uintptr) int32 { /* test1.c:3193:12: */
	var rc int32
	var n int32
	if nKey1 < nKey2 {
		n = nKey1
	} else {
		n = nKey2
	}
	if (nKey1 > 0) && (1 == (1 & (int32(pKey1)))) {
		unaligned_string_counter++
	}
	if (nKey2 > 0) && (1 == (1 & (int32(pKey2)))) {
		unaligned_string_counter++
	}
	rc = libc.Xmemcmp(tls, pKey1, pKey2, uint32(n))
	if rc == 0 {
		rc = (nKey1 - nKey2)
	}
	return rc
}

func add_alignment_test_collations(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3208:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	if objc >= 2 {
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
			return TCL_ERROR
		}
		sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+16252 /* "utf16_unaligned" */, SQLITE_UTF16,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
			}{alignmentCollFunc})))
		sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+16268 /* "utf16_aligned" */, SQLITE_UTF16_ALIGNED,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
			}{alignmentCollFunc})))
	}
	return SQLITE_OK
}

// Usage: add_test_function <db ptr> <utf8> <utf16le> <utf16be>
//
// This function is used to test that SQLite selects the correct user
// function callback when multiple versions (for different text encodings)
// are available.
//
// Calling this routine registers up to three versions of the user function
// "test_function" with database handle <db>.  If the second argument is
// true, then a version of test_function is registered for UTF-8, if the
// third is true, a version is registered for UTF-16le, if the fourth is
// true, a UTF-16be version is available.  Previous versions of
// test_function are deleted.
//
// The user function is implemented by calling the following TCL script:
//
//   "test_function <enc> <arg>"
//
// Where <enc> is one of UTF-8, UTF-16LE or UTF16BE, and <arg> is the
// single argument passed to the SQL function. The value returned by
// the TCL script is used as the return value of the SQL function. It
// is passed to SQLite using UTF-16BE for a UTF-8 test_function(), UTF-8
// for a UTF-16LE test_function(), and UTF-16LE for an implementation that
// prefers UTF-16BE.
func test_function_utf8(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test1.c:3252:13: */
	var interp uintptr
	var pX uintptr
	var pVal uintptr
	interp = sqlite3.Xsqlite3_user_data(tls, pCtx)
	pX = tcl.XTcl_NewStringObj(tls, ts+16282 /* "test_function" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pX, tcl.XTcl_NewStringObj(tls, ts+16186 /* "UTF-8" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pX,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1))
	tcl.XTcl_EvalObjEx(tls, interp, pX, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_result_text(tls, pCtx, tcl.XTcl_GetStringResult(tls, interp), -1, libc.UintptrFromInt32(-1))
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, tcl.XTcl_GetStringResult(tls, interp),
		uint8(SQLITE_UTF8), uintptr(0))
	sqlite3.Xsqlite3_result_text16be(tls, pCtx, sqlite3.Xsqlite3_value_text16be(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3ValueFree(tls, pVal)
}

func test_function_utf16le(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test1.c:3276:13: */
	var interp uintptr
	var pX uintptr
	var pVal uintptr
	interp = sqlite3.Xsqlite3_user_data(tls, pCtx)
	pX = tcl.XTcl_NewStringObj(tls, ts+16282 /* "test_function" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pX, tcl.XTcl_NewStringObj(tls, ts+16192 /* "UTF-16LE" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pX,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1))
	tcl.XTcl_EvalObjEx(tls, interp, pX, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, tcl.XTcl_GetStringResult(tls, interp),
		uint8(SQLITE_UTF8), uintptr(0))
	sqlite3.Xsqlite3_result_text(tls, pCtx, sqlite3.Xsqlite3_value_text(tls, pVal), -1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3ValueFree(tls, pVal)
}

func test_function_utf16be(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test1.c:3298:13: */
	var interp uintptr
	var pX uintptr
	var pVal uintptr
	interp = sqlite3.Xsqlite3_user_data(tls, pCtx)
	pX = tcl.XTcl_NewStringObj(tls, ts+16282 /* "test_function" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pX, tcl.XTcl_NewStringObj(tls, ts+16201 /* "UTF-16BE" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pX,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1))
	tcl.XTcl_EvalObjEx(tls, interp, pX, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, tcl.XTcl_GetStringResult(tls, interp),
		uint8(SQLITE_UTF8), uintptr(0))
	sqlite3.Xsqlite3_result_text16(tls, pCtx, sqlite3.Xsqlite3_value_text16le(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_result_text16be(tls, pCtx, sqlite3.Xsqlite3_value_text16le(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_result_text16le(tls, pCtx, sqlite3.Xsqlite3_value_text16le(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3ValueFree(tls, pVal)
}

func test_function(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3326:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 4

	// var val int32 at bp+36, 4

	if !(objc != 5) {
		goto __1
	}
	goto bad_args
__1:
	;
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &val */)) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 36 /* val */)) != 0) {
		goto __4
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16282 /* "test_function" */, 1, SQLITE_UTF8,
		interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_function_utf8})), uintptr(0), uintptr(0))
__4:
	;
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+36 /* &val */)) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 36 /* val */)) != 0) {
		goto __6
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16282 /* "test_function" */, 1, SQLITE_UTF16LE,
		interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_function_utf16le})), uintptr(0), uintptr(0))
__6:
	;
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+36 /* &val */)) {
		goto __7
	}
	return TCL_ERROR
__7:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 36 /* val */)) != 0) {
		goto __8
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16282 /* "test_function" */, 1, SQLITE_UTF16BE,
		interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_function_utf16be})), uintptr(0), uintptr(0))
__8:
	;

	return TCL_OK
bad_args:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16210 /* " <DB> <utf8> <ut..." */, 0))
	return TCL_ERROR
}

// Usage:         sqlite3_test_errstr <err code>
//
// Test that the english language string equivalents for sqlite error codes
// are sane. The parameter is an integer representing an sqlite error code.
// The result is a list of two elements, the string representation of the
// error code and the english language explanation.
func test_errstr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3371:26: */
	var zCode uintptr
	var i int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16296 /* "<error code>" */)
	}

	zCode = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	for i = 0; i < 200; i++ {
		if 0 == libc.Xstrcmp(tls, sqlite3.Xsqlite3ErrName(tls, i), zCode) {
			break
		}
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, i), uintptr(0))
	return TCL_OK
}

// Usage:    breakpoint
//
// This routine exists for one purpose - to provide a place to put a
// breakpoint with GDB that can be triggered using TCL code.  The use
// for this is when a particular test fails on (say) the 1485th iteration.
// In the TCL test script, we can add code like this:
//
//     if {$i==1485} breakpoint
//
// Then run testfixture in the debugger and wait for the breakpoint to
// fire.  Then additional breakpoints can be set to trace down the bug.
func test_breakpoint(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:3404:26: */
	return TCL_OK // Do nothing
}

// Usage:   sqlite3_bind_zeroblob  STMT IDX N
//
// Test the sqlite3_bind_zeroblob interface.  STMT is a prepared statement.
// IDX is the index of a wildcard in the prepared statement.  This command
// binds a N-byte zero-filled BLOB to the wildcard.
func test_bind_zeroblob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3420:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var pStmt uintptr at bp, 4

	// var idx int32 at bp+4, 4

	// var n int32 at bp+8, 4

	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16309 /* "STMT IDX N" */)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &idx */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+8 /* &n */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_zeroblob(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 4 /* idx */)), *(*int32)(unsafe.Pointer(bp + 8 /* n */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_zeroblob64  STMT IDX N
//
// Test the sqlite3_bind_zeroblob64 interface.  STMT is a prepared statement.
// IDX is the index of a wildcard in the prepared statement.  This command
// binds a N-byte zero-filled BLOB to the wildcard.
func test_bind_zeroblob64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3456:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var pStmt uintptr at bp+16, 4

	// var idx int32 at bp+20, 4

	// var n Tcl_WideInt at bp+24, 8

	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16309 /* "STMT IDX N" */)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+20 /* &idx */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+24 /* &n */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_zeroblob64(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 20 /* idx */)), uint64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 24 /* n */))))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_int  STMT N VALUE
//
// Test the sqlite3_bind_int interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a 32-bit integer VALUE to that wildcard.
func test_bind_int(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3493:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 4

	// var idx int32 at bp+36, 4

	// var value int32 at bp+40, 4

	var rc int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16320 /* " STMT N VALUE" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &idx */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+40 /* &value */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_int(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* idx */)), *(*int32)(unsafe.Pointer(bp + 40 /* value */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   intarray_addr  INT  ...
//
// Return the address of a C-language array of 32-bit integers.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_intarray_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3533:26: */
	var i int32

	sqlite3.Xsqlite3_free(tls, p)
	p = uintptr(0)
	if objc > 1 {
		p = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(int32(0))) * (uint32(objc - 1)))))
		if p == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < (objc - 1); i++ {
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((1+i))*4)), (p+uintptr(i)*4)) != 0 {
				sqlite3.Xsqlite3_free(tls, p)
				p = uintptr(0)
				return TCL_ERROR
			}
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p)))
	return TCL_OK
}

var p uintptr = uintptr(0) /* test1.c:3540:14 */

// Usage:   intarray_addr  INT  ...
//
// Return the address of a C-language array of 32-bit integers.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_int64array_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3567:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32

	sqlite3.Xsqlite3_free(tls, p1)
	p1 = uintptr(0)
	if objc > 1 {
		p1 = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(sqlite3_int64(0))) * (uint32(objc - 1)))))
		if p1 == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < (objc - 1); i++ {
			// var v Tcl_WideInt at bp, 8

			if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((1+i))*4)), bp /* &v */) != 0 {
				sqlite3.Xsqlite3_free(tls, p1)
				p1 = uintptr(0)
				return TCL_ERROR
			}
			*(*sqlite3_int64)(unsafe.Pointer(p1 + uintptr(i)*8)) = *(*Tcl_WideInt)(unsafe.Pointer(bp /* v */))
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p1)))
	return TCL_OK
}

var p1 uintptr = uintptr(0) /* test1.c:3574:24 */

// Usage:   doublearray_addr  INT  ...
//
// Return the address of a C-language array of doubles.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_doublearray_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3603:26: */
	var i int32

	sqlite3.Xsqlite3_free(tls, p2)
	p2 = uintptr(0)
	if objc > 1 {
		p2 = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(float64(0))) * (uint32(objc - 1)))))
		if p2 == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < (objc - 1); i++ {
			if tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((1+i))*4)), (p2+uintptr(i)*8)) != 0 {
				sqlite3.Xsqlite3_free(tls, p2)
				p2 = uintptr(0)
				return TCL_ERROR
			}
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p2)))
	return TCL_OK
}

var p2 uintptr = uintptr(0) /* test1.c:3610:17 */

// Usage:   textarray_addr  TEXT ...
//
// Return the address of a C-language array of strings.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_textarray_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3637:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32

	for i = 0; i < n; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(p3 + uintptr(i)*4)))
	}
	sqlite3.Xsqlite3_free(tls, p3)
	p3 = uintptr(0)
	if objc > 1 {
		p3 = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(uintptr(0))) * (uint32(objc - 1)))))
		if p3 == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < (objc - 1); i++ {
			*(*uintptr)(unsafe.Pointer(p3 + uintptr(i)*4)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((1+i))*4)))))
		}
	}
	n = (objc - 1)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p3)))
	return TCL_OK
}

var n int32 = 0             /* test1.c:3644:14 */
var p3 uintptr = uintptr(0) /* test1.c:3645:15 */

// Usage:   sqlite3_bind_int64  STMT N VALUE
//
// Test the sqlite3_bind_int64 interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a 64-bit integer VALUE to that wildcard.
func test_bind_int64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3670:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var pStmt uintptr at bp+32, 4

	// var idx int32 at bp+36, 4

	// var value Tcl_WideInt at bp+40, 8

	var rc int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16320 /* " STMT N VALUE" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &idx */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+40 /* &value */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* idx */)), *(*Tcl_WideInt)(unsafe.Pointer(bp + 40 /* value */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_double  STMT N VALUE
//
// Test the sqlite3_bind_double interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a 64-bit integer VALUE to that wildcard.
func test_bind_double(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3708:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var pStmt uintptr at bp+32, 4

	// var idx int32 at bp+36, 4

	*(*float64)(unsafe.Pointer(bp + 40 /* value */)) = float64(0)
	var rc int32
	var zVal uintptr
	var i int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16320 /* " STMT N VALUE" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &idx */) != 0 {
		return TCL_ERROR
	}

	// Intercept the string "NaN" and generate a NaN value for it.
	// All other strings are passed through to Tcl_GetDoubleFromObj().
	// Tcl_GetDoubleFromObj() should understand "NaN" but some versions
	// contain a bug.
	zVal = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aSpecialFp)) / uint32(unsafe.Sizeof(struct {
		FzName  uintptr
		FiUpper uint32
		FiLower uint32
	}{}))); i++ {
		if libc.Xstrcmp(tls, aSpecialFp[i].FzName, zVal) == 0 {
			// var x sqlite3_uint64 at bp+48, 8

			*(*sqlite3_uint64)(unsafe.Pointer(bp + 48 /* x */)) = sqlite3_uint64(aSpecialFp[i].FiUpper)
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 48 /* x */)) <<= 32
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 48 /* x */)) |= sqlite3_uint64(aSpecialFp[i].FiLower)

			libc.Xmemcpy(tls, bp+40 /* &value */, bp+48 /* &x */, uint32(8))
			break
		}
	}
	if (uint32(i) >= (uint32(unsafe.Sizeof(aSpecialFp)) / uint32(unsafe.Sizeof(struct {
		FzName  uintptr
		FiUpper uint32
		FiLower uint32
	}{})))) && (tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+40 /* &value */) != 0) {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_bind_double(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* idx */)), *(*float64)(unsafe.Pointer(bp + 40 /* value */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

var aSpecialFp = [10]struct {
	FzName  uintptr
	FiUpper uint32
	FiLower uint32
}{
	{FzName: ts + 16334 /* "NaN" */, FiUpper: uint32(0x7fffffff), FiLower: 0xffffffff},
	{FzName: ts + 16338 /* "SNaN" */, FiUpper: uint32(0x7ff7ffff), FiLower: 0xffffffff},
	{FzName: ts + 16343 /* "-NaN" */, FiUpper: 0xffffffff, FiLower: 0xffffffff},
	{FzName: ts + 16348 /* "-SNaN" */, FiUpper: 0xfff7ffff, FiLower: 0xffffffff},
	{FzName: ts + 16354 /* "+Inf" */, FiUpper: uint32(0x7ff00000)},
	{FzName: ts + 16359 /* "-Inf" */, FiUpper: 0xfff00000},
	{FzName: ts + 16364 /* "Epsilon" */, FiLower: uint32(0x00000001)},
	{FzName: ts + 16372 /* "-Epsilon" */, FiUpper: 0x80000000, FiLower: uint32(0x00000001)},
	{FzName: ts + 16381 /* "NaN0" */, FiUpper: uint32(0x7ff80000)},
	{FzName: ts + 16386 /* "-NaN0" */, FiUpper: 0xfff80000},
} /* test1.c:3724:5 */

// Usage:   sqlite3_bind_null  STMT N
//
// Test the sqlite3_bind_null interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a NULL to the wildcard.
func test_bind_null(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3784:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 4

	// var idx int32 at bp+36, 4

	var rc int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16392 /* " STMT N" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &idx */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* idx */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_text  STMT N STRING BYTES
//
// Test the sqlite3_bind_text interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a UTF-8 string STRING to the wildcard.  The string is BYTES bytes
// long.
func test_bind_text(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3820:26: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var pStmt uintptr at bp+64, 4

	// var idx int32 at bp+68, 4

	*(*int32)(unsafe.Pointer(bp + 72 /* trueLength */)) = 0
	// var bytes int32 at bp+76, 4

	var value uintptr
	var rc int32
	var toFree uintptr = uintptr(0)

	if objc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16400 /* " STMT N VALUE BY..." */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+68 /* &idx */) != 0 {
		return TCL_ERROR
	}
	value = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+72 /* &trueLength */)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+76 /* &bytes */) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 76 /* bytes */)) < 0 {
		toFree = libc.Xmalloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 72 /* trueLength */)) + 1)))
		if toFree == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+1930 /* "out of memory" */, uintptr(0)))
			return TCL_ERROR
		}
		libc.Xmemcpy(tls, toFree, value, uint32(*(*int32)(unsafe.Pointer(bp + 72 /* trueLength */))))
		*(*int8)(unsafe.Pointer(toFree + uintptr(*(*int32)(unsafe.Pointer(bp + 72 /* trueLength */))))) = int8(0)
		value = toFree
	}
	rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 68 /* idx */)), value, *(*int32)(unsafe.Pointer(bp + 76 /* bytes */)), libc.UintptrFromInt32(-1))
	libc.Xfree(tls, toFree)
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_text16 ?-static? STMT N STRING BYTES
//
// Test the sqlite3_bind_text16 interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a UTF-16 string STRING to the wildcard.  The string is BYTES bytes
// long.
func test_bind_text16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3873:26: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var pStmt uintptr at bp+64, 4

	// var idx int32 at bp+68, 4

	// var bytes int32 at bp+76, 4

	var value uintptr
	var toFree uintptr = uintptr(0)
	var rc int32
	*(*int32)(unsafe.Pointer(bp + 72 /* trueLength */)) = 0

	var xDel uintptr = func() uintptr {
		if objc == 6 {
			return uintptr(0)
		}
		return libc.UintptrFromInt32(-1)
	}()
	var oStmt uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-4))*4))
	var oN uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-3))*4))
	var oString uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-2))*4))
	var oBytes uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*4))

	if (objc != 5) && (objc != 6) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16400 /* " STMT N VALUE BY..." */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, oStmt), bp+64 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, oN, bp+68 /* &idx */) != 0 {
		return TCL_ERROR
	}
	value = tcl.XTcl_GetByteArrayFromObj(tls, oString, bp+72 /* &trueLength */)
	if tcl.XTcl_GetIntFromObj(tls, interp, oBytes, bp+76 /* &bytes */) != 0 {
		return TCL_ERROR
	}
	if (*(*int32)(unsafe.Pointer(bp + 76 /* bytes */)) < 0) && (xDel == (libc.UintptrFromInt32(-1))) {
		toFree = libc.Xmalloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 72 /* trueLength */)) + 3)))
		if toFree == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+1930 /* "out of memory" */, uintptr(0)))
			return TCL_ERROR
		}
		libc.Xmemcpy(tls, toFree, value, uint32(*(*int32)(unsafe.Pointer(bp + 72 /* trueLength */))))
		libc.Xmemset(tls, (toFree + uintptr(*(*int32)(unsafe.Pointer(bp + 72 /* trueLength */)))), 0, uint32(3))
		value = toFree
	}
	rc = sqlite3.Xsqlite3_bind_text16(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 68 /* idx */)), value, *(*int32)(unsafe.Pointer(bp + 76 /* bytes */)), xDel)
	libc.Xfree(tls, toFree)
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_blob ?-static? STMT N DATA BYTES
//
// Test the sqlite3_bind_blob interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a BLOB to the wildcard.  The BLOB is BYTES bytes in size.
func test_bind_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3933:26: */
	bp := tls.Alloc(280)
	defer tls.Free(280)

	// var pStmt uintptr at bp+64, 4

	// var len int32 at bp+72, 4

	// var idx int32 at bp+68, 4

	// var bytes int32 at bp+76, 4

	var value uintptr
	var rc int32
	var xDestructor sqlite3_destructor_type = libc.UintptrFromInt32(-1)

	if (objc != 5) && (objc != 6) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16420 /* " STMT N DATA BYT..." */, 0))
		return TCL_ERROR
	}

	if objc == 6 {
		xDestructor = uintptr(0)
		objv += 4
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+68 /* &idx */) != 0 {
		return TCL_ERROR
	}

	value = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+72 /* &len */)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+76 /* &bytes */) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 76 /* bytes */)) > *(*int32)(unsafe.Pointer(bp + 72 /* len */)) {
		// var zBuf [200]int8 at bp+80, 200

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+80, /* &zBuf[0] */
			ts+16439 /* "cannot use %d bl..." */, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 76 /* bytes */)), *(*int32)(unsafe.Pointer(bp + 72 /* len */))))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+80 /* &zBuf[0] */, uintptr(0)))
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_blob(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 68 /* idx */)), value, *(*int32)(unsafe.Pointer(bp + 76 /* bytes */)), xDestructor)
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

// sqlite3_carray_bind [options...] STMT NAME VALUE ...
//
// Options:
//    -transient
//    -static
//    -int32
//    -int64
//    -double
//    -text
//
// Each call clears static data.  Called with no options does nothing
// but clear static data.
func test_carray_bind(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3996:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var pStmt uintptr at bp+80, 4

	var eType int32 // CARRAY_INT32
	var nData int32
	var aData uintptr
	var isTransient int32
	var isStatic int32
	// var idx int32 at bp+84, 4

	var i int32
	var j int32
	var rc int32
	var xDel uintptr
	var z uintptr
	// var v int32 at bp+88, 4
	// INT32
	var a uintptr
	// var v1 Tcl_WideInt at bp+96, 8
	// INT64
	var a1 uintptr
	// var v2 float64 at bp+104, 8
	// DOUBLE
	var a2 uintptr
	var v3 uintptr // TEXT
	var a3 uintptr
	eType = 0
	nData = 0
	aData = uintptr(0)
	isTransient = 0
	isStatic = 0
	xDel = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free}))

	if !(aStaticData != 0) {
		goto __1
	}
	// Always clear preexisting static data on every call
	if !(eStaticType == 3) {
		goto __2
	}
	i = 0
__3:
	if !(i < nStaticData) {
		goto __5
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((aStaticData) + uintptr(i)*4)))
	goto __4
__4:
	i++
	goto __3
	goto __5
__5:
	;
__2:
	;
	sqlite3.Xsqlite3_free(tls, aStaticData)
	aStaticData = uintptr(0)
	nStaticData = 0
	eStaticType = 0
__1:
	;
	if !(objc == 1) {
		goto __6
	}
	return TCL_OK
__6:
	;

	i = 1
__7:
	if !((i < objc) && (int32(*(*int8)(unsafe.Pointer(tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)))))) == '-')) {
		goto __9
	}
	z = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)))
	if !(libc.Xstrcmp(tls, z, ts+16473 /* "-transient" */) == 0) {
		goto __10
	}
	isTransient = 1
	xDel = libc.UintptrFromInt32(-1)
	goto __11
__10:
	if !(libc.Xstrcmp(tls, z, ts+16484 /* "-static" */) == 0) {
		goto __12
	}
	isStatic = 1
	xDel = uintptr(0)
	goto __13
__12:
	if !(libc.Xstrcmp(tls, z, ts+16492 /* "-int32" */) == 0) {
		goto __14
	}
	eType = 0 // CARRAY_INT32
	goto __15
__14:
	if !(libc.Xstrcmp(tls, z, ts+16499 /* "-int64" */) == 0) {
		goto __16
	}
	eType = 1 // CARRAY_INT64
	goto __17
__16:
	if !(libc.Xstrcmp(tls, z, ts+16506 /* "-double" */) == 0) {
		goto __18
	}
	eType = 2 // CARRAY_DOUBLE
	goto __19
__18:
	if !(libc.Xstrcmp(tls, z, ts+16514 /* "-text" */) == 0) {
		goto __20
	}
	eType = 3 // CARRAY_TEXT
	goto __21
__20:
	if !(libc.Xstrcmp(tls, z, ts+16520 /* "--" */) == 0) {
		goto __22
	}
	goto __9
	goto __23
__22:

	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+12133 /* "unknown option: " */, z, uintptr(0)))
	return TCL_ERROR
__23:
	;
__21:
	;
__19:
	;
__17:
	;
__15:
	;
__13:
	;
__11:
	;
	goto __8
__8:
	i++
	goto __7
	goto __9
__9:
	;
	if !(((eType == 3) && !(isStatic != 0)) && !(isTransient != 0)) {
		goto __24
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+16523, /* "text data must b..." */
		uintptr(0)))
	return TCL_ERROR
__24:
	;
	if !((isStatic != 0) && (isTransient != 0)) {
		goto __25
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+16570, /* "cannot be both -..." */
		uintptr(0)))
	return TCL_ERROR
__25:
	;
	if !((objc - i) < 2) {
		goto __26
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16608 /* "[OPTIONS] STMT I..." */)
	return TCL_ERROR
__26:
	;
	if !(getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4))), bp+80 /* &pStmt */) != 0) {
		goto __27
	}
	return TCL_ERROR
__27:
	;
	i++
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+84 /* &idx */) != 0) {
		goto __28
	}
	return TCL_ERROR
__28:
	;
	i++
	nData = (objc - i)
	switch eType + (4 * (libc.Bool32(nData <= 0))) {
	case 0:
		goto __30
	case 1:
		goto __31
	case 2:
		goto __32
	case 3:
		goto __33
	case 4:
		goto __34
	}
	goto __29
__30: // INT32
	a = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(int32(0))) * uint32(nData))))
	if !(a == uintptr(0)) {
		goto __35
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__35:
	;
	j = 0
__36:
	if !(j < nData) {
		goto __38
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+j))*4)), bp+88 /* &v */) != 0) {
		goto __39
	}
	sqlite3.Xsqlite3_free(tls, a)
	return TCL_ERROR
__39:
	;
	*(*int32)(unsafe.Pointer(a + uintptr(j)*4)) = *(*int32)(unsafe.Pointer(bp + 88 /* v */))
	goto __37
__37:
	j++
	goto __36
	goto __38
__38:
	;
	aData = a
	goto __29

__31: // INT64
	a1 = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(sqlite3_int64(0))) * uint32(nData))))
	if !(a1 == uintptr(0)) {
		goto __40
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__40:
	;
	j = 0
__41:
	if !(j < nData) {
		goto __43
	}
	if !(tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+j))*4)), bp+96 /* &v1 */) != 0) {
		goto __44
	}
	sqlite3.Xsqlite3_free(tls, a1)
	return TCL_ERROR
__44:
	;
	*(*sqlite3_int64)(unsafe.Pointer(a1 + uintptr(j)*8)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 96 /* v1 */))
	goto __42
__42:
	j++
	goto __41
	goto __43
__43:
	;
	aData = a1
	goto __29

__32: // DOUBLE
	a2 = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(float64(0))) * uint32(nData))))
	if !(a2 == uintptr(0)) {
		goto __45
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__45:
	;
	j = 0
__46:
	if !(j < nData) {
		goto __48
	}
	if !(tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+j))*4)), bp+104 /* &v2 */) != 0) {
		goto __49
	}
	sqlite3.Xsqlite3_free(tls, a2)
	return TCL_ERROR
__49:
	;
	*(*float64)(unsafe.Pointer(a2 + uintptr(j)*8)) = *(*float64)(unsafe.Pointer(bp + 104 /* v2 */))
	goto __47
__47:
	j++
	goto __46
	goto __48
__48:
	;
	aData = a2
	goto __29

__33: // TEXT
	a3 = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(uintptr(0))) * uint32(nData))))
	if !(a3 == uintptr(0)) {
		goto __50
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__50:
	;
	j = 0
__51:
	if !(j < nData) {
		goto __53
	}
	v3 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+j))*4)))
	*(*uintptr)(unsafe.Pointer(a3 + uintptr(j)*4)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+56, v3))
	goto __52
__52:
	j++
	goto __51
	goto __53
__53:
	;
	aData = a3
	goto __29

__34: // nData==0
	aData = ts + 489 /* "" */
	xDel = uintptr(0)
	isTransient = 0
	isStatic = 0
	goto __29

__29:
	;
	if !(isStatic != 0) {
		goto __54
	}
	aStaticData = aData
	nStaticData = nData
	eStaticType = eType
__54:
	;
	rc = sqlite3_carray_bind(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 84 /* idx */)), aData, nData, eType, xDel)
	if !(isTransient != 0) {
		goto __55
	}
	if !(eType == 3) {
		goto __56
	}
	i = 0
__57:
	if !(i < nData) {
		goto __59
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((aData) + uintptr(i)*4)))
	goto __58
__58:
	i++
	goto __57
	goto __59
__59:
	;
__56:
	;
	sqlite3.Xsqlite3_free(tls, aData)
__55:
	;
carray_bind_done:
	if !(rc != 0) {
		goto __60
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, sqlite3.Xsqlite3_errstr(tls, rc), uintptr(0)))
	return TCL_ERROR
__60:
	;
	return TCL_OK
}

var aStaticData uintptr = uintptr(0) /* test1.c:4012:15 */
var nStaticData int32 = 0            /* test1.c:4013:14 */
var eStaticType int32 = 0            /* test1.c:4014:14 */

// Usage:   sqlite3_bind_parameter_count  STMT
//
// Return the number of wildcards in the given statement.
func test_bind_parameter_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4174:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var pStmt uintptr at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16637 /* "STMT" */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))))
	return TCL_OK
}

// Usage:   sqlite3_bind_parameter_name  STMT  N
//
// Return the name of the Nth wildcard.  The first wildcard is 1.
// An empty string is returned if N is out of range or if the wildcard
// is nameless.
func test_bind_parameter_name(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4198:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 4

	// var i int32 at bp+4, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16642 /* "STMT N" */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &i */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_bind_parameter_name(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 4 /* i */))), -1))
	return TCL_OK
}

// Usage:   sqlite3_bind_parameter_index  STMT  NAME
//
// Return the index of the wildcard called NAME.  Return 0 if there is
// no such wildcard.
func test_bind_parameter_index(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4225:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var pStmt uintptr at bp, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16649 /* "STMT NAME" */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewIntObj(tls,
			sqlite3.Xsqlite3_bind_parameter_index(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))))))
	return TCL_OK
}

// Usage:   sqlite3_clear_bindings STMT
//
func test_clear_bindings(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4250:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var pStmt uintptr at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16637 /* "STMT" */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_clear_bindings(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))))
	return TCL_OK
}

// Usage:   sqlite3_sleep MILLISECONDS
func test_sleep(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4270:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var ms int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+12806 /* "MILLISECONDS" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &ms */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_sleep(tls, *(*int32)(unsafe.Pointer(bp /* ms */)))))
	return TCL_OK
}

// Usage: sqlite3_extended_errcode DB
//
// Return the string representation of the most recent sqlite3_* API
// error code. e.g. "SQLITE_ERROR".
func test_ex_errcode(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4295:26: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// var db uintptr at bp+48, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_extended_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_OK
}

// Usage: sqlite3_errcode DB
//
// Return the string representation of the most recent sqlite3_* API
// error code. e.g. "SQLITE_ERROR".
func test_errcode(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4322:26: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// var db uintptr at bp+48, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_OK
}

// Usage:   sqlite3_errmsg DB
//
// Returns the UTF-8 representation of the error message string for the
// most recent sqlite3_* API call.
func test_errmsg(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4348:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	var zErr uintptr

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}

	zErr = sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErr, -1))
	return TCL_OK
}

// Usage:   test_errmsg16 DB
//
// Returns the UTF-16 representation of the error message string for the
// most recent sqlite3_* API call. This is a byte array object at the TCL
// level, and it includes the 0x00 0x00 terminator bytes at the end of the
// UTF-16 string.
func test_errmsg16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4377:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	var zErr uintptr
	var z uintptr
	var bytes int32 = 0

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}

	zErr = sqlite3.Xsqlite3_errmsg16(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	if zErr != 0 {
		z = zErr
		for bytes = 0; (*(*int8)(unsafe.Pointer(z + uintptr(bytes))) != 0) || (*(*int8)(unsafe.Pointer(z + uintptr((bytes + 1)))) != 0); bytes = bytes + (2) {
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, zErr, bytes))
	return TCL_OK
}

// Usage: sqlite3_prepare DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4414:26: */
	bp := tls.Alloc(146)
	defer tls.Free(146)

	// var db uintptr at bp+80, 4

	var zSql uintptr
	// var bytes int32 at bp+84, 4

	*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+96, 50

	var rc int32

	if (objc != 5) && (objc != 4) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+16659 /* " DB sql bytes ?t..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+80 /* &db */) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+84 /* &bytes */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_prepare(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)), bp+88 /* &pStmt */, func() uintptr {
		if objc >= 5 {
			return bp + 92 /* &zTail */
		}
		return uintptr(0)
	}())
	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	if (*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)) != 0) && (objc >= 5) {
		if *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) = (*(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) - ((int32(*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */))) - int32(zSql)) / 1))
		}
		if int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)))) < *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) {
			*(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */))))
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 84 /* bytes */))), 0)
	}
	if rc != SQLITE_OK {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+96 /* &zBuf[0] */, ts+16167 /* "(%d) " */, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+96 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+96 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+96 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

// Usage: sqlite3_prepare_v2 DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4471:26: */
	bp := tls.Alloc(146)
	defer tls.Free(146)

	// var db uintptr at bp+80, 4

	var zSql uintptr
	var zCopy uintptr = uintptr(0) // malloc() copy of zSql
	// var bytes int32 at bp+84, 4

	*(*uintptr)(unsafe.Pointer(bp + 88 /* zTail */)) = uintptr(0)
	var pzTail uintptr
	*(*uintptr)(unsafe.Pointer(bp + 92 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+96, 50

	var rc int32

	if (objc != 5) && (objc != 4) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+16683 /* " DB sql bytes ta..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+80 /* &db */) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+84 /* &bytes */) != 0 {
		return TCL_ERROR
	}

	// Instead of using zSql directly, make a copy into a buffer obtained
	// directly from malloc(). The idea is to make it easier for valgrind
	// to spot buffer overreads.
	if *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) >= 0 {
		zCopy = libc.Xmalloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 84 /* bytes */))))
		libc.Xmemcpy(tls, zCopy, zSql, uint32(*(*int32)(unsafe.Pointer(bp + 84 /* bytes */))))
	} else {
		var n int32 = (int32(libc.Xstrlen(tls, zSql)) + 1)
		zCopy = libc.Xmalloc(tls, uint32(n))
		libc.Xmemcpy(tls, zCopy, zSql, uint32(n))
	}
	if objc >= 5 {
		pzTail = bp + 88 /* &zTail */
	} else {
		pzTail = uintptr(0)
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zCopy, *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)), bp+92 /* &pStmt */, pzTail)
	if objc >= 5 {
		*(*uintptr)(unsafe.Pointer(bp + 88 /* zTail */)) = (zSql + uintptr(((int32(*(*uintptr)(unsafe.Pointer(bp + 88 /* zTail */))) - int32(zCopy)) / 1)))
	}
	libc.Xfree(tls, zCopy)

	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	if ((rc == SQLITE_OK) && (objc >= 5)) && (*(*uintptr)(unsafe.Pointer(bp + 88 /* zTail */)) != 0) {
		if *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) = (*(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) - ((int32(*(*uintptr)(unsafe.Pointer(bp + 88 /* zTail */))) - int32(zSql)) / 1))
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 84 /* bytes */))), 0)
	}
	if rc != SQLITE_OK {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+96 /* &zBuf[0] */, ts+16167 /* "(%d) " */, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+96 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 92 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+96 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 92 /* pStmt */))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+96 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

// Usage: sqlite3_prepare_v3 DB sql bytes flags ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB> and flags <flags>. The parameter <tailval> is
// the name of a global variable that is set to the unused portion of
// <sql> (if any). A STMT handle is returned.
func test_prepare_v3(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4545:26: */
	bp := tls.Alloc(150)
	defer tls.Free(150)

	// var db uintptr at bp+80, 4

	var zSql uintptr
	var zCopy uintptr = uintptr(0) // malloc() copy of zSql
	// var bytes int32 at bp+84, 4

	// var flags int32 at bp+88, 4

	*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)) = uintptr(0)
	var pzTail uintptr
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+100, 50

	var rc int32

	if (objc != 6) && (objc != 5) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+16705 /* " DB sql bytes fl..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+80 /* &db */) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+84 /* &bytes */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+88 /* &flags */) != 0 {
		return TCL_ERROR
	}

	// Instead of using zSql directly, make a copy into a buffer obtained
	// directly from malloc(). The idea is to make it easier for valgrind
	// to spot buffer overreads.
	if *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) >= 0 {
		zCopy = libc.Xmalloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 84 /* bytes */))))
		libc.Xmemcpy(tls, zCopy, zSql, uint32(*(*int32)(unsafe.Pointer(bp + 84 /* bytes */))))
	} else {
		var n int32 = (int32(libc.Xstrlen(tls, zSql)) + 1)
		zCopy = libc.Xmalloc(tls, uint32(n))
		libc.Xmemcpy(tls, zCopy, zSql, uint32(n))
	}
	if objc >= 6 {
		pzTail = bp + 92 /* &zTail */
	} else {
		pzTail = uintptr(0)
	}
	rc = sqlite3.Xsqlite3_prepare_v3(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zCopy, *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)), uint32(*(*int32)(unsafe.Pointer(bp + 88 /* flags */))), bp+96 /* &pStmt */, pzTail)
	libc.Xfree(tls, zCopy)
	*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)) = (zSql + uintptr(((int32(*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */))) - int32(zCopy)) / 1)))

	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	if ((rc == SQLITE_OK) && (*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)) != 0)) && (objc >= 6) {
		if *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) = (*(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) - ((int32(*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */))) - int32(zSql)) / 1))
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*4)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 84 /* bytes */))), 0)
	}
	if rc != SQLITE_OK {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+100 /* &zBuf[0] */, ts+16167 /* "(%d) " */, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+100 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+100 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+100 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

// Usage: sqlite3_prepare_tkt3134 DB
//
// Generate a prepared statement for a zero-byte string as a test
// for ticket #3134.  The string should be preceded by a zero byte.
func test_prepare_tkt3134(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4616:26: */
	bp := tls.Alloc(138)
	defer tls.Free(138)

	// var db uintptr at bp+80, 4

	*(*uintptr)(unsafe.Pointer(bp + 84 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+88, 50

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+16683 /* " DB sql bytes ta..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+80 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), (uintptr(unsafe.Pointer(&zSql)) + 1), 0, bp+84 /* &pStmt */, uintptr(0))

	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+88 /* &zBuf[0] */, ts+16167 /* "(%d) " */, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+88 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 84 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+88 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 84 /* pStmt */))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+88 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

var zSql = *(*[10]int8)(unsafe.Pointer(ts + 16733 /* "\x00SELECT 1" */)) /* test1.c:4623:21 */

// Usage: sqlite3_prepare16 DB sql bytes tailvar
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4659:26: */
	bp := tls.Alloc(118)
	defer tls.Free(118)

	// var db uintptr at bp+48, 4

	var zSql uintptr
	*(*uintptr)(unsafe.Pointer(bp + 64 /* zTail */)) = uintptr(0)
	var pTail uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 60 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+68, 50

	var rc int32
	// var bytes int32 at bp+56, 4
	// The integer specified as arg 3
	// var objlen int32 at bp+52, 4
	// The byte-array length of arg 2

	if (objc != 5) && (objc != 4) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+16659 /* " DB sql bytes ?t..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+52 /* &objlen */)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+56 /* &bytes */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_prepare16(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 56 /* bytes */)), bp+60 /* &pStmt */, func() uintptr {
		if objc >= 5 {
			return bp + 64 /* &zTail */
		}
		return uintptr(0)
	}())
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	if rc != 0 {
		return TCL_ERROR
	}

	if objc >= 5 {
		if *(*uintptr)(unsafe.Pointer(bp + 64 /* zTail */)) != 0 {
			*(*int32)(unsafe.Pointer(bp + 52 /* objlen */)) = (*(*int32)(unsafe.Pointer(bp + 52 /* objlen */)) - ((int32(*(*uintptr)(unsafe.Pointer(bp + 64 /* zTail */))) - int32(zSql)) / 1))
		} else {
			*(*int32)(unsafe.Pointer(bp + 52 /* objlen */)) = 0
		}
		pTail = tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 52 /* objlen */)))
		(*Tcl_Obj)(unsafe.Pointer(pTail)).FrefCount++
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0), pTail, 0)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pTail
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	if *(*uintptr)(unsafe.Pointer(bp + 60 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+68 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 60 /* pStmt */))) != 0 {
			return TCL_ERROR
		}
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+68 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: sqlite3_prepare16_v2 DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare16_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4719:26: */
	bp := tls.Alloc(118)
	defer tls.Free(118)

	// var db uintptr at bp+48, 4

	var zSql uintptr
	*(*uintptr)(unsafe.Pointer(bp + 64 /* zTail */)) = uintptr(0)
	var pTail uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 60 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+68, 50

	var rc int32
	// var bytes int32 at bp+56, 4
	// The integer specified as arg 3
	// var objlen int32 at bp+52, 4
	// The byte-array length of arg 2

	if (objc != 5) && (objc != 4) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+16659 /* " DB sql bytes ?t..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+52 /* &objlen */)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+56 /* &bytes */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_prepare16_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 56 /* bytes */)), bp+60 /* &pStmt */, func() uintptr {
		if objc >= 5 {
			return bp + 64 /* &zTail */
		}
		return uintptr(0)
	}())
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), rc) != 0 {
		return TCL_ERROR
	}
	if rc != 0 {
		return TCL_ERROR
	}

	if objc >= 5 {
		if *(*uintptr)(unsafe.Pointer(bp + 64 /* zTail */)) != 0 {
			*(*int32)(unsafe.Pointer(bp + 52 /* objlen */)) = (*(*int32)(unsafe.Pointer(bp + 52 /* objlen */)) - ((int32(*(*uintptr)(unsafe.Pointer(bp + 64 /* zTail */))) - int32(zSql)) / 1))
		} else {
			*(*int32)(unsafe.Pointer(bp + 52 /* objlen */)) = 0
		}
		pTail = tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 52 /* objlen */)))
		(*Tcl_Obj)(unsafe.Pointer(pTail)).FrefCount++
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0), pTail, 0)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pTail
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	if *(*uintptr)(unsafe.Pointer(bp + 60 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+68 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 60 /* pStmt */))) != 0 {
			return TCL_ERROR
		}
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+68 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: sqlite3_open filename ?options-list?
func test_open(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4774:26: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var zFilename uintptr
	// var db uintptr at bp+48, 4

	// var zBuf [100]int8 at bp+52, 100

	if ((objc != 3) && (objc != 2)) && (objc != 1) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+16743 /* " filename option..." */, 0))
		return TCL_ERROR
	}

	if objc > 1 {
		zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	} else {
		zFilename = uintptr(0)
	}
	sqlite3.Xsqlite3_open(tls, zFilename, bp+48 /* &db */)

	if sqlite3TestMakePointerStr(tls, interp, bp+52 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+52 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: sqlite3_open_v2 FILENAME FLAGS VFS
func test_open_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4801:26: */
	bp := tls.Alloc(292)
	defer tls.Free(292)

	var zFilename uintptr
	var zVfs uintptr
	var flags int32 = 0
	// var db uintptr at bp+188, 4

	var rc int32
	// var zBuf [100]int8 at bp+192, 100

	// var nFlag int32 at bp+16, 4

	// var apFlag uintptr at bp+20, 4

	var i int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16766 /* "FILENAME FLAGS V..." */)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if int32(*(*int8)(unsafe.Pointer(zVfs))) == 0x00 {
		zVfs = uintptr(0)
	}

	rc = tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16 /* &nFlag */, bp+20 /* &apFlag */)
	if rc != TCL_OK {
		return rc
	}
	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 16 /* nFlag */)); i++ {
		// var iFlag int32 at bp+184, 4

		*(*[20]OpenFlag)(unsafe.Pointer(bp + 24 /* aFlag */)) = [20]OpenFlag{
			{FzFlag: ts + 16785 /* "SQLITE_OPEN_READ..." */, Fflag: SQLITE_OPEN_READONLY},
			{FzFlag: ts + 16806 /* "SQLITE_OPEN_READ..." */, Fflag: SQLITE_OPEN_READWRITE},
			{FzFlag: ts + 16828 /* "SQLITE_OPEN_CREA..." */, Fflag: SQLITE_OPEN_CREATE},
			{FzFlag: ts + 16847 /* "SQLITE_OPEN_DELE..." */, Fflag: SQLITE_OPEN_DELETEONCLOSE},
			{FzFlag: ts + 16873 /* "SQLITE_OPEN_EXCL..." */, Fflag: SQLITE_OPEN_EXCLUSIVE},
			{FzFlag: ts + 16895 /* "SQLITE_OPEN_AUTO..." */, Fflag: SQLITE_OPEN_AUTOPROXY},
			{FzFlag: ts + 16917 /* "SQLITE_OPEN_MAIN..." */, Fflag: SQLITE_OPEN_MAIN_DB},
			{FzFlag: ts + 16937 /* "SQLITE_OPEN_TEMP..." */, Fflag: SQLITE_OPEN_TEMP_DB},
			{FzFlag: ts + 16957 /* "SQLITE_OPEN_TRAN..." */, Fflag: SQLITE_OPEN_TRANSIENT_DB},
			{FzFlag: ts + 16982 /* "SQLITE_OPEN_MAIN..." */, Fflag: SQLITE_OPEN_MAIN_JOURNAL},
			{FzFlag: ts + 17007 /* "SQLITE_OPEN_TEMP..." */, Fflag: SQLITE_OPEN_TEMP_JOURNAL},
			{FzFlag: ts + 17032 /* "SQLITE_OPEN_SUBJ..." */, Fflag: SQLITE_OPEN_SUBJOURNAL},
			{FzFlag: ts + 17055 /* "SQLITE_OPEN_SUPE..." */, Fflag: SQLITE_OPEN_SUPER_JOURNAL},
			{FzFlag: ts + 17081 /* "SQLITE_OPEN_NOMU..." */, Fflag: SQLITE_OPEN_NOMUTEX},
			{FzFlag: ts + 17101 /* "SQLITE_OPEN_FULL..." */, Fflag: SQLITE_OPEN_FULLMUTEX},
			{FzFlag: ts + 17123 /* "SQLITE_OPEN_SHAR..." */, Fflag: SQLITE_OPEN_SHAREDCACHE},
			{FzFlag: ts + 17147 /* "SQLITE_OPEN_PRIV..." */, Fflag: SQLITE_OPEN_PRIVATECACHE},
			{FzFlag: ts + 17172 /* "SQLITE_OPEN_WAL" */, Fflag: SQLITE_OPEN_WAL},
			{FzFlag: ts + 17188 /* "SQLITE_OPEN_URI" */, Fflag: SQLITE_OPEN_URI},
			{},
		}
		rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20 /* apFlag */)) + uintptr(i)*4)), bp+24 /* &aFlag[0] */, int32(unsafe.Sizeof(OpenFlag{})),
			ts+17204 /* "flag" */, 0, bp+184 /* &iFlag */)
		if rc != TCL_OK {
			return rc
		}
		flags = flags | ((*OpenFlag)(unsafe.Pointer(bp + 24 /* &aFlag */ + uintptr(*(*int32)(unsafe.Pointer(bp + 184 /* iFlag */)))*8)).Fflag)
	}

	rc = sqlite3.Xsqlite3_open_v2(tls, zFilename, bp+188 /* &db */, flags, zVfs)
	if sqlite3TestMakePointerStr(tls, interp, bp+192 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 188 /* db */))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, bp+192 /* &zBuf[0] */, 0))
	return TCL_OK
}

type OpenFlag = struct {
	FzFlag uintptr
	Fflag  int32
} /* test1.c:4830:5 */

// Usage: sqlite3_open16 filename options
func test_open16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4871:26: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var zFilename uintptr
	// var db uintptr at bp+48, 4

	// var zBuf [100]int8 at bp+52, 100

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+16743 /* " filename option..." */, 0))
		return TCL_ERROR
	}

	zFilename = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(0))
	sqlite3.Xsqlite3_open16(tls, zFilename, bp+48 /* &db */)

	if sqlite3TestMakePointerStr(tls, interp, bp+52 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+52 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: sqlite3_complete16 <UTF-16 string>
//
// Return 1 if the supplied argument is a complete SQL statement, or zero
// otherwise.
func test_complete16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4903:26: */
	var zBuf uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17209 /* "<utf-16 sql>" */)
		return TCL_ERROR
	}

	zBuf = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_complete16(tls, zBuf)))
	return TCL_OK
}

// Usage: sqlite3_normalize SQL
//
// Return the normalized value for an SQL statement.
func test_normalize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4928:26: */
	var zSql uintptr
	var zNorm uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10170 /* "SQL" */)
		return TCL_ERROR
	}

	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zNorm = sqlite3_normalize(tls, zSql)
	if zNorm != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zNorm, -1))
		sqlite3.Xsqlite3_free(tls, zNorm)
	}
	return TCL_OK
}

// Usage: sqlite3_step STMT
//
// Advance the statement to the next row.
func test_step(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4957:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var pStmt uintptr at bp+32, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+16006 /* " STMT" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))

	// if( rc!=SQLITE_DONE && rc!=SQLITE_ROW ) return TCL_ERROR;
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func test_sql(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4980:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var pStmt uintptr at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16637 /* "STMT" */)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))), uintptr(1))
	return TCL_OK
}

func test_ex_sql(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4997:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var pStmt uintptr at bp, 4

	var z uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16637 /* "STMT" */)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	z = sqlite3.Xsqlite3_expanded_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
	tcl.XTcl_SetResult(tls, interp, z, uintptr(1))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage: sqlite3_column_count STMT
//
// Return the number of columns returned by the sql statement STMT.
func test_column_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5042:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var pStmt uintptr at bp+32, 4

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17222 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))))
	return TCL_OK
}

// Usage: sqlite3_column_type STMT column
//
// Return the type of the data in column 'column' of the current row.
func test_column_type(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5067:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 4

	// var col int32 at bp+36, 4

	var tp int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17222 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &col */) != 0 {
		return TCL_ERROR
	}

	tp = sqlite3.Xsqlite3_column_type(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* col */)))
	switch tp {
	case SQLITE_INTEGER:
		tcl.XTcl_SetResult(tls, interp, ts+2274 /* "INTEGER" */, uintptr(0))
		break
	case SQLITE_NULL:
		tcl.XTcl_SetResult(tls, interp, ts+5707 /* "NULL" */, uintptr(0))
		break
	case SQLITE_FLOAT:
		tcl.XTcl_SetResult(tls, interp, ts+17235 /* "FLOAT" */, uintptr(0))
		break
	case SQLITE_TEXT:
		tcl.XTcl_SetResult(tls, interp, ts+17241 /* "TEXT" */, uintptr(0))
		break
	case SQLITE_BLOB:
		tcl.XTcl_SetResult(tls, interp, ts+17246 /* "BLOB" */, uintptr(0))
		break
	default:

	}

	return TCL_OK
}

// Usage: sqlite3_column_int64 STMT column
//
// Return the data in column 'column' of the current row cast as an
// wide (64-bit) integer.
func test_column_int64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5116:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 4

	// var col int32 at bp+36, 4

	var iVal i64

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17222 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &col */) != 0 {
		return TCL_ERROR
	}

	iVal = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* col */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, iVal))
	return TCL_OK
}

// Usage: sqlite3_column_blob STMT column
func test_column_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5143:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 4

	// var col int32 at bp+36, 4

	var len int32
	var pBlob uintptr

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17222 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &col */) != 0 {
		return TCL_ERROR
	}

	len = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* col */)))
	pBlob = sqlite3.Xsqlite3_column_blob(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* col */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, pBlob, len))
	return TCL_OK
}

// Usage: sqlite3_column_double STMT column
//
// Return the data in column 'column' of the current row cast as a double.
func test_column_double(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5175:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 4

	// var col int32 at bp+36, 4

	var rVal float64

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17222 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &col */) != 0 {
		return TCL_ERROR
	}

	rVal = sqlite3.Xsqlite3_column_double(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* col */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewDoubleObj(tls, rVal))
	return TCL_OK
}

// Usage: sqlite3_data_count STMT
//
// Return the number of columns returned by the sql statement STMT.
func test_data_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5204:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var pStmt uintptr at bp+32, 4

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17222 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_data_count(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))))
	return TCL_OK
}

// Usage: sqlite3_column_text STMT column
//
// Usage: sqlite3_column_decltype STMT column
//
// Usage: sqlite3_column_name STMT column
func test_stmt_utf8(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5231:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 4

	// var col int32 at bp+36, 4

	var xFunc uintptr
	var zRet uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17222 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &col */) != 0 {
		return TCL_ERROR
	}
	zRet = (*(*func(*libc.TLS, uintptr, int32) uintptr)(unsafe.Pointer(&xFunc)))(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* col */)))
	if zRet != 0 {
		tcl.XTcl_SetResult(tls, interp, zRet, uintptr(0))
	}
	return TCL_OK
}

func test_global_recover(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5258:26: */
	var rc int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_global_recover(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage: sqlite3_column_text STMT column
//
// Usage: sqlite3_column_decltype STMT column
//
// Usage: sqlite3_column_name STMT column
func test_stmt_utf16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5283:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 4

	// var col int32 at bp+36, 4

	var pRet uintptr
	var zName16 uintptr
	var xFunc uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17222 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &col */) != 0 {
		return TCL_ERROR
	}

	zName16 = (*(*func(*libc.TLS, uintptr, int32) uintptr)(unsafe.Pointer(&xFunc)))(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* col */)))
	if zName16 != 0 {
		var n int32
		var z uintptr = zName16
		for n = 0; (*(*int8)(unsafe.Pointer(z + uintptr(n))) != 0) || (*(*int8)(unsafe.Pointer(z + uintptr((n + 1)))) != 0); n = n + (2) {
		}
		pRet = tcl.XTcl_NewByteArrayObj(tls, zName16, (n + 2))
		tcl.XTcl_SetObjResult(tls, interp, pRet)
	}

	return TCL_OK
}

// Usage: sqlite3_column_int STMT column
//
// Usage: sqlite3_column_bytes STMT column
//
// Usage: sqlite3_column_bytes16 STMT column
//
func test_stmt_int(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5327:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 4

	// var col int32 at bp+36, 4

	var xFunc uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17222 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &col */) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(&xFunc)))(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 36 /* col */)))))
	return TCL_OK
}

// Usage:  sqlite_set_magic  DB  MAGIC-NUMBER
//
// Set the db->magic value.  This is used to test error recovery logic.
func sqlite_set_magic(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5356:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+17251 /* " DB MAGIC" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), ts+17261 /* "SQLITE_MAGIC_OPE..." */) == 0 {
		(*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmagic = SQLITE_MAGIC_OPEN
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), ts+17279 /* "SQLITE_MAGIC_CLO..." */) == 0 {
		(*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmagic = SQLITE_MAGIC_CLOSED
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), ts+17299 /* "SQLITE_MAGIC_BUS..." */) == 0 {
		(*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmagic = SQLITE_MAGIC_BUSY
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), ts+17317 /* "SQLITE_MAGIC_ERR..." */) == 0 {
		(*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmagic = SQLITE_MAGIC_ERROR
	} else if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), (*(*uintptr)(unsafe.Pointer(bp + 32 /* db */))+100 /* &.magic */)) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_interrupt  DB
//
// Trigger an interrupt on DB
func test_interrupt(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5388:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)), ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_interrupt(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	return TCL_OK
}

// Usage: sqlite_delete_function DB function-name
//
// Delete the user function 'function-name' from database handle DB. It
// is assumed that the user function was created as UTF8, any number of
// arguments (the way the TCL interface does it).
func delete_function(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5411:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32
	// var db uintptr at bp+32, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+17336 /* " DB function-nam..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(argv + 2*4)), -1, SQLITE_UTF8, uintptr(0), uintptr(0), uintptr(0), uintptr(0))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage: sqlite_delete_collation DB collation-name
//
// Delete the collation sequence 'collation-name' from database handle
// DB. It is assumed that the collation sequence was created as UTF8 (the
// way the TCL interface does it).
func delete_collation(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5437:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32
	// var db uintptr at bp+32, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+17336 /* " DB function-nam..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(argv + 2*4)), SQLITE_UTF8, uintptr(0), uintptr(0))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage: sqlite3_get_autocommit DB
//
// Return true if the database DB is currently in auto-commit mode.
// Return false if not.
func get_autocommit(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5462:26: */
	bp := tls.Alloc(90)
	defer tls.Free(90)

	// var zBuf [30]int8 at bp+60, 30

	// var db uintptr at bp+56, 4

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+56 /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+60 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+32, sqlite3.Xsqlite3_get_autocommit(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+60 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: sqlite3_busy_timeout DB MS
//
// Set the busy timeout.  This is more easily done using the timeout
// method of the TCL interface.  But we need a way to test the case
// where it returns SQLITE_MISUSE.
func test_busy_timeout(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5488:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var rc int32
	// var ms int32 at bp+52, 4

	// var db uintptr at bp+48, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+52 /* &ms */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_busy_timeout(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), *(*int32)(unsafe.Pointer(bp + 52 /* ms */)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_OK
}

// Usage:  tcl_variable_type VARIABLENAME
//
// Return the name of the internal representation for the
// value of the given variable.
func tcl_variable_type(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5514:26: */
	var pVar uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17354 /* "VARIABLE" */)
		return TCL_ERROR
	}
	pVar = tcl.XTcl_GetVar2Ex(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0), TCL_LEAVE_ERR_MSG)
	if pVar == uintptr(0) {
		return TCL_ERROR
	}
	if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname, -1))
	}
	return TCL_OK
}

// Usage:  sqlite3_release_memory ?N?
//
// Attempt to release memory currently held but not actually required.
// The integer N is the number of bytes we are trying to release.  The
// return value is the amount of memory actually released.
func test_release_memory(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5540:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var N int32 at bp, 4

	var amt int32
	if (objc != 1) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17363 /* "?N?" */)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &N */) != 0 {
			return TCL_ERROR
		}
	} else {
		*(*int32)(unsafe.Pointer(bp /* N */)) = -1
	}
	amt = sqlite3.Xsqlite3_release_memory(tls, *(*int32)(unsafe.Pointer(bp /* N */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, amt))
	return TCL_OK
}

// Usage:  sqlite3_db_release_memory DB
//
// Attempt to release memory currently held by database DB.  Return the
// result code (which in the current implementation is always zero).
func test_db_release_memory(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5571:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_db_release_memory(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// Usage:  sqlite3_db_cacheflush DB
//
// Attempt to flush any dirty pages to disk.
func test_db_cacheflush(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5594:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_db_cacheflush(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, rc), uintptr(0))
		return TCL_ERROR
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

// Usage:  sqlite3_system_errno DB
//
// Return the low-level system errno value.
func test_system_errno(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5622:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var iErrno int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	iErrno = sqlite3.Xsqlite3_system_errno(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iErrno))
	return TCL_OK
}

// Usage:  sqlite3_db_filename DB DBNAME
//
// Return the name of a file associated with a database.
func test_db_filename(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5645:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	// var db uintptr at bp+16, 4

	var zDbName uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15916 /* "DB DBNAME" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16 /* &db */) != 0 {
		return TCL_ERROR
	}
	zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_db_filename(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zDbName), uintptr(0)))
	return TCL_OK
}

// Usage:  sqlite3_db_readonly DB DBNAME
//
// Return 1 or 0 if DBNAME is readonly or not.  Return -1 if DBNAME does
// not exist.
func test_db_readonly(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5669:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var zDbName uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15916 /* "DB DBNAME" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_db_readonly(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDbName)))
	return TCL_OK
}

// Usage:  sqlite3_soft_heap_limit ?N?
//
// Query or set the soft heap limit for the current thread.  The
// limit is only changed if the N is present.  The previous limit
// is returned.
func test_soft_heap_limit(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5694:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var amt sqlite3_int64
	*(*Tcl_WideInt)(unsafe.Pointer(bp /* N */)) = int64(-1)
	if (objc != 1) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17363 /* "?N?" */)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &N */) != 0 {
			return TCL_ERROR
		}
	}
	amt = sqlite3.Xsqlite3_soft_heap_limit64(tls, *(*Tcl_WideInt)(unsafe.Pointer(bp /* N */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, amt))
	return TCL_OK
}

// Usage:  sqlite3_hard_heap_limit ?N?
//
// Query or set the hard heap limit for the current thread.  The
// limit is only changed if the N is present.  The previous limit
// is returned.
func test_hard_heap_limit(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5721:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var amt sqlite3_int64
	*(*Tcl_WideInt)(unsafe.Pointer(bp /* N */)) = int64(-1)
	if (objc != 1) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17363 /* "?N?" */)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &N */) != 0 {
			return TCL_ERROR
		}
	}
	amt = sqlite3.Xsqlite3_hard_heap_limit64(tls, *(*Tcl_WideInt)(unsafe.Pointer(bp /* N */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, amt))
	return TCL_OK
}

// Usage:   sqlite3_thread_cleanup
//
// Call the sqlite3_thread_cleanup API.
func test_thread_cleanup(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5746:26: */
	sqlite3.Xsqlite3_thread_cleanup(tls)
	return TCL_OK
}

// Usage:   sqlite3_pager_refcounts  DB
//
// Return a list of numbers which are the PagerRefcount for all
// pagers on each database connection.
func test_pager_refcounts(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5764:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	var i int32
	var v int32
	var a uintptr
	var pResult uintptr

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	pResult = tcl.XTcl_NewObj(tls)
	for i = 0; i < (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).FnDb; i++ {
		if (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).FaDb+uintptr(i)*16)).FpBt == uintptr(0) {
			v = -1
		} else {
			sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
			a = sqlite3.Xsqlite3PagerStats(tls, sqlite3.Xsqlite3BtreePager(tls, (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).FaDb+uintptr(i)*16)).FpBt))
			v = *(*int32)(unsafe.Pointer(a))
			sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, v))
	}
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

// tclcmd:   working_64bit_int
//
// Some TCL builds (ex: cygwin) do not support 64-bit integers.  This
// leads to a number of test failures.  The present command checks the
// TCL build to see whether or not it supports 64-bit integers.  It
// returns TRUE if it does and FALSE if not.
//
// This command is used to warn users that their TCL build is defective
// and that the errors they are seeing in the test scripts might be
// a result of their defective TCL rather than problems in SQLite.
func working_64bit_int(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5810:26: */
	var pTestObj uintptr
	var working int32 = 0

	pTestObj = tcl.XTcl_NewWideIntObj(tls, (int64(1000000) * int64(1234567890)))
	working = (libc.Bool32(libc.Xstrcmp(tls, tcl.XTcl_GetString(tls, pTestObj), ts+17367 /* "1234567890000000" */) == 0))
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pTestObj
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (libc.Bool32((working) != 0))))
	return TCL_OK
}

// tclcmd:   vfs_unlink_test
//
// This TCL command unregisters the primary VFS and then registers
// it back again.  This is used to test the ability to register a
// VFS when none are previously registered, and the ability to
// unregister the only available VFS.  Ticket #2738
func vfs_unlink_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5835:26: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	var i int32
	var pMain uintptr
	// var apVfs [20]uintptr at bp+176, 80

	// var one sqlite3_vfs at bp, 88

	// var two sqlite3_vfs at bp+88, 88

	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(0))                       // Unregister of NULL is harmless
	(*sqlite3_vfs)(unsafe.Pointer(bp /* &one */)).FzName = ts + 17384      /* "__one" */
	(*sqlite3_vfs)(unsafe.Pointer(bp + 88 /* &two */)).FzName = ts + 17390 /* "__two" */

	// Calling sqlite3_vfs_register with 2nd argument of 0 does not
	// change the default VFS
	pMain = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 0)

	sqlite3.Xsqlite3_vfs_register(tls, bp+88 /* &two */, 0)

	// We can find a VFS by its name

	// Calling sqlite_vfs_register with non-zero second parameter changes the
	// default VFS, even if the 1st parameter is an existig VFS that is
	// previously registered as the non-default.
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 1)

	sqlite3.Xsqlite3_vfs_register(tls, bp+88 /* &two */, 1)

	if pMain != 0 {
		sqlite3.Xsqlite3_vfs_register(tls, pMain, 1)

	}

	// Unlink the default VFS.  Repeat until there are no more VFSes
	// registered.
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof([20]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0)))); i++ {
		*(*uintptr)(unsafe.Pointer(bp + 176 /* &apVfs[0] */ + uintptr(i)*4)) = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		if *(*uintptr)(unsafe.Pointer(bp + 176 /* &apVfs[0] */ + uintptr(i)*4)) != 0 {

			sqlite3.Xsqlite3_vfs_unregister(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* &apVfs[0] */ + uintptr(i)*4)))

		}
	}

	// Register the main VFS as non-default (will be made default, since
	// it'll be the only one in existence).
	sqlite3.Xsqlite3_vfs_register(tls, pMain, 0)

	// Un-register the main VFS again to restore an empty VFS list
	sqlite3.Xsqlite3_vfs_unregister(tls, pMain)

	/* Relink all VFSes in reverse order. */
	for i = (int32((uint32(unsafe.Sizeof([20]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0)))) - uint32(1))); i >= 0; i-- {
		if *(*uintptr)(unsafe.Pointer(bp + 176 /* &apVfs[0] */ + uintptr(i)*4)) != 0 {
			sqlite3.Xsqlite3_vfs_register(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* &apVfs[0] */ + uintptr(i)*4)), 1)

		}
	}

	// Unregister out sample VFSes.
	sqlite3.Xsqlite3_vfs_unregister(tls, bp /* &one */)
	sqlite3.Xsqlite3_vfs_unregister(tls, bp+88 /* &two */)

	// Unregistering a VFS that is not currently registered is harmless
	sqlite3.Xsqlite3_vfs_unregister(tls, bp /* &one */)
	sqlite3.Xsqlite3_vfs_unregister(tls, bp+88 /* &two */)

	// We should be left with the original default VFS back as the
	// original

	return TCL_OK
}

// tclcmd:   vfs_initfail_test
//
// This TCL command attempts to vfs_find and vfs_register when the
// sqlite3_initialize() interface is failing.  All calls should fail.
func vfs_initfail_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5937:26: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var one sqlite3_vfs at bp, 88

	(*sqlite3_vfs)(unsafe.Pointer(bp /* &one */)).FzName = ts + 17384 /* "__one" */

	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 0)
	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 1)
	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Saved VFSes
var apVfs [20]uintptr /* test1.c:5957:20: */
var nVfs int32 = 0    /* test1.c:5958:12 */

// tclcmd:   vfs_unregister_all
//
// Unregister all VFSes.
func vfs_unregister_all(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5965:26: */
	var i int32
	for i = 0; i < (int32(uint32(unsafe.Sizeof(apVfs)) / uint32(unsafe.Sizeof(uintptr(0))))); i++ {
		apVfs[i] = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		if apVfs[i] == uintptr(0) {
			break
		}
		sqlite3.Xsqlite3_vfs_unregister(tls, apVfs[i])
	}
	nVfs = i
	return TCL_OK
}

// tclcmd:   vfs_reregister_all
//
// Restore all VFSes that were removed using vfs_unregister_all. Taking
// care to put the linked list back together in the same order as it was
// in before vfs_unregister_all was invoked.
func vfs_reregister_all(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5987:26: */
	var i int32
	for i = (nVfs - 1); i >= 0; i-- {
		sqlite3.Xsqlite3_vfs_register(tls, apVfs[i], 1)
	}
	return TCL_OK
}

// tclcmd:   file_control_test DB
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the same.
func file_control_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6007:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	*(*int32)(unsafe.Pointer(bp + 36 /* iArg */)) = 0
	// var db uintptr at bp+32, 4

	var rc int32
	_ = rc

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), uintptr(0), 0, bp+36 /* &iArg */)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+17396 /* "notadatabase" */, SQLITE_FCNTL_LOCKSTATE, bp+36 /* &iArg */)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+85 /* "main" */, -1, bp+36 /* &iArg */)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+8377 /* "temp" */, -1, bp+36 /* &iArg */)

	return TCL_OK
}

// tclcmd:   file_control_lasterrno_test DB
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the SQLITE_LAST_ERRNO verb.
func file_control_lasterrno_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6042:26: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	*(*int32)(unsafe.Pointer(bp + 68 /* iArg */)) = 0
	// var db uintptr at bp+64, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+14681 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64 /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), uintptr(0), SQLITE_FCNTL_LAST_ERRNO, bp+68 /* &iArg */)
	if rc != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 68 /* iArg */)) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+17409, /* "Unexpected non-z..." */
			tcl.XTcl_GetStringFromObj(tls, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 68 /* iArg */))), uintptr(0)), ts+4755 /* " " */, 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// tclcmd:   file_control_data_version DB DBNAME
//
// This TCL command runs the sqlite3_file_control with the
// SQLITE_FCNTL_DATA_VERSION opcode, returning the result.
func file_control_data_version(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6079:26: */
	bp := tls.Alloc(116)
	defer tls.Free(116)

	// var iVers uint32 at bp+12, 4
	// data version
	var zDb uintptr // Db name ("main", "temp" etc.)
	// var db uintptr at bp+8, 4
	// Database handle
	var rc int32 // file_control() return code
	// var zBuf [100]int8 at bp+16, 100

	if (objc != 3) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17437 /* "DB [DBNAME]" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+8 /* &db */) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	} else {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), zDb, SQLITE_FCNTL_DATA_VERSION, bp+12 /* &iVers */)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	} else {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+16 /* &zBuf[0] */, ts+17449 /* "%u" */, libc.VaList(bp, *(*uint32)(unsafe.Pointer(bp + 12 /* iVers */))))
		tcl.XTcl_SetResult(tls, interp, bp+16 /* zBuf */, uintptr(1))
		return TCL_OK
	}
	return int32(0)
}

// tclcmd:   file_control_chunksize_test DB DBNAME SIZE
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the SQLITE_GET_LOCKPROXYFILE and
// SQLITE_SET_LOCKPROXYFILE verbs.
func file_control_chunksize_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6118:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var nSize int32 at bp+4, 4
	// New chunk size
	var zDb uintptr // Db name ("main", "temp" etc.)
	// var db uintptr at bp, 4
	// Database handle
	var rc int32 // file_control() return code

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17452 /* "DB DBNAME SIZE" */)
		return TCL_ERROR
	}
	if (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0) ||
		(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4 /* &nSize */) != 0) {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if int32(*(*int8)(unsafe.Pointer(zDb))) == 0 {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb, SQLITE_FCNTL_CHUNK_SIZE, bp+4 /* &nSize */)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	}
	return TCL_OK
}

// tclcmd:   file_control_sizehint_test DB DBNAME SIZE
//
// This TCL command runs the sqlite3_file_control interface
// with SQLITE_FCNTL_SIZE_HINT
func file_control_sizehint_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6155:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var nSize Tcl_WideInt at bp+8, 8
	// Hinted size
	var zDb uintptr // Db name ("main", "temp" etc.)
	// var db uintptr at bp, 4
	// Database handle
	var rc int32 // file_control() return code

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17452 /* "DB DBNAME SIZE" */)
		return TCL_ERROR
	}
	if (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0) ||
		(tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+8 /* &nSize */) != 0) {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if int32(*(*int8)(unsafe.Pointer(zDb))) == 0 {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb, SQLITE_FCNTL_SIZE_HINT, bp+8 /* &nSize */)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	}
	return TCL_OK
}

// tclcmd:   file_control_lockproxy_test DB PWD
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the SQLITE_GET_LOCKPROXYFILE and
// SQLITE_SET_LOCKPROXYFILE verbs.
func file_control_lockproxy_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6193:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17467 /* " DB PWD" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}

	return TCL_OK
}

// tclcmd:   file_control_persist_wal DB PERSIST-FLAG
//
// This TCL command runs the sqlite3_file_control interface with
// the SQLITE_FCNTL_PERSIST_WAL opcode.
func file_control_persist_wal(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6364:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	// var db uintptr at bp+64, 4

	var rc int32
	// var bPersist int32 at bp+68, 4

	// var z [100]int8 at bp+72, 100

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17475 /* " DB FLAG" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64 /* &db */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+68 /* &bPersist */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), uintptr(0), SQLITE_FCNTL_PERSIST_WAL, bp+68 /* &bPersist */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72 /* &z[0] */, ts+17484 /* "%d %d" */, libc.VaList(bp+32, rc, *(*int32)(unsafe.Pointer(bp + 68 /* bPersist */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+72 /* &z[0] */, uintptr(0)))
	return TCL_OK
}

// tclcmd:   file_control_powersafe_overwrite DB PSOW-FLAG
//
// This TCL command runs the sqlite3_file_control interface with
// the SQLITE_FCNTL_POWERSAFE_OVERWRITE opcode.
func file_control_powersafe_overwrite(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6396:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	// var db uintptr at bp+64, 4

	var rc int32
	// var b int32 at bp+68, 4

	// var z [100]int8 at bp+72, 100

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17475 /* " DB FLAG" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64 /* &db */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+68 /* &b */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), uintptr(0), SQLITE_FCNTL_POWERSAFE_OVERWRITE, bp+68 /* &b */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72 /* &z[0] */, ts+17484 /* "%d %d" */, libc.VaList(bp+32, rc, *(*int32)(unsafe.Pointer(bp + 68 /* b */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+72 /* &z[0] */, uintptr(0)))
	return TCL_OK
}

// tclcmd:   file_control_vfsname DB ?AUXDB?
//
// Return a string that describes the stack of VFSes.
func file_control_vfsname(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6428:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+48, 4

	var zDbName uintptr = ts + 85 /* "main" */
	*(*uintptr)(unsafe.Pointer(bp + 52 /* zVfsName */)) = uintptr(0)

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17490 /* " DB ?AUXDB?" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	}
	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zDbName, SQLITE_FCNTL_VFSNAME, bp+52 /* &zVfsName */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 52 /* zVfsName */)), uintptr(0)))
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 52 /* zVfsName */)))
	return TCL_OK
}

// tclcmd:   file_control_reservebytes DB N
func file_control_reservebytes(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6458:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 4

	var zDbName uintptr = ts + 85 /* "main" */
	*(*int32)(unsafe.Pointer(bp + 4 /* n */)) = 0
	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17502 /* "DB N" */)
		return TCL_ERROR
	}
	if (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0) ||
		(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &n */) != 0) {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDbName, SQLITE_FCNTL_RESERVE_BYTES, bp+4 /* &n */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return TCL_OK
}

// tclcmd:   file_control_tempfilename DB ?AUXDB?
//
// Return a string that is a temporary filename
func file_control_tempfilename(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6490:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+48, 4

	var zDbName uintptr = ts + 85 /* "main" */
	*(*uintptr)(unsafe.Pointer(bp + 52 /* zTName */)) = uintptr(0)

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17490 /* " DB ?AUXDB?" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48 /* &db */) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	}
	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zDbName, SQLITE_FCNTL_TEMPFILENAME, bp+52 /* &zTName */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 52 /* zTName */)), uintptr(0)))
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 52 /* zTName */)))
	return TCL_OK
}

// tclcmd:   file_control_external_reader DB ?AUXDB?
//
// Return a string that is a temporary filename
func file_control_external_reader(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6522:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 4

	var zName uintptr = ts + 85 /* "main" */
	*(*int32)(unsafe.Pointer(bp + 36 /* iRes */)) = 0
	var rc int32 = SQLITE_OK

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17490 /* " DB ?AUXDB?" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), zName, SQLITE_FCNTL_EXTERNAL_READER, bp+36 /* &iRes */)
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 36 /* iRes */))))
	return TCL_OK
}

// tclcmd:   sqlite3_vfs_list
//
//   Return a tcl list containing the names of all registered vfs's.
func vfs_list(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6559:26: */
	var pVfs uintptr
	var pRet uintptr = tcl.XTcl_NewObj(tls)
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}
	for pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)); pVfs != 0; pVfs = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpNext {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName, -1))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

// tclcmd:   sqlite3_limit DB ID VALUE
//
// This TCL command runs the sqlite3_limit interface and
// verifies correct operation of the same.
func test_limit(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6584:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var db uintptr at bp+56, 4

	var rc int32
	var i int32
	var id int32 = 0
	// var val int32 at bp+60, 4

	var zId uintptr

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17507 /* " DB ID VALUE" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+56 /* &db */) != 0 {
		return TCL_ERROR
	}
	zId = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aId)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fid    int32
	}{}))); i++ {
		if libc.Xstrcmp(tls, zId, aId[i].FzName) == 0 {
			id = aId[i].Fid
			break
		}
	}
	if uint32(i) >= (uint32(unsafe.Sizeof(aId)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fid    int32
	}{}))) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+17520 /* "unknown limit ty..." */, zId, uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+60 /* &val */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), id, *(*int32)(unsafe.Pointer(bp + 60 /* val */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

var aId = [14]struct {
	FzName uintptr
	Fid    int32
}{
	{FzName: ts + 17541 /* "SQLITE_LIMIT_LEN..." */},
	{FzName: ts + 17561 /* "SQLITE_LIMIT_SQL..." */, Fid: SQLITE_LIMIT_SQL_LENGTH},
	{FzName: ts + 17585 /* "SQLITE_LIMIT_COL..." */, Fid: SQLITE_LIMIT_COLUMN},
	{FzName: ts + 17605 /* "SQLITE_LIMIT_EXP..." */, Fid: SQLITE_LIMIT_EXPR_DEPTH},
	{FzName: ts + 17629 /* "SQLITE_LIMIT_COM..." */, Fid: SQLITE_LIMIT_COMPOUND_SELECT},
	{FzName: ts + 17658 /* "SQLITE_LIMIT_VDB..." */, Fid: SQLITE_LIMIT_VDBE_OP},
	{FzName: ts + 17679 /* "SQLITE_LIMIT_FUN..." */, Fid: SQLITE_LIMIT_FUNCTION_ARG},
	{FzName: ts + 17705 /* "SQLITE_LIMIT_ATT..." */, Fid: SQLITE_LIMIT_ATTACHED},
	{FzName: ts + 17727 /* "SQLITE_LIMIT_LIK..." */, Fid: SQLITE_LIMIT_LIKE_PATTERN_LENGTH},
	{FzName: ts + 17760 /* "SQLITE_LIMIT_VAR..." */, Fid: SQLITE_LIMIT_VARIABLE_NUMBER},
	{FzName: ts + 17789 /* "SQLITE_LIMIT_TRI..." */, Fid: SQLITE_LIMIT_TRIGGER_DEPTH},
	{FzName: ts + 17816 /* "SQLITE_LIMIT_WOR..." */, Fid: SQLITE_LIMIT_WORKER_THREADS},

	// Out of range test cases
	{FzName: ts + 17844 /* "SQLITE_LIMIT_TOO..." */, Fid: -1},
	{FzName: ts + 17866 /* "SQLITE_LIMIT_TOO..." */, Fid: (SQLITE_LIMIT_WORKER_THREADS + 1)},
} /* test1.c:6595:5 */

// tclcmd:  save_prng_state
//
// Save the state of the pseudo-random number generator.
// At the same time, verify that sqlite3_test_control works even when
// called with an out-of-range opcode.
func save_prng_state(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6647:26: */
	var rc int32 = sqlite3.Xsqlite3_test_control(tls, 9999, 0)
	_ = rc

	rc = sqlite3.Xsqlite3_test_control(tls, -1, 0)

	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PRNG_SAVE, 0)
	return TCL_OK
}

// tclcmd:  restore_prng_state
func restore_prng_state(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6663:26: */
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PRNG_RESTORE, 0)
	return TCL_OK
}

// tclcmd:  reset_prng_state
func reset_prng_state(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6675:26: */
	sqlite3.Xsqlite3_randomness(tls, 0, uintptr(0))
	return TCL_OK
}

// tclcmd:  prng_seed INT ?DB?
//
// Set up the SQLITE_TESTCTRL_PRNG_SEED pragma with parameter INT and DB.
// INT is an integer.  DB is a database connection, or a NULL pointer if
// omitted.
//
// When INT!=0 and DB!=0, set the PRNG seed to the value of the schema
// cookie for DB, or to INT if the schema cookie happens to be zero.
//
// When INT!=0 and DB==0, set the PRNG seed to just INT.
//
// If INT==0 and DB==0 then use the default procedure of calling the
// xRandomness method on the default VFS to get the PRNG seed.
func prng_seed(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6699:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*int32)(unsafe.Pointer(bp + 16 /* i */)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 20 /* db */)) = uintptr(0)
	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17886 /* "SEED ?DB?" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16 /* &i */) != 0 {
		return TCL_ERROR
	}
	if (objc == 3) && (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+20 /* &db */) != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PRNG_SEED, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 16 /* i */)), *(*uintptr)(unsafe.Pointer(bp + 20 /* db */))))
	return TCL_OK
}

// tclcmd:  extra_schema_checks BOOLEAN
//
// Enable or disable schema checks when parsing the sqlite_schema file.
// This is always enabled in production, but it is sometimes useful to
// disable the checks in order to make some internal error states reachable
// for testing.
func extra_schema_checks(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6727:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*int32)(unsafe.Pointer(bp + 8 /* i */)) = 0
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17896 /* "BOOLEAN" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8 /* &i */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* i */))))
	return TCL_OK
}

// tclcmd:  database_may_be_corrupt
//
// Indicate that database files might be corrupt. In other words, set the normal
// state of operation.
func database_may_be_corrupt(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6749:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_NEVER_CORRUPT, libc.VaList(bp, 0))
	return TCL_OK
}

// tclcmd:  database_never_corrupt
//
// Indicate that database files are always well-formed. This enables
// extra assert() statements that test conditions that are always true
// for well-formed databases.
func database_never_corrupt(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6765:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_NEVER_CORRUPT, libc.VaList(bp, 1))
	return TCL_OK
}

// tclcmd:  pcache_stats
func test_pcache_stats(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6778:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var nMin int32 at bp+8, 4

	// var nMax int32 at bp+4, 4

	// var nCurrent int32 at bp, 4

	// var nRecyclable int32 at bp+12, 4

	var pRet uintptr

	sqlite3.Xsqlite3PcacheStats(tls, bp /* &nCurrent */, bp+4 /* &nMax */, bp+8 /* &nMin */, bp+12 /* &nRecyclable */)

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+17904 /* "current" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp /* nCurrent */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+17912 /* "max" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 4 /* nMax */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+17916 /* "min" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 8 /* nMin */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+17920 /* "recyclable" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12 /* nRecyclable */))))

	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return TCL_OK
}

func test_unlock_notify_cb(tls *libc.TLS, aArg uintptr, nArg int32) { /* test1.c:6808:13: */
	var ii int32
	for ii = 0; ii < nArg; ii++ {
		tcl.XTcl_EvalEx(tls, *(*uintptr)(unsafe.Pointer(aArg + uintptr(ii)*4)), ts+13372 /* "unlock_notify" */, -1, TCL_EVAL_GLOBAL)
	}
}

// tclcmd:  sqlite3_unlock_notify db
func test_unlock_notify(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6820:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_unlock_notify(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32)
	}{test_unlock_notify_cb})), interp)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// tclcmd:  sqlite3_wal_checkpoint db ?NAME?
func test_wal_checkpoint(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6846:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zDb uintptr = uintptr(0)
	// var db uintptr at bp, 4

	var rc int32

	if (objc != 3) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17931 /* "DB ?NAME?" */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	}
	rc = sqlite3.Xsqlite3_wal_checkpoint(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// tclcmd:  sqlite3_wal_checkpoint_v2 db MODE ?NAME?
//
// This command calls the wal_checkpoint_v2() function with the specified
// mode argument (passive, full or restart). If present, the database name
// NAME is passed as the second argument to wal_checkpoint_v2(). If it the
// NAME argument is not present, a NULL pointer is passed instead.
//
// If wal_checkpoint_v2() returns any value other than SQLITE_BUSY or
// SQLITE_OK, then this command returns TCL_ERROR. The Tcl result is set
// to the error message obtained from sqlite3_errmsg().
//
// Otherwise, this command returns a list of three integers. The first integer
// is 1 if SQLITE_BUSY was returned, or 0 otherwise. The following two integers
// are the values returned via the output parameters by wal_checkpoint_v2() -
// the number of frames in the log and the number of frames in the log
// that have been checkpointed.
func test_wal_checkpoint_v2(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6890:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var zDb uintptr = uintptr(0)
	// var db uintptr at bp+32, 4

	var rc int32
	// var eMode int32 at bp+36, 4

	*(*int32)(unsafe.Pointer(bp + 60 /* nLog */)) = -555
	*(*int32)(unsafe.Pointer(bp + 64 /* nCkpt */)) = -555
	var pRet uintptr

	*(*[5]uintptr)(unsafe.Pointer(bp + 40 /* aMode */)) = [5]uintptr{ts + 17941 /* "passive" */, ts + 17949 /* "full" */, ts + 17954 /* "restart" */, ts + 17962 /* "truncate" */, uintptr(0)}

	if (objc != 3) && (objc != 4) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17971 /* "DB MODE ?NAME?" */)
		return TCL_ERROR
	}

	if objc == 4 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	}
	if (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0) || ((TCL_OK != tcl.XTcl_GetIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &eMode */)) &&
		(TCL_OK != tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+40 /* &aMode[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+17986 /* "mode" */, 0, bp+36 /* &eMode */))) {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_wal_checkpoint_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), zDb, *(*int32)(unsafe.Pointer(bp + 36 /* eMode */)), bp+60 /* &nLog */, bp+64 /* &nCkpt */)
	if (rc != SQLITE_OK) && (rc != SQLITE_BUSY) {
		var zErrCode uintptr = sqlite3.Xsqlite3ErrName(tls, rc)
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, zErrCode, ts+10280 /* " - " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */))), 0))
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, func() int32 {
		if rc == SQLITE_BUSY {
			return 1
		}
		return 0
	}()))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 60 /* nLog */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 64 /* nCkpt */))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return TCL_OK
}

// tclcmd:  sqlite3_wal_autocheckpoint db VALUE
func test_wal_autocheckpoint(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6946:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 4

	var rc int32
	// var iVal int32 at bp+4, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17991 /* "DB VALUE" */)
		return TCL_ERROR
	}

	if (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0) ||
		(tcl.XTcl_GetIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &iVal */) != 0) {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_wal_autocheckpoint(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*int32)(unsafe.Pointer(bp + 4 /* iVal */)))
	tcl.XTcl_ResetResult(tls, interp)
	if rc != SQLITE_OK {
		var zErrCode uintptr = sqlite3.Xsqlite3ErrName(tls, rc)
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErrCode, -1))
		return TCL_ERROR
	}

	return TCL_OK
}

// tclcmd:  test_sqlite3_log ?SCRIPT?
type LogCallback = struct {
	FpInterp uintptr
	FpObj    uintptr
} /* test1.c:6983:8 */

// tclcmd:  test_sqlite3_log ?SCRIPT?
var logcallback = LogCallback{} /* test1.c:6986:3 */

func xLogcallback(tls *libc.TLS, unused uintptr, err int32, zMsg uintptr) { /* test1.c:6987:13: */
	var pNew uintptr = tcl.XTcl_DuplicateObj(tls, logcallback.FpObj)
	(*Tcl_Obj)(unsafe.Pointer(pNew)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls,
		uintptr(0), pNew, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, err), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pNew, tcl.XTcl_NewStringObj(tls, zMsg, -1))
	tcl.XTcl_EvalObjEx(tls, logcallback.FpInterp, pNew, (TCL_EVAL_GLOBAL | TCL_EVAL_DIRECT))
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pNew
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func test_sqlite3_log(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6997:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if objc > 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+11583 /* "SCRIPT" */)
		return TCL_ERROR
	}
	if logcallback.FpObj != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = logcallback.FpObj
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		logcallback.FpObj = uintptr(0)
		logcallback.FpInterp = uintptr(0)
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOG, libc.VaList(bp, uintptr(0), uintptr(0)))
	}
	if objc > 1 {
		logcallback.FpObj = *(*uintptr)(unsafe.Pointer(objv + 1*4))
		(*Tcl_Obj)(unsafe.Pointer(logcallback.FpObj)).FrefCount++
		logcallback.FpInterp = interp
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOG, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{xLogcallback})), uintptr(0)))
	}
	return TCL_OK
}

//     tcl_objproc COMMANDNAME ARGS...
//
// Run a TCL command using its objProc interface.  Throw an error if
// the command has no objProc interface.
func runAsObjProc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7028:26: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var cmdInfo Tcl_CmdInfo at bp+48, 32

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18000 /* "COMMAND ..." */)
		return TCL_ERROR
	}
	if !(tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48 /* &cmdInfo */) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14539, /* "command not foun..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	if (*Tcl_CmdInfo)(unsafe.Pointer(bp+48 /* &cmdInfo */)).FobjProc == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+18012, /* "command has no o..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	return (*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer((bp + 48 /* &cmdInfo */ + 4 /* &.objProc */))))(tls, (*Tcl_CmdInfo)(unsafe.Pointer(bp+48 /* &cmdInfo */)).FobjClientData, interp, (objc - 1), (objv + uintptr(1)*4))
}

// WARNING: The following function, printExplainQueryPlan() is an exact
// copy of example code from eqp.in (eqp.html). If this code is modified,
// then the documentation copy needs to be modified as well.
// Argument pStmt is a prepared SQL statement. This function compiles
// an EXPLAIN QUERY PLAN command to report on the prepared statement,
// and prints the report to stdout using printf().
func printExplainQueryPlan(tls *libc.TLS, pStmt uintptr) int32 { /* test1.c:7063:5: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var zSql uintptr     // Input SQL
	var zExplain uintptr // SQL with EXPLAIN QUERY PLAN prepended
	// var pExplain uintptr at bp+40, 4
	// Compiled EXPLAIN QUERY PLAN command
	var rc int32 // Return code from sqlite3_prepare_v2()

	zSql = sqlite3.Xsqlite3_sql(tls, pStmt)
	if zSql == uintptr(0) {
		return SQLITE_ERROR
	}

	zExplain = sqlite3.Xsqlite3_mprintf(tls, ts+235 /* "EXPLAIN QUERY PL..." */, libc.VaList(bp, zSql))
	if zExplain == uintptr(0) {
		return SQLITE_NOMEM
	}

	rc = sqlite3.Xsqlite3_prepare_v2(tls, sqlite3.Xsqlite3_db_handle(tls, pStmt), zExplain, -1, bp+40 /* &pExplain */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zExplain)
	if rc != SQLITE_OK {
		return rc
	}

	for SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */))) {
		var iSelectid int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 0)
		var iOrder int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 1)
		var iFrom int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 2)
		var zDetail uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 3)

		libc.Xprintf(tls, ts+18037 /* "%d %d %d %s\n" */, libc.VaList(bp+8, iSelectid, iOrder, iFrom, zDetail))
	}

	return sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)))
}

func test_print_eqp(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7091:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	// var pStmt uintptr at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16637 /* "STMT" */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &pStmt */) != 0 {
		return TCL_ERROR
	}
	rc = printExplainQueryPlan(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
	// This is needed on Windows so that a test case using this
	// function can open a read pipe and get the output of
	// printExplainQueryPlan() immediately.
	libc.Xfflush(tls, libc.Xstdout)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// sqlite3_test_control VERB ARGS...
func test_test_control(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7119:26: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	*(*[4]Verb)(unsafe.Pointer(bp + 64 /* aVerb */)) = [4]Verb{
		{FzName: ts + 18050 /* "SQLITE_TESTCTRL_..." */, Fi: SQLITE_TESTCTRL_LOCALTIME_FAULT},
		{FzName: ts + 18082 /* "SQLITE_TESTCTRL_..." */, Fi: SQLITE_TESTCTRL_SORTER_MMAP},
		{FzName: ts + 18110 /* "SQLITE_TESTCTRL_..." */, Fi: SQLITE_TESTCTRL_IMPOSTER},
		{FzName: ts + 18135 /* "SQLITE_TESTCTRL_..." */, Fi: SQLITE_TESTCTRL_INTERNAL_FUNCTIONS},
	}
	// var iVerb int32 at bp+96, 4

	var iFlag int32
	var rc int32

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18170 /* "VERB ARGS..." */)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+64 /* &aVerb[0] */, int32(unsafe.Sizeof(Verb{})), ts+18183 /* "VERB" */, 0, bp+96 /* &iVerb */)
	if rc != TCL_OK {
		return rc
	}

	iFlag = (*Verb)(unsafe.Pointer(bp + 64 /* &aVerb */ + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* iVerb */)))*8)).Fi
	switch iFlag {
	case SQLITE_TESTCTRL_INTERNAL_FUNCTIONS:
		{
			*(*uintptr)(unsafe.Pointer(bp + 100 /* db */)) = uintptr(0)
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+1911 /* "DB" */)
				return TCL_ERROR
			}
			if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+100 /* &db */) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(bp + 100 /* db */))))
			break

		}
	case SQLITE_TESTCTRL_LOCALTIME_FAULT:
		{
			// var val int32 at bp+104, 4

			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18188 /* "ONOFF" */)
				return TCL_ERROR
			}
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+104 /* &val */) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, iFlag, libc.VaList(bp+8, *(*int32)(unsafe.Pointer(bp + 104 /* val */))))
			break

		}

	case SQLITE_TESTCTRL_SORTER_MMAP:
		{
			// var val int32 at bp+112, 4

			// var db uintptr at bp+108, 4

			if objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18194 /* "DB LIMIT" */)
				return TCL_ERROR
			}
			if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+108 /* &db */) != 0 {
				return TCL_ERROR
			}
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+112 /* &val */) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_SORTER_MMAP, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(bp + 108 /* db */)), *(*int32)(unsafe.Pointer(bp + 112 /* val */))))
			break

		}

	case SQLITE_TESTCTRL_IMPOSTER:
		{
			// var onOff int32 at bp+120, 4

			// var tnum int32 at bp+124, 4

			var zDbName uintptr
			// var db uintptr at bp+116, 4

			if objc != 6 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18203 /* "DB dbName onOff ..." */)
				return TCL_ERROR
			}
			if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+116 /* &db */) != 0 {
				return TCL_ERROR
			}
			zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+120 /* &onOff */) != 0 {
				return TCL_ERROR
			}
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*4)), bp+124 /* &tnum */) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_IMPOSTER, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 116 /* db */)), zDbName, *(*int32)(unsafe.Pointer(bp + 120 /* onOff */)), *(*int32)(unsafe.Pointer(bp + 124 /* tnum */))))
			break

		}
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

type Verb = struct {
	FzName uintptr
	Fi     int32
} /* test1.c:7125:3 */

// Value to indicate that there is no limit.

// We can represent all limits.

// Type for resource quantity measurement.
type rlim_t = uint64   /* resource.h:133:20 */
type rlim64_t = uint64 /* resource.h:136:20 */

type rlimit = struct {
	Frlim_cur rlim_t
	Frlim_max rlim_t
} /* resource.h:139:1 */

type rlimit64 = struct {
	Frlim_cur rlim64_t
	Frlim_max rlim64_t
} /* resource.h:148:1 */

// Define struct rusage.
//    Copyright (C) 1994-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Structure which says how much of each resource has been used.

// The purpose of all the unions is to have the kernel-compatible layout
//    while keeping the API type as 'long int', and among machines where
//    __syscall_slong_t is not 'long int', this only does the right thing
//    for little-endian ones, like x32.
type rusage = struct {
	Fru_utime struct {
		Ftv_sec  int32
		Ftv_usec int32
	}
	Fru_stime struct {
		Ftv_sec  int32
		Ftv_usec int32
	}
	F__16 struct{ Fru_maxrss int32 }
	F__20 struct{ Fru_ixrss int32 }
	F__24 struct{ Fru_idrss int32 }
	F__28 struct{ Fru_isrss int32 }
	F__32 struct{ Fru_minflt int32 }
	F__36 struct{ Fru_majflt int32 }
	F__40 struct{ Fru_nswap int32 }
	F__44 struct{ Fru_inblock int32 }
	F__48 struct{ Fru_oublock int32 }
	F__52 struct{ Fru_msgsnd int32 }
	F__56 struct{ Fru_msgrcv int32 }
	F__60 struct{ Fru_nsignals int32 }
	F__64 struct{ Fru_nvcsw int32 }
	F__68 struct{ Fru_nivcsw int32 }
} /* struct_rusage.h:31:1 */

func test_getrusage(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7209:26: */
	bp := tls.Alloc(1144)
	defer tls.Free(1144)

	// var buf [1024]int8 at bp+120, 1024

	// var r rusage at bp+48, 72

	libc.Xmemset(tls, bp+48 /* &r */, 0, uint32(unsafe.Sizeof(rusage{})))
	libc.Xgetrusage(tls, RUSAGE_SELF, bp+48 /* &r */)

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1024]int8{})), bp+120, /* &buf[0] */
		ts+18224, /* "ru_utime=%d.%06d..." */
		libc.VaList(bp, int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_utime.Ftv_sec), int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_utime.Ftv_usec),
			int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_stime.Ftv_sec), int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_stime.Ftv_usec),
			int32(*(*int32)(unsafe.Pointer(bp + 48 /* &r */ + 32 /* &.ru_minflt */))), int32(*(*int32)(unsafe.Pointer(bp + 48 /* &r */ + 36 /* &.ru_majflt */)))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+120 /* &buf[0] */, -1))
	return TCL_OK
}

//      optimization_control DB OPT BOOLEAN
//
// Enable or disable query optimizations using the sqlite3_test_control()
// interface.  Disable if BOOLEAN is false and enable if BOOLEAN is true.
// OPT is the name of the optimization to be disabled.
func optimization_control(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7489:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	// var db uintptr at bp+56, 4

	var zOpt uintptr
	// var onoff int32 at bp+60, 4

	var mask int32 = 0

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18284 /* "DB OPT BOOLEAN" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+56 /* &db */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+60 /* &onoff */) != 0 {
		return TCL_ERROR
	}
	zOpt = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aOpt)) / uint32(unsafe.Sizeof(struct {
		FzOptName uintptr
		Fmask     int32
	}{}))); i++ {
		if libc.Xstrcmp(tls, zOpt, aOpt[i].FzOptName) == 0 {
			mask = aOpt[i].Fmask
			break
		}
	}
	if *(*int32)(unsafe.Pointer(bp + 60 /* onoff */)) != 0 {
		mask = ^mask
	}
	if uint32(i) >= (uint32(unsafe.Sizeof(aOpt)) / uint32(unsafe.Sizeof(struct {
		FzOptName uintptr
		Fmask     int32
	}{}))) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+18299, /* "unknown optimiza..." */
			uintptr(0)))
		for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aOpt)) / uint32(unsafe.Sizeof(struct {
			FzOptName uintptr
			Fmask     int32
		}{}))); i++ {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+4755 /* " " */, aOpt[i].FzOptName, uintptr(0)))
		}
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_OPTIMIZATIONS, libc.VaList(bp+40, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), mask))
	return TCL_OK
}

var aOpt = [13]struct {
	FzOptName uintptr
	Fmask     int32
}{
	{FzOptName: ts + 18340 /* "all" */, Fmask: libc.Int32FromUint32(SQLITE_AllOpts)},
	{FzOptName: ts + 18344 /* "none" */},
	{FzOptName: ts + 18349 /* "query-flattener" */, Fmask: SQLITE_QueryFlattener},
	{FzOptName: ts + 18365 /* "groupby-order" */, Fmask: SQLITE_GroupByOrder},
	{FzOptName: ts + 18379 /* "factor-constants" */, Fmask: SQLITE_FactorOutConst},
	{FzOptName: ts + 18396 /* "distinct-opt" */, Fmask: SQLITE_DistinctOpt},
	{FzOptName: ts + 18409 /* "cover-idx-scan" */, Fmask: SQLITE_CoverIdxScan},
	{FzOptName: ts + 18424 /* "order-by-idx-joi..." */, Fmask: SQLITE_OrderByIdxJoin},
	{FzOptName: ts + 18442 /* "transitive" */, Fmask: SQLITE_Transitive},
	{FzOptName: ts + 18453 /* "omit-noop-join" */, Fmask: SQLITE_OmitNoopJoin},
	{FzOptName: ts + 18468 /* "stat4" */, Fmask: SQLITE_Stat4},
	{FzOptName: ts + 18474 /* "skip-scan" */, Fmask: SQLITE_SkipScan},
	{FzOptName: ts + 18484 /* "push-down" */, Fmask: SQLITE_PushDown},
} /* test1.c:7503:5 */

//     load_static_extension DB NAME ...
//
// Load one or more statically linked extensions.
func tclLoadStaticExtensionCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7550:26: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	// var db uintptr at bp+64, 4

	var zName uintptr
	var i int32
	var j int32
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 68 /* zErrMsg */)) = uintptr(0)
	if objc < 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18494 /* "DB NAME ..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64 /* &db */) != 0 {
		return TCL_ERROR
	}
	for j = 2; j < objc; j++ {
		zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(j)*4)))
		for i = 0; i < (int32(uint32(unsafe.Sizeof(aExtension)) / uint32(unsafe.Sizeof(struct {
			FzExtName uintptr
			FpInit    uintptr
		}{})))); i++ {
			if libc.Xstrcmp(tls, zName, aExtension[i].FzExtName) == 0 {
				break
			}
		}
		if i >= (int32(uint32(unsafe.Sizeof(aExtension)) / uint32(unsafe.Sizeof(struct {
			FzExtName uintptr
			FpInit    uintptr
		}{})))) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+18506 /* "no such extensio..." */, zName, uintptr(0)))
			return TCL_ERROR
		}
		if aExtension[i].FpInit != 0 {
			rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aExtension)) + uintptr(i)*8 + 4 /* &.pInit */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), bp+68 /* &zErrMsg */, uintptr(0))
		} else {
			rc = SQLITE_OK
		}
		if ((rc != SQLITE_OK) && (rc != (SQLITE_OK | (int32(1) << 8)))) || (*(*uintptr)(unsafe.Pointer(bp + 68 /* zErrMsg */)) != 0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+18526 /* "initialization o..." */, zName, ts+18545 /* " failed: " */, *(*uintptr)(unsafe.Pointer(bp + 68 /* zErrMsg */)),
				uintptr(0)))
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 68 /* zErrMsg */)))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

var aExtension = [22]struct {
	FzExtName uintptr
	FpInit    uintptr
}{
	{FzExtName: ts + 18555 /* "amatch" */, FpInit: 0},
	{FzExtName: ts + 18562 /* "appendvfs" */, FpInit: 0},
	{FzExtName: ts + 3921 /* "carray" */, FpInit: 0},
	{FzExtName: ts + 18572 /* "closure" */, FpInit: 0},
	{FzExtName: ts + 4676 /* "csv" */, FpInit: 0},
	{FzExtName: ts + 4699 /* "decimal" */, FpInit: 0},
	{FzExtName: ts + 4757 /* "eval" */, FpInit: 0},
	{FzExtName: ts + 4835 /* "explain" */, FpInit: 0},
	{FzExtName: ts + 18580 /* "fileio" */, FpInit: 0},
	{FzExtName: ts + 5344 /* "fuzzer" */, FpInit: 0},
	{FzExtName: ts + 5368 /* "ieee754" */, FpInit: 0},
	{FzExtName: ts + 18587 /* "nextchar" */, FpInit: 0},
	{FzExtName: ts + 5948 /* "percentile" */, FpInit: 0},
	{FzExtName: ts + 6023 /* "prefixes" */, FpInit: 0},
	{FzExtName: ts + 6335 /* "regexp" */, FpInit: 0},
	{FzExtName: ts + 6350 /* "remember" */, FpInit: 0},
	{FzExtName: ts + 18596 /* "series" */, FpInit: 0},
	{FzExtName: ts + 18603 /* "spellfix" */, FpInit: 0},
	{FzExtName: ts + 18612 /* "totype" */, FpInit: 0},
	{FzExtName: ts + 8367 /* "unionvtab" */, FpInit: 0},
	{FzExtName: ts + 8909 /* "wholenumber" */, FpInit: 0},
	{FzExtName: ts + 9012 /* "zipfile" */, FpInit: 0},
} /* test1.c:7585:5 */

//     sorter_test_fakeheap BOOL
//
func sorter_test_fakeheap(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7650:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var bArg int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18619 /* "BOOL" */)
		return TCL_ERROR
	}

	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &bArg */) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp /* bArg */)) != 0 {
		if sqlite3.Xsqlite3Config.FpHeap == uintptr(0) {
			sqlite3.Xsqlite3Config.FpHeap = libc.UintptrFromInt32(-1)
		}
	} else {
		if sqlite3.Xsqlite3Config.FpHeap == (libc.UintptrFromInt32(-1)) {
			sqlite3.Xsqlite3Config.FpHeap = uintptr(0)
		}
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

//     sorter_test_sort4_helper DB SQL1 NSTEP SQL2
//
// Compile SQL statement $SQL1 and step it $NSTEP times. For each row,
// check that the leftmost and rightmost columns returned are both integers,
// and that both contain the same value.
//
// Then execute statement $SQL2. Check that the statement returns the same
// set of integers in the same order as in the previous step (using $SQL1).
func sorter_test_sort4_helper(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7690:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var zSql1 uintptr
	var zSql2 uintptr
	// var nStep int32 at bp+60, 4

	var iStep int32
	var iCksum1 uint32
	var iCksum2 uint32
	var rc int32
	var iB int32
	// var db uintptr at bp+56, 4

	// var pStmt uintptr at bp+64, 4

	var a int32
	var a1 int32
	iCksum1 = uint32(0)
	iCksum2 = uint32(0)

	if !(objc != 5) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18624 /* "DB SQL1 NSTEP SQ..." */)
	return TCL_ERROR
__1:
	;

	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+56 /* &db */) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	zSql1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+60 /* &nStep */) != 0) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	zSql2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))

	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), zSql1, -1, bp+64 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __4
	}
	goto sql_error
__4:
	;

	iB = (sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */))) - 1)
	iStep = 0
__5:
	if !((iStep < *(*int32)(unsafe.Pointer(bp + 60 /* nStep */))) && (SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */))))) {
		goto __7
	}
	a = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), 0)
	if !(a != sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), iB)) {
		goto __8
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+18643 /* "data error: (a!=..." */, 0))
	return TCL_ERROR
__8:
	;

	iCksum1 = iCksum1 + ((iCksum1 << 3) + uint32(a))
	goto __6
__6:
	iStep++
	goto __5
	goto __7
__7:
	;
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)))
	if !(rc != SQLITE_OK) {
		goto __9
	}
	goto sql_error
__9:
	;

	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), zSql2, -1, bp+64 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __10
	}
	goto sql_error
__10:
	;
	iStep = 0
__11:
	if !(SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)))) {
		goto __13
	}
	a1 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), 0)
	iCksum2 = iCksum2 + ((iCksum2 << 3) + uint32(a1))
	goto __12
__12:
	iStep++
	goto __11
	goto __13
__13:
	;
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)))
	if !(rc != SQLITE_OK) {
		goto __14
	}
	goto sql_error
__14:
	;

	if !(iCksum1 != iCksum2) {
		goto __15
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+18662 /* "checksum mismatc..." */, 0))
	return TCL_ERROR
__15:
	;

	return TCL_OK
sql_error:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+18680 /* "sql error: " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */))), 0))
	return TCL_ERROR
}

// tclcmd: bad_behavior TYPE
//
// Do some things that should trigger a valgrind or -fsanitize=undefined
// warning.  This is used to verify that errors and warnings output by those
// tools are detected by the test scripts.
//
//       TYPE       BEHAVIOR
//       1          Overflow a signed integer
//       2          Jump based on an uninitialized variable
//       3          Read after free
//       4          Panic
func test_bad_behavior(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7893:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var iType int32 at bp, 4

	var xyz int32
	var i int32 = *(*int32)(unsafe.Pointer(clientData))
	var j int32
	// var w [10]int32 at bp+4, 40

	var a uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18692 /* "TYPE" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &iType */) != 0 {
		return TCL_ERROR
	}
	switch *(*int32)(unsafe.Pointer(bp /* iType */)) {
	case 1:
		{
			xyz = (0x7fffff00 - i)
			xyz = xyz + (0x100)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, xyz))
			break

		}
	case 2:
		{
			*(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + 1*4)) = 5
			if *(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + uintptr(i)*4)) > 0 {
				*(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + 1*4))++
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + 1*4))))
			break

		}
	case 3:
		{
			a = libc.Xmalloc(tls, (uint32(unsafe.Sizeof(int32(0))) * uint32(10)))
			for j = 0; j < 10; j++ {
				*(*int32)(unsafe.Pointer(a + uintptr(j)*4)) = j
			}
			libc.Xfree(tls, a)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
			break

		}
	case 4:
		{
			tcl.XTcl_Panic(tls, ts+18697 /* "Deliberate panic" */, 0)
			break

		}
	}
	return TCL_OK
}

// tclcmd:   register_dbstat_vtab DB
//
// Cause the dbstat virtual table to be available on the connection DB
func test_register_dbstat_vtab(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7943:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zDb uintptr
	// var cmdInfo Tcl_CmdInfo at bp, 32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}

	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp /* &cmdInfo */) != 0 {
		var db uintptr = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp /* &cmdInfo */)).FobjClientData)).Fdb
		sqlite3.Xsqlite3DbstatRegister(tls, db)
	}
	return TCL_OK
}

// tclcmd:   sqlite3_db_config DB SETTING VALUE
//
// Invoke sqlite3_db_config() for one of the setting values.
func test_sqlite3_db_config(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7977:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var i int32
	*(*int32)(unsafe.Pointer(bp + 20 /* v */)) = 0
	var zSetting uintptr
	// var db uintptr at bp+16, 4

	if (objc != 4) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18714 /* "DB SETTING [VALU..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16 /* &db */) != 0 {
		return TCL_ERROR
	}
	zSetting = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if sqlite3.Xsqlite3_strglob(tls, ts+18733 /* "SQLITE_*" */, zSetting) == 0 {
		zSetting += uintptr(7)
	}
	if sqlite3.Xsqlite3_strglob(tls, ts+18742 /* "DBCONFIG_*" */, zSetting) == 0 {
		zSetting += uintptr(9)
	}
	if sqlite3.Xsqlite3_strglob(tls, ts+18753 /* "ENABLE_*" */, zSetting) == 0 {
		zSetting += uintptr(7)
	}
	for i = 0; i < (int32(uint32(unsafe.Sizeof(aSetting)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FeVal  int32
	}{})))); i++ {
		if libc.Xstrcmp(tls, zSetting, aSetting[i].FzName) == 0 {
			break
		}
	}
	if i >= (int32(uint32(unsafe.Sizeof(aSetting)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FeVal  int32
	}{})))) {
		tcl.XTcl_SetObjResult(tls, interp,
			tcl.XTcl_NewStringObj(tls, ts+18762 /* "unknown sqlite3_..." */, -1))
		return TCL_ERROR
	}
	if objc == 4 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+20 /* &v */) != 0 {
			return TCL_ERROR
		}
	} else {
		*(*int32)(unsafe.Pointer(bp + 20 /* v */)) = -1
	}
	sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), aSetting[i].FeVal, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 20 /* v */)), bp+20 /* &v */))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 20 /* v */))))
	return TCL_OK
}

var aSetting = [14]struct {
	FzName uintptr
	FeVal  int32
}{
	{FzName: ts + 18796 /* "FKEY" */, FeVal: SQLITE_DBCONFIG_ENABLE_FKEY},
	{FzName: ts + 18801 /* "TRIGGER" */, FeVal: SQLITE_DBCONFIG_ENABLE_TRIGGER},
	{FzName: ts + 18809 /* "FTS3_TOKENIZER" */, FeVal: SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER},
	{FzName: ts + 18824 /* "LOAD_EXTENSION" */, FeVal: SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION},
	{FzName: ts + 18839 /* "NO_CKPT_ON_CLOSE" */, FeVal: SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE},
	{FzName: ts + 18856 /* "QPSG" */, FeVal: SQLITE_DBCONFIG_ENABLE_QPSG},
	{FzName: ts + 18861 /* "TRIGGER_EQP" */, FeVal: SQLITE_DBCONFIG_TRIGGER_EQP},
	{FzName: ts + 18873 /* "RESET_DB" */, FeVal: SQLITE_DBCONFIG_RESET_DATABASE},
	{FzName: ts + 18882 /* "DEFENSIVE" */, FeVal: SQLITE_DBCONFIG_DEFENSIVE},
	{FzName: ts + 18892 /* "WRITABLE_SCHEMA" */, FeVal: SQLITE_DBCONFIG_WRITABLE_SCHEMA},
	{FzName: ts + 18908 /* "LEGACY_ALTER_TAB..." */, FeVal: SQLITE_DBCONFIG_LEGACY_ALTER_TABLE},
	{FzName: ts + 18927 /* "DQS_DML" */, FeVal: SQLITE_DBCONFIG_DQS_DML},
	{FzName: ts + 18935 /* "DQS_DDL" */, FeVal: SQLITE_DBCONFIG_DQS_DDL},
	{FzName: ts + 18943 /* "LEGACY_FILE_FORM..." */, FeVal: SQLITE_DBCONFIG_LEGACY_FILE_FORMAT},
} /* test1.c:7986:5 */

// tclcmd:   sqlite3_txn_state DB ?SCHEMA?
//
// Invoke sqlite3_txn_state(DB,SCHEMA) and return the
// numeric value that results.  Use NULL for SCHEMA if the 3 argument
// is omitted.
func test_sqlite3_txn_state(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8040:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var zSchema uintptr
	var iTxn int32

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18962 /* "DB ?SCHEMA?" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zSchema = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	} else {
		zSchema = uintptr(0)
	}
	iTxn = sqlite3.Xsqlite3_txn_state(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zSchema)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iTxn))
	return TCL_OK
}

// Change the name of the main database schema from "main" to "icecube".
func test_dbconfig_maindbname_icecube(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8064:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	// var db uintptr at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	} else {
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+8 /* &db */) != 0 {
			return TCL_ERROR
		}
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), SQLITE_DBCONFIG_MAINDBNAME, libc.VaList(bp, ts+18974 /* "icecube" */))
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
		return TCL_OK
	}
	return int32(0)
}

// Usage: sqlite3_mmap_warm DB DBNAME
func test_mmap_warm(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8087:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18982 /* "DB ?DBNAME?" */)
		return TCL_ERROR
	} else {
		var rc int32
		// var db uintptr at bp, 4

		var zDb uintptr = uintptr(0)
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
			return TCL_ERROR
		}
		if objc == 3 {
			zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
		}
		rc = sqlite3_mmap_warm(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb)
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_OK
	}
	return int32(0)
}

// Usage:  test_write_db DB OFFSET DATA
//
// Obtain the sqlite3_file* object for the database file for the "main" db
// of handle DB. Then invoke its xWrite method to write data DATA to offset
// OFFSET.
func test_write_db(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8120:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*uintptr)(unsafe.Pointer(bp /* db */)) = uintptr(0)
	*(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* iOff */)) = int64(0)
	var aData uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 16 /* nData */)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 20 /* pFile */)) = uintptr(0)
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18994 /* "DB OFFSET DATA" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+8 /* &iOff */) != 0 {
		return TCL_ERROR
	}
	aData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+16 /* &nData */)

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+85 /* "main" */, SQLITE_FCNTL_FILE_POINTER, bp+20 /* &pFile */)
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20 /* pFile */)))).FpMethods + 12 /* &.xWrite */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pFile */)), aData, *(*int32)(unsafe.Pointer(bp + 16 /* nData */)), *(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* iOff */)))

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// Usage:  sqlite3_register_cksumvfs
//
func test_register_cksumvfs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8152:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	} else {
		var rc int32 = sqlite3_register_cksumvfs(tls, uintptr(0))
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}
	return TCL_OK
}

// Usage:  sqlite3_unregister_cksumvfs
//
func test_unregister_cksumvfs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8173:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	} else {
		var rc int32 = sqlite3_unregister_cksumvfs(tls)
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}
	return TCL_OK
}

// Usage:  decode_hexdb TEXT
//
// Example:   db deserialize [decode_hexdb $output_of_dbtotxt]
//
// This routine returns a byte-array for an SQLite database file that
// is constructed from a text input which is the output of the "dbtotxt"
// utility.
func test_decode_hexdb(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8199:26: */
	bp := tls.Alloc(296)
	defer tls.Free(296)

	var zIn uintptr = uintptr(0)
	var a uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 216 /* n */)) = 0
	var lineno int32 = 0
	var i int32
	var iNext int32
	var iOffset int32 = 0
	// var j int32 at bp+224, 4

	// var k int32 at bp+228, 4

	var rc int32
	// var x [16]uint32 at bp+232, 64

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19009 /* "HEXDB" */)
		return TCL_ERROR
	}
	zIn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	for i = 0; *(*int8)(unsafe.Pointer(zIn + uintptr(i))) != 0; i = iNext {
		lineno++
		for iNext = i; (*(*int8)(unsafe.Pointer(zIn + uintptr(iNext))) != 0) && (int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iNext)))) != '\n'); iNext++ {
		}
		if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iNext)))) == '\n' {
			iNext++
		}
		for (int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) == ' ') || (int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) == '\t') {
			i++
		}
		if a == uintptr(0) {
			// var pgsz int32 at bp+220, 4

			rc = libc.Xsscanf(tls, (zIn + uintptr(i)), ts+19015 /* "| size %d pagesi..." */, libc.VaList(bp, bp+216 /* &n */, bp+220 /* &pgsz */))
			if rc != 2 {
				continue
			}
			if ((*(*int32)(unsafe.Pointer(bp + 220 /* pgsz */)) < 512) || (*(*int32)(unsafe.Pointer(bp + 220 /* pgsz */)) > 65536)) || ((*(*int32)(unsafe.Pointer(bp + 220 /* pgsz */)) & (*(*int32)(unsafe.Pointer(bp + 220 /* pgsz */)) - 1)) != 0) {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+19037 /* "bad 'pagesize' f..." */, uintptr(0)))
				return TCL_ERROR
			}
			*(*int32)(unsafe.Pointer(bp + 216 /* n */)) = (((*(*int32)(unsafe.Pointer(bp + 216 /* n */)) + *(*int32)(unsafe.Pointer(bp + 220 /* pgsz */))) - 1) & ^(*(*int32)(unsafe.Pointer(bp + 220 /* pgsz */)) - 1)) // Round n up to the next multiple of pgsz
			if *(*int32)(unsafe.Pointer(bp + 216 /* n */)) < 512 {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+19058 /* "bad 'size' field" */, uintptr(0)))
				return TCL_ERROR
			}
			a = libc.Xmalloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 216 /* n */))))
			if a == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+1930 /* "out of memory" */, uintptr(0)))
				return TCL_ERROR
			}
			libc.Xmemset(tls, a, 0, uint32(*(*int32)(unsafe.Pointer(bp + 216 /* n */))))
			continue
		}
		rc = libc.Xsscanf(tls, (zIn + uintptr(i)), ts+19075 /* "| page %d offset..." */, libc.VaList(bp+64, bp+224 /* &j */, bp+228 /* &k */))
		if rc == 2 {
			iOffset = *(*int32)(unsafe.Pointer(bp + 228 /* k */))
			continue
		}
		rc = libc.Xsscanf(tls, (zIn + uintptr(i)), ts+19095, /* "| %d: %x %x %x %..." */
			libc.VaList(bp+80, bp+224 /* &j */, (bp+232 /* &x */), (bp+232 /* &x */ +1*4), (bp+232 /* &x */ +2*4), (bp+232 /* &x */ +3*4), (bp+232 /* &x */ +4*4), (bp+232 /* &x */ +5*4), (bp+232 /* &x */ +6*4), (bp+232 /* &x */ +7*4),
				(bp+232 /* &x */ +8*4), (bp+232 /* &x */ +9*4), (bp+232 /* &x */ +10*4), (bp+232 /* &x */ +11*4), (bp+232 /* &x */ +12*4), (bp+232 /* &x */ +13*4), (bp+232 /* &x */ +14*4), (bp+232 /* &x */ +15*4)))
		if rc == 17 {
			*(*int32)(unsafe.Pointer(bp + 228 /* k */)) = (iOffset + *(*int32)(unsafe.Pointer(bp + 224 /* j */)))
			if (*(*int32)(unsafe.Pointer(bp + 228 /* k */)) + 16) <= *(*int32)(unsafe.Pointer(bp + 216 /* n */)) {
				var ii int32
				for ii = 0; ii < 16; ii++ {
					*(*uint8)(unsafe.Pointer(a + uintptr((*(*int32)(unsafe.Pointer(bp + 228 /* k */)) + ii)))) = (uint8(*(*uint32)(unsafe.Pointer(bp + 232 /* &x[0] */ + uintptr(ii)*4)) & uint32(0xff)))
				}
			}
			continue
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, a, *(*int32)(unsafe.Pointer(bp + 216 /* n */))))
	libc.Xfree(tls, a)
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest1_Init(tls *libc.TLS, interp uintptr) int32 { /* test1.c:8271:5: */
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aCmd1)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd1[i].FzName, aCmd1[i].FxProc, uintptr(0), uintptr(0))
	}
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd1)) / uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd1[i].FzName,
			aObjCmd1[i].FxProc, aObjCmd1[i].FclientData, uintptr(0))
	}
	tcl.XTcl_LinkVar(tls, interp, ts+19149, /* "sqlite_search_co..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_search_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19169, /* "sqlite_found_cou..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_found_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19188, /* "sqlite_sort_coun..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_sort_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19206, /* "sqlite3_max_blob..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_max_blobsize)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19227, /* "sqlite_like_coun..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_like_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19245, /* "sqlite_interrupt..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_interrupt_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19268, /* "sqlite_open_file..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_open_file_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19291, /* "sqlite_current_t..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_current_time)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19311, /* "sqlite3_xferopt_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_xferopt_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19333, /* "sqlite3_pager_re..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_readdb_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19360, /* "sqlite3_pager_wr..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_writedb_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19388, /* "sqlite3_pager_wr..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_writej_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19415, /* "unaligned_string..." */
		uintptr(unsafe.Pointer(&unaligned_string_counter)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19440, /* "sqlite_last_need..." */
		uintptr(unsafe.Pointer(&pzNeededCollation)), (TCL_LINK_STRING | TCL_LINK_READ_ONLY))
	{
		tcl.XTcl_LinkVar(tls, interp, ts+19469, /* "sqlite_query_pla..." */
			uintptr(unsafe.Pointer(&query_plan)), (TCL_LINK_STRING | TCL_LINK_READ_ONLY))

	}
	tcl.XTcl_LinkVar(tls, interp, ts+19487, /* "sqlite_opentemp_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_opentemp_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19509, /* "sqlite_static_bi..." */
		uintptr(unsafe.Pointer(&sqlite_static_bind_value)), TCL_LINK_STRING)
	tcl.XTcl_LinkVar(tls, interp, ts+19534, /* "sqlite_static_bi..." */
		uintptr(unsafe.Pointer(&sqlite_static_bind_nbyte)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19559, /* "sqlite_temp_dire..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_temp_directory)), TCL_LINK_STRING)
	tcl.XTcl_LinkVar(tls, interp, ts+19581, /* "sqlite_data_dire..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_data_directory)), TCL_LINK_STRING)
	tcl.XTcl_LinkVar(tls, interp, ts+19603, /* "bitmask_size" */
		uintptr(unsafe.Pointer(&bitmask_size)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	tcl.XTcl_LinkVar(tls, interp, ts+19616, /* "longdouble_size" */
		uintptr(unsafe.Pointer(&longdouble_size)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	tcl.XTcl_LinkVar(tls, interp, ts+19632, /* "sqlite_sync_coun..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_sync_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+19650, /* "sqlite_fullsync_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_fullsync_count)), TCL_LINK_INT)
	return TCL_OK
}

var iZero int32 = 0 /* test1.c:8284:14 */
var aCmd1 = [40]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 19672 /* "db_enter" */, FxProc: 0},
	{FzName: ts + 19681 /* "db_leave" */, FxProc: 0},
	{FzName: ts + 19690 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 19710 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 19732 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 19753 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 19773 /* "sqlite3_snprintf..." */, FxProc: 0},
	{FzName: ts + 19794 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 19818 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 19841 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 19864 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 19890 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 19913 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 19936 /* "sqlite3_snprintf..." */, FxProc: 0},
	{FzName: ts + 19957 /* "sqlite3_last_ins..." */, FxProc: 0},
	{FzName: ts + 19983 /* "sqlite3_exec_pri..." */, FxProc: 0},
	{FzName: ts + 20003 /* "sqlite3_exec_hex" */, FxProc: 0},
	{FzName: ts + 20020 /* "sqlite3_exec" */, FxProc: 0},
	{FzName: ts + 20033 /* "sqlite3_exec_nr" */, FxProc: 0},
	{FzName: ts + 20049 /* "sqlite3_get_tabl..." */, FxProc: 0},
	{FzName: ts + 20074 /* "sqlite3_close" */, FxProc: 0},
	{FzName: ts + 20088 /* "sqlite3_close_v2" */, FxProc: 0},
	{FzName: ts + 20105 /* "sqlite3_create_f..." */, FxProc: 0},
	{FzName: ts + 20129 /* "sqlite3_create_a..." */, FxProc: 0},
	{FzName: ts + 20154 /* "sqlite3_drop_mod..." */, FxProc: 0},
	{FzName: ts + 20175 /* "sqlite_register_..." */, FxProc: 0},
	{FzName: ts + 20205 /* "sqlite_abort" */, FxProc: 0},
	{FzName: ts + 20218 /* "sqlite_bind" */, FxProc: 0},
	{FzName: ts + 20230 /* "breakpoint" */, FxProc: 0},
	{FzName: ts + 20241 /* "sqlite3_key" */, FxProc: 0},
	{FzName: ts + 20253 /* "sqlite3_rekey" */, FxProc: 0},
	{FzName: ts + 20267 /* "sqlite_set_magic" */, FxProc: 0},
	{FzName: ts + 20284 /* "sqlite3_interrup..." */, FxProc: 0},
	{FzName: ts + 20302 /* "sqlite_delete_fu..." */, FxProc: 0},
	{FzName: ts + 20325 /* "sqlite_delete_co..." */, FxProc: 0},
	{FzName: ts + 20349 /* "sqlite3_get_auto..." */, FxProc: 0},
	{FzName: ts + 20372 /* "sqlite3_busy_tim..." */, FxProc: 0},
	{FzName: ts + 20393 /* "printf" */, FxProc: 0},
	{FzName: ts + 20400 /* "sqlite3IoTrace" */, FxProc: 0},
	{FzName: ts + 20415 /* "clang_sanitize_a..." */, FxProc: 0},
} /* test1.c:8288:5 */
var aObjCmd1 = [161]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 20438 /* "sqlite3_db_confi..." */, FxProc: 0},
	{FzName: ts + 20456 /* "sqlite3_txn_stat..." */, FxProc: 0},
	{FzName: ts + 20474 /* "bad_behavior" */, FxProc: 0, FclientData: 0},
	{FzName: ts + 20487 /* "register_dbstat_..." */, FxProc: 0},
	{FzName: ts + 20508 /* "sqlite3_connecti..." */, FxProc: 0},
	{FzName: ts + 20535 /* "intarray_addr" */, FxProc: 0},
	{FzName: ts + 20549 /* "int64array_addr" */, FxProc: 0},
	{FzName: ts + 20565 /* "doublearray_addr" */, FxProc: 0},
	{FzName: ts + 20582 /* "textarray_addr" */, FxProc: 0},
	{FzName: ts + 20597 /* "sqlite3_bind_int" */, FxProc: 0},
	{FzName: ts + 20614 /* "sqlite3_bind_zer..." */, FxProc: 0},
	{FzName: ts + 20636 /* "sqlite3_bind_zer..." */, FxProc: 0},
	{FzName: ts + 20660 /* "sqlite3_bind_int..." */, FxProc: 0},
	{FzName: ts + 20679 /* "sqlite3_bind_dou..." */, FxProc: 0},
	{FzName: ts + 20699 /* "sqlite3_bind_nul..." */, FxProc: 0},
	{FzName: ts + 20717 /* "sqlite3_bind_tex..." */, FxProc: 0},
	{FzName: ts + 20735 /* "sqlite3_bind_tex..." */, FxProc: 0},
	{FzName: ts + 20755 /* "sqlite3_bind_blo..." */, FxProc: 0},
	{FzName: ts + 20773 /* "sqlite3_carray_b..." */, FxProc: 0},
	{FzName: ts + 20793 /* "sqlite3_bind_par..." */, FxProc: 0},
	{FzName: ts + 20822 /* "sqlite3_bind_par..." */, FxProc: 0},
	{FzName: ts + 20850 /* "sqlite3_bind_par..." */, FxProc: 0},
	{FzName: ts + 20879 /* "sqlite3_clear_bi..." */, FxProc: 0},
	{FzName: ts + 20902 /* "sqlite3_sleep" */, FxProc: 0},
	{FzName: ts + 20916 /* "sqlite3_errcode" */, FxProc: 0},
	{FzName: ts + 20932 /* "sqlite3_extended..." */, FxProc: 0},
	{FzName: ts + 20957 /* "sqlite3_errmsg" */, FxProc: 0},
	{FzName: ts + 20972 /* "sqlite3_errmsg16" */, FxProc: 0},
	{FzName: ts + 20989 /* "sqlite3_open" */, FxProc: 0},
	{FzName: ts + 21002 /* "sqlite3_open16" */, FxProc: 0},
	{FzName: ts + 21017 /* "sqlite3_open_v2" */, FxProc: 0},
	{FzName: ts + 21033 /* "sqlite3_complete..." */, FxProc: 0},
	{FzName: ts + 21052 /* "sqlite3_normaliz..." */, FxProc: 0},

	{FzName: ts + 21070 /* "sqlite3_prepare" */, FxProc: 0},
	{FzName: ts + 21086 /* "sqlite3_prepare1..." */, FxProc: 0},
	{FzName: ts + 21104 /* "sqlite3_prepare_..." */, FxProc: 0},
	{FzName: ts + 21123 /* "sqlite3_prepare_..." */, FxProc: 0},
	{FzName: ts + 21142 /* "sqlite3_prepare_..." */, FxProc: 0},
	{FzName: ts + 21166 /* "sqlite3_prepare1..." */, FxProc: 0},
	{FzName: ts + 21187 /* "sqlite3_finalize" */, FxProc: 0},
	{FzName: ts + 21204 /* "sqlite3_stmt_sta..." */, FxProc: 0},
	{FzName: ts + 21224 /* "sqlite3_reset" */, FxProc: 0},
	{FzName: ts + 21238 /* "sqlite3_expired" */, FxProc: 0},
	{FzName: ts + 21254 /* "sqlite3_transfer..." */, FxProc: 0},
	{FzName: ts + 21280 /* "sqlite3_changes" */, FxProc: 0},
	{FzName: ts + 21296 /* "sqlite3_step" */, FxProc: 0},
	{FzName: ts + 21309 /* "sqlite3_sql" */, FxProc: 0},
	{FzName: ts + 21321 /* "sqlite3_expanded..." */, FxProc: 0},
	{FzName: ts + 21342 /* "sqlite3_next_stm..." */, FxProc: 0},
	{FzName: ts + 21360 /* "sqlite3_stmt_rea..." */, FxProc: 0},
	{FzName: ts + 21382 /* "sqlite3_stmt_ise..." */, FxProc: 0},
	{FzName: ts + 21405 /* "sqlite3_stmt_bus..." */, FxProc: 0},
	{FzName: ts + 21423 /* "uses_stmt_journa..." */, FxProc: 0},

	{FzName: ts + 21441 /* "sqlite3_release_..." */, FxProc: 0},
	{FzName: ts + 21464 /* "sqlite3_db_relea..." */, FxProc: 0},
	{FzName: ts + 21490 /* "sqlite3_db_cache..." */, FxProc: 0},
	{FzName: ts + 21512 /* "sqlite3_system_e..." */, FxProc: 0},
	{FzName: ts + 21533 /* "sqlite3_db_filen..." */, FxProc: 0},
	{FzName: ts + 21553 /* "sqlite3_db_reado..." */, FxProc: 0},
	{FzName: ts + 21573 /* "sqlite3_soft_hea..." */, FxProc: 0},
	{FzName: ts + 21597 /* "sqlite3_soft_hea..." */, FxProc: 0},
	{FzName: ts + 21623 /* "sqlite3_hard_hea..." */, FxProc: 0},
	{FzName: ts + 21649 /* "sqlite3_thread_c..." */, FxProc: 0},
	{FzName: ts + 21672 /* "sqlite3_pager_re..." */, FxProc: 0},

	{FzName: ts + 21696 /* "sqlite3_load_ext..." */, FxProc: 0},
	{FzName: ts + 21719 /* "sqlite3_enable_l..." */, FxProc: 0},
	{FzName: ts + 21749 /* "sqlite3_extended..." */, FxProc: 0},
	{FzName: ts + 21779 /* "sqlite3_limit" */, FxProc: 0},
	{FzName: ts + 21793 /* "dbconfig_maindbn..." */, FxProc: 0},

	{FzName: ts + 21821 /* "save_prng_state" */, FxProc: 0},
	{FzName: ts + 21837 /* "restore_prng_sta..." */, FxProc: 0},
	{FzName: ts + 21856 /* "reset_prng_state" */, FxProc: 0},
	{FzName: ts + 21873 /* "prng_seed" */, FxProc: 0},
	{FzName: ts + 21883 /* "extra_schema_che..." */, FxProc: 0},
	{FzName: ts + 21903 /* "database_never_c..." */, FxProc: 0},
	{FzName: ts + 21926 /* "database_may_be_..." */, FxProc: 0},
	{FzName: ts + 21950 /* "optimization_con..." */, FxProc: 0},
	{FzName: ts + 21971 /* "tcl_objproc" */, FxProc: 0},

	// sqlite3_column_*() API
	{FzName: ts + 21983 /* "sqlite3_column_c..." */, FxProc: 0},
	{FzName: ts + 22004 /* "sqlite3_data_cou..." */, FxProc: 0},
	{FzName: ts + 22023 /* "sqlite3_column_t..." */, FxProc: 0},
	{FzName: ts + 22043 /* "sqlite3_column_b..." */, FxProc: 0},
	{FzName: ts + 22063 /* "sqlite3_column_d..." */, FxProc: 0},
	{FzName: ts + 22085 /* "sqlite3_column_i..." */, FxProc: 0},
	{FzName: ts + 22106 /* "sqlite3_column_t..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22126 /* "sqlite3_column_n..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22146 /* "sqlite3_column_i..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22165 /* "sqlite3_column_b..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22186 /* "sqlite3_column_d..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22210 /* "sqlite3_column_d..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22239 /* "sqlite3_column_t..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22265 /* "sqlite3_column_o..." */, FxProc: 0, FclientData: 0},

	{FzName: ts + 22292 /* "sqlite3_column_b..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22315 /* "sqlite3_column_t..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22337 /* "sqlite3_column_n..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22359 /* "add_alignment_te..." */, FxProc: 0},
	{FzName: ts + 22389 /* "sqlite3_column_d..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22415, /* "sqlite3_column_d..." */
		FxProc: 0, FclientData: 0},
	{FzName: ts + 22446 /* "sqlite3_column_t..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22474 /* "sqlite3_column_o..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 22503 /* "sqlite3_create_c..." */, FxProc: 0},
	{FzName: ts + 22531 /* "sqlite3_global_r..." */, FxProc: 0},
	{FzName: ts + 22554 /* "working_64bit_in..." */, FxProc: 0},
	{FzName: ts + 22572 /* "vfs_unlink_test" */, FxProc: 0},
	{FzName: ts + 22588 /* "vfs_initfail_tes..." */, FxProc: 0},
	{FzName: ts + 22606 /* "vfs_unregister_a..." */, FxProc: 0},
	{FzName: ts + 22625 /* "vfs_reregister_a..." */, FxProc: 0},
	{FzName: ts + 22644 /* "file_control_tes..." */, FxProc: 0},
	{FzName: ts + 22662 /* "file_control_las..." */, FxProc: 0},
	{FzName: ts + 22690 /* "file_control_loc..." */, FxProc: 0},
	{FzName: ts + 22718 /* "file_control_chu..." */, FxProc: 0},
	{FzName: ts + 22746 /* "file_control_siz..." */, FxProc: 0},
	{FzName: ts + 22773 /* "file_control_dat..." */, FxProc: 0},
	{FzName: ts + 22799 /* "file_control_per..." */, FxProc: 0},
	{FzName: ts + 22824 /* "file_control_pow..." */, FxProc: 0},
	{FzName: ts + 22857 /* "file_control_vfs..." */, FxProc: 0},
	{FzName: ts + 22878 /* "file_control_res..." */, FxProc: 0},
	{FzName: ts + 22904 /* "file_control_tem..." */, FxProc: 0},
	{FzName: ts + 22930 /* "file_control_ext..." */, FxProc: 0},
	{FzName: ts + 22959 /* "sqlite3_vfs_list" */, FxProc: 0},
	{FzName: ts + 22976 /* "sqlite3_create_f..." */, FxProc: 0},

	// Functions from os.h
	{FzName: ts + 23003 /* "add_test_collate" */, FxProc: 0},
	{FzName: ts + 23020 /* "add_test_collate..." */, FxProc: 0},
	{FzName: ts + 23044 /* "add_test_functio..." */, FxProc: 0},
	{FzName: ts + 23062 /* "add_test_utf16bi..." */, FxProc: 0},
	{FzName: ts + 23088 /* "sqlite3_test_err..." */, FxProc: 0},
	{FzName: ts + 23108 /* "tcl_variable_typ..." */, FxProc: 0},
	{FzName: ts + 23126 /* "sqlite3_enable_s..." */, FxProc: 0},
	{FzName: ts + 23154 /* "sqlite3_shared_c..." */, FxProc: 0},
	{FzName: ts + 23182 /* "sqlite3_libversi..." */, FxProc: 0},
	{FzName: ts + 23208 /* "sqlite3_table_co..." */, FxProc: 0},
	{FzName: ts + 23238 /* "sqlite3_blob_reo..." */, FxProc: 0},
	{FzName: ts + 23258 /* "pcache_stats" */, FxProc: 0},
	{FzName: ts + 23271 /* "sqlite3_unlock_n..." */, FxProc: 0},
	{FzName: ts + 23293 /* "sqlite3_wal_chec..." */, FxProc: 0},
	{FzName: ts + 23316 /* "sqlite3_wal_chec..." */, FxProc: 0},
	{FzName: ts + 23342 /* "sqlite3_wal_auto..." */, FxProc: 0},
	{FzName: ts + 23369 /* "test_sqlite3_log" */, FxProc: 0},
	{FzName: ts + 23386 /* "print_explain_qu..." */, FxProc: 0},
	{FzName: ts + 23411 /* "sqlite3_test_con..." */, FxProc: 0},
	{FzName: ts + 23432 /* "getrusage" */, FxProc: 0},
	{FzName: ts + 23442 /* "load_static_exte..." */, FxProc: 0},
	{FzName: ts + 23464 /* "sorter_test_fake..." */, FxProc: 0},
	{FzName: ts + 23485 /* "sorter_test_sort..." */, FxProc: 0},
	{FzName: ts + 23510 /* "vfs_current_time..." */, FxProc: 0},
	{FzName: ts + 23533 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 23554 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 23576 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 23598 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 23619 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 23644 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 23670 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 23697 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 23723 /* "sqlite3_delete_d..." */, FxProc: 0},
	{FzName: ts + 23747 /* "atomic_batch_wri..." */, FxProc: 0},
	{FzName: ts + 23766 /* "sqlite3_mmap_war..." */, FxProc: 0},
	{FzName: ts + 23784 /* "sqlite3_config_s..." */, FxProc: 0},
	{FzName: ts + 23809 /* "decode_hexdb" */, FxProc: 0},
	{FzName: ts + 23822 /* "test_write_db" */, FxProc: 0},
	{FzName: ts + 23836 /* "sqlite3_register..." */, FxProc: 0},
	{FzName: ts + 23862 /* "sqlite3_unregist..." */, FxProc: 0},
}                                                                               /* test1.c:8336:5 */
var bitmask_size int32 = (int32(uint32(unsafe.Sizeof(Bitmask(0))) * uint32(8))) /* test1.c:8564:14 */
var longdouble_size int32 = int32(unsafe.Sizeof(float64(0)))                    /* test1.c:8565:14 */
var query_plan uintptr = ts + 23890                                             /* "*** OBSOLETE VAR..." */ /* test1.c:8637:23 */

// Page size and reserved size used for testing.
var test_pagesize int32 = 1024 /* test2.c:31:12 */

// Dummy page reinitializer
func pager_test_reiniter(tls *libc.TLS, pNotUsed uintptr) { /* test2.c:36:13: */
	return
}

// Usage:   pager_open FILENAME N-PAGE
//
// Open a new pager
func pager_open(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:45:26: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// var pageSize u32 at bp+80, 4

	// var pPager uintptr at bp+76, 4

	// var nPage int32 at bp+72, 4

	var rc int32
	// var zBuf [100]int8 at bp+84, 100

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23916 /* " FILENAME N-PAGE..." */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+72 /* &nPage */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3PagerOpen(tls, sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)), bp+76 /* &pPager */, *(*uintptr)(unsafe.Pointer(argv + 1*4)), 0, 0,
		((SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE) | SQLITE_OPEN_MAIN_DB),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{pager_test_reiniter})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3PagerSetCachesize(tls, *(*uintptr)(unsafe.Pointer(bp + 76 /* pPager */)), *(*int32)(unsafe.Pointer(bp + 72 /* nPage */)))
	*(*u32)(unsafe.Pointer(bp + 80 /* pageSize */)) = u32(test_pagesize)
	sqlite3.Xsqlite3PagerSetPagesize(tls, *(*uintptr)(unsafe.Pointer(bp + 76 /* pPager */)), bp+80 /* &pageSize */, -1)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+84 /* &zBuf[0] */, ts+13021 /* "%p" */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 76 /* pPager */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+84 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   pager_close ID
//
// Close the given pager.
func pager_close(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:82:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerClose(tls, pPager, uintptr(0))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_rollback ID
//
// Rollback changes
func pager_rollback(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:109:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerRollback(tls, pPager)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_commit ID
//
// Commit all changes
func pager_commit(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:136:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerCommitPhaseOne(tls, pPager, uintptr(0), 0)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3PagerCommitPhaseTwo(tls, pPager)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_stmt_begin ID
//
// Start a new checkpoint.
func pager_stmt_begin(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:168:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerOpenSavepoint(tls, pPager, 1)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_stmt_rollback ID
//
// Rollback changes to a checkpoint
func pager_stmt_rollback(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:195:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerSavepoint(tls, pPager, SAVEPOINT_ROLLBACK, 0)
	sqlite3.Xsqlite3PagerSavepoint(tls, pPager, SAVEPOINT_RELEASE, 0)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_stmt_commit ID
//
// Commit changes to a checkpoint
func pager_stmt_commit(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:223:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerSavepoint(tls, pPager, SAVEPOINT_RELEASE, 0)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_stats ID
//
// Return pager statistics.
func pager_stats(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:250:26: */
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var pPager uintptr
	var i int32
	var a uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	a = sqlite3.Xsqlite3PagerStats(tls, pPager)
	for i = 0; i < 9; i++ {
		// var zBuf [100]int8 at bp+40, 100

		tcl.XTcl_AppendElement(tls, interp, zName[i])
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
		tcl.XTcl_AppendElement(tls, interp, bp+40 /* &zBuf[0] */)
	}
	return TCL_OK
}

var zName = [9]uintptr{
	ts + 23939 /* "ref" */, ts + 23943 /* "page" */, ts + 17912 /* "max" */, ts + 11491 /* "size" */, ts + 10193 /* "state" */, ts + 23948, /* "err" */
	ts + 23952 /* "hit" */, ts + 23956 /* "miss" */, ts + 23961, /* "ovfl" */
} /* test2.c:266:17 */

// Usage:   pager_pagecount ID
//
// Return the size of the database file.
func pager_pagecount(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:283:26: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	var pPager uintptr
	// var zBuf [100]int8 at bp+60, 100

	// var nPage int32 at bp+56, 4

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3PagerPagecount(tls, pPager, bp+56 /* &nPage */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+60 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 56 /* nPage */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+60 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   page_get ID PGNO
//
// Return a pointer to a page from the database.
func page_get(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:309:26: */
	bp := tls.Alloc(180)
	defer tls.Free(180)

	var pPager uintptr
	// var zBuf [100]int8 at bp+80, 100

	*(*uintptr)(unsafe.Pointer(bp + 76 /* pPage */)) = uintptr(0)
	// var pgno int32 at bp+72, 4

	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23966 /* " ID PGNO\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+72 /* &pgno */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3PagerSharedLock(tls, pPager)
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3PagerGet(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 72 /* pgno */))), bp+76 /* &pPage */, 0)
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+80 /* &zBuf[0] */, ts+13021 /* "%p" */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 76 /* pPage */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+80 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   page_lookup ID PGNO
//
// Return a pointer to a page if the page is already in cache.
// If not in cache, return an empty string.
func page_lookup(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:346:26: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	var pPager uintptr
	// var zBuf [100]int8 at bp+60, 100

	var pPage uintptr
	// var pgno int32 at bp+56, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23966 /* " ID PGNO\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+56 /* &pgno */) != 0 {
		return TCL_ERROR
	}
	pPage = sqlite3.Xsqlite3PagerLookup(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 56 /* pgno */))))
	if pPage != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+60 /* &zBuf[0] */, ts+13021 /* "%p" */, libc.VaList(bp+32, pPage))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+60 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

// Usage:   pager_truncate ID PGNO
func pager_truncate(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:374:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var pPager uintptr
	// var pgno int32 at bp+32, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23966 /* " ID PGNO\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+32 /* &pgno */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3PagerTruncateImage(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 32 /* pgno */))))
	return TCL_OK
}

// Usage:   page_unref PAGE
//
// Drop a pointer to a page.
func page_unref(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:399:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23976 /* " PAGE\"" */, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3PagerUnref(tls, pPage)
	return TCL_OK
}

// Usage:   page_read PAGE
//
// Return the content of a page
func page_read(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:421:26: */
	bp := tls.Alloc(148)
	defer tls.Free(148)

	// var zBuf [100]int8 at bp+48, 100

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23976 /* " PAGE\"" */, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	libc.Xmemcpy(tls, bp+48 /* &zBuf[0] */, sqlite3.Xsqlite3PagerGetData(tls, pPage), uint32(unsafe.Sizeof([100]int8{})))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+48 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   page_number PAGE
//
// Return the page number for a page.
func page_number(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:445:26: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	// var zBuf [100]int8 at bp+56, 100

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23976 /* " PAGE\"" */, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+56 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+32, sqlite3.Xsqlite3PagerPagenumber(tls, pPage)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+56 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   page_write PAGE DATA
//
// Write something into a page.
func page_write(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:469:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPage uintptr
	var pData uintptr
	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23983 /* " PAGE DATA\"" */, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerWrite(tls, pPage)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	pData = sqlite3.Xsqlite3PagerGetData(tls, pPage)
	libc.Xstrncpy(tls, pData, *(*uintptr)(unsafe.Pointer(argv + 2*4)), (uint32(test_pagesize - 1)))
	*(*int8)(unsafe.Pointer(pData + uintptr((test_pagesize - 1)))) = int8(0)
	return TCL_OK
}

// Usage:   fake_big_file  N  FILENAME
//
// Write a few bytes at the N megabyte point of FILENAME.  This will
// create a large file.  If the file was a valid SQLite database, then
// the next time the database is opened, SQLite will begin allocating
// new pages after N.  If N is 2096 or bigger, this will test the
// ability of SQLite to write to large files.
func fake_big_file(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:505:26: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	var pVfs uintptr
	*(*uintptr)(unsafe.Pointer(bp + 84 /* fd */)) = uintptr(0)
	var rc int32
	// var n int32 at bp+80, 4

	var offset i64
	var zFile uintptr
	var nFile int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23995 /* " N-MEGABYTES FIL..." */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+80 /* &n */) != 0 {
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	nFile = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	zFile = sqlite3.Xsqlite3_malloc(tls, (nFile + 2))
	if zFile == uintptr(0) {
		return TCL_ERROR
	}
	libc.Xmemcpy(tls, zFile, *(*uintptr)(unsafe.Pointer(argv + 2*4)), (uint32(nFile + 1)))
	*(*int8)(unsafe.Pointer(zFile + uintptr((nFile + 1)))) = int8(0)
	rc = sqlite3.Xsqlite3OsOpenMalloc(tls, pVfs, zFile, bp+84, /* &fd */
		((SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE) | SQLITE_OPEN_MAIN_DB), uintptr(0))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+24014 /* "open failed: " */, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		sqlite3.Xsqlite3_free(tls, zFile)
		return TCL_ERROR
	}
	offset = i64(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))
	offset = offset * (int64(1024 * 1024))
	rc = sqlite3.Xsqlite3OsWrite(tls, *(*uintptr)(unsafe.Pointer(bp + 84 /* fd */)), ts+24028 /* "Hello, World!" */, 14, offset)
	sqlite3.Xsqlite3OsCloseFree(tls, *(*uintptr)(unsafe.Pointer(bp + 84 /* fd */)))
	sqlite3.Xsqlite3_free(tls, zFile)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, ts+24042 /* "write failed: " */, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// test_control_pending_byte  PENDING_BYTE
//
// Set the PENDING_BYTE using the sqlite3_test_control() interface.
func testPendingByte(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:558:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pbyte int32 at bp+40, 4

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+24057 /* " PENDING-BYTE\"" */, uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+40 /* &pbyte */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PENDING_BYTE, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 40 /* pbyte */))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// The sqlite3FaultSim() callback:
var faultSimInterp uintptr = uintptr(0) /* test2.c:580:19 */
var faultSimScriptSize int32 = 0        /* test2.c:581:12 */
var faultSimScript uintptr              /* test2.c:582:13: */

func faultSimCallback(tls *libc.TLS, x int32) int32 { /* test2.c:583:12: */
	bp := tls.Alloc(38)
	defer tls.Free(38)

	// var zInt [30]int8 at bp+8, 30

	var i int32
	var isNeg int32
	var rc int32
	if x == 0 {
		libc.Xmemcpy(tls, (faultSimScript + uintptr(faultSimScriptSize)), ts+13873 /* "0" */, uint32(2))
	} else {
		// Convert x to text without using any sqlite3 routines
		if x < 0 {
			isNeg = 1
			x = -x
		} else {
			isNeg = 0
		}
		*(*int8)(unsafe.Pointer(bp + 8 /* &zInt[0] */ + 29)) = int8(0)
		i = (int32(uint32(unsafe.Sizeof([30]int8{})) - uint32(2)))
	__1:
		if !((i > 0) && (x > 0)) {
			goto __3
		}
		{
			*(*int8)(unsafe.Pointer(bp + 8 /* &zInt[0] */ + uintptr(i))) = (int8((x % 10) + '0'))

		}
		goto __2
	__2:
		i--
		x = x / (10)
		goto __1
		goto __3
	__3:
		;
		if isNeg != 0 {
			*(*int8)(unsafe.Pointer(bp + 8 /* &zInt[0] */ + uintptr(libc.PostDecInt32(&i, 1)))) = int8('-')
		}
		libc.Xmemcpy(tls, (faultSimScript + uintptr(faultSimScriptSize)), ((bp + 8 /* &zInt[0] */ + uintptr(i)) + uintptr(1)), (uint32(unsafe.Sizeof([30]int8{})) - uint32(i)))
	}
	rc = tcl.XTcl_Eval(tls, faultSimInterp, faultSimScript)
	if rc != 0 {
		libc.Xfprintf(tls, libc.Xstderr, ts+24072 /* "fault simulator ..." */, libc.VaList(bp, faultSimScript))
		rc = SQLITE_ERROR
	} else {
		rc = libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, faultSimInterp))
	}
	tcl.XTcl_ResetResult(tls, faultSimInterp)
	return rc
}

// sqlite3_test_control_fault_install SCRIPT
//
// Arrange to invoke SCRIPT with the integer argument to sqlite3FaultSim()
// appended, whenever sqlite3FaultSim() is called.  Or, if SCRIPT is the
// empty string, cancel the sqlite3FaultSim() callback.
func faultInstallCmd(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:623:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var zScript uintptr
	var nScript int32
	var rc int32
	if (argc != 1) && (argc != 2) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+24108 /* " SCRIPT\"" */, uintptr(0)))
	}
	if argc == 2 {
		zScript = *(*uintptr)(unsafe.Pointer(argv + 1*4))
	} else {
		zScript = ts + 489 /* "" */
	}
	nScript = int32(libc.Xstrlen(tls, zScript))
	if faultSimScript != 0 {
		libc.Xfree(tls, faultSimScript)
		faultSimScript = uintptr(0)
	}
	if nScript == 0 {
		rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_FAULT_INSTALL, libc.VaList(bp+32, 0))
	} else {
		faultSimScript = libc.Xmalloc(tls, (uint32(nScript + 100)))
		if faultSimScript == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+1930 /* "out of memory" */, uintptr(0)))
			return SQLITE_ERROR
		}
		libc.Xmemcpy(tls, faultSimScript, zScript, uint32(nScript))
		*(*int8)(unsafe.Pointer(faultSimScript + uintptr(nScript))) = int8(' ')
		faultSimScriptSize = (nScript + 1)
		faultSimInterp = interp
		rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_FAULT_INSTALL, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) int32 }{faultSimCallback}))))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return SQLITE_OK
}

// sqlite3BitvecBuiltinTest SIZE PROGRAM
//
// Invoke the SQLITE_TESTCTRL_BITVEC_TEST operator on test_control.
// See comments on sqlite3BitvecBuiltinTest() for additional information.
func testBitvecBuiltinTest(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:666:26: */
	bp := tls.Alloc(452)
	defer tls.Free(452)

	// var sz int32 at bp+48, 4

	var rc int32
	var nProg int32 = 0
	// var aProg [100]int32 at bp+52, 400

	var z uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+24117 /* " SIZE PROGRAM\"" */, uintptr(0)))
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48 /* &sz */) != 0 {
		return TCL_ERROR
	}
	z = *(*uintptr)(unsafe.Pointer(argv + 2*4))
	for (nProg < 99) && (*(*int8)(unsafe.Pointer(z)) != 0) {
		for (*(*int8)(unsafe.Pointer(z)) != 0) && !((int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))]) & 0x04) != 0) {
			z++
		}
		if int32(*(*int8)(unsafe.Pointer(z))) == 0 {
			break
		}
		*(*int32)(unsafe.Pointer(bp + 52 /* &aProg[0] */ + uintptr(libc.PostIncInt32(&nProg, 1))*4)) = libc.Xatoi(tls, z)
		for (int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))]) & 0x04) != 0 {
			z++
		}
	}
	*(*int32)(unsafe.Pointer(bp + 52 /* &aProg[0] */ + uintptr(nProg)*4)) = 0
	rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_BITVEC_TEST, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 48 /* sz */)), bp+52 /* &aProg[0] */))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest2_Init(tls *libc.TLS, interp uintptr) int32 { /* test2.c:697:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aCmd2)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd2[i].FzName, aCmd2[i].FxProc, uintptr(0), uintptr(0))
	}
	tcl.XTcl_LinkVar(tls, interp, ts+24132, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_pending)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24156, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_persist)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24180, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_hit)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24200, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_hardhit)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24224, /* "sqlite_diskfull_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_diskfull_pending)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24248, /* "sqlite_diskfull" */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_diskfull)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24264, /* "sqlite_pending_b..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3PendingByte)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	return TCL_OK
}

var aCmd2 = [20]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 24284 /* "pager_open" */, FxProc: 0},
	{FzName: ts + 24295 /* "pager_close" */, FxProc: 0},
	{FzName: ts + 24307 /* "pager_commit" */, FxProc: 0},
	{FzName: ts + 24320 /* "pager_rollback" */, FxProc: 0},
	{FzName: ts + 24335 /* "pager_stmt_begin" */, FxProc: 0},
	{FzName: ts + 24352 /* "pager_stmt_commi..." */, FxProc: 0},
	{FzName: ts + 24370 /* "pager_stmt_rollb..." */, FxProc: 0},
	{FzName: ts + 24390 /* "pager_stats" */, FxProc: 0},
	{FzName: ts + 24402 /* "pager_pagecount" */, FxProc: 0},
	{FzName: ts + 24418 /* "page_get" */, FxProc: 0},
	{FzName: ts + 24427 /* "page_lookup" */, FxProc: 0},
	{FzName: ts + 24439 /* "page_unref" */, FxProc: 0},
	{FzName: ts + 24450 /* "page_read" */, FxProc: 0},
	{FzName: ts + 24460 /* "page_write" */, FxProc: 0},
	{FzName: ts + 24471 /* "page_number" */, FxProc: 0},
	{FzName: ts + 24483 /* "pager_truncate" */, FxProc: 0},
	{FzName: ts + 24498 /* "fake_big_file" */, FxProc: 0},
	{FzName: ts + 24512 /* "sqlite3BitvecBui..." */, FxProc: 0},
	{FzName: ts + 24537 /* "sqlite3_test_con..." */, FxProc: 0},
	{FzName: ts + 24571 /* "sqlite3_test_con..." */, FxProc: 0},
} /* test2.c:707:5 */

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite B-Tree file
// subsystem.  See comments in the source code for a detailed description
// of what each interface routine does.

// TODO: This definition is just included so other modules compile. It
// needs to be revisited.

// If defined as non-zero, auto-vacuum is enabled by default. Otherwise
// it must be turned on for each database using "PRAGMA auto_vacuum = 1".

// Forward declarations of structure
type Btree = Btree1       /* btree.h:39:22 */
type BtCursor = BtCursor1 /* btree.h:40:25 */
type BtShared = BtShared1 /* btree.h:41:25 */

// 2004 April 6
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This file implements an external (disk-based) database using BTrees.
// For a detailed discussion of BTrees, refer to
//
//     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:
//     "Sorting And Searching", pages 473-480. Addison-Wesley
//     Publishing Company, Reading, Massachusetts.
//
// The basic idea is that each page of the file contains N database
// entries and N+1 pointers to subpages.
//
//   ----------------------------------------------------------------
//   |  Ptr(0) | Key(0) | Ptr(1) | Key(1) | ... | Key(N-1) | Ptr(N) |
//   ----------------------------------------------------------------
//
// All of the keys on the page that Ptr(0) points to have values less
// than Key(0).  All of the keys on page Ptr(1) and its subpages have
// values greater than Key(0) and less than Key(1).  All of the keys
// on Ptr(N) and its subpages have values greater than Key(N-1).  And
// so forth.
//
// Finding a particular key requires reading O(log(M)) pages from the
// disk where M is the number of entries in the tree.
//
// In this implementation, a single file can hold one or more separate
// BTrees.  Each BTree is identified by the index of its root page.  The
// key and data for any entry are combined to form the "payload".  A
// fixed amount of payload can be carried directly on the database
// page.  If the payload is larger than the preset amount then surplus
// bytes are stored on overflow pages.  The payload for an entry
// and the preceding pointer are combined to form a "Cell".  Each
// page has a small header which contains the Ptr(N) pointer and other
// information such as the size of key and data.
//
// FORMAT DETAILS
//
// The file is divided into pages.  The first page is called page 1,
// the second is page 2, and so forth.  A page number of zero indicates
// "no such page".  The page size can be any power of 2 between 512 and 65536.
// Each page can be either a btree page, a freelist page, an overflow
// page, or a pointer-map page.
//
// The first page is always a btree page.  The first 100 bytes of the first
// page contain a special header (the "file header") that describes the file.
// The format of the file header is as follows:
//
//   OFFSET   SIZE    DESCRIPTION
//      0      16     Header string: "SQLite format 3\000"
//     16       2     Page size in bytes.  (1 means 65536)
//     18       1     File format write version
//     19       1     File format read version
//     20       1     Bytes of unused space at the end of each page
//     21       1     Max embedded payload fraction (must be 64)
//     22       1     Min embedded payload fraction (must be 32)
//     23       1     Min leaf payload fraction (must be 32)
//     24       4     File change counter
//     28       4     Reserved for future use
//     32       4     First freelist page
//     36       4     Number of freelist pages in the file
//     40      60     15 4-byte meta values passed to higher layers
//
//     40       4     Schema cookie
//     44       4     File format of schema layer
//     48       4     Size of page cache
//     52       4     Largest root-page (auto/incr_vacuum)
//     56       4     1=UTF-8 2=UTF16le 3=UTF16be
//     60       4     User version
//     64       4     Incremental vacuum mode
//     68       4     Application-ID
//     72      20     unused
//     92       4     The version-valid-for number
//     96       4     SQLITE_VERSION_NUMBER
//
// All of the integer values are big-endian (most significant byte first).
//
// The file change counter is incremented when the database is changed
// This counter allows other processes to know when the file has changed
// and thus when they need to flush their cache.
//
// The max embedded payload fraction is the amount of the total usable
// space in a page that can be consumed by a single cell for standard
// B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default
// is to limit the maximum cell size so that at least 4 cells will fit
// on one page.  Thus the default max embedded payload fraction is 64.
//
// If the payload for a cell is larger than the max payload, then extra
// payload is spilled to overflow pages.  Once an overflow page is allocated,
// as many bytes as possible are moved into the overflow pages without letting
// the cell size drop below the min embedded payload fraction.
//
// The min leaf payload fraction is like the min embedded payload fraction
// except that it applies to leaf nodes in a LEAFDATA tree.  The maximum
// payload fraction for a LEAFDATA tree is always 100% (or 255) and it
// not specified in the header.
//
// Each btree pages is divided into three sections:  The header, the
// cell pointer array, and the cell content area.  Page 1 also has a 100-byte
// file header that occurs before the page header.
//
//      |----------------|
//      | file header    |   100 bytes.  Page 1 only.
//      |----------------|
//      | page header    |   8 bytes for leaves.  12 bytes for interior nodes
//      |----------------|
//      | cell pointer   |   |  2 bytes per cell.  Sorted order.
//      | array          |   |  Grows downward
//      |                |   v
//      |----------------|
//      | unallocated    |
//      | space          |
//      |----------------|   ^  Grows upwards
//      | cell content   |   |  Arbitrary order interspersed with freeblocks.
//      | area           |   |  and free space fragments.
//      |----------------|
//
// The page headers looks like this:
//
//   OFFSET   SIZE     DESCRIPTION
//      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf
//      1       2      byte offset to the first freeblock
//      3       2      number of cells on this page
//      5       2      first byte of the cell content area
//      7       1      number of fragmented free bytes
//      8       4      Right child (the Ptr(N) value).  Omitted on leaves.
//
// The flags define the format of this btree page.  The leaf flag means that
// this page has no children.  The zerodata flag means that this page carries
// only keys and no data.  The intkey flag means that the key is an integer
// which is stored in the key size entry of the cell header rather than in
// the payload area.
//
// The cell pointer array begins on the first byte after the page header.
// The cell pointer array contains zero or more 2-byte numbers which are
// offsets from the beginning of the page to the cell content in the cell
// content area.  The cell pointers occur in sorted order.  The system strives
// to keep free space after the last cell pointer so that new cells can
// be easily added without having to defragment the page.
//
// Cell content is stored at the very end of the page and grows toward the
// beginning of the page.
//
// Unused space within the cell content area is collected into a linked list of
// freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset
// to the first freeblock is given in the header.  Freeblocks occur in
// increasing order.  Because a freeblock must be at least 4 bytes in size,
// any group of 3 or fewer unused bytes in the cell content area cannot
// exist on the freeblock chain.  A group of 3 or fewer free bytes is called
// a fragment.  The total number of bytes in all fragments is recorded.
// in the page header at offset 7.
//
//    SIZE    DESCRIPTION
//      2     Byte offset of the next freeblock
//      2     Bytes in this freeblock
//
// Cells are of variable length.  Cells are stored in the cell content area at
// the end of the page.  Pointers to the cells are in the cell pointer array
// that immediately follows the page header.  Cells is not necessarily
// contiguous or in order, but cell pointers are contiguous and in order.
//
// Cell content makes use of variable length integers.  A variable
// length integer is 1 to 9 bytes where the lower 7 bits of each
// byte are used.  The integer consists of all bytes that have bit 8 set and
// the first byte with bit 8 clear.  The most significant byte of the integer
// appears first.  A variable-length integer may not be more than 9 bytes long.
// As a special case, all 8 bytes of the 9th byte are used as data.  This
// allows a 64-bit integer to be encoded in 9 bytes.
//
//    0x00                      becomes  0x00000000
//    0x7f                      becomes  0x0000007f
//    0x81 0x00                 becomes  0x00000080
//    0x82 0x00                 becomes  0x00000100
//    0x80 0x7f                 becomes  0x0000007f
//    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678
//    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081
//
// Variable length integers are used for rowids and to hold the number of
// bytes of key and data in a btree cell.
//
// The content of a cell looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of the left child. Omitted if leaf flag is set.
//     var    Number of bytes of data. Omitted if the zerodata flag is set.
//     var    Number of bytes of key. Or the key itself if intkey flag is set.
//      *     Payload
//      4     First page of the overflow chain.  Omitted if no overflow
//
// Overflow pages form a linked list.  Each page except the last is completely
// filled with data (pagesize - 4 bytes).  The last page can have as little
// as 1 byte of data.
//
//    SIZE    DESCRIPTION
//      4     Page number of next overflow page
//      *     Data
//
// Freelist pages come in two subtypes: trunk pages and leaf pages.  The
// file header points to the first in a linked list of trunk page.  Each trunk
// page points to multiple leaf pages.  The content of a leaf page is
// unspecified.  A trunk page looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of next trunk page
//      4     Number of leaf pointers on this page
//      *     zero or more pages numbers of leaves
// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Internal interface definitions for SQLite.
//

// The following value is the maximum cell size assuming a maximum page
// size give above.

// The maximum number of cells on a single page of the database.  This
// assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself
// plus 2 bytes for the index to the cell in the page header).  Such
// small cells will be rare, but they are possible.

// Forward declarations
type MemPage1 = struct {
	FisInit          u8
	FbBusy           u8
	FintKey          u8
	FintKeyLeaf      u8
	Fpgno            Pgno
	Fleaf            u8
	FhdrOffset       u8
	FchildPtrSize    u8
	Fmax1bytePayload u8
	FnOverflow       u8
	_                [1]byte
	FmaxLocal        u16
	FminLocal        u16
	FcellOffset      u16
	FnFree           int32
	FnCell           u16
	FmaskPage        u16
	FaiOvfl          [4]u16
	FapOvfl          [4]uintptr
	FpBt             uintptr
	FaData           uintptr
	FaDataEnd        uintptr
	FaCellIdx        uintptr
	FaDataOfst       uintptr
	FpDbPage         uintptr
	FxCellSize       uintptr
	FxParseCell      uintptr
} /* btree.h:39:9 */

// 2004 April 6
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This file implements an external (disk-based) database using BTrees.
// For a detailed discussion of BTrees, refer to
//
//     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:
//     "Sorting And Searching", pages 473-480. Addison-Wesley
//     Publishing Company, Reading, Massachusetts.
//
// The basic idea is that each page of the file contains N database
// entries and N+1 pointers to subpages.
//
//   ----------------------------------------------------------------
//   |  Ptr(0) | Key(0) | Ptr(1) | Key(1) | ... | Key(N-1) | Ptr(N) |
//   ----------------------------------------------------------------
//
// All of the keys on the page that Ptr(0) points to have values less
// than Key(0).  All of the keys on page Ptr(1) and its subpages have
// values greater than Key(0) and less than Key(1).  All of the keys
// on Ptr(N) and its subpages have values greater than Key(N-1).  And
// so forth.
//
// Finding a particular key requires reading O(log(M)) pages from the
// disk where M is the number of entries in the tree.
//
// In this implementation, a single file can hold one or more separate
// BTrees.  Each BTree is identified by the index of its root page.  The
// key and data for any entry are combined to form the "payload".  A
// fixed amount of payload can be carried directly on the database
// page.  If the payload is larger than the preset amount then surplus
// bytes are stored on overflow pages.  The payload for an entry
// and the preceding pointer are combined to form a "Cell".  Each
// page has a small header which contains the Ptr(N) pointer and other
// information such as the size of key and data.
//
// FORMAT DETAILS
//
// The file is divided into pages.  The first page is called page 1,
// the second is page 2, and so forth.  A page number of zero indicates
// "no such page".  The page size can be any power of 2 between 512 and 65536.
// Each page can be either a btree page, a freelist page, an overflow
// page, or a pointer-map page.
//
// The first page is always a btree page.  The first 100 bytes of the first
// page contain a special header (the "file header") that describes the file.
// The format of the file header is as follows:
//
//   OFFSET   SIZE    DESCRIPTION
//      0      16     Header string: "SQLite format 3\000"
//     16       2     Page size in bytes.  (1 means 65536)
//     18       1     File format write version
//     19       1     File format read version
//     20       1     Bytes of unused space at the end of each page
//     21       1     Max embedded payload fraction (must be 64)
//     22       1     Min embedded payload fraction (must be 32)
//     23       1     Min leaf payload fraction (must be 32)
//     24       4     File change counter
//     28       4     Reserved for future use
//     32       4     First freelist page
//     36       4     Number of freelist pages in the file
//     40      60     15 4-byte meta values passed to higher layers
//
//     40       4     Schema cookie
//     44       4     File format of schema layer
//     48       4     Size of page cache
//     52       4     Largest root-page (auto/incr_vacuum)
//     56       4     1=UTF-8 2=UTF16le 3=UTF16be
//     60       4     User version
//     64       4     Incremental vacuum mode
//     68       4     Application-ID
//     72      20     unused
//     92       4     The version-valid-for number
//     96       4     SQLITE_VERSION_NUMBER
//
// All of the integer values are big-endian (most significant byte first).
//
// The file change counter is incremented when the database is changed
// This counter allows other processes to know when the file has changed
// and thus when they need to flush their cache.
//
// The max embedded payload fraction is the amount of the total usable
// space in a page that can be consumed by a single cell for standard
// B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default
// is to limit the maximum cell size so that at least 4 cells will fit
// on one page.  Thus the default max embedded payload fraction is 64.
//
// If the payload for a cell is larger than the max payload, then extra
// payload is spilled to overflow pages.  Once an overflow page is allocated,
// as many bytes as possible are moved into the overflow pages without letting
// the cell size drop below the min embedded payload fraction.
//
// The min leaf payload fraction is like the min embedded payload fraction
// except that it applies to leaf nodes in a LEAFDATA tree.  The maximum
// payload fraction for a LEAFDATA tree is always 100% (or 255) and it
// not specified in the header.
//
// Each btree pages is divided into three sections:  The header, the
// cell pointer array, and the cell content area.  Page 1 also has a 100-byte
// file header that occurs before the page header.
//
//      |----------------|
//      | file header    |   100 bytes.  Page 1 only.
//      |----------------|
//      | page header    |   8 bytes for leaves.  12 bytes for interior nodes
//      |----------------|
//      | cell pointer   |   |  2 bytes per cell.  Sorted order.
//      | array          |   |  Grows downward
//      |                |   v
//      |----------------|
//      | unallocated    |
//      | space          |
//      |----------------|   ^  Grows upwards
//      | cell content   |   |  Arbitrary order interspersed with freeblocks.
//      | area           |   |  and free space fragments.
//      |----------------|
//
// The page headers looks like this:
//
//   OFFSET   SIZE     DESCRIPTION
//      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf
//      1       2      byte offset to the first freeblock
//      3       2      number of cells on this page
//      5       2      first byte of the cell content area
//      7       1      number of fragmented free bytes
//      8       4      Right child (the Ptr(N) value).  Omitted on leaves.
//
// The flags define the format of this btree page.  The leaf flag means that
// this page has no children.  The zerodata flag means that this page carries
// only keys and no data.  The intkey flag means that the key is an integer
// which is stored in the key size entry of the cell header rather than in
// the payload area.
//
// The cell pointer array begins on the first byte after the page header.
// The cell pointer array contains zero or more 2-byte numbers which are
// offsets from the beginning of the page to the cell content in the cell
// content area.  The cell pointers occur in sorted order.  The system strives
// to keep free space after the last cell pointer so that new cells can
// be easily added without having to defragment the page.
//
// Cell content is stored at the very end of the page and grows toward the
// beginning of the page.
//
// Unused space within the cell content area is collected into a linked list of
// freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset
// to the first freeblock is given in the header.  Freeblocks occur in
// increasing order.  Because a freeblock must be at least 4 bytes in size,
// any group of 3 or fewer unused bytes in the cell content area cannot
// exist on the freeblock chain.  A group of 3 or fewer free bytes is called
// a fragment.  The total number of bytes in all fragments is recorded.
// in the page header at offset 7.
//
//    SIZE    DESCRIPTION
//      2     Byte offset of the next freeblock
//      2     Bytes in this freeblock
//
// Cells are of variable length.  Cells are stored in the cell content area at
// the end of the page.  Pointers to the cells are in the cell pointer array
// that immediately follows the page header.  Cells is not necessarily
// contiguous or in order, but cell pointers are contiguous and in order.
//
// Cell content makes use of variable length integers.  A variable
// length integer is 1 to 9 bytes where the lower 7 bits of each
// byte are used.  The integer consists of all bytes that have bit 8 set and
// the first byte with bit 8 clear.  The most significant byte of the integer
// appears first.  A variable-length integer may not be more than 9 bytes long.
// As a special case, all 8 bytes of the 9th byte are used as data.  This
// allows a 64-bit integer to be encoded in 9 bytes.
//
//    0x00                      becomes  0x00000000
//    0x7f                      becomes  0x0000007f
//    0x81 0x00                 becomes  0x00000080
//    0x82 0x00                 becomes  0x00000100
//    0x80 0x7f                 becomes  0x0000007f
//    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678
//    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081
//
// Variable length integers are used for rowids and to hold the number of
// bytes of key and data in a btree cell.
//
// The content of a cell looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of the left child. Omitted if leaf flag is set.
//     var    Number of bytes of data. Omitted if the zerodata flag is set.
//     var    Number of bytes of key. Or the key itself if intkey flag is set.
//      *     Payload
//      4     First page of the overflow chain.  Omitted if no overflow
//
// Overflow pages form a linked list.  Each page except the last is completely
// filled with data (pagesize - 4 bytes).  The last page can have as little
// as 1 byte of data.
//
//    SIZE    DESCRIPTION
//      4     Page number of next overflow page
//      *     Data
//
// Freelist pages come in two subtypes: trunk pages and leaf pages.  The
// file header points to the first in a linked list of trunk page.  Each trunk
// page points to multiple leaf pages.  The content of a leaf page is
// unspecified.  A trunk page looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of next trunk page
//      4     Number of leaf pointers on this page
//      *     zero or more pages numbers of leaves
// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Internal interface definitions for SQLite.
//

// The following value is the maximum cell size assuming a maximum page
// size give above.

// The maximum number of cells on a single page of the database.  This
// assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself
// plus 2 bytes for the index to the cell in the page header).  Such
// small cells will be rare, but they are possible.

// Forward declarations
type MemPage = MemPage1 /* btreeInt.h:232:24 */
type BtLock1 = struct {
	FpBtree uintptr
	FiTable Pgno
	FeLock  u8
	_       [3]byte
	FpNext  uintptr
} /* btree.h:39:9 */

type BtLock = BtLock1 /* btreeInt.h:233:23 */
type CellInfo1 = struct {
	FnKey     i64
	FpPayload uintptr
	FnPayload u32
	FnLocal   u16
	FnSize    u16
	_         [4]byte
} /* btree.h:39:9 */

type CellInfo = CellInfo1 /* btreeInt.h:234:25 */

// Legal values for BtCursor.curFlags

// Potential values for BtCursor.eState.
//
// CURSOR_INVALID:
//   Cursor does not point to a valid entry. This can happen (for example)
//   because the table is empty or because BtreeCursorFirst() has not been
//   called.
//
// CURSOR_VALID:
//   Cursor points to a valid entry. getPayload() etc. may be called.
//
// CURSOR_SKIPNEXT:
//   Cursor is valid except that the Cursor.skipNext field is non-zero
//   indicating that the next sqlite3BtreeNext() or sqlite3BtreePrevious()
//   operation should be a no-op.
//
// CURSOR_REQUIRESEEK:
//   The table that this cursor was opened on still exists, but has been
//   modified since the cursor was last used. The cursor position is saved
//   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in
//   this state, restoreCursorPosition() can be called to attempt to
//   seek the cursor to the saved position.
//
// CURSOR_FAULT:
//   An unrecoverable error (an I/O error or a malloc failure) has occurred
//   on a different connection that shares the BtShared cache with this
//   cursor.  The error has left the cache in an inconsistent state.
//   Do nothing else with this cursor.  Any attempt to use the cursor
//   should return the error code stored in BtCursor.skipNext

// The database page the PENDING_BYTE occupies. This page is never used.

// These macros define the location of the pointer-map entry for a
// database page. The first argument to each is the number of usable
// bytes on each page of the database (often 1024). The second is the
// page number to look up in the pointer map.
//
// PTRMAP_PAGENO returns the database page number of the pointer-map
// page that stores the required pointer. PTRMAP_PTROFFSET returns
// the offset of the requested map entry.
//
// If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,
// then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be
// used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements
// this test.

// The pointer map is a lookup table that identifies the parent page for
// each child page in the database file.  The parent page is the page that
// contains a pointer to the child.  Every page in the database contains
// 0 or 1 parent pages.  (In this context 'database page' refers
// to any page that is not part of the pointer map itself.)  Each pointer map
// entry consists of a single byte 'type' and a 4 byte parent page number.
// The PTRMAP_XXX identifiers below are the valid types.
//
// The purpose of the pointer map is to facility moving pages from one
// position in the file to another as part of autovacuum.  When a page
// is moved, the pointer in its parent must be updated to point to the
// new location.  The pointer map is used to locate the parent page quickly.
//
// PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not
//                  used in this case.
//
// PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number
//                  is not used in this case.
//
// PTRMAP_OVERFLOW1: The database page is the first page in a list of
//                   overflow pages. The page number identifies the page that
//                   contains the cell with a pointer to this overflow page.
//
// PTRMAP_OVERFLOW2: The database page is the second or later page in a list of
//                   overflow pages. The page-number identifies the previous
//                   page in the overflow page list.
//
// PTRMAP_BTREE: The database page is a non-root btree page. The page number
//               identifies the parent page in the btree.

// A bunch of assert() statements to check the transaction state variables
// of handle p (type Btree*) are internally consistent.

// The ISAUTOVACUUM macro is used within balance_nonroot() to determine
// if the database supports auto-vacuum or not. Because it is used
// within an expression that is an argument to another macro
// (sqliteMallocRaw), it is not possible to use conditional compilation.
// So, this macro is defined instead.

// This structure is passed around through all the sanity checking routines
// in order to keep track of some global state information.
//
// The aRef[] array is allocated so that there is 1 bit for each page in
// the database. As the integrity-check proceeds, for each page used in
// the database the corresponding bit is set. This allows integrity-check to
// detect pages that are used twice and orphaned pages (both of which
// indicate corruption).
type IntegrityCk1 = struct {
	FpBt       uintptr
	FpPager    uintptr
	FaPgRef    uintptr
	FnPage     Pgno
	FmxErr     int32
	FnErr      int32
	FbOomFault int32
	FzPfx      uintptr
	Fv1        Pgno
	Fv2        int32
	FerrMsg    StrAccum
	Fheap      uintptr
	Fdb        uintptr
} /* btreeInt.h:692:9 */

// Legal values for BtCursor.curFlags

// Potential values for BtCursor.eState.
//
// CURSOR_INVALID:
//   Cursor does not point to a valid entry. This can happen (for example)
//   because the table is empty or because BtreeCursorFirst() has not been
//   called.
//
// CURSOR_VALID:
//   Cursor points to a valid entry. getPayload() etc. may be called.
//
// CURSOR_SKIPNEXT:
//   Cursor is valid except that the Cursor.skipNext field is non-zero
//   indicating that the next sqlite3BtreeNext() or sqlite3BtreePrevious()
//   operation should be a no-op.
//
// CURSOR_REQUIRESEEK:
//   The table that this cursor was opened on still exists, but has been
//   modified since the cursor was last used. The cursor position is saved
//   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in
//   this state, restoreCursorPosition() can be called to attempt to
//   seek the cursor to the saved position.
//
// CURSOR_FAULT:
//   An unrecoverable error (an I/O error or a malloc failure) has occurred
//   on a different connection that shares the BtShared cache with this
//   cursor.  The error has left the cache in an inconsistent state.
//   Do nothing else with this cursor.  Any attempt to use the cursor
//   should return the error code stored in BtCursor.skipNext

// The database page the PENDING_BYTE occupies. This page is never used.

// These macros define the location of the pointer-map entry for a
// database page. The first argument to each is the number of usable
// bytes on each page of the database (often 1024). The second is the
// page number to look up in the pointer map.
//
// PTRMAP_PAGENO returns the database page number of the pointer-map
// page that stores the required pointer. PTRMAP_PTROFFSET returns
// the offset of the requested map entry.
//
// If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,
// then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be
// used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements
// this test.

// The pointer map is a lookup table that identifies the parent page for
// each child page in the database file.  The parent page is the page that
// contains a pointer to the child.  Every page in the database contains
// 0 or 1 parent pages.  (In this context 'database page' refers
// to any page that is not part of the pointer map itself.)  Each pointer map
// entry consists of a single byte 'type' and a 4 byte parent page number.
// The PTRMAP_XXX identifiers below are the valid types.
//
// The purpose of the pointer map is to facility moving pages from one
// position in the file to another as part of autovacuum.  When a page
// is moved, the pointer in its parent must be updated to point to the
// new location.  The pointer map is used to locate the parent page quickly.
//
// PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not
//                  used in this case.
//
// PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number
//                  is not used in this case.
//
// PTRMAP_OVERFLOW1: The database page is the first page in a list of
//                   overflow pages. The page number identifies the page that
//                   contains the cell with a pointer to this overflow page.
//
// PTRMAP_OVERFLOW2: The database page is the second or later page in a list of
//                   overflow pages. The page-number identifies the previous
//                   page in the overflow page list.
//
// PTRMAP_BTREE: The database page is a non-root btree page. The page number
//               identifies the parent page in the btree.

// A bunch of assert() statements to check the transaction state variables
// of handle p (type Btree*) are internally consistent.

// The ISAUTOVACUUM macro is used within balance_nonroot() to determine
// if the database supports auto-vacuum or not. Because it is used
// within an expression that is an argument to another macro
// (sqliteMallocRaw), it is not possible to use conditional compilation.
// So, this macro is defined instead.

// This structure is passed around through all the sanity checking routines
// in order to keep track of some global state information.
//
// The aRef[] array is allocated so that there is 1 bit for each page in
// the database. As the integrity-check proceeds, for each page used in
// the database the corresponding bit is set. This allows integrity-check to
// detect pages that are used twice and orphaned pages (both of which
// indicate corruption).
type IntegrityCk = IntegrityCk1 /* btreeInt.h:692:28 */

// A bogus sqlite3 connection structure for use in the btree
// tests.
var sDb sqlite31          /* test3.c:32:16: */
var nRefSqlite3 int32 = 0 /* test3.c:33:12 */

// Usage:   btree_open FILENAME NCACHE
//
// Open a new database
func btree_open(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:40:26: */
	bp := tls.Alloc(180)
	defer tls.Free(180)

	// var pBt uintptr at bp+76, 4

	var rc int32
	// var nCache int32 at bp+72, 4

	// var zBuf [100]int8 at bp+80, 100

	var n int32
	var zFilename uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+24606 /* " FILENAME NCACHE..." */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+72 /* &nCache */) != 0 {
		return TCL_ERROR
	}
	nRefSqlite3++
	if nRefSqlite3 == 1 {
		sDb.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		sDb.Fmutex = sqlite3.Xsqlite3MutexAlloc(tls, SQLITE_MUTEX_RECURSIVE)
		sqlite3.Xsqlite3_mutex_enter(tls, sDb.Fmutex)
	}
	n = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	zFilename = sqlite3.Xsqlite3_malloc(tls, (n + 2))
	if zFilename == uintptr(0) {
		return TCL_ERROR
	}
	libc.Xmemcpy(tls, zFilename, *(*uintptr)(unsafe.Pointer(argv + 1*4)), (uint32(n + 1)))
	*(*int8)(unsafe.Pointer(zFilename + uintptr((n + 1)))) = int8(0)
	rc = sqlite3.Xsqlite3BtreeOpen(tls, sDb.FpVfs, zFilename, uintptr(unsafe.Pointer(&sDb)), bp+76 /* &pBt */, 0,
		((SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE) | SQLITE_OPEN_MAIN_DB))
	sqlite3.Xsqlite3_free(tls, zFilename)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3BtreeSetCacheSize(tls, *(*uintptr)(unsafe.Pointer(bp + 76 /* pBt */)), *(*int32)(unsafe.Pointer(bp + 72 /* nCache */)))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+80 /* &zBuf[0] */, ts+13021 /* "%p" */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 76 /* pBt */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+80 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   btree_close ID
//
// Close the given database.
func btree_close(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:86:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pBt uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3BtreeClose(tls, pBt)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	nRefSqlite3--
	if nRefSqlite3 == 0 {
		sqlite3.Xsqlite3_mutex_leave(tls, sDb.Fmutex)
		sqlite3.Xsqlite3_mutex_free(tls, sDb.Fmutex)
		sDb.Fmutex = uintptr(0)
		sDb.FpVfs = uintptr(0)
	}
	return TCL_OK
}

// Usage:   btree_begin_transaction ID
//
// Start a new transaction
func btree_begin_transaction(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:121:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pBt uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	rc = sqlite3.Xsqlite3BtreeBeginTrans(tls, pBt, 1, uintptr(0))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   btree_pager_stats ID
//
// Returns pager statistics
func btree_pager_stats(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:150:26: */
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var pBt uintptr
	var i int32
	var a uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))

	// Normally in this file, with a b-tree handle opened using the
	// [btree_open] command it is safe to call sqlite3BtreeEnter() directly.
	// But this function is sometimes called with a btree handle obtained
	// from an open SQLite connection (using [btree_from_db]). In this case
	// we need to obtain the mutex for the controlling SQLite handle before
	// it is safe to call sqlite3BtreeEnter().
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)

	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	a = sqlite3.Xsqlite3PagerStats(tls, sqlite3.Xsqlite3BtreePager(tls, pBt))
	for i = 0; i < 11; i++ {
		// var zBuf [100]int8 at bp+40, 100

		tcl.XTcl_AppendElement(tls, interp, zName1[i])
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
		tcl.XTcl_AppendElement(tls, interp, bp+40 /* &zBuf[0] */)
	}
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)

	// Release the mutex on the SQLite handle that controls this b-tree
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	return TCL_OK
}

var zName1 = [11]uintptr{
	ts + 23939 /* "ref" */, ts + 23943 /* "page" */, ts + 17912 /* "max" */, ts + 11491 /* "size" */, ts + 10193 /* "state" */, ts + 23948, /* "err" */
	ts + 23952 /* "hit" */, ts + 23956 /* "miss" */, ts + 23961 /* "ovfl" */, ts + 24630 /* "read" */, ts + 24635, /* "write" */
} /* test3.c:179:17 */

// Usage:   btree_cursor ID TABLENUM WRITEABLE
//
// Create a new cursor.  Return the ID for the cursor.
func btree_cursor(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:200:26: */
	bp := tls.Alloc(110)
	defer tls.Free(110)

	var pBt uintptr
	// var iTable int32 at bp+72, 4

	var pCur uintptr
	var rc int32 = SQLITE_OK
	// var wrFlag int32 at bp+76, 4

	// var zBuf [30]int8 at bp+80, 30

	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+24641 /* " ID TABLENUM WRI..." */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+72 /* &iTable */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetBoolean(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*4)), bp+76 /* &wrFlag */) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 76 /* wrFlag */)) != 0 {
		*(*int32)(unsafe.Pointer(bp + 76 /* wrFlag */)) = BTREE_WRCSR
	}
	pCur = tcl.XTcl_Alloc(tls, uint32(sqlite3.Xsqlite3BtreeCursorSize(tls)))
	libc.Xmemset(tls, pCur, 0, uint32(sqlite3.Xsqlite3BtreeCursorSize(tls)))
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	rc = sqlite3.Xsqlite3BtreeLockTable(tls, pBt, *(*int32)(unsafe.Pointer(bp + 72 /* iTable */)), libc.BoolUint8(!(!(*(*int32)(unsafe.Pointer(bp + 76 /* wrFlag */)) != 0))))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3BtreeCursor(tls, pBt, uint32(*(*int32)(unsafe.Pointer(bp + 72 /* iTable */))), *(*int32)(unsafe.Pointer(bp + 76 /* wrFlag */)), uintptr(0), pCur)
	}
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	if rc != 0 {
		tcl.XTcl_Free(tls, pCur)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+80 /* &zBuf[0] */, ts+13021 /* "%p" */, libc.VaList(bp+48, pCur))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+80 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// Usage:   btree_close_cursor ID
//
// Close a cursor opened using btree_cursor.
func btree_close_cursor(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:249:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pCur uintptr
	var rc int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	{
		var pBt uintptr = (*BtCursor)(unsafe.Pointer(pCur)).FpBtree
		sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
		sqlite3.Xsqlite3BtreeEnter(tls, pBt)
		rc = sqlite3.Xsqlite3BtreeCloseCursor(tls, pCur)
		sqlite3.Xsqlite3BtreeLeave(tls, pBt)
		sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)

	}
	tcl.XTcl_Free(tls, pCur)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return SQLITE_OK
}

// Usage:   btree_next ID
//
// Move the cursor to the next entry in the table.  Return 0 on success
// or 1 if the cursor was already on the last entry in the table or if
// the table is empty.
func btree_next(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:291:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var pCur uintptr
	var rc int32
	var res int32 = 0
	// var zBuf [100]int8 at bp+72, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeNext(tls, pCur, 0)
	if rc == SQLITE_DONE {
		res = 1
		rc = SQLITE_OK
	}
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+48, res))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+72 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// Usage:   btree_first ID
//
// Move the cursor to the first entry in the table.  Return 0 if the
// cursor was left point to something and 1 if the table is empty.
func btree_first(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:330:26: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	var pCur uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp + 72 /* res */)) = 0
	// var zBuf [100]int8 at bp+76, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeFirst(tls, pCur, bp+72 /* &res */)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+76 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 72 /* res */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+76 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// Usage:   btree_eof ID
//
// Return TRUE if the given cursor is not pointing at a valid entry.
// Return FALSE if the cursor does point to a valid entry.
func btree_eof(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:365:26: */
	bp := tls.Alloc(106)
	defer tls.Free(106)

	var pCur uintptr
	var rc int32
	// var zBuf [50]int8 at bp+56, 50

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeEof(tls, pCur)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+56 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+32, rc))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+56 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// Usage:   btree_payload_size ID
//
// Return the number of bytes of payload
func btree_payload_size(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:394:26: */
	bp := tls.Alloc(106)
	defer tls.Free(106)

	var pCur uintptr
	var n u32
	// var zBuf [50]int8 at bp+56, 50

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	n = sqlite3.Xsqlite3BtreePayloadSize(tls, pCur)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+56 /* &zBuf[0] */, ts+17449 /* "%u" */, libc.VaList(bp+32, n))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+56 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// usage:   varint_test  START  MULTIPLIER  COUNT  INCREMENT
//
// This command tests the putVarint() and getVarint()
// routines, both for accuracy and for speed.
//
// An integer is written using putVarint() and read back with
// getVarint() and varified to be unchanged.  This repeats COUNT
// times.  The first integer is START*MULTIPLIER.  Each iteration
// increases the integer by INCREMENT.
//
// This command returns nothing if it works.  It returns an error message
// if something goes wrong.
func btree_varint_test(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:432:26: */
	bp := tls.Alloc(516)
	defer tls.Free(516)

	// var start u32 at bp+184, 4

	// var mult u32 at bp+188, 4

	// var count u32 at bp+192, 4

	// var incr u32 at bp+196, 4

	var in u64
	// var out u64 at bp+504, 8

	var n1 int32
	var n2 int32
	var i int32
	var j int32
	// var zBuf [100]uint8 at bp+200, 100

	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+24665 /* " START MULTIPLIE..." */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+184 /* &start */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+188 /* &mult */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*4)), bp+192 /* &count */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*4)), bp+196 /* &incr */) != 0 {
		return TCL_ERROR
	}
	in = u64(*(*u32)(unsafe.Pointer(bp + 184 /* start */)))
	in = in * (u64(*(*u32)(unsafe.Pointer(bp + 188 /* mult */))))
	for i = 0; i < int32(*(*u32)(unsafe.Pointer(bp + 192 /* count */))); i++ {
		// var zErr [200]int8 at bp+300, 200

		n1 = sqlite3.Xsqlite3PutVarint(tls, bp+200 /* &zBuf[0] */, in)
		if (n1 > 9) || (n1 < 1) {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
				ts+24700 /* "putVarint return..." */, libc.VaList(bp+32, n1))
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+300 /* &zErr[0] */, 0))
			return TCL_ERROR
		}
		n2 = int32(sqlite3.Xsqlite3GetVarint(tls, bp+200 /* &zBuf[0] */, bp+504 /* &out */))
		if n1 != n2 {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
				ts+24750 /* "putVarint return..." */, libc.VaList(bp+56, n1, n2))
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, bp+300 /* &zErr[0] */, 0))
			return TCL_ERROR
		}
		if in != *(*u64)(unsafe.Pointer(bp + 504 /* out */)) {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
				ts+24798 /* "Wrote 0x%016llx ..." */, libc.VaList(bp+88, in, *(*u64)(unsafe.Pointer(bp + 504 /* out */))))
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+104, bp+300 /* &zErr[0] */, 0))
			return TCL_ERROR
		}
		if (in & uint64(0xffffffff)) == in {
			// var out32 u32 at bp+512, 4

			n2 = int32(func() uint8 {
				if int32(*(*uint8)(unsafe.Pointer(bp + 200 /* zBuf */))) < int32(u8(0x80)) {
					return uint8(func() int32 {
						(*(*u32)(unsafe.Pointer(bp + 512 /* out32 */))) = u32(*(*uint8)(unsafe.Pointer(bp + 200 /* zBuf */)))
						return 1
					}())
				}
				return sqlite3.Xsqlite3GetVarint32(tls, bp+200 /* &zBuf[0] */, bp+512 /* &out32 */)
			}())
			*(*u64)(unsafe.Pointer(bp + 504 /* out */)) = u64(*(*u32)(unsafe.Pointer(bp + 512 /* out32 */)))
			if n1 != n2 {
				sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
					ts+24837, /* "putVarint return..." */
					libc.VaList(bp+120, n1, n2))
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+136, bp+300 /* &zErr[0] */, 0))
				return TCL_ERROR
			}
			if in != *(*u64)(unsafe.Pointer(bp + 504 /* out */)) {
				sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
					ts+24887, /* "Wrote 0x%016llx ..." */
					libc.VaList(bp+152, in, *(*u64)(unsafe.Pointer(bp + 504 /* out */))))
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+168, bp+300 /* &zErr[0] */, 0))
				return TCL_ERROR
			}
		}

		// In order to get realistic timings, run getVarint 19 more times.
		// This is because getVarint is called about 20 times more often
		// than putVarint.
		for j = 0; j < 19; j++ {
			sqlite3.Xsqlite3GetVarint(tls, bp+200 /* &zBuf[0] */, bp+504 /* &out */)
		}
		in = in + (u64(*(*u32)(unsafe.Pointer(bp + 196 /* incr */))))
	}
	return TCL_OK
}

// usage:   btree_from_db  DB-HANDLE
//
// This command returns the btree handle for the main database associated
// with the database-handle passed as the argument. Example usage:
//
// sqlite3 db test.db
// set bt [btree_from_db db]
func btree_from_db(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:516:26: */
	bp := tls.Alloc(204)
	defer tls.Free(204)

	// var zBuf [100]int8 at bp+104, 100

	// var info Tcl_CmdInfo at bp+72, 32

	var db uintptr
	var pBt uintptr
	var iDb int32 = 0

	if (argc != 2) && (argc != 3) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+24943 /* " DB-HANDLE ?N?\"" */, 0))
		return TCL_ERROR
	}

	if 1 != tcl.XTcl_GetCommandInfo(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+72 /* &info */) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+24959 /* "No such db-handl..." */, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+11634 /* "\"" */, 0))
		return TCL_ERROR
	}
	if argc == 3 {
		iDb = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	}

	db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 72 /* &info */)).FobjClientData))

	pBt = (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(db)).FaDb + uintptr(iDb)*16)).FpBt
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+104 /* &zBuf[0] */, ts+13021 /* "%p" */, libc.VaList(bp+64, pBt))
	tcl.XTcl_SetResult(tls, interp, bp+104 /* &zBuf[0] */, uintptr(1))
	return TCL_OK
}

// Usage:   btree_ismemdb ID
//
// Return true if the B-Tree is currently stored entirely in memory.
func btree_ismemdb(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:556:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pBt uintptr
	var res int32
	var pFile uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+23934 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	pFile = sqlite3.Xsqlite3PagerFile(tls, sqlite3.Xsqlite3BtreePager(tls, pBt))
	res = (libc.Bool32((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods == uintptr(0)))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (libc.Bool32((res) != 0))))
	return SQLITE_OK
}

// usage:   btree_set_cache_size ID NCACHE
//
// Set the size of the cache used by btree $ID.
func btree_set_cache_size(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:587:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var nCache int32 at bp+32, 4

	var pBt uintptr

	if argc != 3 {
		tcl.XTcl_AppendResult(tls,
			interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)), ts+24980 /* " BT NCACHE\"" */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+32 /* &nCache */) != 0 {
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	sqlite3.Xsqlite3BtreeSetCacheSize(tls, pBt, *(*int32)(unsafe.Pointer(bp + 32 /* nCache */)))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	return TCL_OK
}

// usage:   btree_insert CSR ?KEY? VALUE
//
// Set the size of the cache used by btree $ID.
func btree_insert(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test3.c:617:26: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var pCur uintptr
	// var rc int32 at bp+56, 4

	// var x BtreePayload at bp+16, 40

	if (objc != 4) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24992 /* "?-intkey? CSR KE..." */)
		return TCL_ERROR
	}

	libc.Xmemset(tls, bp+16 /* &x */, 0, uint32(unsafe.Sizeof(BtreePayload{})))
	if objc == 4 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+56 /* &rc */) != 0 {
			return TCL_ERROR
		}
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FnKey = sqlite3_int64(*(*int32)(unsafe.Pointer(bp + 56 /* rc */)))
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FpData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), (bp + 16 /* &x */ + 28 /* &.nData */))
	} else {
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FpKey = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+56 /* &rc */)
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FnKey = sqlite3_int64(*(*int32)(unsafe.Pointer(bp + 56 /* rc */)))
	}
	pCur = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer((*BtCursor)(unsafe.Pointer(pCur)).FpBtree)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = sqlite3.Xsqlite3BtreeInsert(tls, pCur, bp+16 /* &x */, 0, 0)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer((*BtCursor)(unsafe.Pointer(pCur)).FpBtree)).Fdb)).Fmutex)

	tcl.XTcl_ResetResult(tls, interp)
	if *(*int32)(unsafe.Pointer(bp + 56 /* rc */)) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, *(*int32)(unsafe.Pointer(bp + 56 /* rc */))), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest3_Init(tls *libc.TLS, interp uintptr) int32 { /* test3.c:661:5: */
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aCmd3)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd3[i].FzName, aCmd3[i].FxProc, uintptr(0), uintptr(0))
	}

	tcl.XTcl_CreateObjCommand(tls, interp, ts+25016 /* "btree_insert" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{btree_insert})), uintptr(0), uintptr(0))

	return TCL_OK
}

var aCmd3 = [14]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 25029 /* "btree_open" */, FxProc: 0},
	{FzName: ts + 25040 /* "btree_close" */, FxProc: 0},
	{FzName: ts + 25052 /* "btree_begin_tran..." */, FxProc: 0},
	{FzName: ts + 25076 /* "btree_pager_stat..." */, FxProc: 0},
	{FzName: ts + 25094 /* "btree_cursor" */, FxProc: 0},
	{FzName: ts + 25107 /* "btree_close_curs..." */, FxProc: 0},
	{FzName: ts + 25126 /* "btree_next" */, FxProc: 0},
	{FzName: ts + 25137 /* "btree_eof" */, FxProc: 0},
	{FzName: ts + 25147 /* "btree_payload_si..." */, FxProc: 0},
	{FzName: ts + 25166 /* "btree_first" */, FxProc: 0},
	{FzName: ts + 25178 /* "btree_varint_tes..." */, FxProc: 0},
	{FzName: ts + 25196 /* "btree_from_db" */, FxProc: 0},
	{FzName: ts + 25210 /* "btree_ismemdb" */, FxProc: 0},
	{FzName: ts + 25224 /* "btree_set_cache_..." */, FxProc: 0},
} /* test3.c:665:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Get type definitions.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// NB: Include guard matches what <linux/time.h> uses.

// Get system specific constant and data structure definitions.
// Definitions of constants and data structure for POSIX 1003.1b-1993
//    scheduling interface.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Scheduling algorithms.

// Cloning flags.

// Sched parameter structure.  Generic version.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library;  if not, see
//    <http://www.gnu.org/licenses/>.

// Data structure to describe a process' schedulability.
type sched_param = struct{ Fsched_priority int32 } /* struct_sched_param.h:23:1 */

// Basic access functions.

// Data structure to describe CPU mask.
type cpu_set_t = struct{ F__bits [32]uint32 } /* cpu-set.h:42:3 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.23 Date and time	<time.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// This defines CLOCKS_PER_SEC, which is the number of processor clock
//    ticks per second, and possibly a number of other constants.
// System-dependent timing definitions.  Linux version.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <time.h> instead.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// ISO/IEC 9899:1999 7.23.1: Components of time
//    The macro `CLOCKS_PER_SEC' is an expression with type `clock_t' that is
//    the number per second of the value returned by the `clock' function.
// CAE XSH, Issue 4, Version 2: <time.h>
//    The value of CLOCKS_PER_SEC is required to be 1 million on all
//    XSI-conformant systems.

// Identifier for system-wide realtime clock.
// Monotonic system-wide clock.
// High-resolution timer from the CPU.
// Thread-specific CPU-time clock.
// Monotonic system-wide clock, not adjusted for frequency scaling.
// Identifier for system-wide realtime clock, updated only on ticks.
// Monotonic system-wide clock, updated only on ticks.
// Monotonic system-wide clock that includes time spent in suspension.
// Like CLOCK_REALTIME but also wakes suspended system.
// Like CLOCK_BOOTTIME but also wakes suspended system.
// Like CLOCK_REALTIME but in International Atomic Time.

// Flag to indicate time is absolute.

// Copyright (C) 1995-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// These definitions from linux/timex.h as of 3.18.

type timex = struct {
	Fmodes     uint32
	Foffset    int32
	Ffreq      int32
	Fmaxerror  int32
	Festerror  int32
	Fstatus    int32
	Fconstant  int32
	Fprecision int32
	Ftolerance int32
	Ftime      struct {
		Ftv_sec  int32
		Ftv_usec int32
	}
	Ftick    int32
	Fppsfreq int32
	Fjitter  int32
	Fshift   int32
	Fstabil  int32
	Fjitcnt  int32
	Fcalcnt  int32
	Ferrcnt  int32
	Fstbcnt  int32
	Ftai     int32
	__84     uint32 /* int : 32 */
	__88     uint32 /* int : 32 */
	__92     uint32 /* int : 32 */
	__96     uint32 /* int : 32 */
	__100    uint32 /* int : 32 */
	__104    uint32 /* int : 32 */
	__108    uint32 /* int : 32 */
	__112    uint32 /* int : 32 */
	__116    uint32 /* int : 32 */
	__120    uint32 /* int : 32 */
	__124    uint32 /* int : 32 */
} /* timex.h:26:1 */

// Conditional variable handling.

// Cleanup buffers
type _pthread_cleanup_buffer = struct {
	F__routine    uintptr
	F__arg        uintptr
	F__canceltype int32
	F__prev       uintptr
} /* pthread.h:191:1 */

// No special attributes by default.

// Structure to hold the cleanup handler information.
type __pthread_cleanup_frame = struct {
	F__cancel_routine uintptr
	F__cancel_arg     uintptr
	F__do_it          int32
	F__cancel_type    int32
} /* pthread.h:541:1 */

// Each thread is controlled by an instance of the following
// structure.
type Thread = struct {
	FzFilename  uintptr
	FxOp        uintptr
	FzArg       uintptr
	Fopnum      int32
	Fbusy       int32
	Fcompleted  int32
	Fdb         uintptr
	FpStmt      uintptr
	FzErr       uintptr
	FzStaticErr uintptr
	Frc         int32
	Fargc       int32
	Fargv       [100]uintptr
	Fcolv       [100]uintptr
} /* test4.c:33:23 */

// There can be as many as 26 threads running at once.  Each is named
// by a capital letter: A, B, C, ..., Y, Z.
var threadset [26]Thread /* test4.c:61:15: */

// The main loop for a thread.  Threads use busy waiting.
func test_thread_main(tls *libc.TLS, pArg uintptr) uintptr { /* test4.c:67:13: */
	var p uintptr = pArg
	if (*Thread)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
	}
	sqlite3.Xsqlite3_open(tls, (*Thread)(unsafe.Pointer(p)).FzFilename, (p + 24 /* &.db */))
	if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*Thread)(unsafe.Pointer(p)).Fdb) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.Xstrdup(tls, sqlite3.Xsqlite3_errmsg(tls, (*Thread)(unsafe.Pointer(p)).Fdb))
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
		(*Thread)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fcompleted = 1
	for (*Thread)(unsafe.Pointer(p)).Fopnum <= (*Thread)(unsafe.Pointer(p)).Fcompleted {
		libc2.Xsched_yield(tls)
	}
	for (*Thread)(unsafe.Pointer(p)).FxOp != 0 {
		if ((*Thread)(unsafe.Pointer(p)).FzErr != 0) && ((*Thread)(unsafe.Pointer(p)).FzErr != (*Thread)(unsafe.Pointer(p)).FzStaticErr) {
			sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzErr)
			(*Thread)(unsafe.Pointer(p)).FzErr = uintptr(0)
		}
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((p + 4 /* &.xOp */))))(tls, p)
		(*Thread)(unsafe.Pointer(p)).Fcompleted++
		for (*Thread)(unsafe.Pointer(p)).Fopnum <= (*Thread)(unsafe.Pointer(p)).Fcompleted {
			libc2.Xsched_yield(tls)
		}
	}
	if (*Thread)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	if (*Thread)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
		(*Thread)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	if ((*Thread)(unsafe.Pointer(p)).FzErr != 0) && ((*Thread)(unsafe.Pointer(p)).FzErr != (*Thread)(unsafe.Pointer(p)).FzStaticErr) {
		sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzErr)
		(*Thread)(unsafe.Pointer(p)).FzErr = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).Fcompleted++
	sqlite3.Xsqlite3_thread_cleanup(tls)
	return uintptr(0)
}

// Get a thread ID which is an upper case letter.  Return the index.
// If the argument is not a valid thread ID put an error message in
// the interpreter and return -1.
func parse_thread_id(tls *libc.TLS, interp uintptr, zArg uintptr) int32 { /* test4.c:114:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if (((zArg == uintptr(0)) || (int32(*(*int8)(unsafe.Pointer(zArg))) == 0)) || (int32(*(*int8)(unsafe.Pointer(zArg + 1))) != 0)) || !((int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zArg)))))*2))) & int32(_ISupper)) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+25245 /* "thread ID must b..." */, 0))
		return -1
	}
	return (int32(*(*int8)(unsafe.Pointer(zArg))) - 'A')
}

// Usage:    thread_create NAME  FILENAME
//
// NAME should be an upper case letter.  Start the thread running with
// an open connection to the given database.
func tcl_thread_create(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:128:26: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var i int32
	// var x pthread_t at bp+88, 4

	var rc int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25284 /* " ID FILENAME" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if threadset[i].Fbusy != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25297 /* "thread " */, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+25305 /* " is already runn..." */, 0))
		return TCL_ERROR
	}
	threadset[i].Fbusy = 1
	sqlite3.Xsqlite3_free(tls, threadset[i].FzFilename)
	threadset[i].FzFilename = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	threadset[i].Fopnum = 1
	threadset[i].Fcompleted = 0
	rc = libc2.Xpthread_create(tls, bp+88 /* &x */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{test_thread_main})), (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, ts+25325 /* "failed to create..." */, 0))
		sqlite3.Xsqlite3_free(tls, threadset[i].FzFilename)
		threadset[i].Fbusy = 0
		return TCL_ERROR
	}
	libc2.Xpthread_detach(tls, *(*pthread_t)(unsafe.Pointer(bp + 88 /* x */)))
	return TCL_OK
}

// Wait for a thread to reach its idle state.
func test_thread_wait(tls *libc.TLS, p uintptr) { /* test4.c:168:13: */
	for (*Thread)(unsafe.Pointer(p)).Fopnum > (*Thread)(unsafe.Pointer(p)).Fcompleted {
		libc2.Xsched_yield(tls)
	}
}

// Usage:  thread_wait ID
//
// Wait on thread ID to reach its idle state.
func tcl_thread_wait(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:177:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	return TCL_OK
}

// Stop a thread.
func test_stop_thread(tls *libc.TLS, p uintptr) { /* test4.c:203:13: */
	test_thread_wait(tls, p)
	(*Thread)(unsafe.Pointer(p)).FxOp = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fopnum++
	test_thread_wait(tls, p)
	sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzArg)
	(*Thread)(unsafe.Pointer(p)).FzArg = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzFilename)
	(*Thread)(unsafe.Pointer(p)).FzFilename = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fbusy = 0
}

// Usage:  thread_halt ID
//
// Cause a thread to shut itself down.  Wait for the shutdown to be
// completed.  If ID is "*" then stop all threads.
func tcl_thread_halt(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:221:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	if (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 1*4))))) == '*') && (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 1*4)) + 1))) == 0) {
		for i = 0; i < N_THREAD; i++ {
			if threadset[i].Fbusy != 0 {
				test_stop_thread(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
			}
		}
	} else {
		i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		if i < 0 {
			return TCL_ERROR
		}
		if !(threadset[i].Fbusy != 0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
			return TCL_ERROR
		}
		test_stop_thread(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	}
	return TCL_OK
}

// Usage: thread_argc  ID
//
// Wait on the most recent thread_step to complete, then return the
// number of columns in the result set.
func tcl_thread_argc(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:256:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var i int32
	// var zBuf [100]int8 at bp+72, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+48, threadset[i].Fargc))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+72 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: thread_argv  ID   N
//
// Wait on the most recent thread_step to complete, then return the
// value of the N-th columns in the result set.
func tcl_thread_argv(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:288:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	// var n int32 at bp+80, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25372 /* " ID N" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+80 /* &n */) != 0 {
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	if (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) >= threadset[i].Fargc) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+25378 /* "column number ou..." */, 0))
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848 + 48 /* &.argv */) + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))*4)), 0))
	return TCL_OK
}

// Usage: thread_colname  ID   N
//
// Wait on the most recent thread_step to complete, then return the
// name of the N-th columns in the result set.
func tcl_thread_colname(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:324:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	// var n int32 at bp+80, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25372 /* " ID N" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+80 /* &n */) != 0 {
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	if (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) >= threadset[i].Fargc) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+25378 /* "column number ou..." */, 0))
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848 + 448 /* &.colv */) + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))*4)), 0))
	return TCL_OK
}

// Usage: thread_result  ID
//
// Wait on the most recent operation to complete, then return the
// result code from that operation.
func tcl_thread_result(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:360:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var zName uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	zName = sqlite3.Xsqlite3ErrName(tls, threadset[i].Frc)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, zName, 0))
	return TCL_OK
}

// Usage: thread_error  ID
//
// Wait on the most recent operation to complete, then return the
// error string.
func tcl_thread_error(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:392:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, threadset[i].FzErr, 0))
	return TCL_OK
}

// This procedure runs in the thread to compile an SQL statement.
func do_compile(tls *libc.TLS, p uintptr) { /* test4.c:419:13: */
	if (*Thread)(unsafe.Pointer(p)).Fdb == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+36 /* &.zStaticErr */, ts+25405 /* "no database is o..." */)
		(*Thread)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	if (*Thread)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_prepare(tls, (*Thread)(unsafe.Pointer(p)).Fdb, (*Thread)(unsafe.Pointer(p)).FzArg, -1, (p + 28 /* &.pStmt */), uintptr(0))
}

// Usage: thread_compile ID SQL
//
// Compile a new virtual machine.
func tcl_thread_compile(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:437:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var i int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25425 /* " ID SQL" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_compile}))
	sqlite3.Xsqlite3_free(tls, threadset[i].FzArg)
	threadset[i].FzArg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	threadset[i].Fopnum++
	return TCL_OK
}

// This procedure runs in the thread to step the virtual machine.
func do_step(tls *libc.TLS, p uintptr) { /* test4.c:466:13: */
	var i int32
	if (*Thread)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+36 /* &.zStaticErr */, ts+25433 /* "no virtual machi..." */)
		(*Thread)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_step(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
	if (*Thread)(unsafe.Pointer(p)).Frc == SQLITE_ROW {
		(*Thread)(unsafe.Pointer(p)).Fargc = sqlite3.Xsqlite3_column_count(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		for i = 0; i < sqlite3.Xsqlite3_data_count(tls, (*Thread)(unsafe.Pointer(p)).FpStmt); i++ {
			*(*uintptr)(unsafe.Pointer((p + 48 /* &.argv */) + uintptr(i)*4)) = sqlite3.Xsqlite3_column_text(tls, (*Thread)(unsafe.Pointer(p)).FpStmt, i)
		}
		for i = 0; i < (*Thread)(unsafe.Pointer(p)).Fargc; i++ {
			*(*uintptr)(unsafe.Pointer((p + 448 /* &.colv */) + uintptr(i)*4)) = sqlite3.Xsqlite3_column_name(tls, (*Thread)(unsafe.Pointer(p)).FpStmt, i)
		}
	}
}

// Usage: thread_step ID
//
// Advance the virtual machine by one step
func tcl_thread_step(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:490:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25462 /* " IDL" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_step}))
	threadset[i].Fopnum++
	return TCL_OK
}

// This procedure runs in the thread to finalize a virtual machine.
func do_finalize(tls *libc.TLS, p uintptr) { /* test4.c:517:13: */
	if (*Thread)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+36 /* &.zStaticErr */, ts+25433 /* "no virtual machi..." */)
		(*Thread)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
	(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
}

// Usage: thread_finalize ID
//
// Finalize the virtual machine.
func tcl_thread_finalize(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:532:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25462 /* " IDL" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_finalize}))
	sqlite3.Xsqlite3_free(tls, threadset[i].FzArg)
	threadset[i].FzArg = uintptr(0)
	threadset[i].Fopnum++
	return TCL_OK
}

// Usage: thread_swap ID ID
//
// Interchange the sqlite* pointer between two threads.
func tcl_thread_swap(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:563:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var j int32
	var temp uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25467 /* " ID1 ID2" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	j = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	if j < 0 {
		return TCL_ERROR
	}
	if !(threadset[j].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(j)*848))
	temp = threadset[i].Fdb
	threadset[i].Fdb = threadset[j].Fdb
	threadset[j].Fdb = temp
	return TCL_OK
}

// Usage: thread_db_get ID
//
// Return the database connection pointer for the given thread.  Then
// remove the pointer from the thread itself.  Afterwards, the thread
// can be stopped and the connection can be used by the main thread.
func tcl_thread_db_get(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:603:26: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var i int32
	// var zBuf [100]int8 at bp+64, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	sqlite3TestMakePointerStr(tls, interp, bp+64 /* &zBuf[0] */, threadset[i].Fdb)
	threadset[i].Fdb = uintptr(0)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+64 /* &zBuf[0] */, uintptr(0)))
	return TCL_OK
}

// Usage: thread_db_put ID DB
//
func tcl_thread_db_put(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:634:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25476 /* " ID DB" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))

	threadset[i].Fdb = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	return TCL_OK
}

// Usage: thread_stmt_get ID
//
// Return the database stmt pointer for the given thread.  Then
// remove the pointer from the thread itself.
func tcl_thread_stmt_get(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:666:26: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var i int32
	// var zBuf [100]int8 at bp+64, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848))
	sqlite3TestMakePointerStr(tls, interp, bp+64 /* &zBuf[0] */, threadset[i].FpStmt)
	threadset[i].FpStmt = uintptr(0)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+64 /* &zBuf[0] */, uintptr(0)))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest4_Init(tls *libc.TLS, interp uintptr) int32 { /* test4.c:696:5: */
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aCmd4)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd4[i].FzName, aCmd4[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aCmd4 = [15]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 25483 /* "thread_create" */, FxProc: 0},
	{FzName: ts + 25497 /* "thread_wait" */, FxProc: 0},
	{FzName: ts + 25509 /* "thread_halt" */, FxProc: 0},
	{FzName: ts + 25521 /* "thread_argc" */, FxProc: 0},
	{FzName: ts + 25533 /* "thread_argv" */, FxProc: 0},
	{FzName: ts + 25545 /* "thread_colname" */, FxProc: 0},
	{FzName: ts + 25560 /* "thread_result" */, FxProc: 0},
	{FzName: ts + 25574 /* "thread_error" */, FxProc: 0},
	{FzName: ts + 25587 /* "thread_compile" */, FxProc: 0},
	{FzName: ts + 25602 /* "thread_step" */, FxProc: 0},
	{FzName: ts + 25614 /* "thread_finalize" */, FxProc: 0},
	{FzName: ts + 25630 /* "thread_swap" */, FxProc: 0},
	{FzName: ts + 25642 /* "thread_db_get" */, FxProc: 0},
	{FzName: ts + 25656 /* "thread_db_put" */, FxProc: 0},
	{FzName: ts + 25670 /* "thread_stmt_get" */, FxProc: 0},
} /* test4.c:700:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// The first argument is a TCL UTF-8 string. Return the byte array
// object with the encoded representation of the string, including
// the NULL terminator.
func binarize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:33:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var len int32 at bp, 4

	var bytes uintptr
	var pRet uintptr

	bytes = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &len */)
	pRet = tcl.XTcl_NewByteArrayObj(tls, bytes, (*(*int32)(unsafe.Pointer(bp /* len */)) + 1))
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

// Usage: test_value_overhead <repeat-count> <do-calls>.
//
// This routine is used to test the overhead of calls to
// sqlite3_value_text(), on a value that contains a UTF-8 string. The idea
// is to figure out whether or not it is a problem to use sqlite3_value
// structures with collation sequence functions.
//
// If <do-calls> is 0, then the calls to sqlite3_value_text() are not
// actually made.
func test_value_overhead(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:61:26: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var do_calls int32 at bp+36, 4

	// var repeat_count int32 at bp+32, 4

	var i int32
	// var val Mem at bp+40, 40

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+25686 /* " <repeat-count> ..." */, 0))
		return TCL_ERROR
	}

	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+32 /* &repeat_count */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36 /* &do_calls */) != 0 {
		return TCL_ERROR
	}

	(*Mem)(unsafe.Pointer(bp + 40 /* &val */)).Fflags = (u16((MEM_Str | MEM_Term) | MEM_Static))
	(*Mem)(unsafe.Pointer(bp + 40 /* &val */)).Fz = ts + 25713 /* "hello world" */
	(*Mem)(unsafe.Pointer(bp + 40 /* &val */)).Fenc = u8(SQLITE_UTF8)

	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 32 /* repeat_count */)); i++ {
		if *(*int32)(unsafe.Pointer(bp + 36 /* do_calls */)) != 0 {
			sqlite3.Xsqlite3_value_text(tls, bp+40 /* &val */)
		}
	}

	return TCL_OK
}

func name_to_enc(tls *libc.TLS, interp uintptr, pObj uintptr) u8 { /* test5.c:94:11: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	*(*[5]EncName)(unsafe.Pointer(bp + 24 /* encnames */)) = [5]EncName{
		{FzName: ts + 25725 /* "UTF8" */, Fenc: u8(SQLITE_UTF8)},
		{FzName: ts + 25730 /* "UTF16LE" */, Fenc: u8(SQLITE_UTF16LE)},
		{FzName: ts + 25738 /* "UTF16BE" */, Fenc: u8(SQLITE_UTF16BE)},
		{FzName: ts + 25746 /* "UTF16" */, Fenc: u8(SQLITE_UTF16)},
		{},
	}
	var pEnc uintptr
	var z uintptr = tcl.XTcl_GetString(tls, pObj)
	for pEnc = (bp + 24 /* &encnames */); (*EncName)(unsafe.Pointer(pEnc)).FzName != 0; pEnc += 8 {
		if 0 == sqlite3.Xsqlite3StrICmp(tls, z, (*EncName)(unsafe.Pointer(pEnc)).FzName) {
			break
		}
	}
	if !(int32((*EncName)(unsafe.Pointer(pEnc)).Fenc) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+25752 /* "No such encoding..." */, z, 0))
	}
	if int32((*EncName)(unsafe.Pointer(pEnc)).Fenc) == SQLITE_UTF16 {
		return u8(SQLITE_UTF16LE)
	}
	return (*EncName)(unsafe.Pointer(pEnc)).Fenc
}

type EncName = struct {
	FzName uintptr
	Fenc   u8
	_      [3]byte
} /* test5.c:95:3 */

// Usage:   test_translate <string/blob> <from enc> <to enc> ?<transient>?
//
func test_translate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:125:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var enc_from u8
	var enc_to u8
	var pVal uintptr
	var z uintptr
	// var len int32 at bp+40, 4

	var xDel uintptr = uintptr(0)

	if (objc != 4) && (objc != 5) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)),
			ts+25771 /* " <string/blob> <..." */, 0))
		return TCL_ERROR
	}
	if objc == 5 {
		xDel = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free}))
	}

	enc_from = name_to_enc(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if !(enc_from != 0) {
		return TCL_ERROR
	}
	enc_to = name_to_enc(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if !(enc_to != 0) {
		return TCL_ERROR
	}

	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))

	if int32(enc_from) == SQLITE_UTF8 {
		z = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
		if objc == 5 {
			z = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+32, z))
		}
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, z, enc_from, xDel)
	} else {
		z = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+40 /* &len */)
		if objc == 5 {
			var zTmp uintptr = z
			z = sqlite3.Xsqlite3_malloc(tls, *(*int32)(unsafe.Pointer(bp + 40 /* len */)))
			libc.Xmemcpy(tls, z, zTmp, uint32(*(*int32)(unsafe.Pointer(bp + 40 /* len */))))
		}
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, z, enc_from, xDel)
	}

	z = sqlite3.Xsqlite3ValueText(tls, pVal, enc_to)
	*(*int32)(unsafe.Pointer(bp + 40 /* len */)) = (sqlite3.Xsqlite3ValueBytes(tls, pVal, enc_to) + (func() int32 {
		if int32(enc_to) == SQLITE_UTF8 {
			return 1
		}
		return 2
	}()))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, z, *(*int32)(unsafe.Pointer(bp + 40 /* len */))))

	sqlite3.Xsqlite3ValueFree(tls, pVal)

	return TCL_OK
}

func test_translate_selftest(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:189:26: */
	sqlite3.Xsqlite3UtfSelfTest(tls)
	return SQLITE_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest5_Init(tls *libc.TLS, interp uintptr) int32 { /* test5.c:205:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aCmd5)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd5[i].FzName, aCmd5[i].FxProc, uintptr(0), uintptr(0))
	}
	return SQLITE_OK
}

var aCmd5 = [4]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 25806 /* "binarize" */, FxProc: 0},
	{FzName: ts + 25815 /* "test_value_overh..." */, FxProc: 0},
	{FzName: ts + 25835 /* "test_translate" */, FxProc: 0},
	{FzName: ts + 25850 /* "translate_selfte..." */, FxProc: 0},
} /* test5.c:209:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// #define TRACE_CRASHTEST

type CrashFile1 = struct {
	FpMethod   uintptr
	FpRealFile uintptr
	FzName     uintptr
	Fflags     int32
	FzData     uintptr
	FnData     int32
	FiSize     i64
} /* test6.c:29:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// #define TRACE_CRASHTEST

type CrashFile = CrashFile1 /* test6.c:29:26 */
type CrashGlobal1 = struct {
	FpWriteList             uintptr
	FpWriteListEnd          uintptr
	FiSectorSize            int32
	FiDeviceCharacteristics int32
	FiCrash                 int32
	FzCrashFile             [500]int8
} /* test6.c:30:9 */

type CrashGlobal = CrashGlobal1 /* test6.c:30:28 */
type WriteBuffer1 = struct {
	FiOffset i64
	FnBuf    int32
	FzBuf    uintptr
	FpFile   uintptr
	FpNext   uintptr
} /* test6.c:30:9 */

type WriteBuffer = WriteBuffer1 /* test6.c:31:28 */

var g = CrashGlobal{FiSectorSize: SQLITE_DEFAULT_SECTOR_SIZE} /* test6.c:156:20 */

// Set this global variable to 1 to enable crash testing.
var sqlite3CrashTestEnable int32 = 0 /* test6.c:161:12 */

func crash_malloc(tls *libc.TLS, nByte int32) uintptr { /* test6.c:163:13: */
	return tcl.XTcl_AttemptAlloc(tls, size_t(nByte))
}

func crash_free(tls *libc.TLS, p uintptr) { /* test6.c:166:13: */
	tcl.XTcl_Free(tls, p)
}

func crash_realloc(tls *libc.TLS, p uintptr, n int32) uintptr { /* test6.c:169:13: */
	return tcl.XTcl_AttemptRealloc(tls, p, size_t(n))
}

// Wrapper around the sqlite3OsWrite() function that avoids writing to the
// 512 byte block begining at offset PENDING_BYTE.
func writeDbFile(tls *libc.TLS, p uintptr, z uintptr, iAmt i64, iOff i64) int32 { /* test6.c:177:12: */
	var rc int32 = SQLITE_OK
	var iSkip int32 = 0
	if (iAmt - i64(iSkip)) > int64(0) {
		rc = sqlite3.Xsqlite3OsWrite(tls, (*CrashFile)(unsafe.Pointer(p)).FpRealFile, (z + uintptr(iSkip)), (int32(iAmt - i64(iSkip))), (iOff + i64(iSkip)))
	}
	return rc
}

// Flush the write-list as if xSync() had been called on file handle
// pFile. If isCrash is true, simulate a crash.
func writeListSync(tls *libc.TLS, pFile uintptr, isCrash int32) int32 { /* test6.c:190:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = SQLITE_OK
	var iDc int32 = g.FiDeviceCharacteristics
	var pWrite uintptr
	var ppPtr uintptr

	// If this is not a crash simulation, set pFinal to point to the
	// last element of the write-list that is associated with file handle
	// pFile.
	//
	// If this is a crash simulation, set pFinal to an arbitrarily selected
	// element of the write-list.
	var pFinal uintptr = uintptr(0)
	if !(isCrash != 0) {
		for pWrite = g.FpWriteList; pWrite != 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			if (*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile == pFile {
				pFinal = pWrite
			}
		}
	} else if (iDc & (SQLITE_IOCAP_SEQUENTIAL | SQLITE_IOCAP_SAFE_APPEND)) != 0 {
		var nWrite int32 = 0
		// var iFinal int32 at bp, 4

		for pWrite = g.FpWriteList; pWrite != 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			nWrite++
		}
		sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(int32(0))), bp /* &iFinal */)
		*(*int32)(unsafe.Pointer(bp /* iFinal */)) = ((func() int32 {
			if *(*int32)(unsafe.Pointer(bp /* iFinal */)) < 0 {
				return (-1 * *(*int32)(unsafe.Pointer(bp /* iFinal */)))
			}
			return *(*int32)(unsafe.Pointer(bp /* iFinal */))
		}()) % nWrite)
		for pWrite = g.FpWriteList; *(*int32)(unsafe.Pointer(bp /* iFinal */)) > 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			*(*int32)(unsafe.Pointer(bp /* iFinal */))--
		}
		pFinal = pWrite
	}

	ppPtr = (uintptr(unsafe.Pointer(&g)) /* &.pWriteList */)
	for pWrite = *(*uintptr)(unsafe.Pointer(ppPtr)); (rc == SQLITE_OK) && (pWrite != 0); pWrite = *(*uintptr)(unsafe.Pointer(ppPtr)) {
		var pRealFile uintptr = (*CrashFile)(unsafe.Pointer((*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile)).FpRealFile

		// (eAction==1)      -> write block out normally,
		// (eAction==2)      -> do nothing,
		// (eAction==3)      -> trash sectors.
		var eAction int32 = 0
		if !(isCrash != 0) {
			eAction = 2
			if ((*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile == pFile) || ((iDc & SQLITE_IOCAP_SEQUENTIAL) != 0) {
				eAction = 1
			}
		} else {
			// var random int8 at bp+4, 1

			sqlite3.Xsqlite3_randomness(tls, 1, bp+4 /* &random */)

			// Do not select option 3 (sector trashing) if the IOCAP_ATOMIC flag
			// is set or this is an OsTruncate(), not an Oswrite().
			if ((iDc & SQLITE_IOCAP_ATOMIC) != 0) || ((*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf == uintptr(0)) {
				*(*int8)(unsafe.Pointer(bp + 4 /* random */)) &= int8(0x01)
			}

			// If IOCAP_SEQUENTIAL is set and this is not the final entry
			// in the truncated write-list, always select option 1 (write
			// out correctly).
			if ((iDc & SQLITE_IOCAP_SEQUENTIAL) != 0) && (pWrite != pFinal) {
				*(*int8)(unsafe.Pointer(bp + 4 /* random */)) = int8(0)
			}

			// If IOCAP_SAFE_APPEND is set and this OsWrite() operation is
			// an append (first byte of the written region is 1 byte past the
			// current EOF), always select option 1 (write out correctly).
			if ((iDc & SQLITE_IOCAP_SAFE_APPEND) != 0) && ((*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf != 0) {
				// var iSize i64 at bp+8, 8

				sqlite3.Xsqlite3OsFileSize(tls, pRealFile, bp+8 /* &iSize */)
				if *(*i64)(unsafe.Pointer(bp + 8 /* iSize */)) == (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset {
					*(*int8)(unsafe.Pointer(bp + 4 /* random */)) = int8(0)
				}
			}

			if (int32(*(*int8)(unsafe.Pointer(bp + 4 /* random */))) & 0x06) == 0x06 {
				eAction = 3
			} else {
				eAction = func() int32 {
					if (int32(*(*int8)(unsafe.Pointer(bp + 4 /* random */))) & 0x01) != 0 {
						return 2
					}
					return 1
				}()
			}
		}

		switch eAction {
		case 1:
			{ // Write out correctly
				if (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf != 0 {
					rc = writeDbFile(tls,
						(*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile, (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf, int64((*WriteBuffer)(unsafe.Pointer(pWrite)).FnBuf), (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset)
				} else {
					rc = sqlite3.Xsqlite3OsTruncate(tls, pRealFile, (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset)
				}
				*(*uintptr)(unsafe.Pointer(ppPtr)) = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext
				crash_free(tls, pWrite)
				break

			}
		case 2:
			{ // Do nothing
				ppPtr = (pWrite + 20 /* &.pNext */)
				break

			}
		case 3:
			{ // Trash sectors
				var zGarbage uintptr
				var iFirst int32 = (int32((*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset / i64(g.FiSectorSize)))
				var iLast int32 = (int32((((*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset + i64((*WriteBuffer)(unsafe.Pointer(pWrite)).FnBuf)) - int64(1)) / i64(g.FiSectorSize)))

				zGarbage = crash_malloc(tls, g.FiSectorSize)
				if zGarbage != 0 {
					var i sqlite3_int64
					for i = sqlite3_int64(iFirst); (rc == SQLITE_OK) && (i <= sqlite3_int64(iLast)); i++ {
						sqlite3.Xsqlite3_randomness(tls, g.FiSectorSize, zGarbage)
						rc = writeDbFile(tls,
							(*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile, zGarbage, int64(g.FiSectorSize), (i * sqlite3_int64(g.FiSectorSize)))
					}
					crash_free(tls, zGarbage)
				} else {
					rc = SQLITE_NOMEM
				}

				ppPtr = (pWrite + 20 /* &.pNext */)
				break

			}

		default:

		}

		if pWrite == pFinal {
			break
		}
	}

	if (rc == SQLITE_OK) && (isCrash != 0) {
		libc.Xexit(tls, -1)
	}

	for pWrite = g.FpWriteList; (pWrite != 0) && ((*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext != 0); pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
	}
	g.FpWriteListEnd = pWrite

	return rc
}

// Add an entry to the end of the write-list.
func writeListAppend(tls *libc.TLS, pFile uintptr, iOffset sqlite3_int64, zBuf uintptr, nBuf int32) int32 { /* test6.c:362:12: */
	var pNew uintptr

	pNew = crash_malloc(tls, (int32(uint32(unsafe.Sizeof(WriteBuffer{})) + uint32(nBuf))))
	if pNew == uintptr(0) {
		libc.Xfprintf(tls, libc.Xstderr, ts+25869 /* "out of memory in..." */, 0)
	}
	libc.Xmemset(tls, pNew, 0, (uint32(unsafe.Sizeof(WriteBuffer{})) + uint32(nBuf)))
	(*WriteBuffer)(unsafe.Pointer(pNew)).FiOffset = iOffset
	(*WriteBuffer)(unsafe.Pointer(pNew)).FnBuf = nBuf
	(*WriteBuffer)(unsafe.Pointer(pNew)).FpFile = pFile
	if zBuf != 0 {
		(*WriteBuffer)(unsafe.Pointer(pNew)).FzBuf = (pNew + 1*24)
		libc.Xmemcpy(tls, (*WriteBuffer)(unsafe.Pointer(pNew)).FzBuf, zBuf, uint32(nBuf))
	}

	if g.FpWriteList != 0 {

		(*WriteBuffer)(unsafe.Pointer(g.FpWriteListEnd)).FpNext = pNew
	} else {
		g.FpWriteList = pNew
	}
	g.FpWriteListEnd = pNew

	return SQLITE_OK
}

// Close a crash-file.
func cfClose(tls *libc.TLS, pFile uintptr) int32 { /* test6.c:399:12: */
	var pCrash uintptr = pFile
	writeListSync(tls, pCrash, 0)
	sqlite3.Xsqlite3OsClose(tls, (*CrashFile)(unsafe.Pointer(pCrash)).FpRealFile)
	return SQLITE_OK
}

// Read data from a crash-file.
func cfRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test6.c:409:12: */
	var pCrash uintptr = pFile
	var nCopy int32 = func() int32 {
		if (i64(iAmt)) < ((*CrashFile)(unsafe.Pointer(pCrash)).FiSize - iOfst) {
			return int32(i64(iAmt))
		}
		return (int32((*CrashFile)(unsafe.Pointer(pCrash)).FiSize - iOfst))
	}()

	if nCopy > 0 {
		libc.Xmemcpy(tls, zBuf, ((*CrashFile)(unsafe.Pointer(pCrash)).FzData + uintptr(iOfst)), uint32(nCopy))
	}

	// Check the file-size to see if this is a short-read
	if nCopy < iAmt {
		return (SQLITE_IOERR | (int32(2) << 8))
	}

	return SQLITE_OK
}

// Write data to a crash-file.
func cfWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test6.c:433:12: */
	var pCrash uintptr = pFile
	if (sqlite_int64(iAmt) + iOfst) > (*CrashFile)(unsafe.Pointer(pCrash)).FiSize {
		(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64((int32(sqlite_int64(iAmt) + iOfst)))
	}
	for (*CrashFile)(unsafe.Pointer(pCrash)).FiSize > i64((*CrashFile)(unsafe.Pointer(pCrash)).FnData) {
		var zNew uintptr
		var nNew int32 = (((*CrashFile)(unsafe.Pointer(pCrash)).FnData * 2) + 4096)
		zNew = crash_realloc(tls, (*CrashFile)(unsafe.Pointer(pCrash)).FzData, nNew)
		if !(zNew != 0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, (zNew + uintptr((*CrashFile)(unsafe.Pointer(pCrash)).FnData)), 0, (uint32(nNew - (*CrashFile)(unsafe.Pointer(pCrash)).FnData)))
		(*CrashFile)(unsafe.Pointer(pCrash)).FnData = nNew
		(*CrashFile)(unsafe.Pointer(pCrash)).FzData = zNew
	}
	libc.Xmemcpy(tls, ((*CrashFile)(unsafe.Pointer(pCrash)).FzData + uintptr(iOfst)), zBuf, uint32(iAmt))
	return writeListAppend(tls, pFile, iOfst, zBuf, iAmt)
}

// Truncate a crash-file.
func cfTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test6.c:461:12: */
	var pCrash uintptr = pFile

	if (*CrashFile)(unsafe.Pointer(pCrash)).FiSize > size {
		(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64(int32(size))
	}
	return writeListAppend(tls, pFile, size, uintptr(0), 0)
}

// Sync a crash-file.
func cfSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test6.c:473:12: */
	var pCrash uintptr = pFile
	var isCrash int32 = 0

	var zName uintptr = (*CrashFile)(unsafe.Pointer(pCrash)).FzName
	var zCrashFile uintptr = uintptr(unsafe.Pointer(&g)) + 20 /* &.zCrashFile */
	var nName int32 = int32(libc.Xstrlen(tls, zName))
	var nCrashFile int32 = int32(libc.Xstrlen(tls, zCrashFile))

	if (nCrashFile > 0) && (int32(*(*int8)(unsafe.Pointer(zCrashFile + uintptr((nCrashFile - 1))))) == '*') {
		nCrashFile--
		if nName > nCrashFile {
			nName = nCrashFile
		}
	}

	if (nName == nCrashFile) && (0 == libc.Xmemcmp(tls, zName, zCrashFile, uint32(nName))) {
		if (libc.PreDecInt32(&g.FiCrash, 1)) == 0 {
			isCrash = 1
		}
	}

	return writeListSync(tls, pCrash, isCrash)
}

// Return the current file-size of the crash-file.
func cfFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test6.c:505:12: */
	var pCrash uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = (*CrashFile)(unsafe.Pointer(pCrash)).FiSize
	return SQLITE_OK
}

// Calls related to file-locks are passed on to the real file handle.
func cfLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test6.c:514:12: */
	return sqlite3.Xsqlite3OsLock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, eLock)
}

func cfUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test6.c:517:12: */
	return sqlite3.Xsqlite3OsUnlock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, eLock)
}

func cfCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test6.c:520:12: */
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, pResOut)
}

func cfFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test6.c:523:12: */
	if op == SQLITE_FCNTL_SIZE_HINT {
		var pCrash uintptr = pFile
		var nByte i64 = *(*i64)(unsafe.Pointer(pArg))
		if nByte > (*CrashFile)(unsafe.Pointer(pCrash)).FiSize {
			if SQLITE_OK == writeListAppend(tls, pFile, nByte, uintptr(0), 0) {
				(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64(int32(nByte))
			}
		}
		return SQLITE_OK
	}
	return sqlite3.Xsqlite3OsFileControl(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, op, pArg)
}

// The xSectorSize() and xDeviceCharacteristics() functions return
// the global values configured by the [sqlite_crashparams] tcl
//  interface.
func cfSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test6.c:542:12: */
	return g.FiSectorSize
}

func cfDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test6.c:545:12: */
	return g.FiDeviceCharacteristics
}

// Pass-throughs for WAL support.
func cfShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test6.c:552:12: */
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	return (*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods + 56 /* &.xShmLock */))))(tls, pReal, ofst, n, flags)
}

func cfShmBarrier(tls *libc.TLS, pFile uintptr) { /* test6.c:556:13: */
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods + 60 /* &.xShmBarrier */))))(tls, pReal)
}

func cfShmUnmap(tls *libc.TLS, pFile uintptr, delFlag int32) int32 { /* test6.c:560:12: */
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods + 64 /* &.xShmUnmap */))))(tls, pReal, delFlag)
}

func cfShmMap(tls *libc.TLS, pFile uintptr, iRegion int32, sz int32, w int32, pp uintptr) int32 { /* test6.c:564:12: */
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	return (*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods + 52 /* &.xShmMap */))))(tls, pReal, iRegion, sz, w, libc.AtomicLoadUintptr(&pp))
}

var CrashFileVtab = sqlite3_io_methods{
	FiVersion:               2, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
} /* test6.c:575:33 */

// Application data for the crash VFS
type crashAppData = struct{ FpOrig uintptr } /* test6.c:598:1 */

// Open a crash-file file handle.
//
// The caller will have allocated pVfs->szOsFile bytes of space
// at pFile. This file uses this space for the CrashFile structure
// and allocates space for the "real" file structure using
// sqlite3_malloc(). The assumption here is (pVfs->szOsFile) is
// equal or greater than sizeof(CrashFile).
func cfOpen(tls *libc.TLS, pCfVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test6.c:611:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	var rc int32
	var pWrapper uintptr = pFile
	var pReal uintptr = (pWrapper + 1*32)

	libc.Xmemset(tls, pWrapper, 0, uint32(unsafe.Sizeof(CrashFile{})))
	rc = sqlite3.Xsqlite3OsOpen(tls, pVfs, zName, pReal, flags, pOutFlags)

	if rc == SQLITE_OK {
		// var iSize i64 at bp, 8

		(*CrashFile)(unsafe.Pointer(pWrapper)).FpMethod = uintptr(unsafe.Pointer(&CrashFileVtab))
		(*CrashFile)(unsafe.Pointer(pWrapper)).FzName = zName
		(*CrashFile)(unsafe.Pointer(pWrapper)).FpRealFile = pReal
		rc = sqlite3.Xsqlite3OsFileSize(tls, pReal, bp /* &iSize */)
		(*CrashFile)(unsafe.Pointer(pWrapper)).FiSize = i64(int32(*(*i64)(unsafe.Pointer(bp /* iSize */))))
		(*CrashFile)(unsafe.Pointer(pWrapper)).Fflags = flags
	}
	if rc == SQLITE_OK {
		(*CrashFile)(unsafe.Pointer(pWrapper)).FnData = (int32(int64(4096) + (*CrashFile)(unsafe.Pointer(pWrapper)).FiSize))
		(*CrashFile)(unsafe.Pointer(pWrapper)).FzData = crash_malloc(tls, (*CrashFile)(unsafe.Pointer(pWrapper)).FnData)
		if (*CrashFile)(unsafe.Pointer(pWrapper)).FzData != 0 {
			// os_unix.c contains an assert() that fails if the caller attempts
			// to read data from the 512-byte locking region of a file opened
			// with the SQLITE_OPEN_MAIN_DB flag. This region of a database file
			// never contains valid data anyhow. So avoid doing such a read here.
			//
			// UPDATE: It also contains an assert() verifying that each call
			// to the xRead() method reads less than 128KB of data.
			var iOff i64

			libc.Xmemset(tls, (*CrashFile)(unsafe.Pointer(pWrapper)).FzData, 0, uint32((*CrashFile)(unsafe.Pointer(pWrapper)).FnData))
			for iOff = int64(0); iOff < (*CrashFile)(unsafe.Pointer(pWrapper)).FiSize; iOff = iOff + (int64(512)) {
				var nRead int32 = (int32((*CrashFile)(unsafe.Pointer(pWrapper)).FiSize - iOff))
				if nRead > 512 {
					nRead = 512
				}
				rc = sqlite3.Xsqlite3OsRead(tls, pReal, ((*CrashFile)(unsafe.Pointer(pWrapper)).FzData + uintptr(iOff)), nRead, iOff)
			}
		} else {
			rc = SQLITE_NOMEM
		}
	}
	if (rc != SQLITE_OK) && ((*CrashFile)(unsafe.Pointer(pWrapper)).FpMethod != 0) {
		sqlite3.Xsqlite3OsClose(tls, pFile)
	}
	return rc
}

func cfDelete(tls *libc.TLS, pCfVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test6.c:665:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pVfs + 28 /* &.xDelete */))))(tls, pVfs, zPath, dirSync)
}

func cfAccess(tls *libc.TLS, pCfVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test6.c:669:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 32 /* &.xAccess */))))(tls, pVfs, zPath, flags, pResOut)
}

func cfFullPathname(tls *libc.TLS, pCfVfs uintptr, zPath uintptr, nPathOut int32, zPathOut uintptr) int32 { /* test6.c:678:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 36 /* &.xFullPathname */))))(tls, pVfs, zPath, nPathOut, zPathOut)
}

func cfDlOpen(tls *libc.TLS, pCfVfs uintptr, zPath uintptr) uintptr { /* test6.c:687:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((pVfs + 40 /* &.xDlOpen */))))(tls, pVfs, zPath)
}

func cfDlError(tls *libc.TLS, pCfVfs uintptr, nByte int32, zErrMsg uintptr) { /* test6.c:691:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	(*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer((pVfs + 44 /* &.xDlError */))))(tls, pVfs, nByte, zErrMsg)
}

func cfDlSym(tls *libc.TLS, pCfVfs uintptr, pH uintptr, zSym uintptr) uintptr { /* test6.c:695:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((pVfs + 48 /* &.xDlSym */))))(tls, pVfs, pH, zSym)
}

func cfDlClose(tls *libc.TLS, pCfVfs uintptr, pHandle uintptr) { /* test6.c:699:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	(*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer((pVfs + 52 /* &.xDlClose */))))(tls, pVfs, pHandle)
}

func cfRandomness(tls *libc.TLS, pCfVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test6.c:703:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 56 /* &.xRandomness */))))(tls, pVfs, nByte, zBufOut)
}

func cfSleep(tls *libc.TLS, pCfVfs uintptr, nMicro int32) int32 { /* test6.c:707:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer((pVfs + 60 /* &.xSleep */))))(tls, pVfs, nMicro)
}

func cfCurrentTime(tls *libc.TLS, pCfVfs uintptr, pTimeOut uintptr) int32 { /* test6.c:711:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pVfs + 64 /* &.xCurrentTime */))))(tls, pVfs, pTimeOut)
}

func cfGetLastError(tls *libc.TLS, pCfVfs uintptr, n int32, z uintptr) int32 { /* test6.c:715:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 68 /* &.xGetLastError */))))(tls, pVfs, n, z)
}

func processDevSymArgs(tls *libc.TLS, interp uintptr, objc int32, objv uintptr, piDeviceChar uintptr, piSectorSize uintptr) int32 { /* test6.c:720:12: */
	bp := tls.Alloc(196)
	defer tls.Free(196)

	*(*[14]DeviceFlag)(unsafe.Pointer(bp + 80 /* aFlag */)) = [14]DeviceFlag{
		{FzName: ts + 25907 /* "atomic" */, FiValue: SQLITE_IOCAP_ATOMIC},
		{FzName: ts + 25914 /* "atomic512" */, FiValue: SQLITE_IOCAP_ATOMIC512},
		{FzName: ts + 25924 /* "atomic1k" */, FiValue: SQLITE_IOCAP_ATOMIC1K},
		{FzName: ts + 25933 /* "atomic2k" */, FiValue: SQLITE_IOCAP_ATOMIC2K},
		{FzName: ts + 25942 /* "atomic4k" */, FiValue: SQLITE_IOCAP_ATOMIC4K},
		{FzName: ts + 25951 /* "atomic8k" */, FiValue: SQLITE_IOCAP_ATOMIC8K},
		{FzName: ts + 25960 /* "atomic16k" */, FiValue: SQLITE_IOCAP_ATOMIC16K},
		{FzName: ts + 25970 /* "atomic32k" */, FiValue: SQLITE_IOCAP_ATOMIC32K},
		{FzName: ts + 25980 /* "atomic64k" */, FiValue: SQLITE_IOCAP_ATOMIC64K},
		{FzName: ts + 25990 /* "sequential" */, FiValue: SQLITE_IOCAP_SEQUENTIAL},
		{FzName: ts + 26001 /* "safe_append" */, FiValue: SQLITE_IOCAP_SAFE_APPEND},
		{FzName: ts + 26013 /* "powersafe_overwr..." */, FiValue: SQLITE_IOCAP_POWERSAFE_OVERWRITE},
		{FzName: ts + 26033 /* "batch-atomic" */, FiValue: SQLITE_IOCAP_BATCH_ATOMIC},
		{},
	}
	var i int32
	var iDc int32 = 0
	*(*int32)(unsafe.Pointer(bp + 68 /* iSectorSize */)) = 0
	var setSectorsize int32 = 0
	var setDeviceChar int32 = 0

	for i = 0; i < objc; i = i + (2) {
		// var nOpt int32 at bp+64, 4

		var zOpt uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+64 /* &nOpt */)

		if (((*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)) > 11) || (*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)) < 2)) || (libc.Xstrncmp(tls, ts+26046 /* "-sectorsize" */, zOpt, uint32(*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)))) != 0)) &&
			(((*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)) > 16) || (*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)) < 2)) || (libc.Xstrncmp(tls, ts+26058 /* "-characteristics" */, zOpt, uint32(*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)))) != 0)) {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp, ts+26075 /* "Bad option: \"" */, zOpt,
					ts+26089 /* "\" - must be \"-ch..." */, 0))
			return TCL_ERROR
		}
		if i == (objc - 1) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26137 /* "Option requires ..." */, zOpt, ts+11634 /* "\"" */, 0))
			return TCL_ERROR
		}

		if int32(*(*int8)(unsafe.Pointer(zOpt + 1))) == 's' {
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4)), bp+68 /* &iSectorSize */) != 0 {
				return TCL_ERROR
			}
			setSectorsize = 1
		} else {
			var j int32
			// var apObj uintptr at bp+76, 4

			// var nObj int32 at bp+72, 4

			if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4)), bp+72 /* &nObj */, bp+76 /* &apObj */) != 0 {
				return TCL_ERROR
			}
			for j = 0; j < *(*int32)(unsafe.Pointer(bp + 72 /* nObj */)); j++ {
				var rc int32
				// var iChoice int32 at bp+192, 4

				var pFlag uintptr = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 76 /* apObj */)) + uintptr(j)*4)))
				(*Tcl_Obj)(unsafe.Pointer(pFlag)).FrefCount++
				tcl.XTcl_UtfToLower(tls, tcl.XTcl_GetString(tls, pFlag))

				rc = tcl.XTcl_GetIndexFromObjStruct(tls,
					interp, pFlag, bp+80 /* &aFlag[0] */, int32(unsafe.Sizeof(DeviceFlag{})), ts+26168 /* "no such flag" */, 0, bp+192 /* &iChoice */)
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = pFlag
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				if rc != 0 {
					return TCL_ERROR
				}

				iDc = iDc | ((*DeviceFlag)(unsafe.Pointer(bp + 80 /* &aFlag */ + uintptr(*(*int32)(unsafe.Pointer(bp + 192 /* iChoice */)))*8)).FiValue)
			}
			setDeviceChar = 1
		}
	}

	if setDeviceChar != 0 {
		*(*int32)(unsafe.Pointer(piDeviceChar)) = iDc
	}
	if setSectorsize != 0 {
		*(*int32)(unsafe.Pointer(piSectorSize)) = *(*int32)(unsafe.Pointer(bp + 68 /* iSectorSize */))
	}

	return TCL_OK
}

type DeviceFlag = struct {
	FzName  uintptr
	FiValue int32
} /* test6.c:727:3 */

// tclcmd:   sqlite3_crash_now
//
// Simulate a crash immediately. This function does not return
// (writeListSync() calls exit(-1)).
func crashNowCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:820:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}
	writeListSync(tls, uintptr(0), 1)

	return TCL_OK
}

// tclcmd:   sqlite_crash_enable ENABLE ?DEFAULT?
//
// Parameter ENABLE must be a boolean value. If true, then the "crash"
// vfs is added to the system. If false, it is removed.
func crashEnableCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:841:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var isEnable int32 at bp, 4

	*(*int32)(unsafe.Pointer(bp + 4 /* isDefault */)) = 0

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+26181 /* "ENABLE ?DEFAULT?" */)
		return TCL_ERROR
	}

	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &isEnable */) != 0 {
		return TCL_ERROR
	}
	if (objc == 3) && (tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &isDefault */) != 0) {
		return TCL_ERROR
	}

	if ((*(*int32)(unsafe.Pointer(bp /* isEnable */)) != 0) && (crashVfs.FpAppData != 0)) || (!(*(*int32)(unsafe.Pointer(bp /* isEnable */)) != 0) && !(int32(crashVfs.FpAppData) != 0)) {
		return TCL_OK
	}

	if crashVfs.FpAppData == uintptr(0) {
		var pOriginalVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		crashVfs.FmxPathname = (*sqlite3_vfs)(unsafe.Pointer(pOriginalVfs)).FmxPathname
		crashVfs.FpAppData = pOriginalVfs
		crashVfs.FszOsFile = (int32(uint32(unsafe.Sizeof(CrashFile{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(pOriginalVfs)).FszOsFile)))
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&crashVfs)), *(*int32)(unsafe.Pointer(bp + 4 /* isDefault */)))
	} else {
		crashVfs.FpAppData = uintptr(0)
		sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&crashVfs)))
	}

	return TCL_OK
}

var crashVfs = sqlite3_vfs{
	FiVersion: 2,          // pNext
	FzName:    ts + 26198, /* "crash" */ // pAppData

	FxOpen:         0, // xOpen
	FxDelete:       0, // xDelete
	FxAccess:       0, // xAccess
	FxFullPathname: 0, // xFullPathname
	FxDlOpen:       0, // xDlOpen
	FxDlError:      0, // xDlError
	FxDlSym:        0, // xDlSym
	FxDlClose:      0, // xDlClose
	FxRandomness:   0, // xRandomness
	FxSleep:        0, // xSleep
	FxCurrentTime:  0, // xCurrentTime
	FxGetLastError: 0, // xCurrentTimeInt64
} /* test6.c:849:22 */

// tclcmd:   sqlite_crashparams ?OPTIONS? DELAY CRASHFILE
//
// This procedure implements a TCL command that enables crash testing
// in testfixture.  Once enabled, crash testing cannot be disabled.
//
// Available options are "-characteristics" and "-sectorsize". Both require
// an argument. For -sectorsize, this is the simulated sector size in
// bytes. For -characteristics, the argument must be a list of io-capability
// flags to simulate. Valid flags are "atomic", "atomic512", "atomic1K",
// "atomic2K", "atomic4K", "atomic8K", "atomic16K", "atomic32K",
// "atomic64K", "sequential" and "safe_append".
//
// Example:
//
//   sqlite_crashparams -sect 1024 -char {atomic sequential} ./test.db 1
//
func crashParamsObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:920:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var iDelay int32 at bp+36, 4

	var zCrashFile uintptr
	// var nCrashFile int32 at bp+32, 4

	// var iDc int32 at bp+40, 4

	// var iSectorSize int32 at bp+44, 4

	*(*int32)(unsafe.Pointer(bp + 40 /* iDc */)) = -1
	*(*int32)(unsafe.Pointer(bp + 44 /* iSectorSize */)) = -1

	if !(objc < 3) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+26204 /* "?OPTIONS? DELAY ..." */)
	goto error
__1:
	;

	zCrashFile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*4)), bp+32 /* &nCrashFile */)
	if !(uint32(*(*int32)(unsafe.Pointer(bp + 32 /* nCrashFile */))) >= uint32(unsafe.Sizeof([500]int8{}))) {
		goto __2
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+26230 /* "Filename is too ..." */, zCrashFile, ts+11634 /* "\"" */, 0))
	goto error
__2:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-2))*4)), bp+36 /* &iDelay */) != 0) {
		goto __3
	}
	goto error
__3:
	;

	if !(processDevSymArgs(tls, interp, (objc-3), (objv+1*4), bp+40 /* &iDc */, bp+44 /* &iSectorSize */) != 0) {
		goto __4
	}
	return TCL_ERROR
__4:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 40 /* iDc */)) >= 0) {
		goto __5
	}
	g.FiDeviceCharacteristics = *(*int32)(unsafe.Pointer(bp + 40 /* iDc */))
__5:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 44 /* iSectorSize */)) >= 0) {
		goto __6
	}
	g.FiSectorSize = *(*int32)(unsafe.Pointer(bp + 44 /* iSectorSize */))
__6:
	;

	g.FiCrash = *(*int32)(unsafe.Pointer(bp + 36 /* iDelay */))
	libc.Xmemcpy(tls, uintptr(unsafe.Pointer(&g))+20 /* &.zCrashFile */, zCrashFile, (uint32(*(*int32)(unsafe.Pointer(bp + 32 /* nCrashFile */)) + 1)))
	sqlite3CrashTestEnable = 1
	return TCL_OK

error:
	return TCL_ERROR
}

func devSymObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:967:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp /* iDc */)) = -1
	*(*int32)(unsafe.Pointer(bp + 4 /* iSectorSize */)) = -1

	if processDevSymArgs(tls, interp, (objc-1), (objv+1*4), bp /* &iDc */, bp+4 /* &iSectorSize */) != 0 {
		return TCL_ERROR
	}
	devsym_register(tls, *(*int32)(unsafe.Pointer(bp /* iDc */)), *(*int32)(unsafe.Pointer(bp + 4 /* iSectorSize */)))

	return TCL_OK
}

// tclcmd: sqlite3_crash_on_write N
func writeCrashObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:989:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* nWrite */)) = 0

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+26254 /* "NWRITE" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &nWrite */) != 0 {
		return TCL_ERROR
	}

	devsym_crash_on_write(tls, *(*int32)(unsafe.Pointer(bp /* nWrite */)))
	return TCL_OK
}

// tclcmd: unregister_devsim
func dsUnregisterObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:1013:26: */

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	devsym_unregister(tls)
	return TCL_OK
}

// tclcmd: register_jt_vfs ?-default? PARENT-VFS
func jtObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:1033:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var zParent uintptr = uintptr(0)

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+26261 /* "?-default? PAREN..." */)
		return TCL_ERROR
	}
	zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if objc == 3 {
		if libc.Xstrcmp(tls, zParent, ts+26283 /* "-default" */) != 0 {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp, ts+11533 /* "bad option \"" */, zParent, ts+26292 /* "\": must be -defa..." */, 0))
			return TCL_ERROR
		}
		zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	}

	if !(int32(*(*int8)(unsafe.Pointer(zParent))) != 0) {
		zParent = uintptr(0)
	}
	if jt_register(tls, zParent, (libc.Bool32(objc == 3))) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26312 /* "Error in jt_regi..." */, 0))
		return TCL_ERROR
	}

	return TCL_OK
}

// tclcmd: unregister_jt_vfs
func jtUnregisterObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:1071:26: */

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	jt_unregister(tls)
	return TCL_OK
}

// This procedure registers the TCL procedures defined in this file.
func Sqlitetest6_Init(tls *libc.TLS, interp uintptr) int32 { /* test6.c:1093:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+26333 /* "sqlite3_crash_en..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashEnableCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+26354 /* "sqlite3_crashpar..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashParamsObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+26374 /* "sqlite3_crash_no..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashNowCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+26392 /* "sqlite3_simulate..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{devSymObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+26416 /* "sqlite3_crash_on..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{writeCrashObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+26439 /* "unregister_devsi..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{dsUnregisterObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+26457 /* "register_jt_vfs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{jtObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+26473 /* "unregister_jt_vf..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{jtUnregisterObjCmd})), uintptr(0), uintptr(0))
	return TCL_OK
}

// Each thread is controlled by an instance of the following
// structure.
type Thread1 = struct {
	FzFilename  uintptr
	FxOp        uintptr
	FzArg       uintptr
	Fopnum      int32
	Fbusy       int32
	Fcompleted  int32
	Fdb         uintptr
	FpStmt      uintptr
	FzErr       uintptr
	FzStaticErr uintptr
	Frc         int32
	Fargc       int32
	Fargv       [100]uintptr
	Fcolv       [100]uintptr
	FnServer    int32
} /* test7.c:53:23 */

// There can be as many as 26 threads running at once.  Each is named
// by a capital letter: A, B, C, ..., Y, Z.
var threadset1 [26]Thread1 /* test7.c:90:15: */

// The main loop for a thread.  Threads use busy waiting.
func client_main(tls *libc.TLS, pArg uintptr) uintptr { /* test7.c:95:13: */
	var p uintptr = pArg
	if (*Thread1)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3_client_close(tls, (*Thread1)(unsafe.Pointer(p)).Fdb)
	}
	sqlite3_client_open(tls, (*Thread1)(unsafe.Pointer(p)).FzFilename, (p + 24 /* &.db */))
	if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*Thread1)(unsafe.Pointer(p)).Fdb) {
		(*Thread1)(unsafe.Pointer(p)).FzErr = libc.Xstrdup(tls, sqlite3.Xsqlite3_errmsg(tls, (*Thread1)(unsafe.Pointer(p)).Fdb))
		sqlite3_client_close(tls, (*Thread1)(unsafe.Pointer(p)).Fdb)
		(*Thread1)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	(*Thread1)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	(*Thread1)(unsafe.Pointer(p)).Fcompleted = 1
	for (*Thread1)(unsafe.Pointer(p)).Fopnum <= (*Thread1)(unsafe.Pointer(p)).Fcompleted {
		libc2.Xsched_yield(tls)
	}
	for (*Thread1)(unsafe.Pointer(p)).FxOp != 0 {
		if ((*Thread1)(unsafe.Pointer(p)).FzErr != 0) && ((*Thread1)(unsafe.Pointer(p)).FzErr != (*Thread1)(unsafe.Pointer(p)).FzStaticErr) {
			sqlite3.Xsqlite3_free(tls, (*Thread1)(unsafe.Pointer(p)).FzErr)
			(*Thread1)(unsafe.Pointer(p)).FzErr = uintptr(0)
		}
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((p + 4 /* &.xOp */))))(tls, p)
		(*Thread1)(unsafe.Pointer(p)).Fcompleted++
		for (*Thread1)(unsafe.Pointer(p)).Fopnum <= (*Thread1)(unsafe.Pointer(p)).Fcompleted {
			libc2.Xsched_yield(tls)
		}
	}
	if (*Thread1)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3_client_finalize(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
		(*Thread1)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	if (*Thread1)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3_client_close(tls, (*Thread1)(unsafe.Pointer(p)).Fdb)
		(*Thread1)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	if ((*Thread1)(unsafe.Pointer(p)).FzErr != 0) && ((*Thread1)(unsafe.Pointer(p)).FzErr != (*Thread1)(unsafe.Pointer(p)).FzStaticErr) {
		sqlite3.Xsqlite3_free(tls, (*Thread1)(unsafe.Pointer(p)).FzErr)
		(*Thread1)(unsafe.Pointer(p)).FzErr = uintptr(0)
	}
	(*Thread1)(unsafe.Pointer(p)).Fcompleted++
	sqlite3.Xsqlite3_thread_cleanup(tls)
	return uintptr(0)
}

// Get a thread ID which is an upper case letter.  Return the index.
// If the argument is not a valid thread ID put an error message in
// the interpreter and return -1.
func parse_client_id(tls *libc.TLS, interp uintptr, zArg uintptr) int32 { /* test7.c:142:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if (((zArg == uintptr(0)) || (int32(*(*int8)(unsafe.Pointer(zArg))) == 0)) || (int32(*(*int8)(unsafe.Pointer(zArg + 1))) != 0)) || !((int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zArg)))))*2))) & int32(_ISupper)) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+25245 /* "thread ID must b..." */, 0))
		return -1
	}
	return (int32(*(*int8)(unsafe.Pointer(zArg))) - 'A')
}

// Usage:    client_create NAME  FILENAME
//
// NAME should be an upper case letter.  Start the thread running with
// an open connection to the given database.
func tcl_client_create(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:156:26: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var i int32
	// var x pthread_t at bp+88, 4

	var rc int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25284 /* " ID FILENAME" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if threadset1[i].Fbusy != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25297 /* "thread " */, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+25305 /* " is already runn..." */, 0))
		return TCL_ERROR
	}
	threadset1[i].Fbusy = 1
	sqlite3.Xsqlite3_free(tls, threadset1[i].FzFilename)
	threadset1[i].FzFilename = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	threadset1[i].Fopnum = 1
	threadset1[i].Fcompleted = 0
	rc = libc2.Xpthread_create(tls, bp+88 /* &x */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{client_main})), (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, ts+25325 /* "failed to create..." */, 0))
		sqlite3.Xsqlite3_free(tls, threadset1[i].FzFilename)
		threadset1[i].Fbusy = 0
		return TCL_ERROR
	}
	libc2.Xpthread_detach(tls, *(*pthread_t)(unsafe.Pointer(bp + 88 /* x */)))
	if threadset1[i].FnServer == 0 {
		threadset1[i].FnServer = 1
		sqlite3_server_start2(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852 + 848 /* &.nServer */))
	}
	return TCL_OK
}

// Wait for a thread to reach its idle state.
func client_wait(tls *libc.TLS, p uintptr) { /* test7.c:200:13: */
	for (*Thread1)(unsafe.Pointer(p)).Fopnum > (*Thread1)(unsafe.Pointer(p)).Fcompleted {
		libc2.Xsched_yield(tls)
	}
}

// Usage:  client_wait ID
//
// Wait on thread ID to reach its idle state.
func tcl_client_wait(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:209:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	return TCL_OK
}

// Stop a thread.
func stop_thread(tls *libc.TLS, p uintptr) { /* test7.c:235:13: */
	client_wait(tls, p)
	(*Thread1)(unsafe.Pointer(p)).FxOp = uintptr(0)
	(*Thread1)(unsafe.Pointer(p)).Fopnum++
	client_wait(tls, p)
	sqlite3.Xsqlite3_free(tls, (*Thread1)(unsafe.Pointer(p)).FzArg)
	(*Thread1)(unsafe.Pointer(p)).FzArg = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*Thread1)(unsafe.Pointer(p)).FzFilename)
	(*Thread1)(unsafe.Pointer(p)).FzFilename = uintptr(0)
	(*Thread1)(unsafe.Pointer(p)).Fbusy = 0
}

// Usage:  client_halt ID
//
// Cause a client thread to shut itself down.  Wait for the shutdown to be
// completed.  If ID is "*" then stop all client threads.
func tcl_client_halt(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:253:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	if (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 1*4))))) == '*') && (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 1*4)) + 1))) == 0) {
		for i = 0; i < N_THREAD; i++ {
			if threadset1[i].Fbusy != 0 {
				stop_thread(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
			}
		}
	} else {
		i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		if i < 0 {
			return TCL_ERROR
		}
		if !(threadset1[i].Fbusy != 0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
			return TCL_ERROR
		}
		stop_thread(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	}

	// If no client threads are still running, also stop the server
	for i = 0; (i < N_THREAD) && (threadset1[i].Fbusy == 0); i++ {
	}
	if i >= N_THREAD {
		sqlite3_server_stop(tls)
		for 1 != 0 {
			for i = 0; (i < N_THREAD) && (threadset1[i].FnServer == 0); i++ {
			}
			if i == N_THREAD {
				break
			}
			libc2.Xsched_yield(tls)
		}
	}
	return TCL_OK
}

// Usage: client_argc  ID
//
// Wait on the most recent client_step to complete, then return the
// number of columns in the result set.
func tcl_client_argc(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:301:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var i int32
	// var zBuf [100]int8 at bp+72, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72 /* &zBuf[0] */, ts+1238 /* "%d" */, libc.VaList(bp+48, threadset1[i].Fargc))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+72 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: client_argv  ID   N
//
// Wait on the most recent client_step to complete, then return the
// value of the N-th columns in the result set.
func tcl_client_argv(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:333:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	// var n int32 at bp+80, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25372 /* " ID N" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+80 /* &n */) != 0 {
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	if (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) >= threadset1[i].Fargc) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+25378 /* "column number ou..." */, 0))
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852 + 48 /* &.argv */) + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))*4)), 0))
	return TCL_OK
}

// Usage: client_colname  ID   N
//
// Wait on the most recent client_step to complete, then return the
// name of the N-th columns in the result set.
func tcl_client_colname(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:369:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	// var n int32 at bp+80, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25372 /* " ID N" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+80 /* &n */) != 0 {
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	if (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) >= threadset1[i].Fargc) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+25378 /* "column number ou..." */, 0))
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852 + 448 /* &.colv */) + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))*4)), 0))
	return TCL_OK
}

// Usage: client_result  ID
//
// Wait on the most recent operation to complete, then return the
// result code from that operation.
func tcl_client_result(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:407:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var zName uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	zName = sqlite3.Xsqlite3ErrName(tls, threadset1[i].Frc)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, zName, 0))
	return TCL_OK
}

// Usage: client_error  ID
//
// Wait on the most recent operation to complete, then return the
// error string.
func tcl_client_error(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:439:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25353 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, threadset1[i].FzErr, 0))
	return TCL_OK
}

// This procedure runs in the thread to compile an SQL statement.
func do_compile1(tls *libc.TLS, p uintptr) { /* test7.c:466:13: */
	if (*Thread1)(unsafe.Pointer(p)).Fdb == uintptr(0) {
		(*Thread1)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+36 /* &.zStaticErr */, ts+25405 /* "no database is o..." */)
		(*Thread1)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	if (*Thread1)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3_client_finalize(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
		(*Thread1)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	(*Thread1)(unsafe.Pointer(p)).Frc = sqlite3_client_prepare(tls, (*Thread1)(unsafe.Pointer(p)).Fdb, (*Thread1)(unsafe.Pointer(p)).FzArg, -1, (p + 28 /* &.pStmt */), uintptr(0))
}

// Usage: client_compile ID SQL
//
// Compile a new virtual machine.
func tcl_client_compile(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:484:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var i int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25425 /* " ID SQL" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	threadset1[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_compile1}))
	sqlite3.Xsqlite3_free(tls, threadset1[i].FzArg)
	threadset1[i].FzArg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	threadset1[i].Fopnum++
	return TCL_OK
}

// This procedure runs in the thread to step the virtual machine.
func do_step1(tls *libc.TLS, p uintptr) { /* test7.c:513:13: */
	var i int32
	if (*Thread1)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread1)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+36 /* &.zStaticErr */, ts+25433 /* "no virtual machi..." */)
		(*Thread1)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread1)(unsafe.Pointer(p)).Frc = sqlite3_client_step(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
	if (*Thread1)(unsafe.Pointer(p)).Frc == SQLITE_ROW {
		(*Thread1)(unsafe.Pointer(p)).Fargc = sqlite3.Xsqlite3_column_count(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
		for i = 0; i < sqlite3.Xsqlite3_data_count(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt); i++ {
			*(*uintptr)(unsafe.Pointer((p + 48 /* &.argv */) + uintptr(i)*4)) = sqlite3.Xsqlite3_column_text(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt, i)
		}
		for i = 0; i < (*Thread1)(unsafe.Pointer(p)).Fargc; i++ {
			*(*uintptr)(unsafe.Pointer((p + 448 /* &.colv */) + uintptr(i)*4)) = sqlite3.Xsqlite3_column_name(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt, i)
		}
	}
}

// Usage: client_step ID
//
// Advance the virtual machine by one step
func tcl_client_step(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:537:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25462 /* " IDL" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	threadset1[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_step1}))
	threadset1[i].Fopnum++
	return TCL_OK
}

// This procedure runs in the thread to finalize a virtual machine.
func do_finalize1(tls *libc.TLS, p uintptr) { /* test7.c:564:13: */
	if (*Thread1)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread1)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+36 /* &.zStaticErr */, ts+25433 /* "no virtual machi..." */)
		(*Thread1)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread1)(unsafe.Pointer(p)).Frc = sqlite3_client_finalize(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
	(*Thread1)(unsafe.Pointer(p)).FpStmt = uintptr(0)
}

// Usage: client_finalize ID
//
// Finalize the virtual machine.
func tcl_client_finalize(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:579:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25462 /* " IDL" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	threadset1[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_finalize1}))
	sqlite3.Xsqlite3_free(tls, threadset1[i].FzArg)
	threadset1[i].FzArg = uintptr(0)
	threadset1[i].Fopnum++
	return TCL_OK
}

// This procedure runs in the thread to reset a virtual machine.
func do_reset(tls *libc.TLS, p uintptr) { /* test7.c:608:13: */
	if (*Thread1)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread1)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+36 /* &.zStaticErr */, ts+25433 /* "no virtual machi..." */)
		(*Thread1)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread1)(unsafe.Pointer(p)).Frc = sqlite3_client_reset(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
	(*Thread1)(unsafe.Pointer(p)).FpStmt = uintptr(0)
}

// Usage: client_reset ID
//
// Finalize the virtual machine.
func tcl_client_reset(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:623:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25462 /* " IDL" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	threadset1[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_reset}))
	sqlite3.Xsqlite3_free(tls, threadset1[i].FzArg)
	threadset1[i].FzArg = uintptr(0)
	threadset1[i].Fopnum++
	return TCL_OK
}

// Usage: client_swap ID ID
//
// Interchange the sqlite* pointer between two threads.
func tcl_client_swap(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:654:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var j int32
	var temp uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25467 /* " ID1 ID2" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*852))
	j = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	if j < 0 {
		return TCL_ERROR
	}
	if !(threadset1[j].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+25357 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, (uintptr(unsafe.Pointer(&threadset1)) + uintptr(j)*852))
	temp = threadset1[i].Fdb
	threadset1[i].Fdb = threadset1[j].Fdb
	threadset1[j].Fdb = temp
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest7_Init(tls *libc.TLS, interp uintptr) int32 { /* test7.c:690:5: */
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aCmd6)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd6[i].FzName, aCmd6[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aCmd6 = [13]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 26491 /* "client_create" */, FxProc: 0},
	{FzName: ts + 26505 /* "client_wait" */, FxProc: 0},
	{FzName: ts + 26517 /* "client_halt" */, FxProc: 0},
	{FzName: ts + 26529 /* "client_argc" */, FxProc: 0},
	{FzName: ts + 26541 /* "client_argv" */, FxProc: 0},
	{FzName: ts + 26553 /* "client_colname" */, FxProc: 0},
	{FzName: ts + 26568 /* "client_result" */, FxProc: 0},
	{FzName: ts + 26582 /* "client_error" */, FxProc: 0},
	{FzName: ts + 26595 /* "client_compile" */, FxProc: 0},
	{FzName: ts + 26610 /* "client_step" */, FxProc: 0},
	{FzName: ts + 26622 /* "client_reset" */, FxProc: 0},
	{FzName: ts + 26635 /* "client_finalize" */, FxProc: 0},
	{FzName: ts + 26651 /* "client_swap" */, FxProc: 0},
} /* test7.c:694:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

type echo_vtab1 = struct {
	Fbase          sqlite3_vtab
	Finterp        uintptr
	Fdb            uintptr
	FisPattern     int32
	FinTransaction int32
	FzThis         uintptr
	FzTableName    uintptr
	FzLogName      uintptr
	FnCol          int32
	FaIndex        uintptr
	FaCol          uintptr
} /* test8.c:27:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

type echo_vtab = echo_vtab1 /* test8.c:27:26 */
type echo_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
} /* test8.c:28:9 */

type echo_cursor = echo_cursor1 /* test8.c:28:28 */

func simulateVtabError(tls *libc.TLS, p uintptr, zMethod uintptr) int32 { /* test8.c:97:12: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var zErr uintptr
	// var zVarname [128]int8 at bp+24, 128

	*(*int8)(unsafe.Pointer(bp + 24 /* &zVarname[0] */ + 127)) = int8(0)
	sqlite3.Xsqlite3_snprintf(tls, 127, bp+24 /* &zVarname[0] */, ts+26663 /* "echo_module_fail..." */, libc.VaList(bp, zMethod, (*echo_vtab)(unsafe.Pointer(p)).FzTableName))
	zErr = tcl.XTcl_GetVar2(tls, (*echo_vtab)(unsafe.Pointer(p)).Finterp, bp+24 /* &zVarname[0] */, uintptr(0), TCL_GLOBAL_ONLY)
	if zErr != 0 {
		(*echo_vtab)(unsafe.Pointer(p)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+26687 /* "echo-vtab-error:..." */, libc.VaList(bp+16, zErr))
	}
	return (libc.Bool32(zErr != uintptr(0)))
}

// Convert an SQL-style quoted string into a normal string by removing
// the quote characters.  The conversion is done in-place.  If the
// input does not begin with a quote character, then this routine
// is a no-op.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func dequoteString(tls *libc.TLS, z uintptr) { /* test8.c:122:13: */
	var quote int32
	var i int32
	var j int32
	if z == uintptr(0) {
		return
	}
	quote = int32(*(*int8)(unsafe.Pointer(z)))
	switch quote {
	case '\'':
		break
	case '"':
		break
	case '`':
		break // For MySQL compatibility
	case '[':
		quote = ']'
		break // For MS SqlServer compatibility
	default:
		return
	}
	i = 1
	j = 0
	for ; *(*int8)(unsafe.Pointer(z + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == quote {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr((i + 1))))) == quote {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(quote)
				i++
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(0)
				break
			}
		} else {
			*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(i)))
		}
	}
}

// Retrieve the column names for the table named zTab via database
// connection db. SQLITE_OK is returned on success, or an sqlite error
// code otherwise.
//
// If successful, the number of columns is written to *pnCol. *paCol is
// set to point at sqlite3_malloc()'d space containing the array of
// nCol column names. The caller is responsible for calling sqlite3_free
// on *paCol.
func getColumnNames(tls *libc.TLS, db uintptr, zTab uintptr, paCol uintptr, pnCol uintptr) int32 { /* test8.c:159:12: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var aCol uintptr
	var zSql uintptr
	// var pStmt uintptr at bp+16, 4

	var rc int32
	var nCol int32
	var zName uintptr
	var ii int32
	var nBytes int32
	var zSpace uintptr
	aCol = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)) = uintptr(0)
	rc = SQLITE_OK
	nCol = 0

	// Prepare the statement "SELECT * FROM <tbl>". The column names
	// of the result set of the compiled SELECT will be the same as
	// the column names of table <tbl>.
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+26707 /* "SELECT * FROM %Q" */, libc.VaList(bp, zTab))
	if !(!(zSql != 0)) {
		goto __1
	}
	rc = SQLITE_NOMEM
	goto out
__1:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+16 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	if !(rc == SQLITE_OK) {
		goto __2
	}
	nCol = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)))

	// Figure out how much space to allocate for the array of column names
	// (including space for the strings themselves). Then allocate it.
	nBytes = (int32(uint32(unsafe.Sizeof(uintptr(0))) * uint32(nCol)))
	ii = 0
__3:
	if !(ii < nCol) {
		goto __5
	}
	zName = sqlite3.Xsqlite3_column_name(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), ii)
	if !(!(zName != 0)) {
		goto __6
	}
	rc = SQLITE_NOMEM
	goto out
__6:
	;
	nBytes = nBytes + (int32(libc.Xstrlen(tls, zName)) + 1)
	goto __4
__4:
	ii++
	goto __3
	goto __5
__5:
	;
	aCol = sqlite3.Xsqlite3MallocZero(tls, uint64(nBytes))
	if !(!(aCol != 0)) {
		goto __7
	}
	rc = SQLITE_NOMEM
	goto out
__7:
	;

	// Copy the column names into the allocated space and set up the
	// pointers in the aCol[] array.
	zSpace = (aCol + uintptr(nCol)*4)
	ii = 0
__8:
	if !(ii < nCol) {
		goto __10
	}
	*(*uintptr)(unsafe.Pointer(aCol + uintptr(ii)*4)) = zSpace
	sqlite3.Xsqlite3_snprintf(tls, nBytes, zSpace, ts /* "%s" */, libc.VaList(bp+8, sqlite3.Xsqlite3_column_name(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), ii)))
	zSpace += (uintptr(int32(libc.Xstrlen(tls, zSpace)) + 1))
	goto __9
__9:
	ii++
	goto __8
	goto __10
__10:
	;

__2:
	;

	*(*uintptr)(unsafe.Pointer(paCol)) = aCol
	*(*int32)(unsafe.Pointer(pnCol)) = nCol

out:
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)))
	return rc
}

// Parameter zTab is the name of a table in database db with nCol
// columns. This function allocates an array of integers nCol in
// size and populates it according to any implicit or explicit
// indices on table zTab.
//
// If successful, SQLITE_OK is returned and *paIndex set to point
// at the allocated array. Otherwise, an error code is returned.
//
// See comments associated with the member variable aIndex above
// "struct echo_vtab" for details of the contents of the array.
func getIndexArray(tls *libc.TLS, db uintptr, zTab uintptr, nCol int32, paIndex uintptr) int32 { /* test8.c:239:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var pStmt uintptr at bp+16, 4

	var aIndex uintptr
	var rc int32
	var zSql uintptr
	var cid int32
	var zIdx uintptr
	// var pStmt2 uintptr at bp+20, 4

	var rc2 int32
	*(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)) = uintptr(0)
	aIndex = uintptr(0)

	// Allocate space for the index array
	aIndex = sqlite3.Xsqlite3MallocZero(tls, (uint64(uint32(unsafe.Sizeof(int32(0))) * uint32(nCol))))
	if !(!(aIndex != 0)) {
		goto __1
	}
	rc = SQLITE_NOMEM
	goto get_index_array_out
__1:
	;

	// Compile an sqlite pragma to loop through all indices on table zTab
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+26724 /* "PRAGMA index_lis..." */, libc.VaList(bp, zTab))
	if !(!(zSql != 0)) {
		goto __2
	}
	rc = SQLITE_NOMEM
	goto get_index_array_out
__2:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+16 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	// For each index, figure out the left-most column and set the
	// corresponding entry in aIndex[] to 1.
__3:
	if !((*(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)) != 0) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */))) == SQLITE_ROW)) {
		goto __4
	}
	zIdx = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), 1)
	*(*uintptr)(unsafe.Pointer(bp + 20 /* pStmt2 */)) = uintptr(0)
	if !(zIdx == uintptr(0)) {
		goto __5
	}
	goto __3
__5:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+26746 /* "PRAGMA index_inf..." */, libc.VaList(bp+8, zIdx))
	if !(!(zSql != 0)) {
		goto __6
	}
	rc = SQLITE_NOMEM
	goto get_index_array_out
__6:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+20 /* &pStmt2 */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !((*(*uintptr)(unsafe.Pointer(bp + 20 /* pStmt2 */)) != 0) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pStmt2 */))) == SQLITE_ROW)) {
		goto __7
	}
	cid = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pStmt2 */)), 1)

	*(*int32)(unsafe.Pointer(aIndex + uintptr(cid)*4)) = 1
__7:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 20 /* pStmt2 */)) != 0) {
		goto __8
	}
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pStmt2 */)))
__8:
	;
	if !(rc != SQLITE_OK) {
		goto __9
	}
	goto get_index_array_out
__9:
	;
	goto __3
__4:
	;

get_index_array_out:
	if !(*(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)) != 0) {
		goto __10
	}
	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)))
	if !(rc == SQLITE_OK) {
		goto __11
	}
	rc = rc2
__11:
	;
__10:
	;
	if !(rc != SQLITE_OK) {
		goto __12
	}
	sqlite3.Xsqlite3_free(tls, aIndex)
	aIndex = uintptr(0)
__12:
	;
	*(*uintptr)(unsafe.Pointer(paIndex)) = aIndex
	return rc
}

// Global Tcl variable $echo_module is a list. This routine appends
// the string element zArg to that list in interpreter interp.
func appendToEchoModule(tls *libc.TLS, interp uintptr, zArg uintptr) { /* test8.c:313:13: */
	var flags int32 = ((TCL_APPEND_VALUE | TCL_LIST_ELEMENT) | TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+26768 /* "echo_module" */, uintptr(0), func() uintptr {
		if zArg != 0 {
			return zArg
		}
		return ts + 489 /* "" */
	}(), flags)
}

// This function is called from within the echo-modules xCreate and
// xConnect methods. The argc and argv arguments are copies of those
// passed to the calling method. This function is responsible for
// calling sqlite3_declare_vtab() to declare the schema of the virtual
// table being created or connected.
//
// If the constructor was passed just one argument, i.e.:
//
//   CREATE TABLE t1 AS echo(t2);
//
// Then t2 is assumed to be the name of a *real* database table. The
// schema of the virtual table is declared by passing a copy of the
// CREATE TABLE statement for the real table to sqlite3_declare_vtab().
// Hence, the virtual table should have exactly the same column names and
// types as the real table.
func echoDeclareVtab(tls *libc.TLS, pVtab uintptr, db uintptr) int32 { /* test8.c:335:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32 = SQLITE_OK

	if (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare(tls, db,
			ts+26780, /* "SELECT sql FROM ..." */
			-1, bp /* &pStmt */, uintptr(0))
		if rc == SQLITE_OK {
			sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 1, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, -1, uintptr(0))
			if sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))) == SQLITE_ROW {
				var rc2 int32
				var zCreateTable uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 0)
				rc = sqlite3.Xsqlite3_declare_vtab(tls, db, zCreateTable)
				rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
				if rc == SQLITE_OK {
					rc = rc2
				}
			} else {
				rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
				if rc == SQLITE_OK {
					rc = SQLITE_ERROR
				}
			}
			if rc == SQLITE_OK {
				rc = getColumnNames(tls, db, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, (pVtab + 48 /* &.aCol */), (pVtab + 40 /* &.nCol */))
			}
			if rc == SQLITE_OK {
				rc = getIndexArray(tls, db, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, (*echo_vtab)(unsafe.Pointer(pVtab)).FnCol, (pVtab + 44 /* &.aIndex */))
			}
		}
	}

	return rc
}

// This function frees all runtime structures associated with the virtual
// table pVtab.
func echoDestructor(tls *libc.TLS, pVtab uintptr) int32 { /* test8.c:378:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FaIndex)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FaCol)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzThis)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzTableName)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzLogName)
	sqlite3.Xsqlite3_free(tls, p)
	return 0
}

type EchoModule1 = struct {
	Finterp uintptr
	Fdb     uintptr
} /* test8.c:389:9 */

type EchoModule = EchoModule1 /* test8.c:389:27 */

// This function is called to do the work of the xConnect() method -
// to allocate the required in-memory structures for a newly connected
// virtual table.
func echoConstructor(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test8.c:400:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32
	var i int32
	var pVtab uintptr

	// Allocate the sqlite3_vtab/echo_vtab structure itself
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(echo_vtab{})))
	if !(pVtab != 0) {
		return SQLITE_NOMEM
	}
	(*echo_vtab)(unsafe.Pointer(pVtab)).Finterp = (*EchoModule)(unsafe.Pointer(pAux)).Finterp
	(*echo_vtab)(unsafe.Pointer(pVtab)).Fdb = db

	// Allocate echo_vtab.zThis
	(*echo_vtab)(unsafe.Pointer(pVtab)).FzThis = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	if !(int32((*echo_vtab)(unsafe.Pointer(pVtab)).FzThis) != 0) {
		echoDestructor(tls, pVtab)
		return SQLITE_NOMEM
	}

	// Allocate echo_vtab.zTableName
	if argc > 3 {
		(*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(argv + 3*4))))
		dequoteString(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)
		if ((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName != 0) && (int32(*(*int8)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))) == '*') {
			var z uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+26844 /* "%s%s" */, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + 2*4)), ((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName+1)))
			sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)
			(*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName = z
			(*echo_vtab)(unsafe.Pointer(pVtab)).FisPattern = 1
		}
		if !(int32((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName) != 0) {
			echoDestructor(tls, pVtab)
			return SQLITE_NOMEM
		}
	}

	// Log the arguments to this function to Tcl var ::echo_module
	for i = 0; i < argc; i++ {
		appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	}

	// Invoke sqlite3_declare_vtab and set up other members of the echo_vtab
	// structure. If an error occurs, delete the sqlite3_vtab structure and
	// return an error code.
	rc = echoDeclareVtab(tls, pVtab, db)
	if rc != SQLITE_OK {
		echoDestructor(tls, pVtab)
		return rc
	}

	// Success. Set *ppVtab and return
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pVtab /* &.base */)
	return SQLITE_OK
}

// Echo virtual table module xCreate method.
func echoCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test8.c:465:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	appendToEchoModule(tls, (*EchoModule)(unsafe.Pointer(pAux)).Finterp, ts+26849 /* "xCreate" */)
	rc = echoConstructor(tls, db, pAux, argc, argv, ppVtab, pzErr)

	// If there were two arguments passed to the module at the SQL level
	// (i.e. "CREATE VIRTUAL TABLE tbl USING echo(arg1, arg2)"), then
	// the second argument is used as a table name. Attempt to create
	// such a table with a single column, "logmsg". This table will
	// be used to log calls to the xUpdate method. It will be deleted
	// when the virtual table is DROPed.
	//
	// Note: The main point of this is to test that we can drop tables
	// from within an xDestroy method call.
	if (rc == SQLITE_OK) && (argc == 5) {
		var zSql uintptr
		var pVtab uintptr = *(*uintptr)(unsafe.Pointer(ppVtab))
		(*echo_vtab)(unsafe.Pointer(pVtab)).FzLogName = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 4*4))))
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+26857 /* "CREATE TABLE %Q(..." */, libc.VaList(bp+8, (*echo_vtab)(unsafe.Pointer(pVtab)).FzLogName))
		rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, sqlite3.Xsqlite3_errmsg(tls, db)))
		}
	}

	if (*(*uintptr)(unsafe.Pointer(ppVtab)) != 0) && (rc != SQLITE_OK) {
		echoDestructor(tls, *(*uintptr)(unsafe.Pointer(ppVtab)))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	}

	if rc == SQLITE_OK {
		(*echo_vtab)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ppVtab)))).FinTransaction = 1
	}

	return rc
}

// Echo virtual table module xConnect method.
func echoConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test8.c:513:12: */
	appendToEchoModule(tls, (*EchoModule)(unsafe.Pointer(pAux)).Finterp, ts+26881 /* "xConnect" */)
	return echoConstructor(tls, db, pAux, argc, argv, ppVtab, pzErr)
}

// Echo virtual table module xDisconnect method.
func echoDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test8.c:527:12: */
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+26890 /* "xDisconnect" */)
	return echoDestructor(tls, pVtab)
}

// Echo virtual table module xDestroy method.
func echoDestroy(tls *libc.TLS, pVtab uintptr) int32 { /* test8.c:535:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK
	var p uintptr = pVtab
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+26902 /* "xDestroy" */)

	// Drop the "log" table, if one exists (see echoCreate() for details)
	if (p != 0) && ((*echo_vtab)(unsafe.Pointer(p)).FzLogName != 0) {
		var zSql uintptr
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+26911 /* "DROP TABLE %Q" */, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(p)).FzLogName))
		rc = sqlite3.Xsqlite3_exec(tls, (*echo_vtab)(unsafe.Pointer(p)).Fdb, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}

	if rc == SQLITE_OK {
		rc = echoDestructor(tls, pVtab)
	}
	return rc
}

// Echo virtual table module xOpen method.
func echoOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test8.c:557:12: */
	var pCur uintptr
	if simulateVtabError(tls, pVTab, ts+26925 /* "xOpen" */) != 0 {
		return SQLITE_ERROR
	}
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(echo_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return func() int32 {
		if pCur != 0 {
			return SQLITE_OK
		}
		return SQLITE_NOMEM
	}()
}

// Echo virtual table module xClose method.
func echoClose(tls *libc.TLS, cur uintptr) int32 { /* test8.c:570:12: */
	var rc int32
	var pCur uintptr = cur
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt
	(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)
	sqlite3.Xsqlite3_free(tls, pCur)
	rc = sqlite3.Xsqlite3_finalize(tls, pStmt)
	return rc
}

// Return non-zero if the cursor does not currently point to a valid record
// (i.e if the scan has finished), or zero otherwise.
func echoEof(tls *libc.TLS, cur uintptr) int32 { /* test8.c:584:12: */
	return func() int32 {
		if (*echo_cursor)(unsafe.Pointer(cur)).FpStmt != 0 {
			return 0
		}
		return 1
	}()
}

// Echo virtual table module xNext method.
func echoNext(tls *libc.TLS, cur uintptr) int32 { /* test8.c:591:12: */
	var rc int32 = SQLITE_OK
	var pCur uintptr = cur

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+26931 /* "xNext" */) != 0 {
		return SQLITE_ERROR
	}

	if (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt != 0 {
		rc = sqlite3.Xsqlite3_step(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
		if rc == SQLITE_ROW {
			rc = SQLITE_OK
		} else {
			rc = sqlite3.Xsqlite3_finalize(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
			(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)
		}
	}

	return rc
}

// Echo virtual table module xColumn method.
func echoColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test8.c:615:12: */
	var iCol int32 = (i + 1)
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(cur)).FpStmt

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+26937 /* "xColumn" */) != 0 {
		return SQLITE_ERROR
	}

	if !(pStmt != 0) {
		sqlite3.Xsqlite3_result_null(tls, ctx)
	} else {

		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, pStmt, iCol))
	}
	return SQLITE_OK
}

// Echo virtual table module xRowid method.
func echoRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test8.c:635:12: */
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(cur)).FpStmt

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+2165 /* "xRowid" */) != 0 {
		return SQLITE_ERROR
	}

	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	return SQLITE_OK
}

// Compute a simple hash of the null terminated string zString.
//
// This module uses only sqlite3_index_info.idxStr, not
// sqlite3_index_info.idxNum. So to test idxNum, when idxStr is set
// in echoBestIndex(), idxNum is set to the corresponding hash value.
// In echoFilter(), code assert()s that the supplied idxNum value is
// indeed the hash of the supplied idxStr.
func hashString(tls *libc.TLS, zString uintptr) int32 { /* test8.c:655:12: */
	var val u32 = u32(0)
	var ii int32
	for ii = 0; *(*int8)(unsafe.Pointer(zString + uintptr(ii))) != 0; ii++ {
		val = ((val << 3) + u32(int32(*(*int8)(unsafe.Pointer(zString + uintptr(ii))))))
	}
	return (int32(val & u32(0x7fffffff)))
}

// Echo virtual table module xFilter method.
func echoFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test8.c:667:12: */
	var rc int32
	var i int32

	var pCur uintptr = pVtabCursor
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var db uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb

	if simulateVtabError(tls, pVtab, ts+26945 /* "xFilter" */) != 0 {
		return SQLITE_ERROR
	}

	// Check that idxNum matches idxStr

	// Log arguments to the ::echo_module Tcl variable
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+26945 /* "xFilter" */)
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, idxStr)
	for i = 0; i < argc; i++ {
		appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
	}

	sqlite3.Xsqlite3_finalize(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
	(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)

	// Prepare the SQL statement created by echoBestIndex and bind the
	// runtime parameters passed to this function to it.
	rc = sqlite3.Xsqlite3_prepare(tls, db, idxStr, -1, (pCur + 4 /* &.pStmt */), uintptr(0))

	for i = 0; (rc == SQLITE_OK) && (i < argc); i++ {
		rc = sqlite3.Xsqlite3_bind_value(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt, (i + 1), *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	}

	// If everything was successful, advance to the first row of the scan
	if rc == SQLITE_OK {
		rc = echoNext(tls, pVtabCursor)
	}

	return rc
}

// A helper function used by echoUpdate() and echoBestIndex() for
// manipulating strings in concert with the sqlite3_mprintf() function.
//
// Parameter pzStr points to a pointer to a string allocated with
// sqlite3_mprintf. The second parameter, zAppend, points to another
// string. The two strings are concatenated together and *pzStr
// set to point at the result. The initial buffer pointed to by *pzStr
// is deallocated via sqlite3_free().
//
// If the third argument, doFree, is true, then sqlite3_free() is
// also called to free the buffer pointed to by zAppend.
func string_concat(tls *libc.TLS, pzStr uintptr, zAppend uintptr, doFree int32, pRc uintptr) { /* test8.c:727:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zIn uintptr = *(*uintptr)(unsafe.Pointer(pzStr))
	if (!(zAppend != 0) && (doFree != 0)) && (*(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK) {
		*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
	}
	if *(*int32)(unsafe.Pointer(pRc)) != SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, zIn)
		zIn = uintptr(0)
	} else {
		if zIn != 0 {
			var zTemp uintptr = zIn
			zIn = sqlite3.Xsqlite3_mprintf(tls, ts+26844 /* "%s%s" */, libc.VaList(bp, zIn, zAppend))
			sqlite3.Xsqlite3_free(tls, zTemp)
		} else {
			zIn = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, zAppend))
		}
		if !(zIn != 0) {
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		}
	}
	*(*uintptr)(unsafe.Pointer(pzStr)) = zIn
	if doFree != 0 {
		sqlite3.Xsqlite3_free(tls, zAppend)
	}
}

// This function returns a pointer to an sqlite3_malloc()ed buffer
// containing the select-list (the thing between keywords SELECT and FROM)
// to query the underlying real table with for the scan described by
// argument pIdxInfo.
//
// If the current SQLite version is earlier than 3.10.0, this is just "*"
// (select all columns). Or, for version 3.10.0 and greater, the list of
// columns identified by the pIdxInfo->colUsed mask.
func echoSelectList(tls *libc.TLS, pTab uintptr, pIdxInfo uintptr) uintptr { /* test8.c:763:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zRet uintptr = uintptr(0)
	if sqlite3.Xsqlite3_libversion_number(tls) < 3010000 {
		zRet = sqlite3.Xsqlite3_mprintf(tls, ts+26953 /* ", *" */, 0)
	} else {
		var i int32
		for i = 0; i < (*echo_vtab)(unsafe.Pointer(pTab)).FnCol; i++ {
			if ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FcolUsed & (sqlite3_uint64(uint64(1)) << (func() int32 {
				if i >= 63 {
					return 63
				}
				return i
			}()))) != 0 {
				zRet = sqlite3.Xsqlite3_mprintf(tls, ts+26957 /* "%z, %s" */, libc.VaList(bp, zRet, *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pTab)).FaCol + uintptr(i)*4))))
			} else {
				zRet = sqlite3.Xsqlite3_mprintf(tls, ts+26964 /* "%z, NULL" */, libc.VaList(bp+16, zRet))
			}
			if !(zRet != 0) {
				break
			}
		}
	}
	return zRet
}

// The echo module implements the subset of query constraints and sort
// orders that may take advantage of SQLite indices on the underlying
// real table. For example, if the real table is declared as:
//
//     CREATE TABLE real(a, b, c);
//     CREATE INDEX real_index ON real(b);
//
// then the echo module handles WHERE or ORDER BY clauses that refer
// to the column "b", but not "a" or "c". If a multi-column index is
// present, only its left most column is considered.
//
// This xBestIndex method encodes the proposed search strategy as
// an SQL query on the real table underlying the virtual echo module
// table and stores the query in sqlite3_index_info.idxStr. The SQL
// statement is of the form:
//
//   SELECT rowid, * FROM <real-table> ?<where-clause>? ?<order-by-clause>?
//
// where the <where-clause> and <order-by-clause> are determined
// by the contents of the structure pointed to by the pIdxInfo argument.
func echoBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test8.c:803:12: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var ii int32
	*(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */)) = uintptr(0)
	var zCol uintptr = uintptr(0)
	var zNew uintptr
	var nArg int32 = 0
	var zSep uintptr = ts + 8838 /* "WHERE" */
	var pVtab uintptr = tab
	*(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)) = uintptr(0)
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp

	var nRow int32 = 0
	var useIdx int32 = 0
	*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = SQLITE_OK
	var useCost int32 = 0
	var cost float64 = float64(0)
	var isIgnoreUsable int32 = 0
	if tcl.XTcl_GetVar2(tls, interp, ts+26973 /* "echo_module_igno..." */, uintptr(0), TCL_GLOBAL_ONLY) != 0 {
		isIgnoreUsable = 1
	}

	if simulateVtabError(tls, pVtab, ts+26999 /* "xBestIndex" */) != 0 {
		return SQLITE_ERROR
	}

	// Determine the number of rows in the table and store this value in local
	// variable nRow. The 'estimated-cost' of the scan will be the number of
	// rows in the table for a linear scan, or the log (base 2) of the
	// number of rows if the proposed scan uses an index.
	if tcl.XTcl_GetVar2(tls, interp, ts+27010 /* "echo_module_cost" */, uintptr(0), TCL_GLOBAL_ONLY) != 0 {
		cost = libc.Xatof(tls, tcl.XTcl_GetVar2(tls, interp, ts+27010 /* "echo_module_cost" */, uintptr(0), TCL_GLOBAL_ONLY))
		useCost = 1
	} else {
		*(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */)) = sqlite3.Xsqlite3_mprintf(tls, ts+27027 /* "SELECT count(*) ..." */, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */)) != 0) {
			return SQLITE_NOMEM
		}
		*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = sqlite3.Xsqlite3_prepare(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb, *(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */)), -1, bp+80 /* &pStmt */, uintptr(0))
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */)))
		if *(*int32)(unsafe.Pointer(bp + 88 /* rc */)) != SQLITE_OK {
			return *(*int32)(unsafe.Pointer(bp + 88 /* rc */))
		}
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)))
		nRow = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), 0)
		*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)))
		if *(*int32)(unsafe.Pointer(bp + 88 /* rc */)) != SQLITE_OK {
			return *(*int32)(unsafe.Pointer(bp + 88 /* rc */))
		}
	}

	zCol = echoSelectList(tls, pVtab, pIdxInfo)
	if !(zCol != 0) {
		return SQLITE_NOMEM
	}
	*(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */)) = sqlite3.Xsqlite3_mprintf(tls, ts+27051 /* "SELECT rowid%z F..." */, libc.VaList(bp+8, zCol, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
	if !(*(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */)) != 0) {
		return SQLITE_NOMEM
	}

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pConstraint uintptr
		var pUsage uintptr
		var iCol int32

		pConstraint = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		pUsage = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8)

		if !(isIgnoreUsable != 0) && !(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) != 0) {
			continue
		}

		iCol = (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn
		if (iCol < 0) || (*(*int32)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaIndex + uintptr(iCol)*4)) != 0) {
			var zNewCol uintptr
			if iCol >= 0 {
				zNewCol = *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(iCol)*4))
			} else {
				zNewCol = ts + 27074 /* "rowid" */
			}
			var zOp uintptr = uintptr(0)
			useIdx = 1
			switch int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) {
			case SQLITE_INDEX_CONSTRAINT_EQ:
				zOp = ts + 27080 /* "=" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LT:
				zOp = ts + 27082 /* "<" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GT:
				zOp = ts + 27084 /* ">" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LE:
				zOp = ts + 27086 /* "<=" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GE:
				zOp = ts + 27089 /* ">=" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_MATCH:
				// Purposely translate the MATCH operator into a LIKE, which
				// will be used by the next block of code to construct a new
				// query.  It should also be noted here that the next block
				// of code requires the first letter of this operator to be
				// in upper-case to trigger the special MATCH handling (i.e.
				// wrapping the bound parameter with literal '%'s).
				zOp = ts + 27092 /* "LIKE" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LIKE:
				zOp = ts + 27097 /* "like" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GLOB:
				zOp = ts + 27102 /* "glob" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_REGEXP:
				zOp = ts + 6335 /* "regexp" */
				break
			}
			if zOp != 0 {
				if int32(*(*int8)(unsafe.Pointer(zOp))) == 'L' {
					zNew = sqlite3.Xsqlite3_mprintf(tls, ts+27107, /* " %s %s LIKE (SEL..." */
						libc.VaList(bp+24, zSep, zNewCol))
				} else {
					zNew = sqlite3.Xsqlite3_mprintf(tls, ts+27142 /* " %s %s %s ?" */, libc.VaList(bp+40, zSep, zNewCol, zOp))
				}
				string_concat(tls, bp+84 /* &zQuery */, zNew, 1, bp+88 /* &rc */)
				zSep = ts + 8865 /* "AND" */
				(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&nArg, 1)
				(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
			}
		}
	}

	// If there is only one term in the ORDER BY clause, and it is
	// on a column that this virtual table has an index for, then consume
	// the ORDER BY clause.
	if ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) && (((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn < 0) || (*(*int32)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaIndex + uintptr((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn)*4)) != 0)) {
		var iCol int32 = (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn
		var zNewCol uintptr
		if iCol >= 0 {
			zNewCol = *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(iCol)*4))
		} else {
			zNewCol = ts + 27074 /* "rowid" */
		}
		var zDir uintptr
		if (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc != 0 {
			zDir = ts + 27154 /* "DESC" */
		} else {
			zDir = ts + 27159 /* "ASC" */
		}
		zNew = sqlite3.Xsqlite3_mprintf(tls, ts+27163 /* " ORDER BY %s %s" */, libc.VaList(bp+64, zNewCol, zDir))
		string_concat(tls, bp+84 /* &zQuery */, zNew, 1, bp+88 /* &rc */)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}

	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+26999 /* "xBestIndex" */)

	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, *(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */)))

	if !(*(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */)) != 0) {
		return *(*int32)(unsafe.Pointer(bp + 88 /* rc */))
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = hashString(tls, *(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */)))
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = *(*uintptr)(unsafe.Pointer(bp + 84 /* zQuery */))
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1
	if useCost != 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = cost
	} else if useIdx != 0 {
		// Approximation of log2(nRow).
		for ii = 0; uint32(ii) < ((uint32(unsafe.Sizeof(int32(0))) * uint32(8)) - uint32(1)); ii++ {
			if (nRow & (int32(1) << ii)) != 0 {
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(ii)
			}
		}
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(nRow)
	}
	return *(*int32)(unsafe.Pointer(bp + 88 /* rc */))
}

// The xUpdate method for echo module virtual tables.
//
//    apData[0]  apData[1]  apData[2..]
//
//    INTEGER                              DELETE
//
//    INTEGER    NULL       (nCol args)    UPDATE (do not set rowid)
//    INTEGER    INTEGER    (nCol args)    UPDATE (with SET rowid = <arg1>)
//
//    NULL       NULL       (nCol args)    INSERT INTO (automatic rowid value)
//    NULL       INTEGER    (nCol args)    INSERT (incl. rowid value)
//
func echoUpdate(tls *libc.TLS, tab uintptr, nData int32, apData uintptr, pRowid uintptr) int32 { /* test8.c:969:5: */
	bp := tls.Alloc(116)
	defer tls.Free(116)

	var pVtab uintptr = tab
	var db uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb
	*(*int32)(unsafe.Pointer(bp + 100 /* rc */)) = SQLITE_OK

	*(*uintptr)(unsafe.Pointer(bp + 112 /* pStmt */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) = uintptr(0) // SQL statement to execute
	var bindArgZero int32 = 0                                 // True to bind apData[0] to sql var no. nData
	var bindArgOne int32 = 0                                  // True to bind apData[1] to sql var no. 1
	var i int32                                               // Counter variable used by for loops

	// Ticket #3083 - make sure we always start a transaction prior to
	// making any changes to a virtual table

	if simulateVtabError(tls, pVtab, ts+27179 /* "xUpdate" */) != 0 {
		return SQLITE_ERROR
	}

	// If apData[0] is an integer and nData>1 then do an UPDATE
	if (nData > 1) && (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData))) == SQLITE_INTEGER) {
		var zSep uintptr = ts + 27187 /* " SET" */
		*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) = sqlite3.Xsqlite3_mprintf(tls, ts+27192 /* "UPDATE %Q" */, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 100 /* rc */)) = SQLITE_NOMEM
		}

		bindArgOne = (libc.Bool32((*(*uintptr)(unsafe.Pointer(apData + 1*4)) != 0) && (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + 1*4))) == SQLITE_INTEGER)))
		bindArgZero = 1

		if bindArgOne != 0 {
			string_concat(tls, bp+96 /* &z */, ts+27202 /* " SET rowid=?1 " */, 0, bp+100 /* &rc */)
			zSep = ts + 4619 /* "," */
		}
		for i = 2; i < nData; i++ {
			if *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*4)) == uintptr(0) {
				continue
			}
			string_concat(tls, bp+96 /* &z */, sqlite3.Xsqlite3_mprintf(tls,
				ts+27217 /* "%s %Q=?%d" */, libc.VaList(bp+8, zSep, *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr((i-2))*4)), i)), 1, bp+100 /* &rc */)
			zSep = ts + 4619 /* "," */
		}
		string_concat(tls, bp+96 /* &z */, sqlite3.Xsqlite3_mprintf(tls, ts+27227 /* " WHERE rowid=?%d" */, libc.VaList(bp+32, nData)), 1, bp+100 /* &rc */)
	} else if (nData == 1) && (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData))) == SQLITE_INTEGER) {
		*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) = sqlite3.Xsqlite3_mprintf(tls, ts+27244 /* "DELETE FROM %Q W..." */, libc.VaList(bp+40, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 100 /* rc */)) = SQLITE_NOMEM
		}
		bindArgZero = 1
	} else if (nData > 2) && (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData))) == SQLITE_NULL) {
		var ii int32
		*(*uintptr)(unsafe.Pointer(bp + 104 /* zInsert */)) = uintptr(0)
		*(*uintptr)(unsafe.Pointer(bp + 108 /* zValues */)) = uintptr(0)

		*(*uintptr)(unsafe.Pointer(bp + 104 /* zInsert */)) = sqlite3.Xsqlite3_mprintf(tls, ts+27276 /* "INSERT INTO %Q (" */, libc.VaList(bp+48, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 104 /* zInsert */)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 100 /* rc */)) = SQLITE_NOMEM
		}
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + 1*4))) == SQLITE_INTEGER {
			bindArgOne = 1
			*(*uintptr)(unsafe.Pointer(bp + 108 /* zValues */)) = sqlite3.Xsqlite3_mprintf(tls, ts+3266 /* "?" */, 0)
			string_concat(tls, bp+104 /* &zInsert */, ts+27074 /* "rowid" */, 0, bp+100 /* &rc */)
		}

		for ii = 2; ii < nData; ii++ {
			string_concat(tls, bp+104, /* &zInsert */
				sqlite3.Xsqlite3_mprintf(tls, ts+27293 /* "%s%Q" */, libc.VaList(bp+56, func() uintptr {
					if *(*uintptr)(unsafe.Pointer(bp + 108 /* zValues */)) != 0 {
						return ts + 90 /* ", " */
					}
					return ts + 489 /* "" */
				}(), *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr((ii-2))*4)))), 1, bp+100 /* &rc */)
			string_concat(tls, bp+108, /* &zValues */
				sqlite3.Xsqlite3_mprintf(tls, ts+27298 /* "%s?%d" */, libc.VaList(bp+72, func() uintptr {
					if *(*uintptr)(unsafe.Pointer(bp + 108 /* zValues */)) != 0 {
						return ts + 90 /* ", " */
					}
					return ts + 489 /* "" */
				}(), ii)), 1, bp+100 /* &rc */)
		}

		string_concat(tls, bp+96 /* &z */, *(*uintptr)(unsafe.Pointer(bp + 104 /* zInsert */)), 1, bp+100 /* &rc */)
		string_concat(tls, bp+96 /* &z */, ts+27304 /* ") VALUES(" */, 0, bp+100 /* &rc */)
		string_concat(tls, bp+96 /* &z */, *(*uintptr)(unsafe.Pointer(bp + 108 /* zValues */)), 1, bp+100 /* &rc */)
		string_concat(tls, bp+96 /* &z */, ts+490 /* ")" */, 0, bp+100 /* &rc */)
	} else {

		return SQLITE_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 100 /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 100 /* rc */)) = sqlite3.Xsqlite3_prepare(tls, db, *(*uintptr)(unsafe.Pointer(bp + 96 /* z */)), -1, bp+112 /* &pStmt */, uintptr(0))
	}

	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 96 /* z */)))
	if *(*int32)(unsafe.Pointer(bp + 100 /* rc */)) == SQLITE_OK {
		if bindArgZero != 0 {
			sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* pStmt */)), nData, *(*uintptr)(unsafe.Pointer(apData)))
		}
		if bindArgOne != 0 {
			sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* pStmt */)), 1, *(*uintptr)(unsafe.Pointer(apData + 1*4)))
		}
		for i = 2; (i < nData) && (*(*int32)(unsafe.Pointer(bp + 100 /* rc */)) == SQLITE_OK); i++ {
			if *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*4)) != 0 {
				*(*int32)(unsafe.Pointer(bp + 100 /* rc */)) = sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* pStmt */)), i, *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*4)))
			}
		}
		if *(*int32)(unsafe.Pointer(bp + 100 /* rc */)) == SQLITE_OK {
			sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* pStmt */)))
			*(*int32)(unsafe.Pointer(bp + 100 /* rc */)) = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* pStmt */)))
		} else {
			sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* pStmt */)))
		}
	}

	if (pRowid != 0) && (*(*int32)(unsafe.Pointer(bp + 100 /* rc */)) == SQLITE_OK) {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_last_insert_rowid(tls, db)
	}
	if *(*int32)(unsafe.Pointer(bp + 100 /* rc */)) != SQLITE_OK {
		(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+26687 /* "echo-vtab-error:..." */, libc.VaList(bp+88, sqlite3.Xsqlite3_errmsg(tls, db)))
	}

	return *(*int32)(unsafe.Pointer(bp + 100 /* rc */))
}

// xBegin, xSync, xCommit and xRollback callbacks for echo module
// virtual tables. Do nothing other than add the name of the callback
// to the $::echo_module Tcl variable.
func echoTransactionCall(tls *libc.TLS, tab uintptr, zCall uintptr) int32 { /* test8.c:1102:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	var pVtab uintptr = tab
	z = sqlite3.Xsqlite3_mprintf(tls, ts+27314 /* "echo(%s)" */, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
	if z == uintptr(0) {
		return SQLITE_NOMEM
	}
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, zCall)
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, z)
	sqlite3.Xsqlite3_free(tls, z)
	return SQLITE_OK
}

func echoBegin(tls *libc.TLS, tab uintptr) int32 { /* test8.c:1112:12: */
	var rc int32
	var pVtab uintptr = tab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	var zVal uintptr

	// Ticket #3083 - do not start a transaction if we are already in
	// a transaction

	if simulateVtabError(tls, pVtab, ts+27323 /* "xBegin" */) != 0 {
		return SQLITE_ERROR
	}

	rc = echoTransactionCall(tls, tab, ts+27323 /* "xBegin" */)

	if rc == SQLITE_OK {
		// Check if the $::echo_module_begin_fail variable is defined. If it is,
		// and it is set to the name of the real table underlying this virtual
		// echo module table, then cause this xSync operation to fail.
		zVal = tcl.XTcl_GetVar2(tls, interp, ts+27330 /* "echo_module_begi..." */, uintptr(0), TCL_GLOBAL_ONLY)
		if (zVal != 0) && (0 == libc.Xstrcmp(tls, zVal, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)) {
			rc = SQLITE_ERROR
		}
	}
	if rc == SQLITE_OK {
		(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 1
	}
	return rc
}

func echoSync(tls *libc.TLS, tab uintptr) int32 { /* test8.c:1143:12: */
	var rc int32
	var pVtab uintptr = tab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	var zVal uintptr

	// Ticket #3083 - Only call xSync if we have previously started a
	// transaction

	if simulateVtabError(tls, pVtab, ts+27353 /* "xSync" */) != 0 {
		return SQLITE_ERROR
	}

	rc = echoTransactionCall(tls, tab, ts+27353 /* "xSync" */)

	if rc == SQLITE_OK {
		// Check if the $::echo_module_sync_fail variable is defined. If it is,
		// and it is set to the name of the real table underlying this virtual
		// echo module table, then cause this xSync operation to fail.
		zVal = tcl.XTcl_GetVar2(tls, interp, ts+27359 /* "echo_module_sync..." */, uintptr(0), TCL_GLOBAL_ONLY)
		if (zVal != 0) && (0 == libc.Xstrcmp(tls, zVal, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)) {
			rc = -1
		}
	}
	return rc
}

func echoCommit(tls *libc.TLS, tab uintptr) int32 { /* test8.c:1171:12: */
	var pVtab uintptr = tab
	var rc int32

	// Ticket #3083 - Only call xCommit if we have previously started
	// a transaction

	if simulateVtabError(tls, pVtab, ts+27381 /* "xCommit" */) != 0 {
		return SQLITE_ERROR
	}

	sqlite3.Xsqlite3BeginBenignMalloc(tls)
	rc = echoTransactionCall(tls, tab, ts+27381 /* "xCommit" */)
	sqlite3.Xsqlite3EndBenignMalloc(tls)
	(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 0
	return rc
}

func echoRollback(tls *libc.TLS, tab uintptr) int32 { /* test8.c:1189:12: */
	var rc int32
	var pVtab uintptr = tab

	// Ticket #3083 - Only call xRollback if we have previously started
	// a transaction

	rc = echoTransactionCall(tls, tab, ts+27389 /* "xRollback" */)
	(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 0
	return rc
}

// Implementation of "GLOB" function on the echo module.  Pass
// all arguments to the ::echo_glob_overload procedure of TCL
// and return the result of that procedure as a string.
func overloadedGlobFunction(tls *libc.TLS, pContext uintptr, nArg int32, apArg uintptr) { /* test8.c:1207:13: */
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var interp uintptr = sqlite3.Xsqlite3_user_data(tls, pContext)
	// var str Tcl_DString at bp, 212

	var i int32
	var rc int32
	tcl.XTcl_DStringInit(tls, bp /* &str */)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, ts+27399 /* "::echo_glob_over..." */)
	for i = 0; i < nArg; i++ {
		tcl.XTcl_DStringAppendElement(tls, bp /* &str */, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*4))))
	}
	rc = tcl.XTcl_Eval(tls, interp, (*Tcl_DString)(unsafe.Pointer(bp /* &str */)).Fstring)
	tcl.XTcl_DStringFree(tls, bp /* &str */)
	if rc != 0 {
		sqlite3.Xsqlite3_result_error(tls, pContext, tcl.XTcl_GetStringResult(tls, interp), -1)
	} else {
		sqlite3.Xsqlite3_result_text(tls, pContext, tcl.XTcl_GetStringResult(tls, interp),
			-1, libc.UintptrFromInt32(-1))
	}
	tcl.XTcl_ResetResult(tls, interp)
}

// This is the xFindFunction implementation for the echo module.
// SQLite calls this routine when the first argument of a function
// is a column of an echo virtual table.  This routine can optionally
// override the implementation of that function.  It will choose to
// do so if the function is named "glob", and a TCL command named
// ::echo_glob_overload exists.
func echoFindFunction(tls *libc.TLS, vtab uintptr, nArg int32, zFuncName uintptr, pxFunc uintptr, ppArg uintptr) int32 { /* test8.c:1240:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pVtab uintptr = vtab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	// var info Tcl_CmdInfo at bp, 32

	if libc.Xstrcmp(tls, zFuncName, ts+27102 /* "glob" */) != 0 {
		return 0
	}
	if tcl.XTcl_GetCommandInfo(tls, interp, ts+27399 /* "::echo_glob_over..." */, bp /* &info */) == 0 {
		return 0
	}
	*(*uintptr)(unsafe.Pointer(pxFunc)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{overloadedGlobFunction}))
	*(*uintptr)(unsafe.Pointer(ppArg)) = interp
	return 1
}

func echoRename(tls *libc.TLS, vtab uintptr, zNewName uintptr) int32 { /* test8.c:1261:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	var p uintptr = vtab

	if simulateVtabError(tls, p, ts+27420 /* "xRename" */) != 0 {
		return SQLITE_ERROR
	}

	if (*echo_vtab)(unsafe.Pointer(p)).FisPattern != 0 {
		var nThis int32 = int32(libc.Xstrlen(tls, (*echo_vtab)(unsafe.Pointer(p)).FzThis))
		var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+27428, /* "ALTER TABLE %s R..." */
			libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(p)).FzTableName, zNewName, ((*echo_vtab)(unsafe.Pointer(p)).FzTableName+uintptr(nThis))))
		rc = sqlite3.Xsqlite3_exec(tls, (*echo_vtab)(unsafe.Pointer(p)).Fdb, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}

	return rc
}

func echoSavepoint(tls *libc.TLS, pVTab uintptr, iSavepoint int32) int32 { /* test8.c:1281:12: */

	return SQLITE_OK
}

func echoRelease(tls *libc.TLS, pVTab uintptr, iSavepoint int32) int32 { /* test8.c:1286:12: */

	return SQLITE_OK
}

func echoRollbackTo(tls *libc.TLS, pVTab uintptr, iSavepoint int32) int32 { /* test8.c:1291:12: */

	return SQLITE_OK
}

// A virtual table module that merely "echos" the contents of another
// table (like an SQL VIEW).
var echoModule = sqlite3_module{
	FiVersion:      1, // iVersion
	FxCreate:       0,
	FxConnect:      0,
	FxBestIndex:    0,
	FxDisconnect:   0,
	FxDestroy:      0,
	FxOpen:         0, // xOpen - open a cursor
	FxClose:        0, // xClose - close a cursor
	FxFilter:       0, // xFilter - configure scan constraints
	FxNext:         0, // xNext - advance a cursor
	FxEof:          0, // xEof
	FxColumn:       0, // xColumn - read data
	FxRowid:        0, // xRowid - read data
	FxUpdate:       0, // xUpdate - write data
	FxBegin:        0, // xBegin - begin transaction
	FxSync:         0, // xSync - sync transaction
	FxCommit:       0, // xCommit - commit transaction
	FxRollback:     0, // xRollback - rollback transaction
	FxFindFunction: 0, // xFindFunction - function overloading
	FxRename:       0, // xRename - rename the table
} /* test8.c:1300:23 */

var echoModuleV2 = sqlite3_module{
	FiVersion:      2, // iVersion
	FxCreate:       0,
	FxConnect:      0,
	FxBestIndex:    0,
	FxDisconnect:   0,
	FxDestroy:      0,
	FxOpen:         0, // xOpen - open a cursor
	FxClose:        0, // xClose - close a cursor
	FxFilter:       0, // xFilter - configure scan constraints
	FxNext:         0, // xNext - advance a cursor
	FxEof:          0, // xEof
	FxColumn:       0, // xColumn - read data
	FxRowid:        0, // xRowid - read data
	FxUpdate:       0, // xUpdate - write data
	FxBegin:        0, // xBegin - begin transaction
	FxSync:         0, // xSync - sync transaction
	FxCommit:       0, // xCommit - commit transaction
	FxRollback:     0, // xRollback - rollback transaction
	FxFindFunction: 0, // xFindFunction - function overloading
	FxRename:       0, // xRename - rename the table
	FxSavepoint:    0,
	FxRelease:      0,
	FxRollbackTo:   0,
} /* test8.c:1323:23 */

func moduleDestroy(tls *libc.TLS, p uintptr) { /* test8.c:1355:13: */
	var pMod uintptr = p
	sqlite3.Xsqlite3_create_function(tls, (*EchoModule)(unsafe.Pointer(pMod)).Fdb, ts+27458, /* "function_that_do..." */
		SQLITE_ANY, 1, uintptr(0), uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, p)
}

// Register the echo virtual table module.
func register_echo_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test8.c:1365:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	// var db uintptr at bp, 4

	var pMod uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}

	// Virtual table module "echo"
	pMod = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(EchoModule{})))
	(*EchoModule)(unsafe.Pointer(pMod)).Finterp = interp
	(*EchoModule)(unsafe.Pointer(pMod)).Fdb = *(*uintptr)(unsafe.Pointer(bp /* db */))
	rc = sqlite3.Xsqlite3_create_module_v2(tls,
		*(*uintptr)(unsafe.Pointer(bp /* db */)), ts+27496 /* "echo" */, uintptr(unsafe.Pointer(&echoModule)), pMod, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{moduleDestroy})))

	// Virtual table module "echo_v2"
	if rc == SQLITE_OK {
		pMod = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(EchoModule{})))
		(*EchoModule)(unsafe.Pointer(pMod)).Finterp = interp
		(*EchoModule)(unsafe.Pointer(pMod)).Fdb = *(*uintptr)(unsafe.Pointer(bp /* db */))
		rc = sqlite3.Xsqlite3_create_module_v2(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+27501, /* "echo_v2" */
			uintptr(unsafe.Pointer(&echoModuleV2)), pMod, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{moduleDestroy})))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Tcl interface to sqlite3_declare_vtab, invoked as follows from Tcl:
//
// sqlite3_declare_vtab DB SQL
func declare_vtab(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test8.c:1407:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+27509 /* "DB SQL" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_declare_vtab(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp /* db */))), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest8_Init(tls *libc.TLS, interp uintptr) int32 { /* test8.c:1433:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd2)) / uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd2[i].FzName,
			aObjCmd2[i].FxProc, aObjCmd2[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd2 = [2]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 27516 /* "register_echo_mo..." */, FxProc: 0},
	{FzName: ts + 27537 /* "sqlite3_declare_..." */, FxProc: 0},
} /* test8.c:1439:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// c_collation_test
func c_collation_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test9.c:29:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var zErrFunction uintptr
	// var db uintptr at bp+24, 4

	var rc int32
	zErrFunction = ts + 27558 /* "N/A" */
	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
	return TCL_ERROR
__1:
	;

	// Open a database.
	rc = sqlite3.Xsqlite3_open(tls, ts+1662 /* ":memory:" */, bp+24 /* &db */)
	if !(rc != SQLITE_OK) {
		goto __2
	}
	zErrFunction = ts + 20989 /* "sqlite3_open" */
	goto error_out
__2:
	;

	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), ts+13094 /* "collate" */, 456, uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))
	zErrFunction = ts + 27562 /* "sqlite3_create_c..." */
	goto error_out
__3:
	;

	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))
	return TCL_OK

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+27587 /* "Error testing fu..." */, zErrFunction, 0))
	return TCL_ERROR
}

// c_realloc_test
func c_realloc_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test9.c:70:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr
	var zErrFunction uintptr
	zErrFunction = ts + 27558 /* "N/A" */

	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
	return TCL_ERROR
__1:
	;

	p = sqlite3.Xsqlite3_malloc(tls, 5)
	if !(!(p != 0)) {
		goto __2
	}
	zErrFunction = ts + 27612 /* "sqlite3_malloc" */
	goto error_out
__2:
	;

	// Test that realloc()ing a block of memory to a negative size is
	// the same as free()ing that memory.
	p = sqlite3.Xsqlite3_realloc(tls, p, -1)
	if !(p != 0) {
		goto __3
	}
	zErrFunction = ts + 27627 /* "sqlite3_realloc" */
	goto error_out
__3:
	;

	return TCL_OK

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+27587 /* "Error testing fu..." */, zErrFunction, 0))
	return TCL_ERROR
}

// c_misuse_test
func c_misuse_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test9.c:111:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zErrFunction uintptr
	// var db uintptr at bp+24, 4

	// var pStmt uintptr at bp+28, 4

	var rc int32
	zErrFunction = ts + 27558 /* "N/A" */
	*(*uintptr)(unsafe.Pointer(bp + 24 /* db */)) = uintptr(0)

	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
	return TCL_ERROR
__1:
	;

	// Open a database. Then close it again. We need to do this so that
	// we have a "closed database handle" to pass to various API functions.
	rc = sqlite3.Xsqlite3_open(tls, ts+1662 /* ":memory:" */, bp+24 /* &db */)
	if !(rc != SQLITE_OK) {
		goto __2
	}
	zErrFunction = ts + 20989 /* "sqlite3_open" */
	goto error_out
__2:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))

	rc = sqlite3.Xsqlite3_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	zErrFunction = ts + 20916 /* "sqlite3_errcode" */
	goto error_out
__3:
	;

	*(*uintptr)(unsafe.Pointer(bp + 28 /* pStmt */)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), uintptr(0), 0, bp+28 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __4
	}
	zErrFunction = ts + 21070 /* "sqlite3_prepare" */
	goto error_out
__4:
	;
	// Verify that pStmt is zeroed even on a MISUSE error

	*(*uintptr)(unsafe.Pointer(bp + 28 /* pStmt */)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), uintptr(0), 0, bp+28 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __5
	}
	zErrFunction = ts + 21104 /* "sqlite3_prepare_..." */
	goto error_out
__5:
	;

	*(*uintptr)(unsafe.Pointer(bp + 28 /* pStmt */)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare16(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), uintptr(0), 0, bp+28 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __6
	}
	zErrFunction = ts + 21086 /* "sqlite3_prepare1..." */
	goto error_out
__6:
	;

	*(*uintptr)(unsafe.Pointer(bp + 28 /* pStmt */)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare16_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), uintptr(0), 0, bp+28 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __7
	}
	zErrFunction = ts + 21166 /* "sqlite3_prepare1..." */
	goto error_out
__7:
	;

	return TCL_OK

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+27587 /* "Error testing fu..." */, zErrFunction, 0))
	return TCL_ERROR
}

// Register commands with the TCL interpreter.
func Sqlitetest9_Init(tls *libc.TLS, interp uintptr) int32 { /* test9.c:188:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd3)) / uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd3[i].FzName,
			aObjCmd3[i].FxProc, aObjCmd3[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd3 = [3]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 27643 /* "c_misuse_test" */, FxProc: 0},
	{FzName: ts + 27657 /* "c_realloc_test" */, FxProc: 0},
	{FzName: ts + 27672 /* "c_collation_test" */, FxProc: 0},
} /* test9.c:193:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// This routine registers the custom TCL commands defined in this
// module.  This should be the only procedure visible from outside
// of this module.
func Sqlitetestasync_Init(tls *libc.TLS, interp uintptr) int32 { /* test_async.c:238:5: */
	return TCL_OK
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// tclcmd:   sqlite3_reset_auto_extension
//
// Reset all auto-extensions
func resetAutoExtObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_autoext.c:196:26: */
	sqlite3.Xsqlite3_reset_auto_extension(tls)
	return SQLITE_OK
}

// This procedure registers the TCL procs defined in this file.
func Sqlitetest_autoext_Init(tls *libc.TLS, interp uintptr) int32 { /* test_autoext.c:210:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+27689, /* "sqlite3_reset_au..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{resetAutoExtObjCmd})), uintptr(0), uintptr(0))
	return TCL_OK
}

func backupTestCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_backup.c:33:26: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	*(*[5]BackupSubCommand)(unsafe.Pointer(bp /* aSub */)) = [5]BackupSubCommand{
		{FzCmd: ts + 10120 /* "step" */, FnArg: 1, FzArg: ts + 27718 /* "npage" */},
		{FzCmd: ts + 27724 /* "finish" */, FeCmd: uint32(1) /* BACKUP_FINISH */, FzArg: ts + 489 /* "" */},
		{FzCmd: ts + 27731 /* "remaining" */, FeCmd: uint32(2) /* BACKUP_REMAINING */, FzArg: ts + 489 /* "" */},
		{FzCmd: ts + 27741 /* "pagecount" */, FeCmd: uint32(3) /* BACKUP_PAGECOUNT */, FzArg: ts + 489 /* "" */},
		{},
	}

	var p uintptr = clientData
	// var iCmd int32 at bp+80, 4

	var rc int32

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &aSub[0] */, int32(unsafe.Sizeof(BackupSubCommand{})), ts+11373 /* "option" */, 0, bp+80 /* &iCmd */)
	if rc != TCL_OK {
		return rc
	}
	if objc != (2 + (*BackupSubCommand)(unsafe.Pointer(bp /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* iCmd */)))*16)).FnArg) {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*BackupSubCommand)(unsafe.Pointer(bp /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* iCmd */)))*16)).FzArg)
		return TCL_ERROR
	}

	switch (*BackupSubCommand)(unsafe.Pointer(bp /* &aSub */ + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* iCmd */)))*16)).FeCmd {

	case uint32(1) /* BACKUP_FINISH */ :
		{
			var zCmdName uintptr
			// var cmdInfo Tcl_CmdInfo at bp+84, 32

			zCmdName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv)))
			tcl.XTcl_GetCommandInfo(tls, interp, zCmdName, bp+84 /* &cmdInfo */)
			(*Tcl_CmdInfo)(unsafe.Pointer(bp + 84 /* &cmdInfo */)).FdeleteProc = uintptr(0)
			tcl.XTcl_SetCommandInfo(tls, interp, zCmdName, bp+84 /* &cmdInfo */)
			tcl.XTcl_DeleteCommand(tls, interp, zCmdName)

			rc = sqlite3.Xsqlite3_backup_finish(tls, p)
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
			break

		}

	case uint32(0) /* BACKUP_STEP */ :
		{
			// var nPage int32 at bp+116, 4

			if TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+116 /* &nPage */) {
				return TCL_ERROR
			}
			rc = sqlite3.Xsqlite3_backup_step(tls, p, *(*int32)(unsafe.Pointer(bp + 116 /* nPage */)))
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
			break

		}

	case uint32(2) /* BACKUP_REMAINING */ :
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_backup_remaining(tls, p)))
		break

	case uint32(3) /* BACKUP_PAGECOUNT */ :
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_backup_pagecount(tls, p)))
		break
	}

	return TCL_OK
}

type BackupSubCommand = struct {
	FzCmd uintptr
	FeCmd uint32
	FnArg int32
	FzArg uintptr
} /* test_backup.c:42:3 */

func backupTestFinish(tls *libc.TLS, clientData ClientData) { /* test_backup.c:108:27: */
	var pBackup uintptr = clientData
	sqlite3.Xsqlite3_backup_finish(tls, pBackup)
}

//     sqlite3_backup CMDNAME DESTHANDLE DESTNAME SRCHANDLE SRCNAME
//
func backupTestInit(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_backup.c:117:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var pBackup uintptr
	// var pDestDb uintptr at bp+16, 4

	// var pSrcDb uintptr at bp+20, 4

	var zDestName uintptr
	var zSrcName uintptr
	var zCmd uintptr

	if objc != 6 {
		tcl.XTcl_WrongNumArgs(tls,
			interp, 1, objv, ts+27751 /* "CMDNAME DESTHAND..." */)
		return TCL_ERROR
	}

	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+16 /* &pDestDb */)
	zDestName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4))), bp+20 /* &pSrcDb */)
	zSrcName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 5*4)))

	pBackup = sqlite3.Xsqlite3_backup_init(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pDestDb */)), zDestName, *(*uintptr)(unsafe.Pointer(bp + 20 /* pSrcDb */)), zSrcName)
	if !(pBackup != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+27797 /* "sqlite3_backup_i..." */, 0))
		return TCL_ERROR
	}

	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{backupTestCmd})), pBackup, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{backupTestFinish})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	return TCL_OK
}

func Sqlitetestbackup_Init(tls *libc.TLS, interp uintptr) int32 { /* test_backup.c:154:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+27826 /* "sqlite3_backup" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{backupTestInit})), uintptr(0), uintptr(0))
	return TCL_OK
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type tcl_vtab1 = struct {
	Fbase   sqlite3_vtab
	Finterp uintptr
	FpCmd   uintptr
	Fdb     uintptr
} /* test_bestindex.c:104:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type tcl_vtab = tcl_vtab1 /* test_bestindex.c:104:25 */
type tcl_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
} /* test_bestindex.c:105:9 */

type tcl_cursor = tcl_cursor1 /* test_bestindex.c:105:27 */

// Dequote string z in place.
func tclDequote(tls *libc.TLS, z uintptr) { /* test_bestindex.c:126:13: */
	var q int8 = *(*int8)(unsafe.Pointer(z))

	// Set stack variable q to the close-quote character
	if (((int32(q) == '[') || (int32(q) == '\'')) || (int32(q) == '"')) || (int32(q) == '`') {
		var iIn int32 = 1
		var iOut int32 = 0
		if int32(q) == '[' {
			q = int8(']')
		}

		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr((iIn + 1))))) != int32(q) {
					// Character iIn was the close quote.
					iIn++
					break
				} else {
					// Character iIn and iIn+1 form an escaped quote character. Skip
					// the input cursor past both and copy a single quote character
					// to the output buffer.
					iIn = iIn + (2)
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = q
				}
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
			}
		}

		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

// This function is the implementation of both the xConnect and xCreate
// methods of the fs virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func tclConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_bestindex.c:168:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var interp uintptr = pAux
	var pTab uintptr = uintptr(0)
	var zCmd uintptr = uintptr(0)
	var pScript uintptr = uintptr(0)
	var rc int32 = SQLITE_OK

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+27841 /* "wrong number of ..." */, 0)
		return SQLITE_ERROR
	}

	zCmd = sqlite3.Xsqlite3_malloc64(tls, (uint64(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4))) + size_t(1))))
	pTab = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(tcl_vtab{})))
	if (zCmd != 0) && (pTab != 0) {
		libc.Xmemcpy(tls, zCmd, *(*uintptr)(unsafe.Pointer(argv + 3*4)), (libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4))) + size_t(1)))
		tclDequote(tls, zCmd)
		libc.Xmemset(tls, pTab, 0, uint32(unsafe.Sizeof(tcl_vtab{})))

		(*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd = tcl.XTcl_NewStringObj(tls, zCmd, -1)
		(*tcl_vtab)(unsafe.Pointer(pTab)).Finterp = interp
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fdb = db
		(*Tcl_Obj)(unsafe.Pointer((*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)).FrefCount++

		pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
		(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+26881 /* "xConnect" */, -1))

		rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
		if rc != TCL_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, tcl.XTcl_GetStringResult(tls, interp)))
			rc = SQLITE_ERROR
		} else {
			rc = sqlite3.Xsqlite3_declare_vtab(tls, db, tcl.XTcl_GetStringResult(tls, interp))
		}

		if rc != SQLITE_OK {
			sqlite3.Xsqlite3_free(tls, pTab)
			pTab = uintptr(0)
		}
	} else {
		rc = SQLITE_NOMEM
	}

	sqlite3.Xsqlite3_free(tls, zCmd)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pTab /* &.base */)
	return rc
}

// The xDisconnect and xDestroy methods are also the same
func tclDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test_bestindex.c:224:12: */
	var pTab uintptr = pVtab
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, pTab)
	return SQLITE_OK
}

// Open a new tcl cursor.
func tclOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_bestindex.c:234:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(tcl_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(tcl_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Close a tcl cursor.
func tclClose(tls *libc.TLS, cur uintptr) int32 { /* test_bestindex.c:246:12: */
	var pCur uintptr = cur
	if pCur != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*tcl_cursor)(unsafe.Pointer(pCur)).FpStmt)
		sqlite3.Xsqlite3_free(tls, pCur)
	}
	return SQLITE_OK
}

func tclNext(tls *libc.TLS, pVtabCursor uintptr) int32 { /* test_bestindex.c:255:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCsr uintptr = pVtabCursor
	if (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt != 0 {
		var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
		var rc int32 = sqlite3.Xsqlite3_step(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt)
		if rc != SQLITE_ROW {
			var zErr uintptr
			rc = sqlite3.Xsqlite3_finalize(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt)
			(*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
			if rc != SQLITE_OK {
				zErr = sqlite3.Xsqlite3_errmsg(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb)
				(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zErr))
			}
		}
	}
	return SQLITE_OK
}

func tclFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_bestindex.c:273:12: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var pCsr uintptr = pVtabCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var interp uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).Finterp
	var pScript uintptr
	var pArg uintptr
	var ii int32
	var rc int32

	pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+26945 /* "xFilter" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewIntObj(tls, idxNum))
	if idxStr != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, idxStr, -1))
	} else {
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+489 /* "" */, -1))
	}

	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
	for ii = 0; ii < argc; ii++ {
		var zVal uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(ii)*4)))
		var pVal uintptr
		if zVal == uintptr(0) {
			pVal = tcl.XTcl_NewObj(tls)
		} else {
			pVal = tcl.XTcl_NewStringObj(tls, zVal, -1)
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pArg, pVal)
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, pArg)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pArg
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
	if rc != TCL_OK {
		var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
		rc = SQLITE_ERROR
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zErr))
	} else {
		// Analyze the scripts return value. The return value should be a tcl
		// list object with an even number of elements. The first element of each
		// pair must be one of:
		//
		//   "sql"          (SQL statement to return data)
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)
		*(*uintptr)(unsafe.Pointer(bp + 36 /* apElem */)) = uintptr(0)
		// var nElem int32 at bp+32, 4

		rc = tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+32 /* &nElem */, bp+36 /* &apElem */)
		if rc != TCL_OK {
			var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
			rc = SQLITE_ERROR
			(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, zErr))
		} else {
			for ii = 0; (rc == SQLITE_OK) && (ii < *(*int32)(unsafe.Pointer(bp + 32 /* nElem */))); ii = ii + (2) {
				var zCmd uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 36 /* apElem */)) + uintptr(ii)*4)))
				var p uintptr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 36 /* apElem */)) + uintptr((ii+1))*4))
				if sqlite3.Xsqlite3_stricmp(tls, ts+1808 /* "sql" */, zCmd) == 0 {
					var zSql uintptr = tcl.XTcl_GetString(tls, p)
					rc = sqlite3.Xsqlite3_prepare_v2(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb, zSql, -1, (pCsr + 4 /* &.pStmt */), uintptr(0))
					if rc != SQLITE_OK {
						var zErr uintptr = sqlite3.Xsqlite3_errmsg(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb)
						(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+27867 /* "unexpected: %s" */, libc.VaList(bp+16, zErr))
					}
				} else {
					rc = SQLITE_ERROR
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+27867 /* "unexpected: %s" */, libc.VaList(bp+24, zCmd))
				}
			}
		}
	}

	if rc == SQLITE_OK {
		rc = tclNext(tls, pVtabCursor)
	}
	return rc
}

func tclColumn(tls *libc.TLS, pVtabCursor uintptr, ctx uintptr, i int32) int32 { /* test_bestindex.c:356:12: */
	var pCsr uintptr = pVtabCursor
	sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt, (i+1)))
	return SQLITE_OK
}

func tclRowid(tls *libc.TLS, pVtabCursor uintptr, pRowid uintptr) int32 { /* test_bestindex.c:366:12: */
	var pCsr uintptr = pVtabCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt, 0)
	return SQLITE_OK
}

func tclEof(tls *libc.TLS, pVtabCursor uintptr) int32 { /* test_bestindex.c:372:12: */
	var pCsr uintptr = pVtabCursor
	return (libc.Bool32((*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0)))
}

func tclBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_bestindex.c:377:12: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var pTab uintptr = tab
	var interp uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).Finterp
	var pArg uintptr
	var pScript uintptr
	var ii int32
	var rc int32 = SQLITE_OK

	pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+26999 /* "xBestIndex" */, -1))

	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		var pElem uintptr = tcl.XTcl_NewObj(tls)
		var zOp uintptr = ts + 3266 /* "?" */

		(*Tcl_Obj)(unsafe.Pointer(pElem)).FrefCount++

		switch int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) {
		case SQLITE_INDEX_CONSTRAINT_EQ:
			zOp = ts + 27882 /* "eq" */
			break
		case SQLITE_INDEX_CONSTRAINT_GT:
			zOp = ts + 27885 /* "gt" */
			break
		case SQLITE_INDEX_CONSTRAINT_LE:
			zOp = ts + 27888 /* "le" */
			break
		case SQLITE_INDEX_CONSTRAINT_LT:
			zOp = ts + 27891 /* "lt" */
			break
		case SQLITE_INDEX_CONSTRAINT_GE:
			zOp = ts + 27894 /* "ge" */
			break
		case SQLITE_INDEX_CONSTRAINT_MATCH:
			zOp = ts + 27897 /* "match" */
			break
		case SQLITE_INDEX_CONSTRAINT_LIKE:
			zOp = ts + 27097 /* "like" */
			break
		case SQLITE_INDEX_CONSTRAINT_GLOB:
			zOp = ts + 27102 /* "glob" */
			break
		case SQLITE_INDEX_CONSTRAINT_REGEXP:
			zOp = ts + 6335 /* "regexp" */
			break
		case SQLITE_INDEX_CONSTRAINT_NE:
			zOp = ts + 27903 /* "ne" */
			break
		case SQLITE_INDEX_CONSTRAINT_ISNOT:
			zOp = ts + 27906 /* "isnot" */
			break
		case SQLITE_INDEX_CONSTRAINT_ISNOTNULL:
			zOp = ts + 27912 /* "isnotnull" */
			break
		case SQLITE_INDEX_CONSTRAINT_ISNULL:
			zOp = ts + 27922 /* "isnull" */
			break
		case SQLITE_INDEX_CONSTRAINT_IS:
			zOp = ts + 5712 /* "is" */
			break
		}

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+27929 /* "op" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, zOp, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+27932 /* "column" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+27939 /* "usable" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable)))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, pElem)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pElem
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, pArg)
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pArg
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy; ii++ {
		var pOrder uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(ii)*8)
		var pElem uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pElem)).FrefCount++

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+27932 /* "column" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, (*sqlite3_index_orderby)(unsafe.Pointer(pOrder)).FiColumn))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+27946 /* "desc" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, int32((*sqlite3_index_orderby)(unsafe.Pointer(pOrder)).Fdesc)))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, pElem)
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = pElem
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, pArg)
	for ok3 := true; ok3; ok3 = 0 != 0 {
		var _objPtr uintptr = pArg
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewWideIntObj(tls, int64((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FcolUsed)))

	rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
	for ok4 := true; ok4; ok4 = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if rc != TCL_OK {
		var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
		rc = SQLITE_ERROR
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zErr))
	} else {
		// Analyze the scripts return value. The return value should be a tcl
		// list object with an even number of elements. The first element of each
		// pair must be one of:
		//
		//   "orderby"          (value of orderByConsumed flag)
		//   "cost"             (value of estimatedCost field)
		//   "rows"             (value of estimatedRows field)
		//   "use"              (index of used constraint in aConstraint[])
		//   "idxnum"           (value of idxNum field)
		//   "idxstr"           (value of idxStr field)
		//   "omit"             (index of omitted constraint in aConstraint[])
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)
		*(*uintptr)(unsafe.Pointer(bp + 52 /* apElem */)) = uintptr(0)
		// var nElem int32 at bp+48, 4

		rc = tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+48 /* &nElem */, bp+52 /* &apElem */)
		if rc != TCL_OK {
			var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
			rc = SQLITE_ERROR
			(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, zErr))
		} else {
			var iArgv int32 = 1
			for ii = 0; (rc == SQLITE_OK) && (ii < *(*int32)(unsafe.Pointer(bp + 48 /* nElem */))); ii = ii + (2) {
				var zCmd uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 52 /* apElem */)) + uintptr(ii)*4)))
				var p uintptr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 52 /* apElem */)) + uintptr((ii+1))*4))
				if sqlite3.Xsqlite3_stricmp(tls, ts+27951 /* "cost" */, zCmd) == 0 {
					rc = tcl.XTcl_GetDoubleFromObj(tls, interp, p, (pIdxInfo + 40 /* &.estimatedCost */))
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+27956 /* "orderby" */, zCmd) == 0 {
					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, (pIdxInfo + 32 /* &.orderByConsumed */))
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+27964 /* "idxnum" */, zCmd) == 0 {
					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, (pIdxInfo + 20 /* &.idxNum */))
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+27971 /* "idxstr" */, zCmd) == 0 {
					sqlite3.Xsqlite3_free(tls, (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr)
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, tcl.XTcl_GetString(tls, p)))
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+27978 /* "rows" */, zCmd) == 0 {
					*(*Tcl_WideInt)(unsafe.Pointer(bp + 56 /* x */)) = int64(0)
					rc = tcl.XTcl_GetWideIntFromObj(tls, interp, p, bp+56 /* &x */)
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = sqlite3_int64(tRowcnt(*(*Tcl_WideInt)(unsafe.Pointer(bp + 56 /* x */))))
				} else if (sqlite3.Xsqlite3_stricmp(tls, ts+27983 /* "use" */, zCmd) == 0) ||
					(sqlite3.Xsqlite3_stricmp(tls, ts+27987 /* "omit" */, zCmd) == 0) {
					// var iCons int32 at bp+64, 4

					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, bp+64 /* &iCons */)
					if rc == SQLITE_OK {
						if (*(*int32)(unsafe.Pointer(bp + 64 /* iCons */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 64 /* iCons */)) >= (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
							rc = SQLITE_ERROR
							(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+27992 /* "unexpected: %d" */, libc.VaList(bp+24, *(*int32)(unsafe.Pointer(bp + 64 /* iCons */))))
						} else {
							var bOmit int32 = (libc.Bool32((int32(*(*int8)(unsafe.Pointer(zCmd))) == 'o') || (int32(*(*int8)(unsafe.Pointer(zCmd))) == 'O')))
							(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* iCons */)))*8)).FargvIndex = libc.PostIncInt32(&iArgv, 1)
							(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* iCons */)))*8)).Fomit = uint8(bOmit)
						}
					}
				} else {
					rc = SQLITE_ERROR
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+27867 /* "unexpected: %s" */, libc.VaList(bp+32, zCmd))
				}
				if (rc != SQLITE_OK) && ((*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg == uintptr(0)) {
					var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+40, zErr))
				}
			}
		}
	}

	return rc
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var tclModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_bestindex.c:549:23 */

// Register the echo virtual table module.
func register_tcl_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_bestindex.c:580:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+28007 /* "tcl" */, uintptr(unsafe.Pointer(&tclModule)), interp)
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetesttcl_Init(tls *libc.TLS, interp uintptr) int32 { /* test_bestindex.c:604:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd4)) / uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd4[i].FzName,
			aObjCmd4[i].FxProc, aObjCmd4[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd4 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 28011 /* "register_tcl_mod..." */, FxProc: 0},
} /* test_bestindex.c:610:5 */

// Return a pointer to a buffer containing a text representation of the
// pointer passed as the only argument. The original pointer may be extracted
// from the text using sqlite3TestTextToPtr().
func ptrToText(tls *libc.TLS, p uintptr) uintptr { /* test_blob.c:37:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_snprintf(tls, (int32(uint32(unsafe.Sizeof(buf)) - uint32(1))), uintptr(unsafe.Pointer(&buf)), ts+13021 /* "%p" */, libc.VaList(bp, p))
	return uintptr(unsafe.Pointer(&buf))
}

var buf [100]int8 /* test_blob.c:38:15: */

// Attempt to extract a blob handle (type sqlite3_blob*) from the Tcl
// object passed as the second argument. If successful, set *ppBlob to
// point to the blob handle and return TCL_OK. Otherwise, store an error
// message in the tcl interpreter and return TCL_ERROR. The final value
// of *ppBlob is undefined in this case.
//
// If the object contains a string that begins with "incrblob_", then it
// is assumed to be the name of a Tcl channel opened using the [db incrblob]
// command (see tclsqlite.c). Otherwise, it is assumed to be a pointer
// encoded using the ptrToText() routine or similar.
func blobHandleFromObj1(tls *libc.TLS, interp uintptr, pObj uintptr, ppBlob uintptr) int32 { /* test_blob.c:55:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	// var n int32 at bp, 4

	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp /* &n */)
	if *(*int32)(unsafe.Pointer(bp /* n */)) == 0 {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = uintptr(0)
	} else if (*(*int32)(unsafe.Pointer(bp /* n */)) > 9) && (0 == libc.Xmemcmp(tls, ts+28031 /* "incrblob_" */, z, uint32(9))) {
		// var notUsed int32 at bp+4, 4

		var channel Tcl_Channel
		var instanceData ClientData

		channel = tcl.XTcl_GetChannel(tls, interp, z, bp+4 /* &notUsed */)
		if !(channel != 0) {
			return TCL_ERROR
		}

		tcl.XTcl_Flush(tls, channel)
		tcl.XTcl_Seek(tls, channel, int64(0), SEEK_SET)

		instanceData = tcl.XTcl_GetChannelInstanceData(tls, channel)
		*(*uintptr)(unsafe.Pointer(ppBlob)) = *(*uintptr)(unsafe.Pointer(instanceData))
	} else {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = sqlite3TestTextToPtr(tls, z)
	}

	return TCL_OK
}

// Like Tcl_GetString(), except that if the string is 0 bytes in size, a
// NULL Pointer is returned.
func blobStringFromObj(tls *libc.TLS, pObj uintptr) uintptr { /* test_blob.c:90:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var n int32 at bp, 4

	var z uintptr
	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp /* &n */)
	return func() uintptr {
		if *(*int32)(unsafe.Pointer(bp /* n */)) != 0 {
			return z
		}
		return uintptr(0)
	}()
}

// sqlite3_blob_open DB DATABASE TABLE COLUMN ROWID FLAGS VARNAME
//
// Tcl test harness for the sqlite3_blob_open() function.
func test_blob_open(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:102:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var db uintptr at bp+4, 4

	var zDb uintptr
	var zTable uintptr
	var zColumn uintptr
	// var iRowid Tcl_WideInt at bp+8, 8

	// var flags int32 at bp, 4

	var zVarname uintptr
	// var nVarname int32 at bp+16, 4

	*(*uintptr)(unsafe.Pointer(bp + 20 /* pBlob */)) = bp /* &flags */ // Non-zero initialization
	var rc int32

	if objc != 8 {
		var zUsage uintptr = ts + 28041 /* "DB DATABASE TABL..." */
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, zUsage)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+4 /* &db */) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	zTable = blobStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	zColumn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*4)), bp+8 /* &iRowid */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 6*4)), bp /* &flags */) != 0 {
		return TCL_ERROR
	}
	zVarname = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 7*4)), bp+16 /* &nVarname */)

	if *(*int32)(unsafe.Pointer(bp + 16 /* nVarname */)) > 0 {
		rc = sqlite3.Xsqlite3_blob_open(tls, *(*uintptr)(unsafe.Pointer(bp + 4 /* db */)), zDb, zTable, zColumn, *(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* iRowid */)), *(*int32)(unsafe.Pointer(bp /* flags */)), bp+20 /* &pBlob */)
		tcl.XTcl_SetVar2(tls, interp, zVarname, uintptr(0), ptrToText(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* pBlob */))), 0)
	} else {
		rc = sqlite3.Xsqlite3_blob_open(tls, *(*uintptr)(unsafe.Pointer(bp + 4 /* db */)), zDb, zTable, zColumn, *(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* iRowid */)), *(*int32)(unsafe.Pointer(bp /* flags */)), uintptr(0))
	}

	if rc == SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
	} else {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

// sqlite3_blob_close  HANDLE
func test_blob_close(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:153:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var pBlob uintptr at bp, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28086 /* "HANDLE" */)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &pBlob */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_blob_close(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)))

	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	} else {
		tcl.XTcl_ResetResult(tls, interp)
	}
	return TCL_OK
}

// sqlite3_blob_bytes  HANDLE
func test_blob_bytes(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:181:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var pBlob uintptr at bp, 4

	var nByte int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28086 /* "HANDLE" */)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &pBlob */) != 0 {
		return TCL_ERROR
	}
	nByte = sqlite3.Xsqlite3_blob_bytes(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nByte))

	return TCL_OK
}

// sqlite3_blob_read  CHANNEL OFFSET N
//
//   This command is used to test the sqlite3_blob_read() in ways that
//   the Tcl channel interface does not. The first argument should
//   be the name of a valid channel created by the [incrblob] method
//   of a database handle. This function calls sqlite3_blob_read()
//   to read N bytes from offset OFFSET from the underlying SQLite
//   blob handle.
//
//   On success, a byte-array object containing the read data is
//   returned. On failure, the interpreter result is set to the
//   text representation of the returned error code (i.e. "SQLITE_NOMEM")
//   and a Tcl exception is thrown.
func test_blob_read(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:217:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var pBlob uintptr at bp+16, 4

	// var nByte int32 at bp+24, 4

	// var iOffset int32 at bp+20, 4

	var zBuf uintptr = uintptr(0)
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28093 /* "CHANNEL OFFSET N" */)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16 /* &pBlob */) != 0 {
		return TCL_ERROR
	}
	if (TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+20 /* &iOffset */)) ||
		(TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+24 /* &nByte */)) {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 24 /* nByte */)) > 0 {
		zBuf = tcl.XTcl_AttemptAlloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 24 /* nByte */))))
		if zBuf == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+28110 /* "out of memory in..." */, 0))
			return TCL_ERROR
		}
	}
	rc = sqlite3.Xsqlite3_blob_read(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pBlob */)), zBuf, *(*int32)(unsafe.Pointer(bp + 24 /* nByte */)), *(*int32)(unsafe.Pointer(bp + 20 /* iOffset */)))
	if rc == SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, zBuf, *(*int32)(unsafe.Pointer(bp + 24 /* nByte */))))
	} else {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}
	tcl.XTcl_Free(tls, zBuf)

	return func() int32 {
		if rc == SQLITE_OK {
			return TCL_OK
		}
		return TCL_ERROR
	}()
}

// sqlite3_blob_write HANDLE OFFSET DATA ?NDATA?
//
//   This command is used to test the sqlite3_blob_write() in ways that
//   the Tcl channel interface does not. The first argument should
//   be the name of a valid channel created by the [incrblob] method
//   of a database handle. This function calls sqlite3_blob_write()
//   to write the DATA byte-array to the underlying SQLite blob handle.
//   at offset OFFSET.
//
//   On success, an empty string is returned. On failure, the interpreter
//   result is set to the text representation of the returned error code
//   (i.e. "SQLITE_NOMEM") and a Tcl exception is thrown.
func test_blob_write(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:273:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var pBlob uintptr at bp, 4

	// var iOffset int32 at bp+4, 4

	var rc int32
	var zBuf uintptr
	// var nBuf int32 at bp+8, 4

	if (objc != 4) && (objc != 5) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28171 /* "HANDLE OFFSET DA..." */)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &pBlob */) != 0 {
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &iOffset */) {
		return TCL_ERROR
	}

	zBuf = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+8 /* &nBuf */)
	if (objc == 5) && (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+8 /* &nBuf */) != 0) {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_blob_write(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)), zBuf, *(*int32)(unsafe.Pointer(bp + 8 /* nBuf */)), *(*int32)(unsafe.Pointer(bp + 4 /* iOffset */)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}

	return func() int32 {
		if rc == SQLITE_OK {
			return TCL_OK
		}
		return TCL_ERROR
	}()
}

// Register commands with the TCL interpreter.
func Sqlitetest_blob_Init(tls *libc.TLS, interp uintptr) int32 { /* test_blob.c:312:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd5)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd5[i].FzName, aObjCmd5[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aObjCmd5 = [5]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 28198 /* "sqlite3_blob_ope..." */, FxProc: 0},
	{FzName: ts + 28216 /* "sqlite3_blob_clo..." */, FxProc: 0},
	{FzName: ts + 28235 /* "sqlite3_blob_byt..." */, FxProc: 0},
	{FzName: ts + 28254 /* "sqlite3_blob_rea..." */, FxProc: 0},
	{FzName: ts + 28272 /* "sqlite3_blob_wri..." */, FxProc: 0},
} /* test_blob.c:317:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Usage: sqlite3_shared_cache_report
//
// Return a list of file that are shared and the number of
// references to each file.
func sqlite3BtreeSharedCacheReport(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_btree.c:29:19: */
	var pBt uintptr
	var pRet uintptr = tcl.XTcl_NewObj(tls)
	for pBt = sqlite3.Xsqlite3SharedCacheList; pBt != 0; pBt = (*BtShared)(unsafe.Pointer(pBt)).FpNext {
		var zFile uintptr = sqlite3.Xsqlite3PagerFilename(tls, (*BtShared)(unsafe.Pointer(pBt)).FpPager, 1)
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, zFile, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, (*BtShared)(unsafe.Pointer(pBt)).FnRef))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

// Print debugging information about all cursors to standard output.
func sqlite3BtreeCursorList(tls *libc.TLS, p uintptr) { /* test_btree.c:52:6: */
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Macro to stringify the results of the evaluation a pre-processor
// macro. i.e. so that STRINGVALUE(SQLITE_NOMEM) -> "7".

// This routine sets entries in the global ::sqlite_options() array variable
// according to the compile-time configuration of the database.  Test
// procedures use this to determine when tests should be omitted.
func set_options(tls *libc.TLS, interp uintptr) { /* test_config.c:47:13: */
	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28306 /* "malloc_usable_si..." */, ts+28325, /* "1" */
		TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28327 /* "rowid32" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28335 /* "casesensitivelik..." */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28353 /* "configslower" */, ts+28366 /* "1.0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28370 /* "curdir" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28377 /* "win32malloc" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28389 /* "debug" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28395 /* "default_ckptfull..." */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28417 /* "direct_read" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28429 /* "dirsync" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28437 /* "lfs" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28441 /* "pagecache_overfl..." */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28466 /* "mmap" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28471, /* "worker_threads" */
		ts+28486 /* "8" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28488 /* "memdebug" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28497 /* "8_3_names" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28507 /* "cursorhints" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28519 /* "hiddencolumns" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+13152 /* "deserialize" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28533 /* "mathlib" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28541 /* "mem3" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28546 /* "mem5" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28551 /* "offset_sql_func" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+13260 /* "preupdate" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28567 /* "snapshot" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28576 /* "mutex" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28582 /* "mutex_noop" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28593 /* "altertable" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+1818 /* "analyze" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28604 /* "api_armor" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28614 /* "atomicwrite" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28626 /* "geopoly" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28634 /* "json1" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28640 /* "has_codec" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28650 /* "like_match_blobs" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28667 /* "attach" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28674 /* "auth" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28679 /* "autoinc" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+12733 /* "autoindex" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28687 /* "autoreset" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28697 /* "autovacuum" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28708, /* "default_autovacu..." */
		ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28727 /* "between_opt" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28739 /* "builtin_test" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28752 /* "bloblit" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28760 /* "cast" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28765 /* "check" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28771 /* "cte" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28775 /* "columnmetadata" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28790 /* "oversize_cell_ch..." */, ts+13873, /* "0" */
		TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28810 /* "compileoption_di..." */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+13131 /* "complete" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28830 /* "compound" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28839 /* "conflict" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28848 /* "crashtest" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28858 /* "datetime" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28867 /* "decltype" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28876 /* "deprecated" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28887 /* "diskio" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+4835 /* "explain" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28894 /* "floatingpoint" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28908 /* "foreignkey" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28919 /* "fts1" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28924 /* "fts2" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28929 /* "fts3" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28934 /* "fts5" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28939 /* "fts3_unicode" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28952 /* "fts4_deferred" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28966 /* "gettable" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28975 /* "icu" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28979 /* "icu_collations" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+10524 /* "incrblob" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+28994 /* "integrityck" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29006 /* "legacyformat" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29019 /* "like_opt" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29028 /* "load_ext" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29037 /* "localtime" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29047 /* "lookaside" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29057, /* "long_double" */
		func() uintptr {
			if uint32(unsafe.Sizeof(float64(0))) > uint32(unsafe.Sizeof(float64(0))) {
				return ts + 28325 /* "1" */
			}
			return ts + 13873 /* "0" */
		}(),
		TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29069 /* "memorydb" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29078 /* "memorymanage" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29091 /* "mergesort" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29101 /* "null_trim" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29111 /* "or_opt" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29118 /* "rbu" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29122 /* "pager_pragmas" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29136 /* "pragma" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+10199 /* "progress" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29143 /* "reindex" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29151 /* "rtree" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29157 /* "rtree_int_only" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29172 /* "schema_pragmas" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29187 /* "schema_version" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29202 /* "session" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+18468 /* "stat4" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29210 /* "stmtvtab" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29219 /* "scanstatus" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29230 /* "lock_proxy_pragm..." */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29249 /* "prefer_proxy_loc..." */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29270 /* "shared_cache" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29283 /* "subquery" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29292 /* "tclvar" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29299, /* "threadsafe" */
		func() uintptr {
			if 1 != 0 {
				return ts + 28325 /* "1" */
			}
			return ts + 13873 /* "0" */
		}(), TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29310, /* "threadsafe1" */
		func() uintptr {
			if SQLITE_THREADSAFE == 1 {
				return ts + 28325 /* "1" */
			}
			return ts + 13873 /* "0" */
		}(), TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29322, /* "threadsafe2" */
		func() uintptr {
			if SQLITE_THREADSAFE == 2 {
				return ts + 28325 /* "1" */
			}
			return ts + 13873 /* "0" */
		}(), TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29334 /* "tempdb" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+13345 /* "trace" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29341 /* "trigger" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29349 /* "truncate_opt" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+15418 /* "utf16" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29362 /* "vacuum" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29369 /* "view" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29374 /* "vtab" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29379 /* "wal" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29383 /* "wsd" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29387 /* "update_delete_li..." */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+13372 /* "unlock_notify" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29407 /* "fast_secure_dele..." */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29426 /* "secure_delete" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29440 /* "userauth" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29449 /* "multiplex_ext_ov..." */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29473 /* "yytrackmaxstackd..." */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29494 /* "sqllog" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29501 /* "uri_00_error" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29514 /* "normalize" */, ts+13873 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+28291 /* "sqlite_options" */, ts+29524 /* "windowfunc" */, ts+28325 /* "1" */, TCL_GLOBAL_ONLY)

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29535 /* "SQLITE_MAX_LENGT..." */, uintptr(unsafe.Pointer(&cv_MAX_LENGTH)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29553 /* "SQLITE_MAX_COLUM..." */, uintptr(unsafe.Pointer(&cv_MAX_COLUMN)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29571 /* "SQLITE_MAX_SQL_L..." */, uintptr(unsafe.Pointer(&cv_MAX_SQL_LENGTH)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29593 /* "SQLITE_MAX_EXPR_..." */, uintptr(unsafe.Pointer(&cv_MAX_EXPR_DEPTH)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29615 /* "SQLITE_MAX_COMPO..." */, uintptr(unsafe.Pointer(&cv_MAX_COMPOUND_SELECT)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29642 /* "SQLITE_MAX_VDBE_..." */, uintptr(unsafe.Pointer(&cv_MAX_VDBE_OP)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29661 /* "SQLITE_MAX_FUNCT..." */, uintptr(unsafe.Pointer(&cv_MAX_FUNCTION_ARG)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29685 /* "SQLITE_MAX_VARIA..." */, uintptr(unsafe.Pointer(&cv_MAX_VARIABLE_NUMBER)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29712 /* "SQLITE_MAX_PAGE_..." */, uintptr(unsafe.Pointer(&cv_MAX_PAGE_SIZE)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29733 /* "SQLITE_MAX_PAGE_..." */, uintptr(unsafe.Pointer(&cv_MAX_PAGE_COUNT)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29755 /* "SQLITE_MAX_LIKE_..." */, uintptr(unsafe.Pointer(&cv_MAX_LIKE_PATTERN_LENGTH)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29786 /* "SQLITE_MAX_TRIGG..." */, uintptr(unsafe.Pointer(&cv_MAX_TRIGGER_DEPTH)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29811 /* "SQLITE_DEFAULT_C..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_CACHE_SIZE)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29837 /* "SQLITE_DEFAULT_P..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_PAGE_SIZE)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29862 /* "SQLITE_DEFAULT_F..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_FILE_FORMAT)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29889 /* "SQLITE_DEFAULT_S..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_SYNCHRONOUS)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29916 /* "SQLITE_DEFAULT_W..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_WAL_SYNCHRONOUS)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29947 /* "SQLITE_MAX_ATTAC..." */, uintptr(unsafe.Pointer(&cv_MAX_ATTACHED)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29967 /* "SQLITE_MAX_DEFAU..." */, uintptr(unsafe.Pointer(&cv_MAX_DEFAULT_PAGE_SIZE)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+29996 /* "SQLITE_MAX_WORKE..." */, uintptr(unsafe.Pointer(&cv_MAX_WORKER_THREADS)), (TCL_LINK_INT | TCL_LINK_READ_ONLY))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30022 /* "TEMP_STORE" */, uintptr(unsafe.Pointer(&cv_TEMP_STORE)),
			(TCL_LINK_INT | TCL_LINK_READ_ONLY))

	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30033 /* "__GNUC__" */, uintptr(unsafe.Pointer(&cv___GNUC__)),
			(TCL_LINK_INT | TCL_LINK_READ_ONLY))

	}
}

var cv_MAX_LENGTH int32 = SQLITE_MAX_LENGTH                           /* test_config.c:791:3 */
var cv_MAX_COLUMN int32 = SQLITE_MAX_COLUMN                           /* test_config.c:792:3 */
var cv_MAX_SQL_LENGTH int32 = SQLITE_MAX_SQL_LENGTH                   /* test_config.c:793:3 */
var cv_MAX_EXPR_DEPTH int32 = SQLITE_MAX_EXPR_DEPTH                   /* test_config.c:794:3 */
var cv_MAX_COMPOUND_SELECT int32 = SQLITE_MAX_COMPOUND_SELECT         /* test_config.c:795:3 */
var cv_MAX_VDBE_OP int32 = SQLITE_MAX_VDBE_OP                         /* test_config.c:796:3 */
var cv_MAX_FUNCTION_ARG int32 = SQLITE_MAX_FUNCTION_ARG               /* test_config.c:797:3 */
var cv_MAX_VARIABLE_NUMBER int32 = SQLITE_MAX_VARIABLE_NUMBER         /* test_config.c:798:3 */
var cv_MAX_PAGE_SIZE int32 = SQLITE_MAX_PAGE_SIZE                     /* test_config.c:799:3 */
var cv_MAX_PAGE_COUNT int32 = SQLITE_MAX_PAGE_COUNT                   /* test_config.c:800:3 */
var cv_MAX_LIKE_PATTERN_LENGTH int32 = SQLITE_MAX_LIKE_PATTERN_LENGTH /* test_config.c:801:3 */
var cv_MAX_TRIGGER_DEPTH int32 = SQLITE_MAX_TRIGGER_DEPTH             /* test_config.c:802:3 */
var cv_DEFAULT_CACHE_SIZE int32 = -2000                               /* test_config.c:803:3 */
var cv_DEFAULT_PAGE_SIZE int32 = SQLITE_DEFAULT_PAGE_SIZE             /* test_config.c:804:3 */
var cv_DEFAULT_FILE_FORMAT int32 = SQLITE_DEFAULT_FILE_FORMAT         /* test_config.c:805:3 */
var cv_DEFAULT_SYNCHRONOUS int32 = SQLITE_DEFAULT_SYNCHRONOUS         /* test_config.c:806:3 */
var cv_DEFAULT_WAL_SYNCHRONOUS int32 = SQLITE_DEFAULT_SYNCHRONOUS     /* test_config.c:807:3 */
var cv_MAX_ATTACHED int32 = SQLITE_MAX_ATTACHED                       /* test_config.c:808:3 */
var cv_MAX_DEFAULT_PAGE_SIZE int32 = SQLITE_MAX_DEFAULT_PAGE_SIZE     /* test_config.c:809:3 */
var cv_MAX_WORKER_THREADS int32 = SQLITE_MAX_WORKER_THREADS           /* test_config.c:810:3 */
var cv_TEMP_STORE int32 = SQLITE_TEMP_STORE                           /* test_config.c:813:22 */
var cv___GNUC__ int32 = 1                                             /* test_config.c:827:22 */

// Register commands with the TCL interpreter.
func Sqliteconfig_Init(tls *libc.TLS, interp uintptr) int32 { /* test_config.c:838:5: */
	set_options(tls, interp)
	return TCL_OK
}

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// The following #defines are copied from test_multiplex.c

// This routine is a copy of (most of) the code from SQLite function
// sqlite3FileSuffix3(). It modifies the filename in buffer z in the
// same way as SQLite does when in 8.3 filenames mode.
func sqlite3Delete83Name(tls *libc.TLS, z uintptr) { /* test_delete.c:46:13: */
	var i int32
	var sz int32
	sz = int32(libc.Xstrlen(tls, z))
	for i = (sz - 1); ((i > 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '/')) && (int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '.'); i-- {
	}
	if (int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == '.') && (sz > (i + 4)) {
		libc.Xmemmove(tls, (z + uintptr((i + 1))), (z + uintptr((sz - 3))), uint32(4))
	}
}

// zFile is a filename. Assuming no error occurs, if this file exists,
// set *pbExists to true and unlink it. Or, if the file does not exist,
// set *pbExists to false before returning.
//
// If an error occurs, non-zero is returned. Or, if no error occurs, zero.
func sqlite3DeleteUnlinkIfExists(tls *libc.TLS, pVfs uintptr, zFile uintptr, pbExists uintptr) int32 { /* test_delete.c:60:12: */
	var rc int32 = SQLITE_ERROR

	rc = libc.Xaccess(tls, zFile, F_OK)
	if rc != 0 {
		if (*(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))) == ENOENT {
			if pbExists != 0 {
				*(*int32)(unsafe.Pointer(pbExists)) = 0
			}
			rc = SQLITE_OK
		}
	} else {
		if pbExists != 0 {
			*(*int32)(unsafe.Pointer(pbExists)) = 1
		}
		rc = libc.Xunlink(tls, zFile)
	}
	return rc
}

// Delete the database file identified by the string argument passed to this
// function. The string must contain a filename, not an SQLite URI.
func sqlite3_delete_database(tls *libc.TLS, zFile uintptr) int32 { /* test_delete.c:95:16: */
	bp := tls.Alloc(116)
	defer tls.Free(116)

	var zBuf uintptr // Buffer to sprintf() filenames to
	var nBuf int32   // Size of buffer in bytes
	var rc int32 = 0 // System error code
	var i int32      // Iterate through azFmt[] and aMFile[]

	*(*[4]uintptr)(unsafe.Pointer(bp + 24 /* azFmt */)) = [4]uintptr{ts /* "%s" */, ts + 30042 /* "%s-journal" */, ts + 30053 /* "%s-wal" */, ts + 30060 /* "%s-shm" */}

	*(*[6]MFile)(unsafe.Pointer(bp + 40 /* aMFile */)) = [6]MFile{
		{FzFmt: ts + 30067 /* "%s%03d" */},
		{FzFmt: ts + 30074 /* "%s-journal%03d" */},
		{FzFmt: ts + 30089 /* "%s-wal%03d" */},
		{FzFmt: ts + 30067 /* "%s%03d" */, Fb83: 1},
		{FzFmt: ts + 30074 /* "%s-journal%03d" */, FiOffset: SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET, Fb83: 1},
		{FzFmt: ts + 30089 /* "%s-wal%03d" */, FiOffset: SQLITE_MULTIPLEX_WAL_8_3_OFFSET, Fb83: 1},
	}

	var pVfs uintptr = uintptr(0)

	// Allocate a buffer large enough for any of the files that need to be
	// deleted.
	nBuf = (int32(libc.Xstrlen(tls, zFile)) + 100)
	zBuf = sqlite3.Xsqlite3_malloc(tls, nBuf)
	if zBuf == uintptr(0) {
		return SQLITE_NOMEM
	}

	// Delete both the regular and 8.3 filenames versions of the database,
	// journal, wal and shm files.
	for i = 0; (rc == 0) && (uint32(i) < (uint32(unsafe.Sizeof([4]uintptr{})) / uint32(unsafe.Sizeof(uintptr(0))))); i++ {
		sqlite3.Xsqlite3_snprintf(tls, nBuf, zBuf, *(*uintptr)(unsafe.Pointer(bp + 24 /* &azFmt[0] */ + uintptr(i)*4)), libc.VaList(bp, zFile))
		rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, uintptr(0))
		if (rc == 0) && (i != 0) {
			sqlite3Delete83Name(tls, zBuf)
			rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, uintptr(0))
		}
	}

	// Delete any multiplexor files
	for i = 0; (rc == 0) && (uint32(i) < (uint32(unsafe.Sizeof([6]MFile{})) / uint32(unsafe.Sizeof(MFile{})))); i++ {
		var p uintptr = (bp + 40 /* &aMFile */ + uintptr(i)*12)
		var iChunk int32
		for iChunk = 1; iChunk <= MX_CHUNK_NUMBER; iChunk++ {
			// var bExists int32 at bp+112, 4

			sqlite3.Xsqlite3_snprintf(tls, nBuf, zBuf, (*MFile)(unsafe.Pointer(p)).FzFmt, libc.VaList(bp+8, zFile, (iChunk+(*MFile)(unsafe.Pointer(p)).FiOffset)))
			if (*MFile)(unsafe.Pointer(p)).Fb83 != 0 {
				sqlite3Delete83Name(tls, zBuf)
			}
			rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, bp+112 /* &bExists */)
			if (*(*int32)(unsafe.Pointer(bp + 112 /* bExists */)) == 0) || (rc != 0) {
				break
			}
		}
	}

	sqlite3.Xsqlite3_free(tls, zBuf)
	return func() int32 {
		if rc != 0 {
			return SQLITE_ERROR
		}
		return SQLITE_OK
	}()
}

type MFile = struct {
	FzFmt    uintptr
	FiOffset int32
	Fb83     int32
} /* test_delete.c:105:3 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

func Sqlitetest_demovfs_Init(tls *libc.TLS, interp uintptr) int32 { /* test_demovfs.c:686:5: */
	return TCL_OK
}

// Maximum pathname length supported by the devsym backend.

// Name used to identify this VFS.

type devsym_file1 = struct {
	Fbase  sqlite3_file
	FpReal uintptr
} /* test_devsym.c:33:9 */

// Maximum pathname length supported by the devsym backend.

// Name used to identify this VFS.

type devsym_file = devsym_file1 /* test_devsym.c:33:28 */

type DevsymGlobal = struct {
	FpVfs        uintptr
	FiDeviceChar int32
	FiSectorSize int32
	FnWriteCrash int32
} /* test_devsym.c:76:1 */

var g1 = DevsymGlobal{FiSectorSize: 512} /* test_devsym.c:82:21 */

// Close an devsym-file.
func devsymClose(tls *libc.TLS, pFile uintptr) int32 { /* test_devsym.c:87:12: */
	var p uintptr = pFile
	sqlite3.Xsqlite3OsClose(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
	return SQLITE_OK
}

// Read data from an devsym-file.
func devsymRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_devsym.c:96:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsRead(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

// Write data to an devsym-file.
func devsymWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_devsym.c:109:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsWrite(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

// Truncate an devsym-file.
func devsymTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_devsym.c:122:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsTruncate(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, size)
}

// Sync an devsym-file.
func devsymSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_devsym.c:130:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSync(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags)
}

// Return the current file-size of an devsym-file.
func devsymFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_devsym.c:138:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileSize(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, pSize)
}

// Lock an devsym-file.
func devsymLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_devsym.c:146:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsLock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, eLock)
}

// Unlock an devsym-file.
func devsymUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_devsym.c:154:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsUnlock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, eLock)
}

// Check if another file-handle holds a RESERVED lock on an devsym-file.
func devsymCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_devsym.c:162:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, pResOut)
}

// File control method. For custom operations on an devsym-file.
func devsymFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_devsym.c:170:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileControl(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, op, pArg)
}

// Return the sector-size in bytes for an devsym-file.
func devsymSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_devsym.c:178:12: */
	return g1.FiSectorSize
}

// Return the device characteristic flags supported by an devsym-file.
func devsymDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_devsym.c:185:12: */
	return g1.FiDeviceChar
}

// Shared-memory methods are all pass-thrus.
func devsymShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test_devsym.c:192:12: */
	var p uintptr = pFile
	return (*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 56 /* &.xShmLock */))))(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, ofst, n, flags)
}

func devsymShmMap(tls *libc.TLS, pFile uintptr, iRegion int32, szRegion int32, isWrite int32, pp uintptr) int32 { /* test_devsym.c:196:12: */
	var p uintptr = pFile
	return (*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 52 /* &.xShmMap */))))(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, iRegion, szRegion, isWrite, libc.AtomicLoadUintptr(&pp))
}

func devsymShmBarrier(tls *libc.TLS, pFile uintptr) { /* test_devsym.c:206:13: */
	var p uintptr = pFile
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 60 /* &.xShmBarrier */))))(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

func devsymShmUnmap(tls *libc.TLS, pFile uintptr, delFlag int32) int32 { /* test_devsym.c:210:12: */
	var p uintptr = pFile
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 64 /* &.xShmUnmap */))))(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, delFlag)
}

// Open an devsym file handle.
func devsymOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_devsym.c:220:12: */
	var rc int32
	var p uintptr = pFile
	(*devsym_file)(unsafe.Pointer(p)).FpReal = (p + 1*8)
	rc = sqlite3.Xsqlite3OsOpen(tls, g1.FpVfs, zName, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&devsym_io_methods))
	}
	return rc
}

var devsym_io_methods = sqlite3_io_methods{
	FiVersion:               2, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
} /* test_devsym.c:227:27 */

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func devsymDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_devsym.c:262:12: */
	return sqlite3.Xsqlite3OsDelete(tls, g1.FpVfs, zPath, dirSync)
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func devsymAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_devsym.c:270:12: */
	return sqlite3.Xsqlite3OsAccess(tls, g1.FpVfs, zPath, flags, pResOut)
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (DEVSYM_MAX_PATHNAME+1) bytes.
func devsymFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_devsym.c:284:12: */
	return sqlite3.Xsqlite3OsFullPathname(tls, g1.FpVfs, zPath, nOut, zOut)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func devsymRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_devsym.c:329:12: */
	return sqlite3.Xsqlite3OsRandomness(tls, g1.FpVfs, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func devsymSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* test_devsym.c:337:12: */
	return sqlite3.Xsqlite3OsSleep(tls, g1.FpVfs, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func devsymCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_devsym.c:344:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((g1.FpVfs + 64 /* &.xCurrentTime */))))(tls, g1.FpVfs, pTimeOut)
}

// Return the sector-size in bytes for an writecrash-file.
func writecrashSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_devsym.c:351:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSectorSize(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

// Return the device characteristic flags supported by an writecrash-file.
func writecrashDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_devsym.c:359:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

// Write data to an writecrash-file.
func writecrashWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_devsym.c:367:12: */
	var p uintptr = pFile
	if g1.FnWriteCrash > 0 {
		g1.FnWriteCrash--
		if g1.FnWriteCrash == 0 {
			libc.Xabort(tls)
		}
	}
	return sqlite3.Xsqlite3OsWrite(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

// Open an writecrash file handle.
func writecrashOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_devsym.c:384:12: */
	var rc int32
	var p uintptr = pFile
	(*devsym_file)(unsafe.Pointer(p)).FpReal = (p + 1*8)
	rc = sqlite3.Xsqlite3OsOpen(tls, g1.FpVfs, zName, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&writecrash_io_methods))
	}
	return rc
}

var writecrash_io_methods = sqlite3_io_methods{
	FiVersion:               2, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
} /* test_devsym.c:391:27 */

var devsym_vfs = sqlite3_vfs{
	FiVersion:      2,                                   // iVersion
	FszOsFile:      int32(unsafe.Sizeof(devsym_file{})), // szOsFile
	FmxPathname:    DEVSYM_MAX_PATHNAME,                 // pNext
	FzName:         ts + 30100,                          /* "devsym" */ // pAppData
	FxOpen:         0,                                   // xOpen
	FxDelete:       0,                                   // xDelete
	FxAccess:       0,                                   // xAccess
	FxFullPathname: 0,                                   // xDlClose
	FxRandomness:   0,                                   // xRandomness
	FxSleep:        0,                                   // xSleep
	FxCurrentTime:  0,                                   // xCurrentTimeInt64
} /* test_devsym.c:421:20 */

var writecrash_vfs = sqlite3_vfs{
	FiVersion:      2,                                   // iVersion
	FszOsFile:      int32(unsafe.Sizeof(devsym_file{})), // szOsFile
	FmxPathname:    DEVSYM_MAX_PATHNAME,                 // pNext
	FzName:         ts + 30107,                          /* "writecrash" */ // pAppData
	FxOpen:         0,                                   // xOpen
	FxDelete:       0,                                   // xDelete
	FxAccess:       0,                                   // xAccess
	FxFullPathname: 0,                                   // xDlClose
	FxRandomness:   0,                                   // xRandomness
	FxSleep:        0,                                   // xSleep
	FxCurrentTime:  0,                                   // xCurrentTimeInt64
} /* test_devsym.c:450:20 */

// This procedure registers the devsym vfs with SQLite. If the argument is
// true, the devsym vfs becomes the new default vfs. It is the only publicly
// available function in this file.
func devsym_register(tls *libc.TLS, iDeviceChar int32, iSectorSize int32) { /* test_devsym.c:485:6: */

	if g1.FpVfs == uintptr(0) {
		g1.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 4 /* &.szOsFile */)) += ((*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile)
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 4 /* &.szOsFile */)) += ((*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&devsym_vfs)), 0)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&writecrash_vfs)), 0)
	}
	if iDeviceChar >= 0 {
		g1.FiDeviceChar = iDeviceChar
	} else {
		g1.FiDeviceChar = 0
	}
	if iSectorSize >= 0 {
		g1.FiSectorSize = iSectorSize
	} else {
		g1.FiSectorSize = 512
	}
}

func devsym_unregister(tls *libc.TLS) { /* test_devsym.c:506:6: */
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&devsym_vfs)))
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&writecrash_vfs)))
	g1.FpVfs = uintptr(0)
	g1.FiDeviceChar = 0
	g1.FiSectorSize = 0
}

func devsym_crash_on_write(tls *libc.TLS, nWrite int32) { /* test_devsym.c:514:6: */
	if g1.FpVfs == uintptr(0) {
		g1.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 4 /* &.szOsFile */)) += ((*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile)
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 4 /* &.szOsFile */)) += ((*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&devsym_vfs)), 0)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&writecrash_vfs)), 0)
	}
	g1.FnWriteCrash = nWrite
}

// The next short section of defines are only done when not running on Windows
// or some other strange platform.

type Tcl_StatBuf = stat /* tcl.h:470:25 */

type stat64 = struct {
	Fst_dev     uint64
	F__pad1     uint32
	F__st_ino   uint32
	Fst_mode    uint32
	Fst_nlink   uint32
	Fst_uid     uint32
	Fst_gid     uint32
	Fst_rdev    uint64
	F__pad2     uint32
	_           [4]byte
	Fst_size    int64
	Fst_blksize int32
	_           [4]byte
	Fst_blocks  int64
	Fst_atim    struct {
		Ftv_sec  int32
		Ftv_nsec int32
	}
	Fst_mtim struct {
		Ftv_sec  int32
		Ftv_nsec int32
	}
	Fst_ctim struct {
		Ftv_sec  int32
		Ftv_nsec int32
	}
	Fst_ino uint64
} /* stat.h:95:1 */

// statx-related definitions and declarations.
//    Copyright (C) 2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This interface is based on <linux/stat.h> in Linux.

type statx_timestamp = struct {
	Ftv_sec                 int64
	Ftv_nsec                uint32
	F__statx_timestamp_pad1 [1]int32
} /* statx.h:25:1 */

// Warning: The kernel may add additional fields to this struct in the
//    future.  Only use this struct for calling the statx function, not
//    for storing data.  (Expansion will be controlled by the mask
//    argument of the statx function.)
type statx = struct {
	Fstx_mask            uint32
	Fstx_blksize         uint32
	Fstx_attributes      uint64
	Fstx_nlink           uint32
	Fstx_uid             uint32
	Fstx_gid             uint32
	Fstx_mode            uint16
	F__statx_pad1        [1]uint16
	Fstx_ino             uint64
	Fstx_size            uint64
	Fstx_blocks          uint64
	Fstx_attributes_mask uint64
	Fstx_atime           struct {
		Ftv_sec                 int64
		Ftv_nsec                uint32
		F__statx_timestamp_pad1 [1]int32
	}
	Fstx_btime struct {
		Ftv_sec                 int64
		Ftv_nsec                uint32
		F__statx_timestamp_pad1 [1]int32
	}
	Fstx_ctime struct {
		Ftv_sec                 int64
		Ftv_nsec                uint32
		F__statx_timestamp_pad1 [1]int32
	}
	Fstx_mtime struct {
		Ftv_sec                 int64
		Ftv_nsec                uint32
		F__statx_timestamp_pad1 [1]int32
	}
	Fstx_rdev_major uint32
	Fstx_rdev_minor uint32
	Fstx_dev_major  uint32
	Fstx_dev_minor  uint32
	F__statx_pad2   [14]uint64
} /* statx.h:36:1 */

type flock64 = struct {
	Fl_type   int16
	Fl_whence int16
	_         [4]byte
	Fl_start  int64
	Fl_len    int64
	Fl_pid    int32
	_         [4]byte
} /* fcntl.h:43:1 */

// Include generic Linux declarations.
// O_*, F_*, FD_* bit values for Linux.
//    Copyright (C) 2001-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// This file contains shared definitions between Linux architectures
//    and is included by <bits/fcntl.h> to declare them.  The various
//    #ifndef cases allow the architecture specific file to define those
//    values with different values.
//
//    A minimal <bits/fcntl.h> contains just:
//
//    struct flock {...}
//    #ifdef __USE_LARGEFILE64
//    struct flock64 {...}
//    #endif
//    #include <bits/fcntl-linux.h>

// Define struct iovec.
//    Copyright (C) 1996-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//    one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//    defined if the corresponding type is *not* defined.
//    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//    NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//     are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Structure for scatter/gather I/O.
type iovec = struct {
	Fiov_base uintptr
	Fiov_len  size_t
} /* struct_iovec.h:26:1 */

// Structure to use with F_GETOWN_EX and F_SETOWN_EX.
type f_owner_ex = struct {
	Ftype uint32
	Fpid  int32
} /* fcntl-linux.h:274:1 */

// Types of seals.

// Hint values for F_{GET,SET}_RW_HINT.

// Define some more compatibility macros to be backward compatible with
//    BSD systems which did not managed to hide these kernel macros.

// Advise to `posix_fadvise'.

// Flags for SYNC_FILE_RANGE.

// Flags for SPLICE and VMSPLICE.

// Flags for fallocate.
// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// FALLOC_FL_COLLAPSE_RANGE is used to remove a range of a file
// without leaving a hole in the file. The contents of the file beyond
// the range being removed is appended to the start offset of the range
// being removed (i.e. the hole that was punched is "collapsed"),
// resulting in a file layout that looks like the range that was
// removed never existed. As such collapsing a range of a file changes
// the size of the file, reducing it by the same length of the range
// that has been removed by the operation.
//
// Different filesystems may implement different limitations on the
// granularity of the operation. Most will limit operations to
// filesystem block size boundaries, but this boundary may be larger or
// smaller depending on the filesystem and/or the configuration of the
// filesystem or file.
//
// Attempting to collapse a range that crosses the end of the file is
// considered an illegal operation - just use ftruncate(2) if you need
// to collapse a range that crosses EOF.

// FALLOC_FL_ZERO_RANGE is used to convert a range of file to zeros preferably
// without issuing data IO. Blocks should be preallocated for the regions that
// span holes in the file, and the entire range is preferable converted to
// unwritten extents - even though file system may choose to zero out the
// extent or do whatever which will result in reading zeros from the range
// while the range remains allocated for the file.
//
// This can be also used to preallocate blocks past EOF in the same way as
// with fallocate. Flag FALLOC_FL_KEEP_SIZE should cause the inode
// size to remain the same.

// FALLOC_FL_INSERT_RANGE is use to insert space within the file size without
// overwriting any existing data. The contents of the file beyond offset are
// shifted towards right by len bytes to create a hole.  As such, this
// operation will increase the size of the file by len bytes.
//
// Different filesystems may implement different limitations on the granularity
// of the operation. Most will limit operations to filesystem block size
// boundaries, but this boundary may be larger or smaller depending on
// the filesystem and/or the configuration of the filesystem or file.
//
// Attempting to insert space using this flag at OR beyond the end of
// the file is considered an illegal operation - just use ftruncate(2) or
// fallocate(2) with mode 0 for such type of operations.

// FALLOC_FL_UNSHARE_RANGE is used to unshare shared blocks within the
// file size without overwriting any existing data. The purpose of this
// call is to preemptively reallocate any blocks that are subject to
// copy-on-write.
//
// Different filesystems may implement different limitations on the
// granularity of the operation. Most will limit operations to filesystem
// block size boundaries, but this boundary may be larger or smaller
// depending on the filesystem and/or the configuration of the filesystem
// or file.
//
// This flag can only be used with allocate-mode fallocate, which is
// to say that it cannot be used with the punch, zero, collapse, or
// insert range modes.

// File handle structure.
type file_handle = struct {
	_             [0]uint32
	Fhandle_bytes uint32
	Fhandle_type  int32
} /* fcntl-linux.h:350:1 */

type dirent64 = struct {
	Fd_ino    uint64
	Fd_off    int64
	Fd_reclen uint16
	Fd_type   uint8
	Fd_name   [256]int8
	_         [5]byte
} /* dirent.h:37:1 */

type fs_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
	FzDb  uintptr
	FzTbl uintptr
} /* test_fs.c:96:9 */

type fs_vtab = fs_vtab1 /* test_fs.c:96:24 */
type fs_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FpStmt  uintptr
	FzBuf   uintptr
	FnBuf   int32
	FnAlloc int32
} /* test_fs.c:97:9 */

type fs_cursor = fs_cursor1 /* test_fs.c:97:26 */

// ************************************************************************
//
// Start of fsdir implementation.
type FsdirVtab1 = struct{ Fbase sqlite3_vtab } /* test_fs.c:121:9 */

// ************************************************************************
//
// Start of fsdir implementation.
type FsdirVtab = FsdirVtab1 /* test_fs.c:121:26 */
type FsdirCsr1 = struct {
	Fbase   sqlite3_vtab_cursor
	FzDir   uintptr
	FpDir   uintptr
	_       [4]byte
	FiRowid sqlite3_int64
	FpEntry uintptr
	_       [4]byte
} /* test_fs.c:122:9 */

type FsdirCsr = FsdirCsr1 /* test_fs.c:122:25 */

// This function is the implementation of both the xConnect and xCreate
// methods of the fsdir virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func fsdirConnect1(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_fs.c:146:12: */
	var pTab uintptr

	if argc != 3 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+27841 /* "wrong number of ..." */, 0)
		return SQLITE_ERROR
	}

	pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FsdirVtab{})))
	if !(pTab != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pTab, 0, uint32(unsafe.Sizeof(FsdirVtab{})))

	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pTab /* &.base */)
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+30118 /* "CREATE TABLE xyz..." */)

	return SQLITE_OK
}

// xDestroy/xDisconnect implementation.
func fsdirDisconnect1(tls *libc.TLS, pVtab uintptr) int32 { /* test_fs.c:173:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// xBestIndex implementation. The only constraint supported is:
//
//   (dir = ?)
func fsdirBestIndex1(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_fs.c:183:12: */
	var ii int32

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000000000.0

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var p uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		if (((*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == 0) && ((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0)) && (int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			var pUsage uintptr
			pUsage = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1.0
			break
		}
	}

	return SQLITE_OK
}

// xOpen implementation.
//
// Open a new fsdir cursor.
func fsdirOpen1(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_fs.c:209:12: */
	var pCur uintptr
	// Allocate an extra 256 bytes because it is undefined how big dirent.d_name
	// is and we need enough space.  Linux provides plenty already, but
	// Solaris only provides one byte.
	pCur = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(FsdirCsr{})) + uint32(256))))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(FsdirCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Close a fsdir cursor.
func fsdirClose1(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:224:12: */
	var pCur uintptr = cur
	if (*FsdirCsr)(unsafe.Pointer(pCur)).FpDir != 0 {
		libc.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCur)).FpDir)
	}
	sqlite3.Xsqlite3_free(tls, (*FsdirCsr)(unsafe.Pointer(pCur)).FzDir)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Skip the cursor to the next entry.
func fsdirNext1(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:235:12: */
	var pCsr uintptr = cur

	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir != 0 {
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry = libc.Xreaddir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
		if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry == uintptr(0) {
			libc.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
			(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = uintptr(0)
		}
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid++
	}

	return SQLITE_OK
}

// xFilter method implementation.
func fsdirFilter1(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_fs.c:253:12: */
	var pCsr uintptr = pVtabCursor
	var zDir uintptr
	var nDir int32

	if (idxNum != 1) || (argc != 1) {
		return SQLITE_ERROR
	}

	(*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid = int64(0)
	sqlite3.Xsqlite3_free(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir)
	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir != 0 {
		libc.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = uintptr(0)
	}

	zDir = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	nDir = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	(*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir = sqlite3.Xsqlite3_malloc(tls, (nDir + 1))
	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemcpy(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir, zDir, (uint32(nDir + 1)))

	(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = libc.Xopendir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir)
	return fsdirNext1(tls, pVtabCursor)
}

// xEof method implementation.
func fsdirEof1(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:287:12: */
	var pCsr uintptr = cur
	return (libc.Bool32((*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir == uintptr(0)))
}

// xColumn method implementation.
func fsdirColumn1(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_fs.c:295:12: */
	var pCsr uintptr = cur
	switch i {
	case 0: // dir
		sqlite3.Xsqlite3_result_text(tls, ctx, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir, -1, uintptr(0))
		break

	case 1: // name
		sqlite3.Xsqlite3_result_text(tls, ctx, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry+19 /* &.d_name */, -1, libc.UintptrFromInt32(-1))
		break

	default:

	}

	return SQLITE_OK
}

// xRowid method implementation.
func fsdirRowid1(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_fs.c:316:12: */
	var pCsr uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid
	return SQLITE_OK
}

//
// End of fsdir implementation.
//

// ************************************************************************
//
// Start of fstree implementation.
type FstreeVtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
} /* test_fs.c:328:9 */

//
// End of fsdir implementation.
//

// ************************************************************************
//
// Start of fstree implementation.
type FstreeVtab = FstreeVtab1 /* test_fs.c:328:27 */
type FstreeCsr1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
	Ffd    int32
} /* test_fs.c:329:9 */

type FstreeCsr = FstreeCsr1 /* test_fs.c:329:26 */

// This function is the implementation of both the xConnect and xCreate
// methods of the fstree virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func fstreeConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_fs.c:352:12: */
	var pTab uintptr

	if argc != 3 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+27841 /* "wrong number of ..." */, 0)
		return SQLITE_ERROR
	}

	pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FstreeVtab{})))
	if !(pTab != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pTab, 0, uint32(unsafe.Sizeof(FstreeVtab{})))
	(*FstreeVtab)(unsafe.Pointer(pTab)).Fdb = db

	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pTab /* &.base */)
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+30147 /* "CREATE TABLE xyz..." */)

	return SQLITE_OK
}

// xDestroy/xDisconnect implementation.
func fstreeDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test_fs.c:380:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// xBestIndex implementation. The only constraint supported is:
//
//   (dir = ?)
func fstreeBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_fs.c:390:12: */
	var ii int32

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var p uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		if (((*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == 0) && ((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0)) && (((int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_GLOB) ||
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_LIKE)) ||
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ)) {
			var pUsage uintptr
			pUsage = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8)
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 100000.0
			return SQLITE_OK
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000000000.0
	return SQLITE_OK
}

// xOpen implementation.
//
// Open a new fstree cursor.
func fstreeOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_fs.c:418:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FstreeCsr{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(FstreeCsr{})))
	(*FstreeCsr)(unsafe.Pointer(pCur)).Ffd = -1
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

func fstreeCloseFd(tls *libc.TLS, pCsr uintptr) { /* test_fs.c:428:13: */
	if (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd >= 0 {
		libc.Xclose(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd)
		(*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd = -1
	}
}

// Close a fstree cursor.
func fstreeClose(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:438:12: */
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	fstreeCloseFd(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

// Skip the cursor to the next entry.
func fstreeNext(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:449:12: */
	var pCsr uintptr = cur
	var rc int32

	fstreeCloseFd(tls, pCsr)
	rc = sqlite3.Xsqlite3_step(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	if rc != SQLITE_ROW {
		rc = sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
		(*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
	} else {
		rc = SQLITE_OK
		(*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd = libc.Xopen(tls, sqlite3.Xsqlite3_column_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 0), O_RDONLY, 0)
	}

	return rc
}

// xFilter method implementation.
func fstreeFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_fs.c:469:12: */
	bp := tls.Alloc(2)
	defer tls.Free(2)

	var pCsr uintptr = pVtabCursor
	var pTab uintptr = (*FstreeCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
	var rc int32
	var zSql uintptr = ts + 30183 /* "WITH r(d) AS (  ..." */
	var zRoot uintptr
	var nRoot int32
	var zPrefix uintptr
	var nPrefix int32
	var zDir uintptr
	var nDir int32
	*(*[2]int8)(unsafe.Pointer(bp /* aWild */)) = [2]int8{int8(0), int8(0)}

	zRoot = ts + 30415 /* "/" */
	nRoot = 1
	zPrefix = ts + 489 /* "" */
	nPrefix = 0

	zDir = zRoot
	nDir = nRoot

	fstreeCloseFd(tls, pCsr)
	sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	(*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*FstreeVtab)(unsafe.Pointer(pTab)).Fdb, zSql, -1, (pCsr + 4 /* &.pStmt */), uintptr(0))
	if rc != SQLITE_OK {
		return rc
	}

	if idxNum != 0 {
		var zQuery uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		switch idxNum {
		case SQLITE_INDEX_CONSTRAINT_GLOB:
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */)) = int8('*')
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + 1)) = int8('?')
			break
			fallthrough
		case SQLITE_INDEX_CONSTRAINT_LIKE:
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */)) = int8('_')
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + 1)) = int8('%')
			break
		}

		if sqlite3.Xsqlite3_strnicmp(tls, zQuery, zPrefix, nPrefix) == 0 {
			var i int32
			for i = nPrefix; *(*int8)(unsafe.Pointer(zQuery + uintptr(i))) != 0; i++ {
				if (int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(bp /* &aWild[0] */)))) || (int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + 1)))) {
					break
				}
				if int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == '/' {
					nDir = i
				}
			}
			zDir = zQuery
		}
	}
	if nDir == 0 {
		nDir = 1
	}

	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 1, zDir, nDir, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 2, zRoot, nRoot, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 3, zPrefix, nPrefix, libc.UintptrFromInt32(-1))

	return fstreeNext(tls, pVtabCursor)
}

// xEof method implementation.
func fstreeEof(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:557:12: */
	var pCsr uintptr = cur
	return (libc.Bool32((*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0)))
}

// xColumn method implementation.
func fstreeColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_fs.c:565:12: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var pCsr uintptr = cur
	if i == 0 { // path
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 0))
	} else {
		// var sBuf stat at bp, 104

		libc.Xfstat(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd, bp /* &sBuf */)

		if (((*stat)(unsafe.Pointer(bp /* &sBuf */)).Fst_mode) & uint32(0170000)) == (uint32(0100000)) {
			if i == 1 {
				sqlite3.Xsqlite3_result_int64(tls, ctx, (*stat)(unsafe.Pointer(bp /* &sBuf */)).Fst_size)
			} else {
				var nRead int32
				var aBuf uintptr = sqlite3.Xsqlite3_malloc(tls, (int32((*stat)(unsafe.Pointer(bp /* &sBuf */)).Fst_mode + uint32(1))))
				if !(aBuf != 0) {
					return SQLITE_NOMEM
				}
				nRead = libc.Xread(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd, aBuf, (*stat)(unsafe.Pointer(bp /* &sBuf */)).Fst_mode)
				if uint32(nRead) != (*stat)(unsafe.Pointer(bp /* &sBuf */)).Fst_mode {
					return SQLITE_IOERR
				}
				sqlite3.Xsqlite3_result_blob(tls, ctx, aBuf, nRead, libc.UintptrFromInt32(-1))
				sqlite3.Xsqlite3_free(tls, aBuf)
			}
		}
	}

	return SQLITE_OK
}

// xRowid method implementation.
func fstreeRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_fs.c:596:12: */
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return SQLITE_OK
}

//
// End of fstree implementation.
//

// This function is the implementation of both the xConnect and xCreate
// methods of the fs virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func fsConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_fs.c:618:12: */
	var pVtab uintptr
	var nByte int32
	var zTbl uintptr
	var zDb uintptr = *(*uintptr)(unsafe.Pointer(argv + 1*4))

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+27841 /* "wrong number of ..." */, 0)
		return SQLITE_ERROR
	}
	zTbl = *(*uintptr)(unsafe.Pointer(argv + 3*4))

	nByte = (int32((((uint32(unsafe.Sizeof(fs_vtab{})) + uint32(int32(libc.Xstrlen(tls, zTbl)))) + uint32(1)) + uint32(int32(libc.Xstrlen(tls, zDb)))) + uint32(1)))
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(nByte))
	if !(pVtab != 0) {
		return SQLITE_NOMEM
	}

	(*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl = (pVtab + 1*24)
	(*fs_vtab)(unsafe.Pointer(pVtab)).FzDb = ((*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl + uintptr((libc.Xstrlen(tls, zTbl) + size_t(1))))
	(*fs_vtab)(unsafe.Pointer(pVtab)).Fdb = db
	libc.Xmemcpy(tls, (*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl, zTbl, libc.Xstrlen(tls, zTbl))
	libc.Xmemcpy(tls, (*fs_vtab)(unsafe.Pointer(pVtab)).FzDb, zDb, libc.Xstrlen(tls, zDb))
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pVtab /* &.base */)
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+30417 /* "CREATE TABLE x(p..." */)

	return SQLITE_OK
}

// Note that for this virtual table, the xCreate and xConnect
// methods are identical.

func fsDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test_fs.c:653:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// The xDisconnect and xDestroy methods are also the same

// Open a new fs cursor.
func fsOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_fs.c:662:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(fs_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Close a fs cursor.
func fsClose(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:672:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt)
	sqlite3.Xsqlite3_free(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func fsNext(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:680:12: */
	var pCur uintptr = cur
	var rc int32

	rc = sqlite3.Xsqlite3_step(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt)
	if (rc == SQLITE_ROW) || (rc == SQLITE_DONE) {
		rc = SQLITE_OK
	}

	return rc
}

func fsFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_fs.c:690:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32
	var pCur uintptr = pVtabCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab

	if idxNum == 1 {
		var zStmt uintptr = sqlite3.Xsqlite3_mprintf(tls,
			ts+30454 /* "SELECT * FROM %Q..." */, libc.VaList(bp, (*fs_vtab)(unsafe.Pointer(p)).FzDb, (*fs_vtab)(unsafe.Pointer(p)).FzTbl))
		if !(zStmt != 0) {
			return SQLITE_NOMEM
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*fs_vtab)(unsafe.Pointer(p)).Fdb, zStmt, -1, (pCur + 4 /* &.pStmt */), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zStmt)
		if rc == SQLITE_OK {
			sqlite3.Xsqlite3_bind_value(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 1, *(*uintptr)(unsafe.Pointer(argv)))
		}
	} else {
		var zStmt uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+3268 /* "SELECT * FROM %Q..." */, libc.VaList(bp+16, (*fs_vtab)(unsafe.Pointer(p)).FzDb, (*fs_vtab)(unsafe.Pointer(p)).FzTbl))
		if !(zStmt != 0) {
			return SQLITE_NOMEM
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*fs_vtab)(unsafe.Pointer(p)).Fdb, zStmt, -1, (pCur + 4 /* &.pStmt */), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zStmt)
	}

	if rc == SQLITE_OK {
		rc = fsNext(tls, pVtabCursor)
	}
	return rc
}

func fsColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_fs.c:722:12: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var pCur uintptr = cur

	if i == 0 {
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 0))
	} else {
		var zFile uintptr = sqlite3.Xsqlite3_column_text(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 1)
		// var sbuf stat at bp, 104

		var fd int32
		var n int32
		fd = libc.Xopen(tls, zFile, O_RDONLY, 0)
		if fd < 0 {
			return SQLITE_IOERR
		}
		libc.Xfstat(tls, fd, bp /* &sbuf */)

		if (*stat)(unsafe.Pointer(bp /* &sbuf */)).Fst_size >= int64((*fs_cursor)(unsafe.Pointer(pCur)).FnAlloc) {
			var nNew sqlite3_int64 = ((*stat)(unsafe.Pointer(bp /* &sbuf */)).Fst_size * int64(2))
			var zNew uintptr
			if nNew < int64(1024) {
				nNew = int64(1024)
			}

			zNew = sqlite3.Xsqlite3Realloc(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, uint64(nNew))
			if zNew == uintptr(0) {
				libc.Xclose(tls, fd)
				return SQLITE_NOMEM
			}
			(*fs_cursor)(unsafe.Pointer(pCur)).FzBuf = zNew
			(*fs_cursor)(unsafe.Pointer(pCur)).FnAlloc = int32(nNew)
		}

		n = libc.Xread(tls, fd, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, uint32((*stat)(unsafe.Pointer(bp /* &sbuf */)).Fst_size))
		libc.Xclose(tls, fd)
		if int64(n) != (*stat)(unsafe.Pointer(bp /* &sbuf */)).Fst_size {
			return SQLITE_ERROR
		}
		(*fs_cursor)(unsafe.Pointer(pCur)).FnBuf = int32((*stat)(unsafe.Pointer(bp /* &sbuf */)).Fst_size)
		*(*int8)(unsafe.Pointer((*fs_cursor)(unsafe.Pointer(pCur)).FzBuf + uintptr((*fs_cursor)(unsafe.Pointer(pCur)).FnBuf))) = int8(0)

		sqlite3.Xsqlite3_result_text(tls, ctx, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, -1, libc.UintptrFromInt32(-1))
	}
	return SQLITE_OK
}

func fsRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_fs.c:763:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 0)
	return SQLITE_OK
}

func fsEof(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:769:12: */
	var pCur uintptr = cur
	return (libc.Bool32(sqlite3.Xsqlite3_data_count(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt) == 0))
}

func fsBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_fs.c:774:12: */
	var ii int32

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		if (((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn < 0) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			var pUsage uintptr
			pUsage = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(0)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1.0
			break
		}
	}

	return SQLITE_OK
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var fsModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_fs.c:798:23 */

var fsdirModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_fs.c:821:23 */

var fstreeModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_fs.c:844:23 */

// Register the echo virtual table module.
func register_fs_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_fs.c:875:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+30488 /* "fs" */, uintptr(unsafe.Pointer(&fsModule)), interp)
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+5186 /* "fsdir" */, uintptr(unsafe.Pointer(&fsdirModule)), uintptr(0))
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+30491 /* "fstree" */, uintptr(unsafe.Pointer(&fstreeModule)), uintptr(0))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetestfs_Init(tls *libc.TLS, interp uintptr) int32 { /* test_fs.c:901:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd6)) / uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd6[i].FzName,
			aObjCmd6[i].FxProc, aObjCmd6[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd6 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 30498 /* "register_fs_modu..." */, FxProc: 0},
} /* test_fs.c:907:5 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set2 = struct{ F__fds_bits [32]int32 } /* select.h:70:5 */

// Allocate nByte bytes of space using sqlite3_malloc(). If the
// allocation fails, call sqlite3_result_error_nomem() to notify
// the database handle that malloc() has failed.
func testContextMalloc(tls *libc.TLS, context uintptr, nByte int32) uintptr { /* test_func.c:33:13: */
	var z uintptr = sqlite3.Xsqlite3_malloc(tls, nByte)
	if !(z != 0) && (nByte > 0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	}
	return z
}

// This function generates a string of random characters.  Used for
// generating test data.
func randStr(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:45:13: */
	bp := tls.Alloc(1004)
	defer tls.Free(1004)

	var iMin int32
	var iMax int32
	var n int32
	// var r int32 at bp, 4

	var i int32
	// var zBuf [1000]uint8 at bp+4, 1000

	// It used to be possible to call randstr() with any number of arguments,
	// but now it is registered with SQLite as requiring exactly 2.

	iMin = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if iMin < 0 {
		iMin = 0
	}
	if uint32(iMin) >= uint32(unsafe.Sizeof([1000]uint8{})) {
		iMin = (int32(uint32(unsafe.Sizeof([1000]uint8{})) - uint32(1)))
	}
	iMax = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if iMax < iMin {
		iMax = iMin
	}
	if uint32(iMax) >= uint32(unsafe.Sizeof([1000]uint8{})) {
		iMax = (int32(uint32(unsafe.Sizeof([1000]uint8{})) - uint32(1)))
	}
	n = iMin
	if iMax > iMin {
		sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(int32(0))), bp /* &r */)
		*(*int32)(unsafe.Pointer(bp /* r */)) &= 0x7fffffff
		n = n + (*(*int32)(unsafe.Pointer(bp /* r */)) % ((iMax + 1) - iMin))
	}

	sqlite3.Xsqlite3_randomness(tls, n, bp+4 /* &zBuf[0] */)
	for i = 0; i < n; i++ {
		*(*uint8)(unsafe.Pointer(bp + 4 /* &zBuf[0] */ + uintptr(i))) = zSrc[(uint32(*(*uint8)(unsafe.Pointer(bp + 4 /* &zBuf[0] */ + uintptr(i)))) % (uint32(unsafe.Sizeof(zSrc)) - uint32(1)))]
	}
	*(*uint8)(unsafe.Pointer(bp + 4 /* &zBuf[0] */ + uintptr(n))) = uint8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp+4 /* zBuf */, n, libc.UintptrFromInt32(-1))
}

var zSrc = *(*[79]uint8)(unsafe.Pointer(ts + 30517 /* "abcdefghijklmnop..." */)) /* test_func.c:46:30 */

// The following two SQL functions are used to test returning a text
// result with a destructor. Function 'test_destructor' takes one argument
// and returns the same argument interpreted as TEXT. A destructor is
// passed with the sqlite3_result_text() call.
//
// SQL function 'test_destructor_count' returns the number of outstanding
// allocations made by 'test_destructor';
//
// WARNING: Not threadsafe.
var test_destructor_count_var int32 = 0 /* test_func.c:91:12 */

func destructor(tls *libc.TLS, p uintptr) { /* test_func.c:92:13: */
	var zVal uintptr = p

	zVal--
	sqlite3.Xsqlite3_free(tls, zVal)
	test_destructor_count_var--
}

func test_destructor(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:99:13: */
	var zVal uintptr
	var len int32

	test_destructor_count_var++

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	len = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zVal = testContextMalloc(tls, pCtx, (len + 3))
	if !(zVal != 0) {
		return
	}
	*(*int8)(unsafe.Pointer(zVal + uintptr((len + 1)))) = int8(0)
	*(*int8)(unsafe.Pointer(zVal + uintptr((len + 2)))) = int8(0)
	zVal++
	libc.Xmemcpy(tls, zVal, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), uint32(len))
	sqlite3.Xsqlite3_result_text(tls, pCtx, zVal, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{destructor})))
}

func test_destructor16(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:122:13: */
	var zVal uintptr
	var len int32

	test_destructor_count_var++

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	len = sqlite3.Xsqlite3_value_bytes16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zVal = testContextMalloc(tls, pCtx, (len + 3))
	if !(zVal != 0) {
		return
	}
	*(*int8)(unsafe.Pointer(zVal + uintptr((len + 1)))) = int8(0)
	*(*int8)(unsafe.Pointer(zVal + uintptr((len + 2)))) = int8(0)
	zVal++
	libc.Xmemcpy(tls, zVal, sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv))), uint32(len))
	sqlite3.Xsqlite3_result_text16(tls, pCtx, zVal, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{destructor})))
}

func test_destructor_count(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:145:13: */
	sqlite3.Xsqlite3_result_int(tls, pCtx, test_destructor_count_var)
}

func test_agg_errmsg16_step(tls *libc.TLS, a uintptr, b int32, c uintptr) { /* test_func.c:165:13: */
}

func test_agg_errmsg16_final(tls *libc.TLS, ctx uintptr) { /* test_func.c:167:13: */
	var z uintptr
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, ctx)
	sqlite3.Xsqlite3_aggregate_context(tls, ctx, 2048)
	z = sqlite3.Xsqlite3_errmsg16(tls, db)
	sqlite3.Xsqlite3_result_text16(tls, ctx, z, -1, libc.UintptrFromInt32(-1))
}

// Routines for testing the sqlite3_get_auxdata() and sqlite3_set_auxdata()
// interface.
//
// The test_auxdata() SQL function attempts to register each of its arguments
// as auxiliary data.  If there are no prior registrations of aux data for
// that argument (meaning the argument is not a constant or this is its first
// call) then the result for that argument is 0.  If there is a prior
// registration, the result for that argument is 1.  The overall result
// is the individual argument results separated by spaces.
func free_test_auxdata(tls *libc.TLS, p uintptr) { /* test_func.c:188:13: */
	sqlite3.Xsqlite3_free(tls, p)
}

func test_auxdata(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:189:13: */
	var i int32
	var zRet uintptr = testContextMalloc(tls, pCtx, (nArg * 2))
	if !(zRet != 0) {
		return
	}
	libc.Xmemset(tls, zRet, 0, (uint32(nArg * 2)))
	for i = 0; i < nArg; i++ {
		var z uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
		if z != 0 {
			var n int32
			var zAux uintptr = sqlite3.Xsqlite3_get_auxdata(tls, pCtx, i)
			if zAux != 0 {
				*(*int8)(unsafe.Pointer(zRet + uintptr((i * 2)))) = int8('1')

			} else {
				*(*int8)(unsafe.Pointer(zRet + uintptr((i * 2)))) = int8('0')
			}
			n = (int32(libc.Xstrlen(tls, z)) + 1)
			zAux = testContextMalloc(tls, pCtx, n)
			if zAux != 0 {
				libc.Xmemcpy(tls, zAux, z, uint32(n))
				sqlite3.Xsqlite3_set_auxdata(tls, pCtx, i, zAux, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{free_test_auxdata})))
			}
			*(*int8)(unsafe.Pointer(zRet + uintptr(((i * 2) + 1)))) = int8(' ')
		}
	}
	sqlite3.Xsqlite3_result_text(tls, pCtx, zRet, ((2 * nArg) - 1), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{free_test_auxdata})))
}

// A function to test error reporting from user functions. This function
// returns a copy of its first argument as the error message.  If the
// second argument exists, it becomes the error code.
func test_error(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:226:13: */
	sqlite3.Xsqlite3_result_error(tls, pCtx, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1)
	if nArg == 2 {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	}
}

// Implementation of the counter(X) function.  If X is an integer
// constant, then the first invocation will return X.  The second X+1.
// and so forth.  Can be used (for example) to provide a sequence number
// in a result set.
func counterFunc(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:243:13: */
	var pCounter uintptr = sqlite3.Xsqlite3_get_auxdata(tls, pCtx, 0)
	if pCounter == uintptr(0) {
		pCounter = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(int32(0))))
		if pCounter == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
			return
		}
		*(*int32)(unsafe.Pointer(pCounter)) = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
		sqlite3.Xsqlite3_set_auxdata(tls, pCtx, 0, pCounter, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	} else {
		*(*int32)(unsafe.Pointer(pCounter))++
	}
	sqlite3.Xsqlite3_result_int(tls, pCtx, *(*int32)(unsafe.Pointer(pCounter)))
}

// This function takes two arguments.  It performance UTF-8/16 type
// conversions on the first argument then returns a copy of the second
// argument.
//
// This function is used in cases such as the following:
//
//      SELECT test_isolation(x,x) FROM t1;
//
// We want to verify that the type conversions that occur on the
// first argument do not invalidate the second argument.
func test_isolation(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:276:13: */
	sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_value(tls, pCtx, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
}

// Invoke an SQL statement recursively.  The function result is the
// first column of the first row of the result set.
func test_eval(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:294:13: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var pStmt uintptr at bp+8, 4

	var rc int32
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, pCtx)
	var zSql uintptr

	zSql = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+8 /* &pStmt */, uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
		if rc == SQLITE_ROW {
			sqlite3.Xsqlite3_result_value(tls, pCtx, sqlite3.Xsqlite3_column_value(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 0))
		}
		rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
	}
	if rc != 0 {
		var zErr uintptr

		zErr = sqlite3.Xsqlite3_mprintf(tls, ts+30596 /* "sqlite3_prepare_..." */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
		sqlite3.Xsqlite3_result_text(tls, pCtx, zErr, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
	}
}

// convert one character from hex to binary
func testHexChar(tls *libc.TLS, c int8) int32 { /* test_func.c:326:12: */
	if (int32(c) >= '0') && (int32(c) <= '9') {
		return (int32(c) - '0')
	} else if (int32(c) >= 'a') && (int32(c) <= 'f') {
		return ((int32(c) - 'a') + 10)
	} else if (int32(c) >= 'A') && (int32(c) <= 'F') {
		return ((int32(c) - 'A') + 10)
	}
	return 0
}

// Convert hex to binary.
func testHexToBin(tls *libc.TLS, zIn uintptr, zOut uintptr) { /* test_func.c:340:13: */
	for (*(*int8)(unsafe.Pointer(zIn)) != 0) && (*(*int8)(unsafe.Pointer(zIn + 1)) != 0) {
		*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zOut, 1))) = (int8((testHexChar(tls, *(*int8)(unsafe.Pointer(zIn))) << 4) + testHexChar(tls, *(*int8)(unsafe.Pointer(zIn + 1)))))
		zIn += uintptr(2)
	}
}

//      hex_to_utf16be(HEX)
//
// Convert the input string from HEX into binary.  Then return the
// result using sqlite3_result_text16le().
func testHexToUtf16be(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:354:13: */
	var n int32
	var zIn uintptr
	var zOut uintptr

	n = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zOut = sqlite3.Xsqlite3_malloc(tls, (n / 2))
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		testHexToBin(tls, zIn, zOut)
		sqlite3.Xsqlite3_result_text16be(tls, pCtx, zOut, (n / 2), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

//      hex_to_utf8(HEX)
//
// Convert the input string from HEX into binary.  Then return the
// result using sqlite3_result_text16le().
func testHexToUtf8(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:381:13: */
	var n int32
	var zIn uintptr
	var zOut uintptr

	n = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zOut = sqlite3.Xsqlite3_malloc(tls, (n / 2))
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		testHexToBin(tls, zIn, zOut)
		sqlite3.Xsqlite3_result_text(tls, pCtx, zOut, (n / 2), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

//      hex_to_utf16le(HEX)
//
// Convert the input string from HEX into binary.  Then return the
// result using sqlite3_result_text16le().
func testHexToUtf16le(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:408:13: */
	var n int32
	var zIn uintptr
	var zOut uintptr

	n = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zOut = sqlite3.Xsqlite3_malloc(tls, (n / 2))
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		testHexToBin(tls, zIn, zOut)
		sqlite3.Xsqlite3_result_text16le(tls, pCtx, zOut, (n / 2), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

// SQL function:   real2hex(X)
//
// If argument X is a real number, then convert it into a string which is
// the big-endian hexadecimal representation of the ieee754 encoding of
// that number.  If X is not a real number, return NULL.
func real2hex(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:436:13: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var v struct {Fi sqlite3_uint64;} at bp, 8

	// var zOut [20]int8 at bp+8, 20

	var i int32
	var bigEndian int32
	*(*sqlite3_uint64)(unsafe.Pointer(bp /* &v */)) = uint64(1)
	bigEndian = (libc.Bool32(int32(*(*uint8)(unsafe.Pointer((bp /* &v */ /* &.x */)))) == 0))
	*(*float64)(unsafe.Pointer(bp /* &v */)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
	for i = 0; i < 8; i++ {
		if bigEndian != 0 {
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr((i * 2)))) = *(*int8)(unsafe.Pointer(ts + 30627 /* "0123456789abcdef" */ + uintptr((int32(*(*uint8)(unsafe.Pointer((bp /* &v */ /* &.x */) + uintptr(i)))) >> 4))))
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr(((i * 2) + 1)))) = *(*int8)(unsafe.Pointer(ts + 30627 /* "0123456789abcdef" */ + uintptr((int32(*(*uint8)(unsafe.Pointer((bp /* &v */ /* &.x */) + uintptr(i)))) & 0xf))))
		} else {
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr((14 - (i * 2))))) = *(*int8)(unsafe.Pointer(ts + 30627 /* "0123456789abcdef" */ + uintptr((int32(*(*uint8)(unsafe.Pointer((bp /* &v */ /* &.x */) + uintptr(i)))) >> 4))))
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr(((14 - (i * 2)) + 1)))) = *(*int8)(unsafe.Pointer(ts + 30627 /* "0123456789abcdef" */ + uintptr((int32(*(*uint8)(unsafe.Pointer((bp /* &v */ /* &.x */) + uintptr(i)))) & 0xf))))
		}
	}
	*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + 16)) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp+8 /* &zOut[0] */, -1, libc.UintptrFromInt32(-1))
}

//     test_extract(record, field)
//
// This function implements an SQL user-function that accepts a blob
// containing a formatted database record as the first argument. The
// second argument is the index of the field within that record to
// extract and return.
func test_extract(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:473:13: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var pRec uintptr
	var pEndHdr uintptr // Points to one byte past record header
	var pHdr uintptr    // Current point in record header
	var pBody uintptr   // Current point in record data
	// var nHdr u64 at bp, 8
	// Bytes in record header
	var iIdx int32         // Required field
	var iCurrent int32 = 0 // Current field

	pRec = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	iIdx = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))

	pHdr = (pRec + uintptr(sqlite3.Xsqlite3GetVarint(tls, pRec, bp /* &nHdr */)))
	pBody = libc.AssignUintptr(&pEndHdr, (pRec + uintptr(*(*u64)(unsafe.Pointer(bp /* nHdr */)))))

	for iCurrent = 0; (pHdr < pEndHdr) && (iCurrent <= iIdx); iCurrent++ {
		// var iSerialType u64 at bp+48, 8

		// var mem Mem at bp+8, 40

		libc.Xmemset(tls, bp+8 /* &mem */, 0, uint32(unsafe.Sizeof(Mem{})))
		(*Mem)(unsafe.Pointer(bp + 8 /* &mem */)).Fdb = db
		(*Mem)(unsafe.Pointer(bp + 8 /* &mem */)).Fenc = (*sqlite31)(unsafe.Pointer(db)).Fenc
		pHdr += uintptr(sqlite3.Xsqlite3GetVarint(tls, pHdr, bp+48 /* &iSerialType */))
		pBody += uintptr(sqlite3.Xsqlite3VdbeSerialGet(tls, pBody, u32(*(*u64)(unsafe.Pointer(bp + 48 /* iSerialType */))), bp+8 /* &mem */))

		if iCurrent == iIdx {
			sqlite3.Xsqlite3_result_value(tls, context, bp+8 /* &mem */)
		}

		if (*Mem)(unsafe.Pointer(bp+8 /* &mem */)).FszMalloc != 0 {
			sqlite3.Xsqlite3DbFree(tls, db, (*Mem)(unsafe.Pointer(bp+8 /* &mem */)).FzMalloc)
		}
	}
}

//      test_decode(record)
//
// This function implements an SQL user-function that accepts a blob
// containing a formatted database record as its only argument. It returns
// a tcl list (type SQLITE_TEXT) containing each of the values stored
// in the record.
func test_decode(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:520:13: */
	bp := tls.Alloc(107)
	defer tls.Free(107)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var pRec uintptr
	var pEndHdr uintptr // Points to one byte past record header
	var pHdr uintptr    // Current point in record header
	var pBody uintptr   // Current point in record data
	// var nHdr u64 at bp+32, 8
	// Bytes in record header
	var pRet uintptr // Return value

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++

	pRec = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))

	pHdr = (pRec + uintptr(sqlite3.Xsqlite3GetVarint(tls, pRec, bp+32 /* &nHdr */)))
	pBody = libc.AssignUintptr(&pEndHdr, (pRec + uintptr(*(*u64)(unsafe.Pointer(bp + 32 /* nHdr */)))))
	for pHdr < pEndHdr {
		var pVal uintptr = uintptr(0)
		// var iSerialType u64 at bp+80, 8

		// var mem Mem at bp+40, 40

		libc.Xmemset(tls, bp+40 /* &mem */, 0, uint32(unsafe.Sizeof(Mem{})))
		(*Mem)(unsafe.Pointer(bp + 40 /* &mem */)).Fdb = db
		(*Mem)(unsafe.Pointer(bp + 40 /* &mem */)).Fenc = (*sqlite31)(unsafe.Pointer(db)).Fenc
		pHdr += uintptr(sqlite3.Xsqlite3GetVarint(tls, pHdr, bp+80 /* &iSerialType */))
		pBody += uintptr(sqlite3.Xsqlite3VdbeSerialGet(tls, pBody, u32(*(*u64)(unsafe.Pointer(bp + 80 /* iSerialType */))), bp+40 /* &mem */))

		switch sqlite3.Xsqlite3_value_type(tls, bp+40 /* &mem */) {
		case SQLITE_TEXT:
			pVal = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, bp+40 /* &mem */), -1)
			break

		case SQLITE_BLOB:
			{
				*(*[16]int8)(unsafe.Pointer(bp + 91 /* hexdigit */)) = [16]int8{
					int8('0'), int8('1'), int8('2'), int8('3'), int8('4'), int8('5'), int8('6'), int8('7'),
					int8('8'), int8('9'), int8('a'), int8('b'), int8('c'), int8('d'), int8('e'), int8('f'),
				}
				var n int32 = sqlite3.Xsqlite3_value_bytes(tls, bp+40 /* &mem */)
				var z uintptr = sqlite3.Xsqlite3_value_blob(tls, bp+40 /* &mem */)
				var i int32
				pVal = tcl.XTcl_NewStringObj(tls, ts+30644 /* "x'" */, -1)
				for i = 0; i < n; i++ {
					// var hex [3]int8 at bp+88, 3

					*(*int8)(unsafe.Pointer(bp + 88 /* &hex[0] */)) = *(*int8)(unsafe.Pointer(bp + 91 /* &hexdigit[0] */ + uintptr(((int32(*(*u8)(unsafe.Pointer(z + uintptr(i)))) >> 4) & 0x0F))))
					*(*int8)(unsafe.Pointer(bp + 88 /* &hex[0] */ + 1)) = *(*int8)(unsafe.Pointer(bp + 91 /* &hexdigit[0] */ + uintptr((int32(*(*u8)(unsafe.Pointer(z + uintptr(i)))) & 0x0F))))
					*(*int8)(unsafe.Pointer(bp + 88 /* &hex[0] */ + 2)) = int8(0)
					tcl.XTcl_AppendStringsToObj(tls, pVal, libc.VaList(bp, bp+88 /* &hex[0] */, 0))
				}
				tcl.XTcl_AppendStringsToObj(tls, pVal, libc.VaList(bp+16, ts+5485 /* "'" */, 0))
				break

			}

		case SQLITE_FLOAT:
			pVal = tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_value_double(tls, bp+40 /* &mem */))
			break

		case SQLITE_INTEGER:
			pVal = tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_value_int64(tls, bp+40 /* &mem */))
			break

		case SQLITE_NULL:
			pVal = tcl.XTcl_NewStringObj(tls, ts+5707 /* "NULL" */, -1)
			break

		default:

		}

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, pVal)

		if (*Mem)(unsafe.Pointer(bp+40 /* &mem */)).FszMalloc != 0 {
			sqlite3.Xsqlite3DbFree(tls, db, (*Mem)(unsafe.Pointer(bp+40 /* &mem */)).FzMalloc)
		}
	}

	sqlite3.Xsqlite3_result_text(tls, context, tcl.XTcl_GetString(tls, pRet), -1, libc.UintptrFromInt32(-1))
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pRet
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

//       test_zeroblob(N)
//
// The implementation of scalar SQL function "test_zeroblob()". This is
// similar to the built-in zeroblob() function, except that it does not
// check that the integer parameter is within range before passing it
// to sqlite3_result_zeroblob().
func test_zeroblob(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:612:13: */
	var nZero int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_zeroblob(tls, context, nZero)
}

// test_getsubtype(V)
//
// Return the subtype for value V.
func test_getsubtype(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:625:13: */
	sqlite3.Xsqlite3_result_int(tls, context, int32(sqlite3.Xsqlite3_value_subtype(tls, *(*uintptr)(unsafe.Pointer(argv)))))
}

// test_frombind(A,B,C,...)
//
// Return an integer bitmask that has a bit set for every argument
// (up to the first 63 arguments) that originates from a bind a parameter.
func test_frombind(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:638:13: */
	var m sqlite3_uint64 = uint64(0)
	var i int32
	for i = 0; (i < argc) && (i < 63); i++ {
		if sqlite3.Xsqlite3_value_frombind(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))) != 0 {
			m = m | (sqlite3_uint64((uint64(1))) << i)
		}
	}
	sqlite3.Xsqlite3_result_int64(tls, context, sqlite3_int64(m))
}

// test_setsubtype(V, T)
//
// Return the value V with its subtype changed to T
func test_setsubtype(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:655:13: */
	sqlite3.Xsqlite3_result_value(tls, context, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_subtype(tls, context, uint32(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))))
}

func registerTestFunctions(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pThunk uintptr) int32 { /* test_func.c:664:12: */
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aFuncs)) / uint32(unsafe.Sizeof(struct {
		FzName    uintptr
		FnArg     int8
		_         [3]byte
		FeTextRep uint32
		FxFunc    uintptr
	}{}))); i++ {
		sqlite3.Xsqlite3_create_function(tls, db, aFuncs[i].FzName, int32(aFuncs[i].FnArg),
			int32(aFuncs[i].FeTextRep), uintptr(0), aFuncs[i].FxFunc, uintptr(0), uintptr(0))
	}

	sqlite3.Xsqlite3_create_function(tls, db, ts+30647 /* "test_agg_errmsg1..." */, 0, SQLITE_ANY, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_agg_errmsg16_step})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{test_agg_errmsg16_final})))

	return SQLITE_OK
}

var aFuncs = [20]struct {
	FzName    uintptr
	FnArg     int8
	_         [3]byte
	FeTextRep uint32
	FxFunc    uintptr
}{
	{FzName: ts + 30665 /* "randstr" */, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30673 /* "test_destructor" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30689 /* "test_destructor1..." */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30707 /* "hex_to_utf16be" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30722 /* "hex_to_utf16le" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30737 /* "hex_to_utf8" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30749 /* "test_destructor_..." */, FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30771 /* "test_auxdata" */, FnArg: int8(-1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30784 /* "test_error" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30784 /* "test_error" */, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30795 /* "test_eval" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30805 /* "test_isolation" */, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30820 /* "test_counter" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30833 /* "real2hex" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30842 /* "test_decode" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30854 /* "test_extract" */, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30867 /* "test_zeroblob" */, FnArg: int8(1), FeTextRep: (uint32(SQLITE_UTF8 | SQLITE_DETERMINISTIC)), FxFunc: 0},
	{FzName: ts + 30881 /* "test_getsubtype" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30897 /* "test_setsubtype" */, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 30913 /* "test_frombind" */, FnArg: int8(-1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
} /* test_func.c:674:5 */

// TCLCMD:  autoinstall_test_functions
//
// Invoke this TCL command to use sqlite3_auto_extension() to cause
// the standard set of test functions to be loaded into each new
// database connection.
func autoinstall_test_funcs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_func.c:718:26: */
	var rc int32 = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{registerTestFunctions})))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		}{Md5_Register})))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// A bogus step function and finalizer function.
func tStep(tls *libc.TLS, a uintptr, b int32, c uintptr) { /* test_func.c:736:13: */
}

func tFinal(tls *libc.TLS, a uintptr) { /* test_func.c:737:13: */
}

// tclcmd:  abuse_create_function
//
// Make various calls to sqlite3_create_function that do not have valid
// parameters.  Verify that the error condition is detected and reported.
func abuse_create_function(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_func.c:746:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	// var db uintptr at bp+16, 4

	var rc int32
	var mxArg int32

	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16 /* &db */) != 0) {
		goto __1
	}
	return TCL_ERROR
__1:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+30927 /* "tx" */, 1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tFinal})))
	if !(rc != SQLITE_MISUSE) {
		goto __2
	}
	goto abuse_err
__2:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+30927 /* "tx" */, 1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	goto abuse_err
__3:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+30927 /* "tx" */, 1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tFinal})))
	if !(rc != SQLITE_MISUSE) {
		goto __4
	}
	goto abuse_err
__4:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+30927 /* "tx" */, 1, SQLITE_UTF8, uintptr(0), uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tFinal})))
	if !(rc != SQLITE_MISUSE) {
		goto __5
	}
	goto abuse_err
__5:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+30927 /* "tx" */, 1, SQLITE_UTF8, uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __6
	}
	goto abuse_err
__6:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+30927 /* "tx" */, -2, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __7
	}
	goto abuse_err
__7:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+30927 /* "tx" */, 128, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __8
	}
	goto abuse_err
__8:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)),

		ts+30930, /* "funcxx_123456789..." */
		1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __9
	}
	goto abuse_err
__9:
	;

	// This last function registration should actually work.  Generate
	// a no-op function (that always returns NULL) and which has the
	// maximum-length function name and the maximum number of parameters.
	sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), SQLITE_LIMIT_FUNCTION_ARG, 10000)
	mxArg = sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), SQLITE_LIMIT_FUNCTION_ARG, -1)
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)),

		ts+31187, /* "nullx_123456789_..." */
		mxArg, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __10
	}
	goto abuse_err
__10:
	;

	return TCL_OK

abuse_err:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+31443, /* "sqlite3_create_f..." */
		uintptr(0)))
	return TCL_ERROR
}

// SQLite user defined function to use with matchinfo() to calculate the
// relevancy of an FTS match. The value returned is the relevancy score
// (a real value greater than or equal to zero). A larger value indicates
// a more relevant document.
//
// The overall relevancy returned is the sum of the relevancies of each
// column value in the FTS table. The relevancy of a column value is the
// sum of the following for each reportable phrase in the FTS query:
//
//   (<hit count> / <global hit count>) * <column weight>
//
// where <hit count> is the number of instances of the phrase in the
// column value of the current row and <global hit count> is the number
// of instances of the phrase in the same column of all rows in the FTS
// table. The <column weight> is a weighting factor assigned to each
// column by the caller (see below).
//
// The first argument to this function must be the return value of the FTS
// matchinfo() function. Following this must be one argument for each column
// of the FTS table containing a numeric weight factor for the corresponding
// column. Example:
//
//     CREATE VIRTUAL TABLE documents USING fts3(title, content)
//
// The following query returns the docids of documents that match the full-text
// query <query> sorted from most to least relevant. When calculating
// relevance, query term instances in the 'title' column are given twice the
// weighting of those in the 'content' column.
//
//     SELECT docid FROM documents
//     WHERE documents MATCH <query>
//     ORDER BY rank(matchinfo(documents), 1.0, 0.5) DESC
func rankfunc(tls *libc.TLS, pCtx uintptr, nVal int32, apVal uintptr) { /* test_func.c:847:13: */
	var aMatchinfo uintptr // Return value of matchinfo()
	var nMatchinfo int32   // Number of elements in aMatchinfo[]
	var nCol int32         // Number of columns in the table
	var nPhrase int32      // Number of phrases in the query
	var iPhrase int32      // Current phrase
	var score float64
	var nHitCount int32
	var nGlobalHitCount int32
	var weight float64
	var iCol int32 // Current column

	// Now iterate through each column in the users query. For each column,
	// increment the relevancy score by:
	//
	//   (<hit count> / <global hit count>) * <column weight>
	//
	// aPhraseinfo[] points to the start of the data for phrase iPhrase. So
	// the hit count and global hit counts for each column are found in
	// aPhraseinfo[iCol*3] and aPhraseinfo[iCol*3+1], respectively.
	var aPhraseinfo uintptr
	nCol = 0
	nPhrase = 0
	score = 0.0 // Value to return

	// Check that the number of arguments passed to this function is correct.
	// If not, jump to wrong_number_args. Set aMatchinfo to point to the array
	// of unsigned integer values returned by FTS function matchinfo. Set
	// nPhrase to contain the number of reportable phrases in the users full-text
	// query, and nCol to the number of columns in the table. Then check that the
	// size of the matchinfo blob is as expected. Return an error if it is not.
	if !(nVal < 1) {
		goto __1
	}
	goto wrong_number_args
__1:
	;
	aMatchinfo = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	nMatchinfo = (int32(uint32(sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal)))) / uint32(unsafe.Sizeof(int32(0)))))
	if !(nMatchinfo >= 2) {
		goto __2
	}
	nPhrase = *(*int32)(unsafe.Pointer(aMatchinfo))
	nCol = *(*int32)(unsafe.Pointer(aMatchinfo + 1*4))
__2:
	;
	if !(nMatchinfo != (2 + ((3 * nCol) * nPhrase))) {
		goto __3
	}
	sqlite3.Xsqlite3_result_error(tls, pCtx,
		ts+31486 /* "invalid matchinf..." */, -1)
	return
__3:
	;
	if !(nVal != (1 + nCol)) {
		goto __4
	}
	goto wrong_number_args
__4:
	;

	// Iterate through each phrase in the users query.
	iPhrase = 0
__5:
	if !(iPhrase < nPhrase) {
		goto __7
	} // Current column

	// Now iterate through each column in the users query. For each column,
	// increment the relevancy score by:
	//
	//   (<hit count> / <global hit count>) * <column weight>
	//
	// aPhraseinfo[] points to the start of the data for phrase iPhrase. So
	// the hit count and global hit counts for each column are found in
	// aPhraseinfo[iCol*3] and aPhraseinfo[iCol*3+1], respectively.
	aPhraseinfo = (aMatchinfo + uintptr((2+((iPhrase*nCol)*3)))*4)
	iCol = 0
__8:
	if !(iCol < nCol) {
		goto __10
	}
	nHitCount = *(*int32)(unsafe.Pointer(aPhraseinfo + uintptr((3*iCol))*4))
	nGlobalHitCount = *(*int32)(unsafe.Pointer(aPhraseinfo + uintptr(((3*iCol)+1))*4))
	weight = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr((iCol+1))*4)))
	if !(nHitCount > 0) {
		goto __11
	}
	score = score + ((float64(nHitCount) / float64(nGlobalHitCount)) * weight)
__11:
	;
	goto __9
__9:
	iCol++
	goto __8
	goto __10
__10:
	;
	goto __6
__6:
	iPhrase++
	goto __5
	goto __7
__7:
	;

	sqlite3.Xsqlite3_result_double(tls, pCtx, score)
	return

	// Jump here if the wrong number of arguments are passed to this function
wrong_number_args:
	sqlite3.Xsqlite3_result_error(tls, pCtx, ts+31535 /* "wrong number of ..." */, -1)
}

func install_fts3_rank_function(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_func.c:910:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+31580 /* "rank" */, -1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{rankfunc})), uintptr(0), uintptr(0))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest_func_Init(tls *libc.TLS, interp uintptr) int32 { /* test_func.c:933:5: */
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd7)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd7[i].FzName, aObjCmd7[i].FxProc, uintptr(0), uintptr(0))
	}
	sqlite3.Xsqlite3_initialize(tls)
	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{registerTestFunctions})))
	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{Md5_Register})))
	return TCL_OK
}

var aObjCmd7 = [3]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 31585 /* "autoinstall_test..." */, FxProc: 0},
	{FzName: ts + 31612 /* "abuse_create_fun..." */, FxProc: 0},
	{FzName: ts + 31634 /* "install_fts3_ran..." */, FxProc: 0},
} /* test_func.c:937:5 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set3 = struct{ Ffds_bits [32]int32 } /* select.h:70:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// Convert binary to hex.  The input zBuf[] contains N bytes of
// binary data.  zBuf[] is 2*n+1 bytes long.  Overwrite zBuf[]
// with a hexadecimal representation of its original binary input.
func sqlite3TestBinToHex(tls *libc.TLS, zBuf uintptr, N int32) { /* test_hexio.c:36:6: */
	bp := tls.Alloc(17)
	defer tls.Free(17)

	*(*[17]uint8)(unsafe.Pointer(bp /* zHex */)) = *(*[17]uint8)(unsafe.Pointer(ts + 31661 /* "0123456789ABCDEF" */))
	var i int32
	var j int32
	var c uint8
	i = (N * 2)
	*(*uint8)(unsafe.Pointer(zBuf + uintptr(libc.PostDecInt32(&i, 1)))) = uint8(0)
	for j = (N - 1); j >= 0; j-- {
		c = *(*uint8)(unsafe.Pointer(zBuf + uintptr(j)))
		*(*uint8)(unsafe.Pointer(zBuf + uintptr(libc.PostDecInt32(&i, 1)))) = *(*uint8)(unsafe.Pointer(bp /* &zHex[0] */ + uintptr((int32(c) & 0xf))))
		*(*uint8)(unsafe.Pointer(zBuf + uintptr(libc.PostDecInt32(&i, 1)))) = *(*uint8)(unsafe.Pointer(bp /* &zHex[0] */ + uintptr((int32(c) >> 4))))
	}

}

// Convert hex to binary.  The input zIn[] contains N bytes of
// hexadecimal.  Convert this into binary and write aOut[] with
// the binary data.  Spaces in the original input are ignored.
// Return the number of bytes of binary rendered.
func sqlite3TestHexToBin(tls *libc.TLS, zIn uintptr, N int32, aOut uintptr) int32 { /* test_hexio.c:56:5: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	*(*[256]uint8)(unsafe.Pointer(bp /* aMap */)) = [256]uint8{
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
	}
	var i int32
	var j int32
	var hi int32 = 1
	var c uint8

	for i = libc.AssignInt32(&j, 0); i < N; i++ {
		c = *(*uint8)(unsafe.Pointer(bp /* &aMap[0] */ + uintptr(*(*uint8)(unsafe.Pointer(zIn + uintptr(i))))))
		if int32(c) == 0 {
			continue
		}
		if hi != 0 {
			*(*uint8)(unsafe.Pointer(aOut + uintptr(j))) = (uint8((int32(c) - 1) << 4))
			hi = 0
		} else {
			*(*uint8)(unsafe.Pointer(aOut + uintptr(libc.PostIncInt32(&j, 1)))) |= uint8((int32(c) - 1))
			hi = 1
		}
	}
	return j
}

// Usage:   hexio_read  FILENAME  OFFSET  AMT
//
// Read AMT bytes from file FILENAME beginning at OFFSET from the
// beginning of the file.  Convert that information to hexadecimal
// and return the resulting HEX string.
func hexio_read(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:101:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var offset int32 at bp+40, 4

	// var amt int32 at bp+44, 4

	var got int32
	var zFile uintptr
	var zBuf uintptr
	var in uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31678 /* "FILENAME OFFSET ..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+40 /* &offset */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+44 /* &amt */) != 0 {
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zBuf = sqlite3.Xsqlite3_malloc(tls, ((*(*int32)(unsafe.Pointer(bp + 44 /* amt */)) * 2) + 1))
	if zBuf == uintptr(0) {
		return TCL_ERROR
	}
	in = libc.Xfopen(tls, zFile, ts+4263 /* "rb" */)
	if in == uintptr(0) {
		in = libc.Xfopen(tls, zFile, ts+31698 /* "r" */)
	}
	if in == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+31700 /* "cannot open inpu..." */, zFile, 0))
		return TCL_ERROR
	}
	libc.Xfseek(tls, in, int32(*(*int32)(unsafe.Pointer(bp + 40 /* offset */))), SEEK_SET)
	got = int32(libc.Xfread(tls, zBuf, uint32(1), uint32(*(*int32)(unsafe.Pointer(bp + 44 /* amt */))), in))
	libc.Xfclose(tls, in)
	if got < 0 {
		got = 0
	}
	sqlite3TestBinToHex(tls, zBuf, got)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, zBuf, 0))
	sqlite3.Xsqlite3_free(tls, zBuf)
	return TCL_OK
}

// Usage:   hexio_write  FILENAME  OFFSET  DATA
//
// Write DATA into file FILENAME beginning at OFFSET from the
// beginning of the file.  DATA is expressed in hexadecimal.
func hexio_write(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:151:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var offset int32 at bp+24, 4

	// var nIn int32 at bp+28, 4

	var nOut int32
	var written int32
	var zFile uintptr
	var zIn uintptr
	var aOut uintptr
	var out uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31724 /* "FILENAME OFFSET ..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+24 /* &offset */) != 0 {
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zIn = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+28 /* &nIn */)
	aOut = sqlite3.Xsqlite3_malloc(tls, (1 + (*(*int32)(unsafe.Pointer(bp + 28 /* nIn */)) / 2)))
	if aOut == uintptr(0) {
		return TCL_ERROR
	}
	nOut = sqlite3TestHexToBin(tls, zIn, *(*int32)(unsafe.Pointer(bp + 28 /* nIn */)), aOut)
	out = libc.Xfopen(tls, zFile, ts+31748 /* "r+b" */)
	if out == uintptr(0) {
		out = libc.Xfopen(tls, zFile, ts+31752 /* "r+" */)
	}
	if out == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+31755 /* "cannot open outp..." */, zFile, 0))
		return TCL_ERROR
	}
	libc.Xfseek(tls, out, int32(*(*int32)(unsafe.Pointer(bp + 24 /* offset */))), SEEK_SET)
	written = int32(libc.Xfwrite(tls, aOut, uint32(1), uint32(nOut), out))
	sqlite3.Xsqlite3_free(tls, aOut)
	libc.Xfclose(tls, out)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, written))
	return TCL_OK
}

// USAGE:   hexio_get_int   HEXDATA
//
// Interpret the HEXDATA argument as a big-endian integer.  Return
// the value of that integer.  HEXDATA can contain between 2 and 8
// hexadecimal digits.
func hexio_get_int(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:199:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var val int32
	// var nIn int32 at bp, 4

	var nOut int32
	var zIn uintptr
	var aOut uintptr
	// var aNum [4]uint8 at bp+4, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31780 /* "HEXDATA" */)
		return TCL_ERROR
	}
	zIn = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &nIn */)
	aOut = sqlite3.Xsqlite3_malloc(tls, (1 + (*(*int32)(unsafe.Pointer(bp /* nIn */)) / 2)))
	if aOut == uintptr(0) {
		return TCL_ERROR
	}
	nOut = sqlite3TestHexToBin(tls, zIn, *(*int32)(unsafe.Pointer(bp /* nIn */)), aOut)
	if nOut >= 4 {
		libc.Xmemcpy(tls, bp+4 /* &aNum[0] */, aOut, uint32(4))
	} else {
		libc.Xmemset(tls, bp+4 /* &aNum[0] */, 0, uint32(unsafe.Sizeof([4]uint8{})))
		libc.Xmemcpy(tls, (bp + 4 /* &aNum */ + uintptr((4 - nOut))), aOut, uint32(nOut))
	}
	sqlite3.Xsqlite3_free(tls, aOut)
	val = ((((int32(*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */))) << 24) | (int32(*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 1))) << 16)) | (int32(*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 2))) << 8)) | int32(*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 3))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, val))
	return TCL_OK
}

// USAGE:   hexio_render_int16   INTEGER
//
// Render INTEGER has a 16-bit big-endian integer in hexadecimal.
func hexio_render_int16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:239:26: */
	bp := tls.Alloc(14)
	defer tls.Free(14)

	// var val int32 at bp, 4

	// var aNum [10]uint8 at bp+4, 10

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2274 /* "INTEGER" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &val */) != 0 {
		return TCL_ERROR
	}
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */)) = (uint8(*(*int32)(unsafe.Pointer(bp /* val */)) >> 8))
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 1)) = uint8(*(*int32)(unsafe.Pointer(bp /* val */)))
	sqlite3TestBinToHex(tls, bp+4 /* &aNum[0] */, 2)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+4 /* aNum */, 4))
	return TCL_OK
}

// USAGE:   hexio_render_int32   INTEGER
//
// Render INTEGER has a 32-bit big-endian integer in hexadecimal.
func hexio_render_int32(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:266:26: */
	bp := tls.Alloc(14)
	defer tls.Free(14)

	// var val int32 at bp, 4

	// var aNum [10]uint8 at bp+4, 10

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2274 /* "INTEGER" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &val */) != 0 {
		return TCL_ERROR
	}
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */)) = (uint8(*(*int32)(unsafe.Pointer(bp /* val */)) >> 24))
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 1)) = (uint8(*(*int32)(unsafe.Pointer(bp /* val */)) >> 16))
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 2)) = (uint8(*(*int32)(unsafe.Pointer(bp /* val */)) >> 8))
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 3)) = uint8(*(*int32)(unsafe.Pointer(bp /* val */)))
	sqlite3TestBinToHex(tls, bp+4 /* &aNum[0] */, 4)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+4 /* aNum */, 8))
	return TCL_OK
}

// USAGE:  utf8_to_utf8  HEX
//
// The argument is a UTF8 string represented in hexadecimal.
// The UTF8 might not be well-formed.  Run this string through
// sqlite3Utf8to8() convert it back to hex and return the result.
func utf8_to_utf8(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:296:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	tcl.XTcl_AppendResult(tls, interp,
		libc.VaList(bp, ts+31788 /* "[utf8_to_utf8] u..." */, 0))
	return TCL_ERROR
}

func getFts3Varint(tls *libc.TLS, p uintptr, v uintptr) int32 { /* test_hexio.c:328:12: */
	var q uintptr = p
	var x sqlite_uint64 = uint64(0)
	var y sqlite_uint64 = uint64(1)
	for (int32(*(*uint8)(unsafe.Pointer(q))) & 0x80) == 0x80 {
		x = x + (y * (sqlite_uint64(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1)))) & 0x7f)))
		y <<= 7
	}
	x = x + (y * (sqlite_uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))))))
	*(*sqlite_int64)(unsafe.Pointer(v)) = sqlite_int64(x)
	return ((int32(q) - int32(p)) / 1)
}

func putFts3Varint(tls *libc.TLS, p uintptr, v sqlite_int64) int32 { /* test_hexio.c:340:12: */
	var q uintptr = p
	var vu sqlite_uint64 = sqlite_uint64(v)
	for ok := true; ok; ok = (vu != uint64(0)) {
		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = (uint8((vu & uint64(0x7f)) | uint64(0x80)))
		vu >>= 7
	}
	*(*uint8)(unsafe.Pointer(q + libc.UintptrFromInt32(-1))) &= uint8((0x7f)) // turn off high bit in final byte

	return ((int32(q) - int32(p)) / 1)
}

// USAGE:  read_fts3varint BLOB VARNAME
//
// Read a varint from the start of BLOB. Set variable VARNAME to contain
// the interpreted value. Return the number of bytes of BLOB consumed.
func read_fts3varint(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:358:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var nBlob int32 at bp, 4

	var zBlob uintptr
	// var iVal sqlite3_int64 at bp+8, 8

	var nVal int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31842 /* "BLOB VARNAME" */)
		return TCL_ERROR
	}
	zBlob = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &nBlob */)

	nVal = getFts3Varint(tls, zBlob, bp+8 /* &iVal */)
	tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0), tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* iVal */))), 0)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nVal))
	return TCL_OK
}

// USAGE:  make_fts3record ARGLIST
func make_fts3record(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:384:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	*(*uintptr)(unsafe.Pointer(bp + 4 /* aArg */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp /* nArg */)) = 0
	var aOut uintptr = uintptr(0)
	var nOut int32 = 0
	var nAlloc int32 = 0
	var i int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31855 /* "LIST" */)
		return TCL_ERROR
	}
	if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &nArg */, bp+4 /* &aArg */) != 0 {
		return TCL_ERROR
	}

	for i = 0; i < *(*int32)(unsafe.Pointer(bp /* nArg */)); i++ {
		// var iVal sqlite3_int64 at bp+8, 8

		if TCL_OK == tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4 /* aArg */)) + uintptr(i)*4)), bp+8 /* &iVal */) {
			if (nOut + 10) > nAlloc {
				var nNew int32
				if nAlloc != 0 {
					nNew = (nAlloc * 2)
				} else {
					nNew = 128
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc(tls, aOut, nNew)
				if aNew == uintptr(0) {
					sqlite3.Xsqlite3_free(tls, aOut)
					return TCL_ERROR
				}
				aOut = aNew
				nAlloc = nNew
			}
			nOut = nOut + (putFts3Varint(tls, (aOut + uintptr(nOut)), *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* iVal */))))
		} else {
			*(*int32)(unsafe.Pointer(bp + 16 /* nVal */)) = 0
			var zVal uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4 /* aArg */)) + uintptr(i)*4)), bp+16 /* &nVal */)
			for (nOut + *(*int32)(unsafe.Pointer(bp + 16 /* nVal */))) > nAlloc {
				var nNew int32
				if nAlloc != 0 {
					nNew = (nAlloc * 2)
				} else {
					nNew = 128
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc(tls, aOut, nNew)
				if aNew == uintptr(0) {
					sqlite3.Xsqlite3_free(tls, aOut)
					return TCL_ERROR
				}
				aOut = aNew
				nAlloc = nNew
			}
			libc.Xmemcpy(tls, (aOut + uintptr(nOut)), zVal, uint32(*(*int32)(unsafe.Pointer(bp + 16 /* nVal */))))
			nOut = nOut + (*(*int32)(unsafe.Pointer(bp + 16 /* nVal */)))
		}
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, aOut, nOut))
	sqlite3.Xsqlite3_free(tls, aOut)
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest_hexio_Init(tls *libc.TLS, interp uintptr) int32 { /* test_hexio.c:446:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd8)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd8[i].FzName, aObjCmd8[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aObjCmd8 = [8]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 31860 /* "hexio_read" */, FxProc: 0},
	{FzName: ts + 31871 /* "hexio_write" */, FxProc: 0},
	{FzName: ts + 31883 /* "hexio_get_int" */, FxProc: 0},
	{FzName: ts + 31897 /* "hexio_render_int..." */, FxProc: 0},
	{FzName: ts + 31916 /* "hexio_render_int..." */, FxProc: 0},
	{FzName: ts + 31935 /* "utf8_to_utf8" */, FxProc: 0},
	{FzName: ts + 31948 /* "read_fts3varint" */, FxProc: 0},
	{FzName: ts + 31964 /* "make_fts3record" */, FxProc: 0},
} /* test_hexio.c:450:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Wrapped = struct {
	Fpcache      sqlite3_pcache_methods2
	Fmem         sqlite3_mem_methods
	Fmutex       sqlite3_mutex_methods
	Fmem_init    int32
	Fmem_fail    int32
	Fmutex_init  int32
	Fmutex_fail  int32
	Fpcache_init int32
	Fpcache_fail int32
} /* test_init.c:36:8 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

var wrapped Wrapped /* test_init.c:47:3: */

func wrMemInit(tls *libc.TLS, pAppData uintptr) int32 { /* test_init.c:49:12: */
	var rc int32
	if wrapped.Fmem_fail != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 52 /* &.mem */ + 20 /* &.xInit */))))(tls, wrapped.Fmem.FpAppData)
	}
	if rc == SQLITE_OK {
		wrapped.Fmem_init = 1
	}
	return rc
}

func wrMemShutdown(tls *libc.TLS, pAppData uintptr) { /* test_init.c:61:13: */
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 52 /* &.mem */ + 24 /* &.xShutdown */))))(tls, wrapped.Fmem.FpAppData)
	wrapped.Fmem_init = 0
}

func wrMemMalloc(tls *libc.TLS, n int32) uintptr { /* test_init.c:65:13: */
	return (*(*func(*libc.TLS, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 52 /* &.mem */ /* &.xMalloc */))))(tls, n)
}

func wrMemFree(tls *libc.TLS, p uintptr) { /* test_init.c:66:13: */
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 52 /* &.mem */ + 4 /* &.xFree */))))(tls, p)
}

func wrMemRealloc(tls *libc.TLS, p uintptr, n int32) uintptr { /* test_init.c:67:13: */
	return (*(*func(*libc.TLS, uintptr, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 52 /* &.mem */ + 8 /* &.xRealloc */))))(tls, p, n)
}

func wrMemSize(tls *libc.TLS, p uintptr) int32 { /* test_init.c:68:12: */
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 52 /* &.mem */ + 12 /* &.xSize */))))(tls, p)
}

func wrMemRoundup(tls *libc.TLS, n int32) int32 { /* test_init.c:69:12: */
	return (*(*func(*libc.TLS, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 52 /* &.mem */ + 16 /* &.xRoundup */))))(tls, n)
}

func wrMutexInit(tls *libc.TLS) int32 { /* test_init.c:72:12: */
	var rc int32
	if wrapped.Fmutex_fail != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = (*(*func(*libc.TLS) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 84 /* &.mutex */ /* &.xMutexInit */))))(tls)
	}
	if rc == SQLITE_OK {
		wrapped.Fmutex_init = 1
	}
	return rc
}

func wrMutexEnd(tls *libc.TLS) int32 { /* test_init.c:84:12: */
	(*(*func(*libc.TLS) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 84 /* &.mutex */ + 4 /* &.xMutexEnd */))))(tls)
	wrapped.Fmutex_init = 0
	return SQLITE_OK
}

func wrMutexAlloc(tls *libc.TLS, e int32) uintptr { /* test_init.c:89:22: */
	return (*(*func(*libc.TLS, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 84 /* &.mutex */ + 8 /* &.xMutexAlloc */))))(tls, e)
}

func wrMutexFree(tls *libc.TLS, p uintptr) { /* test_init.c:92:13: */
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 84 /* &.mutex */ + 12 /* &.xMutexFree */))))(tls, p)
}

func wrMutexEnter(tls *libc.TLS, p uintptr) { /* test_init.c:95:13: */
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 84 /* &.mutex */ + 16 /* &.xMutexEnter */))))(tls, p)
}

func wrMutexTry(tls *libc.TLS, p uintptr) int32 { /* test_init.c:98:12: */
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 84 /* &.mutex */ + 20 /* &.xMutexTry */))))(tls, p)
}

func wrMutexLeave(tls *libc.TLS, p uintptr) { /* test_init.c:101:13: */
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 84 /* &.mutex */ + 24 /* &.xMutexLeave */))))(tls, p)
}

func wrMutexHeld(tls *libc.TLS, p uintptr) int32 { /* test_init.c:104:12: */
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 84 /* &.mutex */ + 28 /* &.xMutexHeld */))))(tls, p)
}

func wrMutexNotheld(tls *libc.TLS, p uintptr) int32 { /* test_init.c:107:12: */
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 84 /* &.mutex */ + 32 /* &.xMutexNotheld */))))(tls, p)
}

func wrPCacheInit(tls *libc.TLS, pArg uintptr) int32 { /* test_init.c:113:12: */
	var rc int32
	if wrapped.Fpcache_fail != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 8 /* &.xInit */))))(tls, wrapped.Fpcache.FpArg)
	}
	if rc == SQLITE_OK {
		wrapped.Fpcache_init = 1
	}
	return rc
}

func wrPCacheShutdown(tls *libc.TLS, pArg uintptr) { /* test_init.c:125:13: */
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 12 /* &.xShutdown */))))(tls, wrapped.Fpcache.FpArg)
	wrapped.Fpcache_init = 0
}

func wrPCacheCreate(tls *libc.TLS, a int32, b int32, c int32) uintptr { /* test_init.c:130:23: */
	return (*(*func(*libc.TLS, int32, int32, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 16 /* &.xCreate */))))(tls, a, b, c)
}

func wrPCacheCachesize(tls *libc.TLS, p uintptr, n int32) { /* test_init.c:133:13: */
	(*(*func(*libc.TLS, uintptr, int32))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 20 /* &.xCachesize */))))(tls, p, n)
}

func wrPCachePagecount(tls *libc.TLS, p uintptr) int32 { /* test_init.c:136:12: */
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 24 /* &.xPagecount */))))(tls, p)
}

func wrPCacheFetch(tls *libc.TLS, p uintptr, a uint32, b int32) uintptr { /* test_init.c:139:28: */
	return (*(*func(*libc.TLS, uintptr, uint32, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 28 /* &.xFetch */))))(tls, p, a, b)
}

func wrPCacheUnpin(tls *libc.TLS, p uintptr, a uintptr, b int32) { /* test_init.c:142:13: */
	(*(*func(*libc.TLS, uintptr, uintptr, int32))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 32 /* &.xUnpin */))))(tls, p, a, b)
}

func wrPCacheRekey(tls *libc.TLS, p uintptr, a uintptr, b uint32, c uint32) { /* test_init.c:145:13: */
	(*(*func(*libc.TLS, uintptr, uintptr, uint32, uint32))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 36 /* &.xRekey */))))(tls, p, a, b, c)
}

func wrPCacheTruncate(tls *libc.TLS, p uintptr, a uint32) { /* test_init.c:153:13: */
	(*(*func(*libc.TLS, uintptr, uint32))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 40 /* &.xTruncate */))))(tls, p, a)
}

func wrPCacheDestroy(tls *libc.TLS, p uintptr) { /* test_init.c:156:13: */
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 44 /* &.xDestroy */))))(tls, p)
}

func installInitWrappers(tls *libc.TLS) { /* test_init.c:160:13: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	*(*sqlite3_mutex_methods)(unsafe.Pointer(bp + 48 /* mutexmethods */)) = sqlite3_mutex_methods{
		FxMutexInit: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{wrMutexInit})), FxMutexEnd: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{wrMutexEnd})), FxMutexAlloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32) uintptr
		}{wrMutexAlloc})),
		FxMutexFree: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMutexFree})), FxMutexEnter: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMutexEnter})), FxMutexTry: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMutexTry})),
		FxMutexLeave: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMutexLeave})), FxMutexHeld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMutexHeld})), FxMutexNotheld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMutexNotheld})),
	}
	*(*sqlite3_pcache_methods2)(unsafe.Pointer(bp + 116 /* pcachemethods */)) = sqlite3_pcache_methods2{
		FiVersion: 1,
		FxInit: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrPCacheInit})), FxShutdown: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrPCacheShutdown})), FxCreate: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32, int32, int32) uintptr
		}{wrPCacheCreate})),
		FxCachesize: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32)
		}{wrPCacheCachesize})), FxPagecount: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrPCachePagecount})), FxFetch: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uint32, int32) uintptr
		}{wrPCacheFetch})),
		FxUnpin: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		}{wrPCacheUnpin})), FxRekey: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uint32, uint32)
		}{wrPCacheRekey})), FxTruncate: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uint32)
		}{wrPCacheTruncate})),
		FxDestroy: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrPCacheDestroy})),
	}
	*(*sqlite3_mem_methods)(unsafe.Pointer(bp + 84 /* memmethods */)) = sqlite3_mem_methods{
		FxMalloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32) uintptr
		}{wrMemMalloc})), FxFree: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMemFree})), FxRealloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		}{wrMemRealloc})),
		FxSize: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMemSize})), FxRoundup: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) int32 }{wrMemRoundup})), FxInit: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMemInit})),
		FxShutdown: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMemShutdown})),
	}

	libc.Xmemset(tls, uintptr(unsafe.Pointer(&wrapped)), 0, uint32(unsafe.Sizeof(wrapped)))

	sqlite3.Xsqlite3_shutdown(tls)
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMUTEX, libc.VaList(bp, (uintptr(unsafe.Pointer(&wrapped))+84 /* &.mutex */)))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMALLOC, libc.VaList(bp+8, (uintptr(unsafe.Pointer(&wrapped))+52 /* &.mem */)))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETPCACHE2, libc.VaList(bp+16, (uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */)))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp+24, bp+48 /* &mutexmethods */))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+32, bp+84 /* &memmethods */))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+40, bp+116 /* &pcachemethods */))
}

func init_wrapper_install(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:191:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var i int32
	installInitWrappers(tls)
	for i = 1; i < objc; i++ {
		var z uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)))
		if libc.Xstrcmp(tls, z, ts+31980 /* "mem" */) == 0 {
			wrapped.Fmem_fail = 1
		} else if libc.Xstrcmp(tls, z, ts+28576 /* "mutex" */) == 0 {
			wrapped.Fmutex_fail = 1
		} else if libc.Xstrcmp(tls, z, ts+31984 /* "pcache" */) == 0 {
			wrapped.Fpcache_fail = 1
		} else {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+31991 /* "Unknown argument..." */, z, ts+11634 /* "\"" */))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

func init_wrapper_uninstall(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:215:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_shutdown(tls)
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp, (uintptr(unsafe.Pointer(&wrapped))+84 /* &.mutex */)))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+8, (uintptr(unsafe.Pointer(&wrapped))+52 /* &.mem */)))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+16, (uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */)))
	return TCL_OK
}

func init_wrapper_clear(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:233:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	wrapped.Fmem_fail = 0
	wrapped.Fmutex_fail = 0
	wrapped.Fpcache_fail = 0
	return TCL_OK
}

func init_wrapper_query(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:250:26: */
	var pRet uintptr

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	if wrapped.Fmutex_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+28576 /* "mutex" */, -1))
	}
	if wrapped.Fmem_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+31980 /* "mem" */, -1))
	}
	if wrapped.Fpcache_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+31984 /* "pcache" */, -1))
	}

	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

func Sqlitetest_init_Init(tls *libc.TLS, interp uintptr) int32 { /* test_init.c:278:5: */
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd9)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd9[i].FzName, aObjCmd9[i].FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

var aObjCmd9 = [4]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 32011 /* "init_wrapper_ins..." */, FxProc: 0},
	{FzName: ts + 32032 /* "init_wrapper_que..." */, FxProc: 0},
	{FzName: ts + 32051 /* "init_wrapper_uni..." */, FxProc: 0},
	{FzName: ts + 32074 /* "init_wrapper_cle..." */, FxProc: 0},
} /* test_init.c:282:5 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// Make sure we can call this stuff from C++.

// An sqlite3_intarray is an abstract type to stores an instance of
// an integer array.
type sqlite3_intarray1 = struct {
	Fn     int32
	Fa     uintptr
	FxFree uintptr
} /* test_intarray.h:99:9 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// Make sure we can call this stuff from C++.

// An sqlite3_intarray is an abstract type to stores an instance of
// an integer array.
type sqlite3_intarray = sqlite3_intarray1 /* test_intarray.h:99:33 */

// Objects used internally by the virtual table implementation
type intarray_vtab1 = struct {
	Fbase     sqlite3_vtab
	FpContent uintptr
} /* test_intarray.c:41:9 */

// Objects used internally by the virtual table implementation
type intarray_vtab = intarray_vtab1 /* test_intarray.c:41:30 */
type intarray_cursor1 = struct {
	Fbase sqlite3_vtab_cursor
	Fi    int32
} /* test_intarray.c:42:9 */

type intarray_cursor = intarray_cursor1 /* test_intarray.c:42:32 */

// None of this works unless we have virtual tables.

// Free an sqlite3_intarray object.
func intarrayFree(tls *libc.TLS, p uintptr) { /* test_intarray.c:64:13: */
	if (*sqlite3_intarray)(unsafe.Pointer(p)).FxFree != 0 {
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((p + 8 /* &.xFree */))))(tls, (*sqlite3_intarray)(unsafe.Pointer(p)).Fa)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

// Table destructor for the intarray module.
func intarrayDestroy(tls *libc.TLS, p uintptr) int32 { /* test_intarray.c:74:12: */
	var pVtab uintptr = p
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// Table constructor for the intarray module.
func intarrayCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_intarray.c:83:12: */
	var rc int32 = SQLITE_NOMEM
	var pVtab uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(intarray_vtab{})))

	if pVtab != 0 {
		libc.Xmemset(tls, pVtab, 0, uint32(unsafe.Sizeof(intarray_vtab{})))
		(*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent = pAux
		rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+32093 /* "CREATE TABLE x(v..." */)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	return rc
}

// Open a new cursor on the intarray table.
func intarrayOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_intarray.c:106:12: */
	var rc int32 = SQLITE_NOMEM
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(intarray_cursor{})))
	if pCur != 0 {
		libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(intarray_cursor{})))
		*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
		rc = SQLITE_OK
	}
	return rc
}

// Close a intarray table cursor.
func intarrayClose(tls *libc.TLS, cur uintptr) int32 { /* test_intarray.c:121:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Retrieve a column of data.
func intarrayColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_intarray.c:130:12: */
	var pCur uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	if ((*intarray_cursor)(unsafe.Pointer(pCur)).Fi >= 0) && ((*intarray_cursor)(unsafe.Pointer(pCur)).Fi < (*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fn) {
		sqlite3.Xsqlite3_result_int64(tls, ctx, *(*sqlite3_int64)(unsafe.Pointer((*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fa + uintptr((*intarray_cursor)(unsafe.Pointer(pCur)).Fi)*8)))
	}
	return SQLITE_OK
}

// Retrieve the current rowid.
func intarrayRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_intarray.c:142:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite_int64((*intarray_cursor)(unsafe.Pointer(pCur)).Fi)
	return SQLITE_OK
}

func intarrayEof(tls *libc.TLS, cur uintptr) int32 { /* test_intarray.c:148:12: */
	var pCur uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	return (libc.Bool32((*intarray_cursor)(unsafe.Pointer(pCur)).Fi >= (*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fn))
}

// Advance the cursor to the next row.
func intarrayNext(tls *libc.TLS, cur uintptr) int32 { /* test_intarray.c:157:12: */
	var pCur uintptr = cur
	(*intarray_cursor)(unsafe.Pointer(pCur)).Fi++
	return SQLITE_OK
}

// Reset a intarray table cursor.
func intarrayFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_intarray.c:166:12: */
	var pCur uintptr = pVtabCursor
	(*intarray_cursor)(unsafe.Pointer(pCur)).Fi = 0
	return SQLITE_OK
}

// Analyse the WHERE condition.
func intarrayBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_intarray.c:179:12: */
	return SQLITE_OK
}

// A virtual table module that merely echos method calls into TCL
// variables.
var intarrayModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate - create a new virtual table
	FxConnect:    0, // xConnect - connect to an existing vtab
	FxBestIndex:  0, // xBestIndex - find the best query index
	FxDisconnect: 0, // xDisconnect - disconnect a vtab
	FxDestroy:    0, // xDestroy - destroy a vtab
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_intarray.c:187:23 */

// Invoke this routine to create a specific instance of an intarray object.
// The new intarray object is returned by the 3rd parameter.
//
// Each intarray object corresponds to a virtual table in the TEMP table
// with a name of zName.
//
// Destroy the intarray object by dropping the virtual table.  If not done
// explicitly by the application, the virtual table will be dropped implicitly
// by the system when the database connection is closed.
func sqlite3_intarray_create(tls *libc.TLS, db uintptr, zName uintptr, ppReturn uintptr) int32 { /* test_intarray.c:223:16: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = SQLITE_OK
	var p uintptr

	*(*uintptr)(unsafe.Pointer(ppReturn)) = libc.AssignUintptr(&p, sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(sqlite3_intarray{}))))
	if p == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(sqlite3_intarray{})))
	rc = sqlite3.Xsqlite3_create_module_v2(tls, db, zName, uintptr(unsafe.Pointer(&intarrayModule)), p,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{intarrayFree})))
	if rc == SQLITE_OK {
		var zSql uintptr
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+32135, /* "CREATE VIRTUAL T..." */
			libc.VaList(bp, zName, zName))
		rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	return rc
}

// Bind a new array array of integers to a specific intarray object.
//
// The array of integers bound must be unchanged for the duration of
// any query against the corresponding virtual table.  If the integer
// array does change or is deallocated undefined behavior will result.
func sqlite3_intarray_bind(tls *libc.TLS, pIntArray uintptr, nElements int32, aElements uintptr, xFree uintptr) int32 { /* test_intarray.c:257:16: */
	if (*sqlite3_intarray)(unsafe.Pointer(pIntArray)).FxFree != 0 {
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((pIntArray + 8 /* &.xFree */))))(tls, (*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fa)
	}
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fn = nElements
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fa = aElements
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).FxFree = xFree
	return SQLITE_OK
}

//    sqlite3_intarray_create  DB  NAME
//
// Invoke the sqlite3_intarray_create interface.  A string that becomes
// the first parameter to sqlite3_intarray_bind.
func test_intarray_create(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_intarray.c:300:26: */
	bp := tls.Alloc(140)
	defer tls.Free(140)

	// var db uintptr at bp+32, 4

	var zName uintptr
	// var pArray uintptr at bp+36, 4

	var rc int32 = SQLITE_OK
	// var zPtr [100]int8 at bp+40, 100

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	rc = sqlite3_intarray_create(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), zName, bp+36 /* &pArray */)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return TCL_ERROR
	}
	sqlite3TestMakePointerStr(tls, interp, bp+40 /* &zPtr[0] */, *(*uintptr)(unsafe.Pointer(bp + 36 /* pArray */)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, bp+40 /* &zPtr[0] */, uintptr(0)))
	return TCL_OK
}

//    sqlite3_intarray_bind  INTARRAY  ?VALUE ...?
//
// Invoke the sqlite3_intarray_bind interface on the given array of integers.
func test_intarray_bind(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_intarray.c:335:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var pArray uintptr
	var rc int32 = SQLITE_OK
	var i int32
	var n int32
	var a uintptr

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32173 /* "INTARRAY" */)
		return TCL_ERROR
	}
	pArray = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	n = (objc - 2)
	a = sqlite3.Xsqlite3_malloc64(tls, (uint64(uint32(unsafe.Sizeof(sqlite3_int64(0))) * uint32(n))))
	if a == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32182 /* "SQLITE_NOMEM" */, uintptr(0)))
		return TCL_ERROR
	}
	for i = 0; i < n; i++ {
		*(*Tcl_WideInt)(unsafe.Pointer(bp + 32 /* x */)) = int64(0)
		tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + uintptr((i+2))*4)), bp+32 /* &x */)
		*(*sqlite3_int64)(unsafe.Pointer(a + uintptr(i)*8)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 32 /* x */))
	}
	rc = sqlite3_intarray_bind(tls, pArray, n, a, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetestintarray_Init(tls *libc.TLS, interp uintptr) int32 { /* test_intarray.c:375:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd10)) / uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd10[i].FzName,
			aObjCmd10[i].FxProc, aObjCmd10[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd10 = [2]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 32195 /* "sqlite3_intarray..." */, FxProc: 0},
	{FzName: ts + 32219 /* "sqlite3_intarray..." */, FxProc: 0},
} /* test_intarray.c:380:5 */

// Maximum pathname length supported by the jt backend.

// Name used to identify this VFS.

type jt_file1 = struct {
	Fbase      sqlite3_file
	FzName     uintptr
	Fflags     int32
	FeLock     int32
	FnPage     u32
	FnPagesize u32
	FpWritable uintptr
	FaCksum    uintptr
	FnSync     int32
	_          [4]byte
	FiMaxOff   sqlite3_int64
	FpNext     uintptr
	FpReal     uintptr
} /* test_journal.c:111:9 */

// Maximum pathname length supported by the jt backend.

// Name used to identify this VFS.

type jt_file = jt_file1 /* test_journal.c:111:24 */

var jt_vfs = sqlite3_vfs{
	FiVersion:          2,                               // iVersion
	FszOsFile:          int32(unsafe.Sizeof(jt_file{})), // szOsFile
	FmxPathname:        JT_MAX_PATHNAME,                 // pNext
	FzName:             ts + 32241,                      /* "jt" */ // pAppData
	FxOpen:             0,                               // xOpen
	FxDelete:           0,                               // xDelete
	FxAccess:           0,                               // xAccess
	FxFullPathname:     0,                               // xFullPathname
	FxDlOpen:           0,                               // xDlOpen
	FxDlError:          0,                               // xDlError
	FxDlSym:            0,                               // xDlSym
	FxDlClose:          0,                               // xDlClose
	FxRandomness:       0,                               // xRandomness
	FxSleep:            0,                               // xSleep
	FxCurrentTime:      0,                               // xCurrentTime
	FxGetLastError:     0,                               // xGetLastError
	FxCurrentTimeInt64: 0,                               // xCurrentTimeInt64
} /* test_journal.c:165:20 */

var jt_io_methods = sqlite3_io_methods{
	FiVersion:               1, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
} /* test_journal.c:187:27 */

type JtGlobal = struct {
	FpVfs  uintptr
	FpList uintptr
} /* test_journal.c:203:1 */

var g2 = JtGlobal{} /* test_journal.c:207:24 */

// Functions to obtain and relinquish a mutex to protect g.pList. The
// STATIC_PRNG mutex is reused, purely for the sake of convenience.
func enterJtMutex(tls *libc.TLS) { /* test_journal.c:213:13: */
	sqlite3.Xsqlite3_mutex_enter(tls, sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_STATIC_PRNG))
}

func leaveJtMutex(tls *libc.TLS) { /* test_journal.c:216:13: */
	sqlite3.Xsqlite3_mutex_leave(tls, sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_STATIC_PRNG))
}

func stop_ioerr_simulation(tls *libc.TLS, piSave uintptr, piSave2 uintptr) { /* test_journal.c:222:13: */
	*(*int32)(unsafe.Pointer(piSave)) = libc.AtomicLoadInt32(&sqlite3.Xsqlite3_io_error_pending)
	*(*int32)(unsafe.Pointer(piSave2)) = sqlite3.Xsqlite3_io_error_hit
	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, int32(-1))
	sqlite3.Xsqlite3_io_error_hit = 0
}

func start_ioerr_simulation(tls *libc.TLS, iSave int32, iSave2 int32) { /* test_journal.c:228:13: */
	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, int32(iSave))
	sqlite3.Xsqlite3_io_error_hit = iSave2
}

// The jt_file pointed to by the argument may or may not be a file-handle
// open on a main database file. If it is, and a transaction is currently
// opened on the file, then discard all transaction related data.
func closeTransaction(tls *libc.TLS, p uintptr) { /* test_journal.c:238:13: */
	sqlite3.Xsqlite3BitvecDestroy(tls, (*jt_file)(unsafe.Pointer(p)).FpWritable)
	sqlite3.Xsqlite3_free(tls, (*jt_file)(unsafe.Pointer(p)).FaCksum)
	(*jt_file)(unsafe.Pointer(p)).FpWritable = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FaCksum = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FnSync = 0
}

// Close an jt-file.
func jtClose(tls *libc.TLS, pFile uintptr) int32 { /* test_journal.c:249:12: */
	var pp uintptr
	var p uintptr = pFile

	closeTransaction(tls, p)
	enterJtMutex(tls)
	if (*jt_file)(unsafe.Pointer(p)).FzName != 0 {
		for pp = (uintptr(unsafe.Pointer(&g2)) + 4 /* &.pList */); *(*uintptr)(unsafe.Pointer(pp)) != p; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 48 /* &.pNext */) {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = (*jt_file)(unsafe.Pointer(p)).FpNext
	}
	leaveJtMutex(tls)
	sqlite3.Xsqlite3OsClose(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
	return SQLITE_OK
}

// Read data from an jt-file.
func jtRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_journal.c:267:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsRead(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

//
// Parameter zJournal is the name of a journal file that is currently
// open. This function locates and returns the handle opened on the
// corresponding database file by the pager that currently has the
// journal file opened. This file-handle is identified by the
// following properties:
//
//   a) SQLITE_OPEN_MAIN_DB was specified when the file was opened.
//
//   b) The file-name specified when the file was opened matches
//      all but the final 8 characters of the journal file name.
//
//   c) There is currently a reserved lock on the file. This
//      condition is waived if the noLock argument is non-zero.
//
func locateDatabaseHandle(tls *libc.TLS, zJournal uintptr, noLock int32) uintptr { /* test_journal.c:292:16: */
	var pMain uintptr = uintptr(0)
	enterJtMutex(tls)
	for pMain = g2.FpList; pMain != 0; pMain = (*jt_file)(unsafe.Pointer(pMain)).FpNext {
		var nName int32 = (int32(libc.Xstrlen(tls, zJournal) - libc.Xstrlen(tls, ts+32244 /* "-journal" */)))
		if (((((*jt_file)(unsafe.Pointer(pMain)).Fflags & SQLITE_OPEN_MAIN_DB) != 0) &&
			(int32(libc.Xstrlen(tls, (*jt_file)(unsafe.Pointer(pMain)).FzName)) == nName)) &&
			(0 == libc.Xmemcmp(tls, (*jt_file)(unsafe.Pointer(pMain)).FzName, zJournal, uint32(nName)))) &&
			(((*jt_file)(unsafe.Pointer(pMain)).FeLock >= SQLITE_LOCK_RESERVED) || (noLock != 0)) {
			break
		}
	}
	leaveJtMutex(tls)
	return pMain
}

// Parameter z points to a buffer of 4 bytes in size containing a
// unsigned 32-bit integer stored in big-endian format. Decode the
// integer and return its value.
func decodeUint32(tls *libc.TLS, z uintptr) u32 { /* test_journal.c:314:12: */
	return (u32((((int32(*(*uint8)(unsafe.Pointer(z))) << 24) + (int32(*(*uint8)(unsafe.Pointer(z + 1))) << 16)) + (int32(*(*uint8)(unsafe.Pointer(z + 2))) << 8)) + int32(*(*uint8)(unsafe.Pointer(z + 3)))))
}

// Calculate a checksum from the buffer of length n bytes pointed to
// by parameter z.
func genCksum(tls *libc.TLS, z uintptr, n int32) u32 { /* test_journal.c:322:12: */
	var i int32
	var cksum u32 = u32(0)
	for i = 0; i < n; i++ {
		cksum = ((cksum + u32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) + (cksum << 3))
	}
	return cksum
}

// The first argument, zBuf, points to a buffer containing a 28 byte
// serialized journal header. This function deserializes four of the
// integer fields contained in the journal header and writes their
// values to the output variables.
//
// SQLITE_OK is returned if the journal-header is successfully
// decoded. Otherwise, SQLITE_ERROR.
func decodeJournalHdr(tls *libc.TLS, zBuf uintptr, pnRec uintptr, pnPage uintptr, pnSector uintptr, pnPagesize uintptr) int32 { /* test_journal.c:340:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*[8]uint8)(unsafe.Pointer(bp /* aMagic */)) = [8]uint8{uint8(0xd9), uint8(0xd5), uint8(0x05), uint8(0xf9), uint8(0x20), uint8(0xa1), uint8(0x63), uint8(0xd7)}
	if libc.Xmemcmp(tls, bp /* &aMagic[0] */, zBuf, uint32(8)) != 0 {
		return SQLITE_ERROR
	}
	if pnRec != 0 {
		*(*u32)(unsafe.Pointer(pnRec)) = decodeUint32(tls, (zBuf + 8))
	}
	if pnPage != 0 {
		*(*u32)(unsafe.Pointer(pnPage)) = decodeUint32(tls, (zBuf + 16))
	}
	if pnSector != 0 {
		*(*u32)(unsafe.Pointer(pnSector)) = decodeUint32(tls, (zBuf + 20))
	}
	if pnPagesize != 0 {
		*(*u32)(unsafe.Pointer(pnPagesize)) = decodeUint32(tls, (zBuf + 24))
	}
	return SQLITE_OK
}

// This function is called when a new transaction is opened, just after
// the first journal-header is written to the journal file.
func openTransaction(tls *libc.TLS, pMain uintptr, pJournal uintptr) int32 { /* test_journal.c:360:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var aData uintptr
	var p uintptr = (*jt_file)(unsafe.Pointer(pMain)).FpReal
	var rc int32 = SQLITE_OK

	closeTransaction(tls, pMain)
	aData = sqlite3.Xsqlite3_malloc(tls, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
	(*jt_file)(unsafe.Pointer(pMain)).FpWritable = sqlite3.Xsqlite3BitvecCreate(tls, (*jt_file)(unsafe.Pointer(pMain)).FnPage)
	(*jt_file)(unsafe.Pointer(pMain)).FaCksum = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(u32(0))) * ((*jt_file)(unsafe.Pointer(pMain)).FnPage + u32(1)))))
	(*jt_file)(unsafe.Pointer(pJournal)).FiMaxOff = int64(0)

	if (!(int32((*jt_file)(unsafe.Pointer(pMain)).FpWritable) != 0) || !(int32((*jt_file)(unsafe.Pointer(pMain)).FaCksum) != 0)) || !(aData != 0) {
		rc = (SQLITE_IOERR | (int32(12) << 8))
	} else if (*jt_file)(unsafe.Pointer(pMain)).FnPage > u32(0) {
		var iTrunk u32
		// var iSave int32 at bp, 4

		// var iSave2 int32 at bp+4, 4

		stop_ioerr_simulation(tls, bp /* &iSave */, bp+4 /* &iSave2 */)

		// Read the database free-list. Add the page-number for each free-list
		// leaf to the jt_file.pWritable bitvec.
		rc = sqlite3.Xsqlite3OsRead(tls, p, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), int64(0))
		if rc == SQLITE_OK {
			var nDbsize u32 = decodeUint32(tls, (aData + 28))
			if (nDbsize > u32(0)) && (libc.Xmemcmp(tls, (aData+24), (aData+92), uint32(4)) == 0) {
				var iPg u32
				for iPg = (nDbsize + u32(1)); iPg <= (*jt_file)(unsafe.Pointer(pMain)).FnPage; iPg++ {
					sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, iPg)
				}
			}
		}
		iTrunk = decodeUint32(tls, (aData + 32))
		for (rc == SQLITE_OK) && (iTrunk > u32(0)) {
			var nLeaf u32
			var iLeaf u32
			var iOff sqlite3_int64 = ((i64(iTrunk - u32(1))) * i64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
			rc = sqlite3.Xsqlite3OsRead(tls, p, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), iOff)
			nLeaf = decodeUint32(tls, (aData + 4))
			for iLeaf = u32(0); (rc == SQLITE_OK) && (iLeaf < nLeaf); iLeaf++ {
				var pgno u32 = decodeUint32(tls, (aData + uintptr((u32(8) + (u32(4) * iLeaf)))))
				sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)
			}
			iTrunk = decodeUint32(tls, aData)
		}

		// Calculate and store a checksum for each page in the database file.
		if rc == SQLITE_OK {
			var ii int32
			for ii = 0; (rc == SQLITE_OK) && (ii < int32((*jt_file)(unsafe.Pointer(pMain)).FnPage)); ii++ {
				var iOff i64 = ((i64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize)) * i64(ii))
				if iOff == i64(sqlite3.Xsqlite3PendingByte) {
					continue
				}
				rc = sqlite3.Xsqlite3OsRead(tls, (*jt_file)(unsafe.Pointer(pMain)).FpReal, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), iOff)
				*(*u32)(unsafe.Pointer((*jt_file)(unsafe.Pointer(pMain)).FaCksum + uintptr(ii)*4)) = genCksum(tls, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
				if ((ii + 1) == int32((*jt_file)(unsafe.Pointer(pMain)).FnPage)) && (rc == (SQLITE_IOERR | (int32(2) << 8))) {
					rc = SQLITE_OK
				}
			}
		}

		start_ioerr_simulation(tls, *(*int32)(unsafe.Pointer(bp /* iSave */)), *(*int32)(unsafe.Pointer(bp + 4 /* iSave2 */)))
	}

	sqlite3.Xsqlite3_free(tls, aData)
	return rc
}

// The first argument to this function is a handle open on a journal file.
// This function reads the journal file and adds the page number for each
// page in the journal to the Bitvec object passed as the second argument.
func readJournalFile(tls *libc.TLS, p uintptr, pMain uintptr) int32 { /* test_journal.c:433:12: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	var rc int32
	// var zBuf [28]uint8 at bp+8, 28

	var pReal uintptr
	var iOff sqlite3_int64
	var iSize sqlite3_int64
	var aPage uintptr
	// var iSave int32 at bp, 4

	// var iSave2 int32 at bp+4, 4

	var cksum u32
	_ = cksum
	var pgno u32
	// var nRec u32 at bp+36, 4

	// var nPage u32 at bp+40, 4

	// var nSector u32 at bp+44, 4

	// var nPagesize u32 at bp+48, 4

	var ii u32
	rc = SQLITE_OK
	pReal = (*jt_file)(unsafe.Pointer(p)).FpReal
	iOff = int64(0)
	iSize = (*jt_file)(unsafe.Pointer(p)).FiMaxOff

	aPage = sqlite3.Xsqlite3_malloc(tls, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
	if !(!(aPage != 0)) {
		goto __1
	}
	return (SQLITE_IOERR | (int32(12) << 8))
__1:
	;

	stop_ioerr_simulation(tls, bp /* &iSave */, bp+4 /* &iSave2 */)

__2:
	if !((rc == SQLITE_OK) && (iOff < iSize)) {
		goto __3
	}

	// Read and decode the next journal-header from the journal file.
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8 /* &zBuf[0] */, 28, iOff)
	if !((rc != SQLITE_OK) ||
		(decodeJournalHdr(tls, bp+8 /* &zBuf[0] */, bp+36 /* &nRec */, bp+40 /* &nPage */, bp+44 /* &nSector */, bp+48 /* &nPagesize */) != 0)) {
		goto __4
	}
	goto finish_rjf
__4:
	;
	iOff = iOff + (sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44 /* nSector */))))

	if !(*(*u32)(unsafe.Pointer(bp + 36 /* nRec */)) == u32(0)) {
		goto __5
	}
	// A trick. There might be another journal-header immediately
	// following this one. In this case, 0 records means 0 records,
	// not "read until the end of the file". See also ticket #2565.
	if !(iSize >= (iOff + sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44 /* nSector */))))) {
		goto __6
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8 /* &zBuf[0] */, 28, iOff)
	if !((rc != SQLITE_OK) || (0 == decodeJournalHdr(tls, bp+8 /* &zBuf[0] */, uintptr(0), uintptr(0), uintptr(0), uintptr(0)))) {
		goto __7
	}
	goto __2
__7:
	;
__6:
	;
	*(*u32)(unsafe.Pointer(bp + 36 /* nRec */)) = (u32((iSize - iOff) / (sqlite3_int64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize + u32(8)))))
__5:
	;

	// Read all the records that follow the journal-header just read.
	ii = u32(0)
__8:
	if !(((rc == SQLITE_OK) && (ii < *(*u32)(unsafe.Pointer(bp + 36 /* nRec */)))) && (iOff < iSize)) {
		goto __10
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8 /* &zBuf[0] */, 4, iOff)
	if !(rc == SQLITE_OK) {
		goto __11
	}
	pgno = decodeUint32(tls, bp+8 /* &zBuf[0] */)
	if !((pgno > u32(0)) && (pgno <= (*jt_file)(unsafe.Pointer(pMain)).FnPage)) {
		goto __12
	}
	if !(0 == sqlite3.Xsqlite3BitvecTest(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)) {
		goto __13
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, aPage, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), (iOff + int64(4)))
	if !(rc == SQLITE_OK) {
		goto __14
	}
	cksum = genCksum(tls, aPage, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))

__14:
	;
__13:
	;
	sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)
__12:
	;
	iOff = iOff + (sqlite3_int64(u32(8) + (*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
__11:
	;
	goto __9
__9:
	ii++
	goto __8
	goto __10
__10:
	;

	iOff = (((iOff + (sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44 /* nSector */)) - u32(1)))) / sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44 /* nSector */)))) * sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44 /* nSector */))))
	goto __2
__3:
	;

finish_rjf:
	start_ioerr_simulation(tls, *(*int32)(unsafe.Pointer(bp /* iSave */)), *(*int32)(unsafe.Pointer(bp + 4 /* iSave2 */)))
	sqlite3.Xsqlite3_free(tls, aPage)
	if !(rc == (SQLITE_IOERR | (int32(2) << 8))) {
		goto __15
	}
	rc = SQLITE_OK
__15:
	;
	return rc
}

// Write data to an jt-file.
func jtWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_journal.c:512:12: */
	var rc int32
	var p uintptr = pFile
	if ((*jt_file)(unsafe.Pointer(p)).Fflags & SQLITE_OPEN_MAIN_JOURNAL) != 0 {
		if iOfst == int64(0) {
			var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)

			if iAmt == 28 {
				// Zeroing the first journal-file header. This is the end of a
				// transaction.
				closeTransaction(tls, pMain)
			} else if iAmt != 12 {
				// Writing the first journal header to a journal file. This happens
				// when a transaction is first started.
				var z uintptr = zBuf
				(*jt_file)(unsafe.Pointer(pMain)).FnPage = decodeUint32(tls, (z + 16))
				(*jt_file)(unsafe.Pointer(pMain)).FnPagesize = decodeUint32(tls, (z + 24))
				if SQLITE_OK != (libc.AssignInt32(&rc, openTransaction(tls, pMain, p))) {
					return rc
				}
			}
		}
		if (*jt_file)(unsafe.Pointer(p)).FiMaxOff < (iOfst + sqlite_int64(iAmt)) {
			(*jt_file)(unsafe.Pointer(p)).FiMaxOff = (iOfst + sqlite_int64(iAmt))
		}
	}

	if (((*jt_file)(unsafe.Pointer(p)).Fflags & SQLITE_OPEN_MAIN_DB) != 0) && ((*jt_file)(unsafe.Pointer(p)).FpWritable != 0) {
		if (((iAmt < int32((*jt_file)(unsafe.Pointer(p)).FnPagesize)) &&
			(((*jt_file)(unsafe.Pointer(p)).FnPagesize % u32(iAmt)) == u32(0))) &&
			(iOfst >= (sqlite_int64(sqlite3.Xsqlite3PendingByte + 512)))) &&
			((iOfst + sqlite_int64(iAmt)) <= (sqlite_int64(u32(sqlite3.Xsqlite3PendingByte) + (*jt_file)(unsafe.Pointer(p)).FnPagesize))) {
			// No-op. This special case is hit when the backup code is copying a
			// to a database with a larger page-size than the source database and
			// it needs to fill in the non-locking-region part of the original
			// pending-byte page.
		} else {
			var pgno u32 = (u32((iOfst / sqlite_int64((*jt_file)(unsafe.Pointer(p)).FnPagesize)) + int64(1)))
			_ = pgno

			// The following assert() statements may fail if this layer is used
			// with a connection in "PRAGMA synchronous=off" mode. If they
			// fail with sync=normal or sync=full, this may indicate problem.

		}
	}

	rc = sqlite3.Xsqlite3OsWrite(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
	if (((*jt_file)(unsafe.Pointer(p)).Fflags & SQLITE_OPEN_MAIN_JOURNAL) != 0) && (iAmt == 12) {
		var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)
		var rc2 int32 = readJournalFile(tls, p, pMain)
		if rc == SQLITE_OK {
			rc = rc2
		}
	}
	return rc
}

// Truncate an jt-file.
func jtTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_journal.c:580:12: */
	var p uintptr = pFile
	if (((*jt_file)(unsafe.Pointer(p)).Fflags & SQLITE_OPEN_MAIN_JOURNAL) != 0) && (size == int64(0)) {
		// Truncating a journal file. This is the end of a transaction.
		var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)
		closeTransaction(tls, pMain)
	}
	if (((*jt_file)(unsafe.Pointer(p)).Fflags & SQLITE_OPEN_MAIN_DB) != 0) && ((*jt_file)(unsafe.Pointer(p)).FpWritable != 0) {
		var pgno u32
		var locking_page u32 = ((u32(sqlite3.Xsqlite3PendingByte) / (*jt_file)(unsafe.Pointer(p)).FnPagesize) + u32(1))
		_ = locking_page
		for pgno = (u32((size / sqlite_int64((*jt_file)(unsafe.Pointer(p)).FnPagesize)) + int64(1))); pgno <= (*jt_file)(unsafe.Pointer(p)).FnPage; pgno++ {

		}
	}
	return sqlite3.Xsqlite3OsTruncate(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, size)
}

// Sync an jt-file.
func jtSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_journal.c:600:12: */
	var p uintptr = pFile

	if ((*jt_file)(unsafe.Pointer(p)).Fflags & SQLITE_OPEN_MAIN_JOURNAL) != 0 {
		var rc int32
		var pMain uintptr // The associated database file

		// The journal file is being synced. At this point, we inspect the
		// contents of the file up to this point and set each bit in the
		// jt_file.pWritable bitvec of the main database file associated with
		// this journal file.
		pMain = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)

		// Set the bitvec values
		if (pMain != 0) && ((*jt_file)(unsafe.Pointer(pMain)).FpWritable != 0) {
			(*jt_file)(unsafe.Pointer(pMain)).FnSync++
			rc = readJournalFile(tls, p, pMain)
			if rc != SQLITE_OK {
				return rc
			}
		}
	}

	return sqlite3.Xsqlite3OsSync(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, flags)
}

// Return the current file-size of an jt-file.
func jtFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_journal.c:630:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileSize(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, pSize)
}

// Lock an jt-file.
func jtLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_journal.c:638:12: */
	var rc int32
	var p uintptr = pFile
	rc = sqlite3.Xsqlite3OsLock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, eLock)
	if (rc == SQLITE_OK) && (eLock > (*jt_file)(unsafe.Pointer(p)).FeLock) {
		(*jt_file)(unsafe.Pointer(p)).FeLock = eLock
	}
	return rc
}

// Unlock an jt-file.
func jtUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_journal.c:651:12: */
	var rc int32
	var p uintptr = pFile
	rc = sqlite3.Xsqlite3OsUnlock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, eLock)
	if (rc == SQLITE_OK) && (eLock < (*jt_file)(unsafe.Pointer(p)).FeLock) {
		(*jt_file)(unsafe.Pointer(p)).FeLock = eLock
	}
	return rc
}

// Check if another file-handle holds a RESERVED lock on an jt-file.
func jtCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_journal.c:664:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, pResOut)
}

// File control method. For custom operations on an jt-file.
func jtFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_journal.c:672:12: */
	var p uintptr = pFile
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*jt_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 40 /* &.xFileControl */))))(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, op, pArg)
}

// Return the sector-size in bytes for an jt-file.
func jtSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_journal.c:680:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSectorSize(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
}

// Return the device characteristic flags supported by an jt-file.
func jtDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_journal.c:688:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
}

// Open an jt file handle.
func jtOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_journal.c:696:12: */
	var rc int32
	var p uintptr = pFile
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FpReal = (p + 1*56)
	(*sqlite3_file)(unsafe.Pointer((*jt_file)(unsafe.Pointer(p)).FpReal)).FpMethods = uintptr(0)
	rc = sqlite3.Xsqlite3OsOpen(tls, g2.FpVfs, zName, (*jt_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)

	if rc == SQLITE_OK {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&jt_io_methods))
		(*jt_file)(unsafe.Pointer(p)).FeLock = 0
		(*jt_file)(unsafe.Pointer(p)).FzName = zName
		(*jt_file)(unsafe.Pointer(p)).Fflags = flags
		(*jt_file)(unsafe.Pointer(p)).FpNext = uintptr(0)
		(*jt_file)(unsafe.Pointer(p)).FpWritable = uintptr(0)
		(*jt_file)(unsafe.Pointer(p)).FaCksum = uintptr(0)
		enterJtMutex(tls)
		if zName != 0 {
			(*jt_file)(unsafe.Pointer(p)).FpNext = g2.FpList
			g2.FpList = p
		}
		leaveJtMutex(tls)
	}
	return rc
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func jtDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_journal.c:733:12: */
	var nPath int32 = int32(libc.Xstrlen(tls, zPath))
	if (nPath > 8) && (0 == libc.Xstrcmp(tls, ts+32244 /* "-journal" */, (zPath+uintptr((nPath-8))))) {
		// Deleting a journal file. The end of a transaction.
		var pMain uintptr = locateDatabaseHandle(tls, zPath, 0)
		if pMain != 0 {
			closeTransaction(tls, pMain)
		}
	}

	return sqlite3.Xsqlite3OsDelete(tls, g2.FpVfs, zPath, dirSync)
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func jtAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_journal.c:750:12: */
	return sqlite3.Xsqlite3OsAccess(tls, g2.FpVfs, zPath, flags, pResOut)
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (JT_MAX_PATHNAME+1) bytes.
func jtFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_journal.c:764:12: */
	return sqlite3.Xsqlite3OsFullPathname(tls, g2.FpVfs, zPath, nOut, zOut)
}

// Open the dynamic library located at zPath and return a handle.
func jtDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr { /* test_journal.c:776:13: */
	return (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((g2.FpVfs + 40 /* &.xDlOpen */))))(tls, g2.FpVfs, zPath)
}

// Populate the buffer zErrMsg (size nByte bytes) with a human readable
// utf-8 string describing the most recent error encountered associated
// with dynamic libraries.
func jtDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* test_journal.c:785:13: */
	(*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer((g2.FpVfs + 44 /* &.xDlError */))))(tls, g2.FpVfs, nByte, zErrMsg)
}

// Return a pointer to the symbol zSymbol in the dynamic library pHandle.
func jtDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr { /* test_journal.c:792:13: */
	return (*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((g2.FpVfs + 48 /* &.xDlSym */))))(tls, g2.FpVfs, p, zSym)
}

// Close the dynamic library handle pHandle.
func jtDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) { /* test_journal.c:799:13: */
	(*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer((g2.FpVfs + 52 /* &.xDlClose */))))(tls, g2.FpVfs, pHandle)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func jtRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_journal.c:807:12: */
	return sqlite3.Xsqlite3OsRandomness(tls, g2.FpVfs, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func jtSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* test_journal.c:815:12: */
	return sqlite3.Xsqlite3OsSleep(tls, g2.FpVfs, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func jtCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_journal.c:822:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((g2.FpVfs + 64 /* &.xCurrentTime */))))(tls, g2.FpVfs, pTimeOut)
}

// Return the current time as a Julian Day number in *pTimeOut.
func jtCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_journal.c:828:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((g2.FpVfs + 72 /* &.xCurrentTimeInt64 */))))(tls, g2.FpVfs, pTimeOut)
}

func jtGetLastError(tls *libc.TLS, pVfs uintptr, n int32, z uintptr) int32 { /* test_journal.c:832:12: */
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((g2.FpVfs + 68 /* &.xGetLastError */))))(tls, g2.FpVfs, n, z)
}

// *************************************************************************
//
// Start of public API.

// Configure the jt VFS as a wrapper around the VFS named by parameter
// zWrap. If the isDefault parameter is true, then the jt VFS is installed
// as the new default VFS for SQLite connections. If isDefault is not
// true, then the jt VFS is installed as non-default. In this case it
// is available via its name, "jt".
func jt_register(tls *libc.TLS, zWrap uintptr, isDefault int32) int32 { /* test_journal.c:847:5: */
	g2.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, zWrap)
	if g2.FpVfs == uintptr(0) {
		return SQLITE_ERROR
	}
	jt_vfs.FszOsFile = (int32(uint32(unsafe.Sizeof(jt_file{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FszOsFile)))
	if (*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FiVersion == 1 {
		jt_vfs.FiVersion = 1
	} else if (*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxCurrentTimeInt64 == uintptr(0) {
		jt_vfs.FxCurrentTimeInt64 = uintptr(0)
	}
	sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&jt_vfs)), isDefault)
	return SQLITE_OK
}

// Uninstall the jt VFS, if it is installed.
func jt_unregister(tls *libc.TLS) { /* test_journal.c:865:6: */
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&jt_vfs)))
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// This structure is used to encapsulate the global state variables used
// by malloc() fault simulation.
type MemFault = struct {
	FiCountdown   int32
	FnRepeat      int32
	FnBenign      int32
	FnFail        int32
	FnOkBefore    int32
	FnOkAfter     int32
	Fenable       u8
	_             [3]byte
	FisInstalled  int32
	FisBenignMode int32
	Fm            sqlite3_mem_methods
} /* test_malloc.c:30:8 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// This structure is used to encapsulate the global state variables used
// by malloc() fault simulation.
var memfault MemFault /* test_malloc.c:41:3: */

// This routine exists as a place to set a breakpoint that will
// fire on any simulated malloc() failure.
func sqlite3Fault(tls *libc.TLS) { /* test_malloc.c:47:13: */
	cnt1++
}

var cnt1 int32 = 0 /* test_malloc.c:48:14 */

// This routine exists as a place to set a breakpoint that will
// fire the first time any malloc() fails on a single test case.
// The sqlite3Fault() routine above runs on every malloc() failure.
// This routine only runs on the first such failure.
func sqlite3FirstFault(tls *libc.TLS) { /* test_malloc.c:58:13: */
	cnt2++
}

var cnt2 int32 = 0 /* test_malloc.c:59:14 */

// Check to see if a fault should be simulated.  Return true to simulate
// the fault.  Return false if the fault should not be simulated.
func faultsimStep(tls *libc.TLS) int32 { /* test_malloc.c:67:12: */
	if !(int32(memfault.Fenable) != 0) {
		memfault.FnOkAfter++
		return 0
	}
	if memfault.FiCountdown > 0 {
		memfault.FiCountdown--
		memfault.FnOkBefore++
		return 0
	}
	if memfault.FnFail == 0 {
		sqlite3FirstFault(tls)
	}
	sqlite3Fault(tls)
	memfault.FnFail++
	if memfault.FisBenignMode > 0 {
		memfault.FnBenign++
	}
	memfault.FnRepeat--
	if memfault.FnRepeat <= 0 {
		memfault.Fenable = u8(0)
	}
	return 1
}

// A version of sqlite3_mem_methods.xMalloc() that includes fault simulation
// logic.
func faultsimMalloc(tls *libc.TLS, n int32) uintptr { /* test_malloc.c:94:13: */
	var p uintptr = uintptr(0)
	if !(faultsimStep(tls) != 0) {
		p = (*(*func(*libc.TLS, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&memfault)) + 36 /* &.m */ /* &.xMalloc */))))(tls, n)
	}
	return p
}

// A version of sqlite3_mem_methods.xRealloc() that includes fault simulation
// logic.
func faultsimRealloc(tls *libc.TLS, pOld uintptr, n int32) uintptr { /* test_malloc.c:107:13: */
	var p uintptr = uintptr(0)
	if !(faultsimStep(tls) != 0) {
		p = (*(*func(*libc.TLS, uintptr, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&memfault)) + 36 /* &.m */ + 8 /* &.xRealloc */))))(tls, pOld, n)
	}
	return p
}

// This routine configures the malloc failure simulation.  After
// calling this routine, the next nDelay mallocs will succeed, followed
// by a block of nRepeat failures, after which malloc() calls will begin
// to succeed again.
func faultsimConfig(tls *libc.TLS, nDelay int32, nRepeat int32) { /* test_malloc.c:121:13: */
	memfault.FiCountdown = nDelay
	memfault.FnRepeat = nRepeat
	memfault.FnBenign = 0
	memfault.FnFail = 0
	memfault.FnOkBefore = 0
	memfault.FnOkAfter = 0
	memfault.Fenable = (u8(libc.Bool32(nDelay >= 0)))

	// Sometimes, when running multi-threaded tests, the isBenignMode
	// variable is not properly incremented/decremented so that it is
	// 0 when not inside a benign malloc block. This doesn't affect
	// the multi-threaded tests, as they do not use this system. But
	// it does affect OOM tests run later in the same process. So
	// zero the variable here, just to be sure.
	memfault.FisBenignMode = 0
}

// Return the number of faults (both hard and benign faults) that have
// occurred since the injector was last configured.
func faultsimFailures(tls *libc.TLS) int32 { /* test_malloc.c:144:12: */
	return memfault.FnFail
}

// Return the number of benign faults that have occurred since the
// injector was last configured.
func faultsimBenignFailures(tls *libc.TLS) int32 { /* test_malloc.c:152:12: */
	return memfault.FnBenign
}

// Return the number of successes that will occur before the next failure.
// If no failures are scheduled, return -1.
func faultsimPending(tls *libc.TLS) int32 { /* test_malloc.c:160:12: */
	if memfault.Fenable != 0 {
		return memfault.FiCountdown
	} else {
		return -1
	}
	return int32(0)
}

func faultsimBeginBenign(tls *libc.TLS) { /* test_malloc.c:169:13: */
	memfault.FisBenignMode++
}

func faultsimEndBenign(tls *libc.TLS) { /* test_malloc.c:172:13: */
	memfault.FisBenignMode--
}

// Add or remove the fault-simulation layer using sqlite3_config(). If
// the argument is non-zero, the
func faultsimInstall(tls *libc.TLS, install int32) int32 { /* test_malloc.c:180:12: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var rc int32

	install = func() int32 {
		if install != 0 {
			return 1
		}
		return 0
	}()

	if install == memfault.FisInstalled {
		return SQLITE_ERROR
	}

	if install != 0 {
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMALLOC, libc.VaList(bp, (uintptr(unsafe.Pointer(&memfault))+36 /* &.m */)))

		if rc == SQLITE_OK {
			*(*sqlite3_mem_methods)(unsafe.Pointer(bp + 72 /* m */)) = memfault.Fm
			(*sqlite3_mem_methods)(unsafe.Pointer(bp + 72 /* &m */)).FxMalloc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, int32) uintptr
			}{faultsimMalloc}))
			(*sqlite3_mem_methods)(unsafe.Pointer(bp + 72 /* &m */)).FxRealloc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			}{faultsimRealloc}))
			rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+8, bp+72 /* &m */))
		}
		sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS,
			libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) }{faultsimBeginBenign})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) }{faultsimEndBenign}))))
	} else {
		// var m2 sqlite3_mem_methods at bp+104, 32

		// One should be able to reset the default memory allocator by storing
		// a zeroed allocator then calling GETMALLOC.
		libc.Xmemset(tls, bp+104 /* &m2 */, 0, uint32(unsafe.Sizeof(sqlite3_mem_methods{})))
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+32, bp+104 /* &m2 */))
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMALLOC, libc.VaList(bp+40, bp+104 /* &m2 */))

		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+48, (uintptr(unsafe.Pointer(&memfault))+36 /* &.m */)))
		sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS,
			libc.VaList(bp+56, uintptr(0), uintptr(0)))
	}

	if rc == SQLITE_OK {
		memfault.FisInstalled = 1
	}
	return rc
}

// Transform pointers to text and back again
func pointerToText(tls *libc.TLS, p uintptr, z uintptr) { /* test_malloc.c:239:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = p

	var i int32
	var k int32
	// var u uint32 at bp+12, 4

	// var n sqlite3_uint64 at bp, 8

	if *(*uintptr)(unsafe.Pointer(bp + 8 /* p */)) == uintptr(0) {
		libc.Xstrcpy(tls, z, ts+13873 /* "0" */)
		return
	}
	if uint32(unsafe.Sizeof(sqlite3_uint64(0))) == uint32(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, bp /* &n */, bp+8 /* &p */, uint32(unsafe.Sizeof(uintptr(0))))
	} else if uint32(unsafe.Sizeof(uint32(0))) == uint32(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, bp+12 /* &u */, bp+8 /* &p */, uint32(unsafe.Sizeof(uint32(0))))
		*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) = sqlite3_uint64(*(*uint32)(unsafe.Pointer(bp + 12 /* u */)))
	} else {

	}
	i = 0
	k = (int32((uint32(unsafe.Sizeof(uintptr(0))) * uint32(2)) - uint32(1)))
__1:
	if !(uint32(i) < (uint32(unsafe.Sizeof(uintptr(0))) * uint32(2))) {
		goto __3
	}
	{
		*(*int8)(unsafe.Pointer(z + uintptr(k))) = zHex[(*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) & uint64(0xf))]
		*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) >>= 4

	}
	goto __2
__2:
	i++
	k--
	goto __1
	goto __3
__3:
	;
	*(*int8)(unsafe.Pointer(z + 8)) = int8(0)
}

var zHex = *(*[17]int8)(unsafe.Pointer(ts + 30627 /* "0123456789abcdef" */)) /* test_malloc.c:240:21 */

func hexToInt(tls *libc.TLS, h int32) int32 { /* test_malloc.c:262:12: */
	if (h >= '0') && (h <= '9') {
		return (h - '0')
	} else if (h >= 'a') && (h <= 'f') {
		return ((h - 'a') + 10)
	} else {
		return -1
	}
	return int32(0)
}

func textToPointer(tls *libc.TLS, z uintptr, pp uintptr) int32 { /* test_malloc.c:271:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) = uint64(0)
	var i int32
	// var u uint32 at bp+8, 4

	for i = 0; (uint32(i) < (uint32(unsafe.Sizeof(uintptr(0))) * uint32(2))) && (*(*int8)(unsafe.Pointer(z)) != 0); i++ {
		var v int32
		v = hexToInt(tls, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))))
		if v < 0 {
			return TCL_ERROR
		}
		*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) = ((*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) * uint64(16)) + sqlite3_uint64(v))
	}
	if int32(*(*int8)(unsafe.Pointer(z))) != 0 {
		return TCL_ERROR
	}
	if uint32(unsafe.Sizeof(sqlite3_uint64(0))) == uint32(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, pp, bp /* &n */, uint32(unsafe.Sizeof(sqlite3_uint64(0))))
	} else if uint32(unsafe.Sizeof(uint32(0))) == uint32(unsafe.Sizeof(uintptr(0))) {
		*(*uint32)(unsafe.Pointer(bp + 8 /* u */)) = uint32(*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)))
		libc.Xmemcpy(tls, pp, bp+8 /* &u */, uint32(unsafe.Sizeof(uint32(0))))
	} else {

	}
	return TCL_OK
}

// Usage:    sqlite3_malloc  NBYTES
//
// Raw test interface for sqlite3_malloc().
func test_malloc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:298:26: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	// var nByte int32 at bp+16, 4

	var p uintptr
	// var zOut [100]int8 at bp+20, 100

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32253 /* "NBYTES" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16 /* &nByte */) != 0 {
		return TCL_ERROR
	}
	p = sqlite3.Xsqlite3_malloc(tls, int32(uint32(*(*int32)(unsafe.Pointer(bp + 16 /* nByte */)))))
	pointerToText(tls, p, bp+20 /* &zOut[0] */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, bp+20 /* &zOut[0] */, uintptr(0)))
	return TCL_OK
}

// Usage:    sqlite3_realloc  PRIOR  NBYTES
//
// Raw test interface for sqlite3_realloc().
func test_realloc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:323:26: */
	bp := tls.Alloc(148)
	defer tls.Free(148)

	// var nByte int32 at bp+40, 4

	// var pPrior uintptr at bp+44, 4

	var p uintptr
	// var zOut [100]int8 at bp+48, 100

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32260 /* "PRIOR NBYTES" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+40 /* &nByte */) != 0 {
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+44 /* &pPrior */) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32273 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	p = sqlite3.Xsqlite3_realloc(tls, *(*uintptr)(unsafe.Pointer(bp + 44 /* pPrior */)), int32(uint32(*(*int32)(unsafe.Pointer(bp + 40 /* nByte */)))))
	pointerToText(tls, p, bp+48 /* &zOut[0] */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, bp+48 /* &zOut[0] */, uintptr(0)))
	return TCL_OK
}

// Usage:    sqlite3_free  PRIOR
//
// Raw test interface for sqlite3_free().
func test_free(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:352:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var pPrior uintptr at bp+24, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32287 /* "PRIOR" */)
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+24 /* &pPrior */) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32273 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pPrior */)))
	return TCL_OK
}

// Usage:    memset  ADDRESS  SIZE  HEX
//
// Set a chunk of memory (obtained from malloc, probably) to a
// specified hex pattern.
func test_memset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:383:26: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var p uintptr at bp+56, 4

	// var size int32 at bp+60, 4

	// var n int32 at bp+64, 4

	var i int32
	var zHex uintptr
	var zOut uintptr
	// var zBin [100]int8 at bp+68, 100

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32293 /* "ADDRESS SIZE HEX" */)
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+56 /* &p */) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32273 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+60 /* &size */) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 60 /* size */)) <= 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+32310 /* "size must be pos..." */, uintptr(0)))
		return TCL_ERROR
	}
	zHex = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+64 /* &n */)
	if uint32(*(*int32)(unsafe.Pointer(bp + 64 /* n */))) > (uint32(unsafe.Sizeof([100]int8{})) * uint32(2)) {
		*(*int32)(unsafe.Pointer(bp + 64 /* n */)) = (int32(uint32(unsafe.Sizeof([100]int8{})) * uint32(2)))
	}
	*(*int32)(unsafe.Pointer(bp + 64 /* n */)) = sqlite3TestHexToBin(tls, zHex, *(*int32)(unsafe.Pointer(bp + 64 /* n */)), bp+68 /* &zBin[0] */)
	if *(*int32)(unsafe.Pointer(bp + 64 /* n */)) == 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+32332 /* "no data" */, uintptr(0)))
		return TCL_ERROR
	}
	zOut = *(*uintptr)(unsafe.Pointer(bp + 56 /* p */))
	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 60 /* size */)); i++ {
		*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = *(*int8)(unsafe.Pointer(bp + 68 /* &zBin[0] */ + uintptr((i % *(*int32)(unsafe.Pointer(bp + 64 /* n */))))))
	}
	return TCL_OK
}

// Usage:    memget  ADDRESS  SIZE
//
// Return memory as hexadecimal text.
func test_memget(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:429:26: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	// var p uintptr at bp+56, 4

	// var size int32 at bp+60, 4

	var n int32
	var zBin uintptr
	// var zHex [100]int8 at bp+64, 100

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32340 /* "ADDRESS SIZE" */)
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+56 /* &p */) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32273 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+60 /* &size */) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 60 /* size */)) <= 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+32310 /* "size must be pos..." */, uintptr(0)))
		return TCL_ERROR
	}
	zBin = *(*uintptr)(unsafe.Pointer(bp + 56 /* p */))
	for *(*int32)(unsafe.Pointer(bp + 60 /* size */)) > 0 {
		if uint32(*(*int32)(unsafe.Pointer(bp + 60 /* size */))) > ((uint32(unsafe.Sizeof([100]int8{})) - uint32(1)) / uint32(2)) {
			n = (int32((uint32(unsafe.Sizeof([100]int8{})) - uint32(1)) / uint32(2)))
		} else {
			n = *(*int32)(unsafe.Pointer(bp + 60 /* size */))
		}
		libc.Xmemcpy(tls, bp+64 /* &zHex[0] */, zBin, uint32(n))
		zBin += uintptr(n)
		*(*int32)(unsafe.Pointer(bp + 60 /* size */)) -= n
		sqlite3TestBinToHex(tls, bp+64 /* &zHex[0] */, n)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+64 /* &zHex[0] */, uintptr(0)))
	}
	return TCL_OK
}

// Usage:    sqlite3_memory_used
//
// Raw test interface for sqlite3_memory_used().
func test_memory_used(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:476:26: */
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_memory_used(tls)))
	return TCL_OK
}

// Usage:    sqlite3_memory_highwater ?RESETFLAG?
//
// Raw test interface for sqlite3_memory_highwater().
func test_memory_highwater(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:491:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* resetFlag */)) = 0
	if (objc != 1) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32353 /* "?RESET?" */)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &resetFlag */) != 0 {
			return TCL_ERROR
		}
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_memory_highwater(tls, *(*int32)(unsafe.Pointer(bp /* resetFlag */)))))
	return TCL_OK
}

// Usage:    sqlite3_memdebug_backtrace DEPTH
//
// Set the depth of backtracing.  If SQLITE_MEMDEBUG is not defined
// then this routine is a no-op.
func test_memdebug_backtrace(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:516:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var depth int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32361 /* "DEPT" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &depth */) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:    sqlite3_memdebug_dump  FILENAME
//
// Write a summary of unfreed memory to FILENAME.
func test_memdebug_dump(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:542:26: */
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32366 /* "FILENAME" */)
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:    sqlite3_memdebug_malloc_count
//
// Return the total number of times malloc() has been called.
func test_memdebug_malloc_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:567:26: */
	var nMalloc int32 = -1
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nMalloc))
	return TCL_OK
}

// Usage:    sqlite3_memdebug_fail  COUNTER  ?OPTIONS?
//
// where options are:
//
//     -repeat    <count>
//     -benigncnt <varname>
//
// Arrange for a simulated malloc() failure after COUNTER successes.
// If a repeat count is specified, the fault is repeated that many
// times.
//
// Each call to this routine overrides the prior counter value.
// This routine returns the number of simulated failures that have
// happened since the previous call to this routine.
//
// To disable simulated failures, use a COUNTER of -1.
func test_memdebug_fail(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:607:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var ii int32
	// var iFail int32 at bp+24, 4

	*(*int32)(unsafe.Pointer(bp + 32 /* nRepeat */)) = 1
	var pBenignCnt uintptr = uintptr(0)
	var nBenign int32
	var nFail int32 = 0

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32375 /* "COUNTER ?OPTIONS..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+24 /* &iFail */) != 0 {
		return TCL_ERROR
	}

	for ii = 2; ii < objc; ii = ii + (2) {
		// var nOption int32 at bp+28, 4

		var zOption uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(ii)*4)), bp+28 /* &nOption */)
		var zErr uintptr = uintptr(0)

		if (*(*int32)(unsafe.Pointer(bp + 28 /* nOption */)) > 1) && (libc.Xstrncmp(tls, zOption, ts+32393 /* "-repeat" */, uint32(*(*int32)(unsafe.Pointer(bp + 28 /* nOption */)))) == 0) {
			if ii == (objc - 1) {
				zErr = ts + 12327 /* "option requires ..." */
			} else {
				if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((ii+1))*4)), bp+32 /* &nRepeat */) != 0 {
					return TCL_ERROR
				}
			}
		} else if (*(*int32)(unsafe.Pointer(bp + 28 /* nOption */)) > 1) && (libc.Xstrncmp(tls, zOption, ts+32401 /* "-benigncnt" */, uint32(*(*int32)(unsafe.Pointer(bp + 28 /* nOption */)))) == 0) {
			if ii == (objc - 1) {
				zErr = ts + 12327 /* "option requires ..." */
			} else {
				pBenignCnt = *(*uintptr)(unsafe.Pointer(objv + uintptr((ii+1))*4))
			}
		} else {
			zErr = ts + 12133 /* "unknown option: " */
		}

		if zErr != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, zErr, zOption, 0))
			return TCL_ERROR
		}
	}

	nBenign = faultsimBenignFailures(tls)
	nFail = faultsimFailures(tls)
	faultsimConfig(tls, *(*int32)(unsafe.Pointer(bp + 24 /* iFail */)), *(*int32)(unsafe.Pointer(bp + 32 /* nRepeat */)))

	if pBenignCnt != 0 {
		tcl.XTcl_ObjSetVar2(tls, interp, pBenignCnt, uintptr(0), tcl.XTcl_NewIntObj(tls, nBenign), 0)
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nFail))
	return TCL_OK
}

// Usage:    sqlite3_memdebug_pending
//
// Return the number of malloc() calls that will succeed before a
// simulated failure occurs. A negative return value indicates that
// no malloc() failure is scheduled.
func test_memdebug_pending(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:673:26: */
	var nPending int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}
	nPending = faultsimPending(tls)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nPending))
	return TCL_OK
}

// The following global variable keeps track of the number of tests
// that have run.  This variable is only useful when running in the
// debugger.
var sqlite3_memdebug_title_count int32 = 0 /* test_malloc.c:694:12 */

// Usage:    sqlite3_memdebug_settitle TITLE
//
// Set a title string stored with each allocation.  The TITLE is
// typically the name of the test that was running when the
// allocation occurred.  The TITLE is stored with the allocation
// and can be used to figure out which tests are leaking memory.
//
// Each title overwrite the previous.
func test_memdebug_settitle(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:706:26: */
	sqlite3_memdebug_title_count++
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32412 /* "TITLE" */)
		return TCL_ERROR
	}
	return TCL_OK
}

var aMallocLog Tcl_HashTable   /* test_malloc.c:732:22: */
var mallocLogEnabled int32 = 0 /* test_malloc.c:733:12 */

type MallocLog1 = struct {
	FnCall int32
	FnByte int32
} /* test_malloc.c:735:9 */

type MallocLog = MallocLog1 /* test_malloc.c:735:26 */

func test_memdebug_log_clear(tls *libc.TLS) { /* test_malloc.c:772:13: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var search Tcl_HashSearch at bp, 12

	var pEntry uintptr
	for pEntry = tcl.XTcl_FirstHashEntry(tls, uintptr(unsafe.Pointer(&aMallocLog)), bp /* &search */); pEntry != 0; pEntry = tcl.XTcl_NextHashEntry(tls, bp /* &search */) {
		var pLog uintptr = (*Tcl_HashEntry)(unsafe.Pointer(pEntry)).FclientData
		tcl.XTcl_Free(tls, pLog)
	}
	tcl.XTcl_DeleteHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)))
	tcl.XTcl_InitHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)), (int32(uint32(10) * (func() uint32 {
		if uint32(unsafe.Sizeof(int32(0))) >= uint32(unsafe.Sizeof(uintptr(0))) {
			return uint32(1)
		}
		return (uint32(unsafe.Sizeof(uintptr(0))) / uint32(unsafe.Sizeof(int32(0))))
	}()))))
}

func test_memdebug_log(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:787:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var iSub int32 at bp, 4

	if !(isInit != 0) {
		tcl.XTcl_InitHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)), (int32(uint32(10) * (func() uint32 {
			if uint32(unsafe.Sizeof(int32(0))) >= uint32(unsafe.Sizeof(uintptr(0))) {
				return uint32(1)
			}
			return (uint32(unsafe.Sizeof(uintptr(0))) / uint32(unsafe.Sizeof(int32(0))))
		}()))))
		isInit = 1
	}

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32418 /* "SUB-COMMAND ..." */)
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(unsafe.Pointer(&MB_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+1875 /* "sub-command" */, 0, bp /* &iSub */) != 0 {
		return TCL_ERROR
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp /* iSub */))) {
	case uint32(0) /* MB_LOG_START */ :
		mallocLogEnabled = 1
		break
	case uint32(1) /* MB_LOG_STOP */ :
		mallocLogEnabled = 0
		break
	case uint32(2) /* MB_LOG_DUMP */ :
		{
			// var search Tcl_HashSearch at bp+4, 12

			var pEntry uintptr
			var pRet uintptr = tcl.XTcl_NewObj(tls)

			for pEntry = tcl.XTcl_FirstHashEntry(tls, uintptr(unsafe.Pointer(&aMallocLog)), bp+4 /* &search */); pEntry != 0; pEntry = tcl.XTcl_NextHashEntry(tls, bp+4 /* &search */) {
				// var apElem [12]uintptr at bp+16, 48

				var pLog uintptr = (*Tcl_HashEntry)(unsafe.Pointer(pEntry)).FclientData
				var aKey uintptr = func() uintptr {
					if ((*Tcl_HashTable)(unsafe.Pointer((uintptr(unsafe.Pointer(&aMallocLog))))).FkeyType == (1)) || ((*Tcl_HashTable)(unsafe.Pointer((uintptr(unsafe.Pointer(&aMallocLog))))).FkeyType == (-1)) {
						return *(*uintptr)(unsafe.Pointer(pEntry + 16 /* &.key */))
					}
					return pEntry + 16 /* &.key */
				}()
				var ii int32

				*(*uintptr)(unsafe.Pointer(bp + 16 /* &apElem[0] */)) = tcl.XTcl_NewIntObj(tls, (*MallocLog)(unsafe.Pointer(pLog)).FnCall)
				*(*uintptr)(unsafe.Pointer(bp + 16 /* &apElem[0] */ + 1*4)) = tcl.XTcl_NewIntObj(tls, (*MallocLog)(unsafe.Pointer(pLog)).FnByte)
				for ii = 0; ii < MALLOC_LOG_FRAMES; ii++ {
					*(*uintptr)(unsafe.Pointer(bp + 16 /* &apElem[0] */ + uintptr((ii+2))*4)) = tcl.XTcl_NewWideIntObj(tls, *(*Tcl_WideInt)(unsafe.Pointer(aKey + uintptr(ii)*8)))
				}

				tcl.XTcl_ListObjAppendElement(tls, interp, pRet,
					tcl.XTcl_NewListObj(tls, (MALLOC_LOG_FRAMES+2), bp+16 /* &apElem[0] */))
			}

			tcl.XTcl_SetObjResult(tls, interp, pRet)
			break

		}
	case uint32(3) /* MB_LOG_CLEAR */ :
		{
			test_memdebug_log_clear(tls)
			break

		}

	case uint32(4) /* MB_LOG_SYNC */ :
		{
			break

		}
	}

	return TCL_OK
}

var isInit int32 = 0                                                                                                                                    /* test_malloc.c:793:14 */
var MB_strs = [5]uintptr{ts + 32434 /* "start" */, ts + 32440 /* "stop" */, ts + 32445 /* "dump" */, ts + 32450 /* "clear" */, ts + 32456 /* "sync" */} /* test_malloc.c:796:21 */

// Usage:    sqlite3_config_pagecache SIZE N
//
// Set the page-cache memory buffer using SQLITE_CONFIG_PAGECACHE.
// The buffer is static and is of limited size.  N might be
// adjusted downward as needed to accommodate the requested size.
// The revised value of N is returned.
//
// A negative SIZE causes the buffer pointer to be NULL.
func test_config_pagecache(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:885:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var sz int32 at bp+48, 4

	// var N int32 at bp+52, 4

	var pRes uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32461 /* "SIZE N" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+48 /* &sz */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+52 /* &N */) != 0 {
		return TCL_ERROR
	}
	libc.Xfree(tls, buf1)
	buf1 = uintptr(0)

	// Set the return value
	pRes = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRes, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FszPage))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRes, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FnPage))
	tcl.XTcl_SetObjResult(tls, interp, pRes)

	if *(*int32)(unsafe.Pointer(bp + 48 /* sz */)) < 0 {
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PAGECACHE, libc.VaList(bp, uintptr(0), 0, 0))
	} else {
		buf1 = libc.Xmalloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 48 /* sz */)) * *(*int32)(unsafe.Pointer(bp + 52 /* N */)))))
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PAGECACHE, libc.VaList(bp+24, buf1, *(*int32)(unsafe.Pointer(bp + 48 /* sz */)), *(*int32)(unsafe.Pointer(bp + 52 /* N */))))
	}
	return TCL_OK
}

var buf1 uintptr = uintptr(0) /* test_malloc.c:893:15 */

// Usage:    sqlite3_config_alt_pcache INSTALL_FLAG DISCARD_CHANCE PRNG_SEED
//
// Set up the alternative test page cache.  Install if INSTALL_FLAG is
// true and uninstall (reverting to the default page cache) if INSTALL_FLAG
// is false.  DISCARD_CHANGE is an integer between 0 and 100 inclusive
// which determines the chance of discarding a page when unpinned.  100
// is certainty.  0 is never.  PRNG_SEED is the pseudo-random number generator
// seed.
func test_alt_pcache(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:928:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var installFlag int32 at bp+16, 4

	*(*int32)(unsafe.Pointer(bp + 20 /* discardChance */)) = 0
	*(*int32)(unsafe.Pointer(bp + 24 /* prngSeed */)) = 0
	*(*int32)(unsafe.Pointer(bp + 28 /* highStress */)) = 0
	if (objc < 2) || (objc > 5) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,
			ts+32468 /* "INSTALLFLAG DISC..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16 /* &installFlag */) != 0 {
		return TCL_ERROR
	}
	if (objc >= 3) && (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+20 /* &discardChance */) != 0) {
		return TCL_ERROR
	}
	if (objc >= 4) && (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+24 /* &prngSeed */) != 0) {
		return TCL_ERROR
	}
	if (objc >= 5) && (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+28 /* &highStress */) != 0) {
		return TCL_ERROR
	}
	if (*(*int32)(unsafe.Pointer(bp + 20 /* discardChance */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 20 /* discardChance */)) > 100) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32515, /* "discard-chance s..." */
			uintptr(0)))
		return TCL_ERROR
	}
	installTestPCache(tls, *(*int32)(unsafe.Pointer(bp + 16 /* installFlag */)), uint32(*(*int32)(unsafe.Pointer(bp + 20 /* discardChance */))), uint32(*(*int32)(unsafe.Pointer(bp + 24 /* prngSeed */))),
		uint32(*(*int32)(unsafe.Pointer(bp + 28 /* highStress */))))
	return TCL_OK
}

// Usage:    sqlite3_config_memstatus BOOLEAN
//
// Enable or disable memory status reporting using SQLITE_CONFIG_MEMSTATUS.
func test_config_memstatus(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:969:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var enable int32 at bp+8, 4

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17896 /* "BOOLEAN" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8 /* &enable */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MEMSTATUS, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* enable */))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// Usage:    sqlite3_config_lookaside  SIZE  COUNT
//
func test_config_lookaside(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:990:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var sz int32 at bp+16, 4

	// var cnt int32 at bp+20, 4

	var pRet uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32558 /* "SIZE COUNT" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16 /* &sz */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+20 /* &cnt */) != 0 {
		return TCL_ERROR
	}
	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls,
		interp, pRet, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FszLookaside))
	tcl.XTcl_ListObjAppendElement(tls,
		interp, pRet, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FnLookaside))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOOKASIDE, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 16 /* sz */)), *(*int32)(unsafe.Pointer(bp + 20 /* cnt */))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

// Usage:    sqlite3_db_config_lookaside  CONNECTION  BUFID  SIZE  COUNT
//
// There are two static buffers with BUFID 1 and 2.   Each static buffer
// is 10KB in size.  A BUFID of 0 indicates that the buffer should be NULL
// which will cause sqlite3_db_config() to allocate space on its own.
func test_db_config_lookaside(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1024:26: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var rc int32
	// var sz int32 at bp+72, 4

	// var cnt int32 at bp+76, 4

	// var db uintptr at bp+64, 4

	// var bufid int32 at bp+68, 4

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32569 /* "BUFID SIZE COUNT" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64 /* &db */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+68 /* &bufid */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+72 /* &sz */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+76 /* &cnt */) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 68 /* bufid */)) == 0 {
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), SQLITE_DBCONFIG_LOOKASIDE, libc.VaList(bp, uintptr(0), *(*int32)(unsafe.Pointer(bp + 72 /* sz */)), *(*int32)(unsafe.Pointer(bp + 76 /* cnt */))))
	} else if ((*(*int32)(unsafe.Pointer(bp + 68 /* bufid */)) >= 1) && (*(*int32)(unsafe.Pointer(bp + 68 /* bufid */)) <= 2)) && ((uint32(*(*int32)(unsafe.Pointer(bp + 72 /* sz */)) * *(*int32)(unsafe.Pointer(bp + 76 /* cnt */)))) <= uint32(unsafe.Sizeof([10000]int8{}))) {
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), SQLITE_DBCONFIG_LOOKASIDE, libc.VaList(bp+24, (uintptr(unsafe.Pointer(&azBuf))+uintptr(*(*int32)(unsafe.Pointer(bp + 68 /* bufid */)))*10000), *(*int32)(unsafe.Pointer(bp + 72 /* sz */)), *(*int32)(unsafe.Pointer(bp + 76 /* cnt */))))
	} else {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+32586 /* "illegal argument..." */, uintptr(0)))
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

var azBuf [2][10000]int8 /* test_malloc.c:1034:15: */

// Usage:    sqlite3_config_heap NBYTE NMINALLOC
func test_config_heap(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1059:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)
	// Use this memory
	// var nByte int32 at bp+48, 4
	// Size of buffer to pass to sqlite3_config()
	// var nMinAlloc int32 at bp+52, 4
	// Size of minimum allocation
	var rc int32 // Return code of sqlite3_config()

	var aArg uintptr = (objv + 1*4)
	var nArg int32 = (objc - 1)

	if nArg != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32624 /* "NBYTE NMINALLOC" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg)), bp+48 /* &nByte */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg + 1*4)), bp+52 /* &nMinAlloc */) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 48 /* nByte */)) == 0 {
		libc.Xfree(tls, zBuf)
		zBuf = uintptr(0)
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_HEAP, libc.VaList(bp, uintptr(0), 0, 0))
	} else {
		zBuf = libc.Xrealloc(tls, zBuf, uint32(*(*int32)(unsafe.Pointer(bp + 48 /* nByte */))))
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_HEAP, libc.VaList(bp+24, zBuf, *(*int32)(unsafe.Pointer(bp + 48 /* nByte */)), *(*int32)(unsafe.Pointer(bp + 52 /* nMinAlloc */))))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

var zBuf uintptr /* test_malloc.c:1065:15: */

// Usage:    sqlite3_config_heap_size NBYTE
func test_config_heap_size(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1096:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var nByte int32 at bp+8, 4
	// Size to pass to sqlite3_config()
	var rc int32 // Return code of sqlite3_config()

	var aArg uintptr = (objv + 1*4)
	var nArg int32 = (objc - 1)

	if nArg != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15910 /* "NBYTE" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg)), bp+8 /* &nByte */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_WIN32_HEAPSIZE, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* nByte */))))

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// Usage:    sqlite3_config_error  [DB]
//
// Invoke sqlite3_config() or sqlite3_db_config() with invalid
// opcodes and verify that they return errors.
func test_config_error(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1126:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var db uintptr at bp+32, 4

	if (objc != 2) && (objc != 1) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32640 /* "[DB]" */)
		return TCL_ERROR
	}
	if objc == 2 {
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32 /* &db */) != 0 {
			return TCL_ERROR
		}
		if sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), 99999, 0) != SQLITE_ERROR {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp, ts+32645, /* "sqlite3_db_confi..." */
					uintptr(0)))
			return TCL_ERROR
		}
	} else {
		if sqlite3.Xsqlite3_config(tls, 99999, 0) != SQLITE_ERROR {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp+16, ts+32703, /* "sqlite3_config(9..." */
					uintptr(0)))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

// Usage:    sqlite3_config_uri  BOOLEAN
//
// Enables or disables interpretation of URI parameters by default using
// SQLITE_CONFIG_URI.
func test_config_uri(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1164:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	// var bOpenUri int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18619 /* "BOOL" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8 /* &bOpenUri */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_URI, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* bOpenUri */))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return TCL_OK
}

// Usage:    sqlite3_config_cis  BOOLEAN
//
// Enables or disables the use of the covering-index scan optimization.
// SQLITE_CONFIG_COVERING_INDEX_SCAN.
func test_config_cis(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1193:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	// var bUseCis int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18619 /* "BOOL" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8 /* &bUseCis */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_COVERING_INDEX_SCAN, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* bUseCis */))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return TCL_OK
}

// Usage:    sqlite3_config_pmasz  INTEGER
//
// Set the minimum PMA size.
func test_config_pmasz(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1221:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	// var iPmaSz int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18619 /* "BOOL" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8 /* &iPmaSz */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PMASZ, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* iPmaSz */))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return TCL_OK
}

// Usage:    sqlite3_dump_memsys3  FILENAME
//           sqlite3_dump_memsys5  FILENAME
//
// Write a summary of unfreed memsys3 allocations to FILENAME.
func test_dump_memsys3(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1251:26: */
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32366 /* "FILENAME" */)
		return TCL_ERROR
	}

	switch int32(clientData) {
	case 3:
		{

		}
		fallthrough
	case 5:
		{

		}
	}
	return TCL_OK
}

// Usage:    sqlite3_status  OPCODE  RESETFLAG
//
// Return a list of three elements which are the sqlite3_status() return
// code, the current value, and the high-water mark value.
func test_status(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1287:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	// var iValue int32 at bp+8, 4

	// var mxValue int32 at bp+12, 4

	var i int32
	*(*int32)(unsafe.Pointer(bp /* op */)) = 0
	// var resetFlag int32 at bp+4, 4

	var zOpName uintptr
	var pResult uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32754 /* "PARAMETER RESETF..." */)
		return TCL_ERROR
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	for i = 0; i < (int32(uint32(unsafe.Sizeof(aOp1)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{})))); i++ {
		if libc.Xstrcmp(tls, aOp1[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp /* op */)) = aOp1[i].Fop
			break
		}
	}
	if i >= (int32(uint32(unsafe.Sizeof(aOp1)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{})))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &op */) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &resetFlag */) != 0 {
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 8 /* iValue */)) = 0
	*(*int32)(unsafe.Pointer(bp + 12 /* mxValue */)) = 0
	rc = sqlite3.Xsqlite3_status(tls, *(*int32)(unsafe.Pointer(bp /* op */)), bp+8 /* &iValue */, bp+12 /* &mxValue */, *(*int32)(unsafe.Pointer(bp + 4 /* resetFlag */)))
	pResult = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, rc))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 8 /* iValue */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12 /* mxValue */))))
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

var aOp1 = [10]struct {
	FzName uintptr
	Fop    int32
}{
	{FzName: ts + 32774 /* "SQLITE_STATUS_ME..." */},
	{FzName: ts + 32800 /* "SQLITE_STATUS_MA..." */, Fop: SQLITE_STATUS_MALLOC_SIZE},
	{FzName: ts + 32826 /* "SQLITE_STATUS_PA..." */, Fop: SQLITE_STATUS_PAGECACHE_USED},
	{FzName: ts + 32855 /* "SQLITE_STATUS_PA..." */, Fop: SQLITE_STATUS_PAGECACHE_OVERFLOW},
	{FzName: ts + 32888 /* "SQLITE_STATUS_PA..." */, Fop: SQLITE_STATUS_PAGECACHE_SIZE},
	{FzName: ts + 32917 /* "SQLITE_STATUS_SC..." */, Fop: SQLITE_STATUS_SCRATCH_USED},
	{FzName: ts + 32944 /* "SQLITE_STATUS_SC..." */, Fop: SQLITE_STATUS_SCRATCH_OVERFLOW},
	{FzName: ts + 32975 /* "SQLITE_STATUS_SC..." */, Fop: SQLITE_STATUS_SCRATCH_SIZE},
	{FzName: ts + 33002 /* "SQLITE_STATUS_PA..." */, Fop: SQLITE_STATUS_PARSER_STACK},
	{FzName: ts + 33029 /* "SQLITE_STATUS_MA..." */, Fop: SQLITE_STATUS_MALLOC_COUNT},
} /* test_malloc.c:1299:5 */

// Usage:    sqlite3_db_status  DATABASE  OPCODE  RESETFLAG
//
// Return a list of three elements which are the sqlite3_db_status() return
// code, the current value, and the high-water mark value.
func test_db_status(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1344:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var rc int32
	// var iValue int32 at bp+12, 4

	// var mxValue int32 at bp+16, 4

	var i int32
	*(*int32)(unsafe.Pointer(bp + 4 /* op */)) = 0
	// var resetFlag int32 at bp+8, 4

	var zOpName uintptr
	// var db uintptr at bp, 4

	var pResult uintptr
	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33056 /* "DB PARAMETER RES..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if libc.Xmemcmp(tls, zOpName, ts+33079 /* "SQLITE_" */, uint32(7)) == 0 {
		zOpName += uintptr(7)
	}
	if libc.Xmemcmp(tls, zOpName, ts+33087 /* "DBSTATUS_" */, uint32(9)) == 0 {
		zOpName += uintptr(9)
	}
	for i = 0; i < (int32(uint32(unsafe.Sizeof(aOp2)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{})))); i++ {
		if libc.Xstrcmp(tls, aOp2[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp + 4 /* op */)) = aOp2[i].Fop
			break
		}
	}
	if i >= (int32(uint32(unsafe.Sizeof(aOp2)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{})))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4 /* &op */) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+8 /* &resetFlag */) != 0 {
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 12 /* iValue */)) = 0
	*(*int32)(unsafe.Pointer(bp + 16 /* mxValue */)) = 0
	rc = sqlite3.Xsqlite3_db_status(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*int32)(unsafe.Pointer(bp + 4 /* op */)), bp+12 /* &iValue */, bp+16 /* &mxValue */, *(*int32)(unsafe.Pointer(bp + 8 /* resetFlag */)))
	pResult = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, rc))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12 /* iValue */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 16 /* mxValue */))))
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

var aOp2 = [13]struct {
	FzName uintptr
	Fop    int32
}{
	{FzName: ts + 33097 /* "LOOKASIDE_USED" */},
	{FzName: ts + 33112 /* "CACHE_USED" */, Fop: SQLITE_DBSTATUS_CACHE_USED},
	{FzName: ts + 33123 /* "SCHEMA_USED" */, Fop: SQLITE_DBSTATUS_SCHEMA_USED},
	{FzName: ts + 33135 /* "STMT_USED" */, Fop: SQLITE_DBSTATUS_STMT_USED},
	{FzName: ts + 33145 /* "LOOKASIDE_HIT" */, Fop: SQLITE_DBSTATUS_LOOKASIDE_HIT},
	{FzName: ts + 33159 /* "LOOKASIDE_MISS_S..." */, Fop: SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE},
	{FzName: ts + 33179 /* "LOOKASIDE_MISS_F..." */, Fop: SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL},
	{FzName: ts + 33199 /* "CACHE_HIT" */, Fop: SQLITE_DBSTATUS_CACHE_HIT},
	{FzName: ts + 33209 /* "CACHE_MISS" */, Fop: SQLITE_DBSTATUS_CACHE_MISS},
	{FzName: ts + 33220 /* "CACHE_WRITE" */, Fop: SQLITE_DBSTATUS_CACHE_WRITE},
	{FzName: ts + 33232 /* "DEFERRED_FKS" */, Fop: SQLITE_DBSTATUS_DEFERRED_FKS},
	{FzName: ts + 33245 /* "CACHE_USED_SHARE..." */, Fop: SQLITE_DBSTATUS_CACHE_USED_SHARED},
	{FzName: ts + 33263 /* "CACHE_SPILL" */, Fop: SQLITE_DBSTATUS_CACHE_SPILL},
} /* test_malloc.c:1358:5 */

// install_malloc_faultsim BOOLEAN
func test_install_malloc_faultsim(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1406:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	// var isInstall int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17896 /* "BOOLEAN" */)
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &isInstall */) {
		return TCL_ERROR
	}
	rc = faultsimInstall(tls, *(*int32)(unsafe.Pointer(bp /* isInstall */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// sqlite3_install_memsys3
func test_install_memsys3(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1430:26: */
	var rc int32 = SQLITE_MISUSE
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

func test_vfs_oom_test(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1445:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33275 /* "?INTEGER?" */)
		return TCL_ERROR
	} else if objc == 2 {
		// var iNew int32 at bp, 4

		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &iNew */) != 0 {
			return TCL_ERROR
		}
		sqlite3.Xsqlite3_memdebug_vfs_oom_test = *(*int32)(unsafe.Pointer(bp /* iNew */))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_memdebug_vfs_oom_test))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest_malloc_Init(tls *libc.TLS, interp uintptr) int32 { /* test_malloc.c:1467:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd11)) / uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData int32
	}{}))); i++ {
		var c ClientData = uintptr(aObjCmd11[i].FclientData)
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd11[i].FzName, aObjCmd11[i].FxProc, c, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd11 = [32]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData int32
}{
	{FzName: ts + 27612 /* "sqlite3_malloc" */, FxProc: 0},
	{FzName: ts + 27627 /* "sqlite3_realloc" */, FxProc: 0},
	{FzName: ts + 33285 /* "sqlite3_free" */, FxProc: 0},
	{FzName: ts + 33298 /* "memset" */, FxProc: 0},
	{FzName: ts + 33305 /* "memget" */, FxProc: 0},
	{FzName: ts + 33312 /* "sqlite3_memory_u..." */, FxProc: 0},
	{FzName: ts + 33332 /* "sqlite3_memory_h..." */, FxProc: 0},
	{FzName: ts + 33357 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 33384 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 33406 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 33428 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 33453 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 33479 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 33509 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 33530 /* "sqlite3_config_p..." */, FxProc: 0},
	{FzName: ts + 33555 /* "sqlite3_config_a..." */, FxProc: 0},
	{FzName: ts + 33581 /* "sqlite3_status" */, FxProc: 0},
	{FzName: ts + 33596 /* "sqlite3_db_statu..." */, FxProc: 0},
	{FzName: ts + 33614 /* "install_malloc_f..." */, FxProc: 0},
	{FzName: ts + 33638 /* "sqlite3_config_h..." */, FxProc: 0},
	{FzName: ts + 33658 /* "sqlite3_config_h..." */, FxProc: 0},
	{FzName: ts + 33683 /* "sqlite3_config_m..." */, FxProc: 0},
	{FzName: ts + 33708 /* "sqlite3_config_l..." */, FxProc: 0},
	{FzName: ts + 33733 /* "sqlite3_config_e..." */, FxProc: 0},
	{FzName: ts + 33754 /* "sqlite3_config_u..." */, FxProc: 0},
	{FzName: ts + 33773 /* "sqlite3_config_c..." */, FxProc: 0},
	{FzName: ts + 33792 /* "sqlite3_config_p..." */, FxProc: 0},
	{FzName: ts + 33813 /* "sqlite3_db_confi..." */, FxProc: 0},
	{FzName: ts + 33841 /* "sqlite3_dump_mem..." */, FxProc: 0, FclientData: 3},
	{FzName: ts + 33862 /* "sqlite3_dump_mem..." */, FxProc: 0, FclientData: 5},
	{FzName: ts + 33883 /* "sqlite3_install_..." */, FxProc: 0},
	{FzName: ts + 33907 /* "sqlite3_memdebug..." */, FxProc: 0},
} /* test_malloc.c:1472:5 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set4 = struct{ F__fds_bits [32]int32 } /* select.h:70:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// This code implements the MD5 message-digest algorithm.
// The algorithm is due to Ron Rivest.  This code was
// written by Colin Plumb in 1993, no copyright is claimed.
// This code is in the public domain; do with it what you wish.
//
// Equivalent code is available from RSA Data Security, Inc.
// This code has been tested against that, and is equivalent,
// except that you don't need to include two pages of legalese
// with every copy.
//
// To compute the message digest of a chunk of bytes, declare an
// MD5Context structure, pass it to MD5Init, call MD5Update as
// needed on buffers full of bytes, and then call MD5Final, which
// will fill a supplied 16-byte array with the digest.

// If compiled on a machine that doesn't have a 32-bit integer,
// you just set "uint32" to the appropriate datatype for an
// unsigned 32-bit integer.  For example:
//
//       cc -Duint32='unsigned long' md5.c
//

type MD5Context1 = struct {
	FisInit int32
	Fbuf    [4]uint32
	Fbits   [2]uint32
	Fin     [64]uint8
} /* test_md5.c:57:1 */

type MD5Context = MD5Context1 /* test_md5.c:63:27 */

// Note: this code is harmless on little-endian machines.
func byteReverse(tls *libc.TLS, buf uintptr, longs uint32) { /* test_md5.c:68:13: */
	var t uint32
	for ok := true; ok; ok = libc.PreDecUint32(&longs, 1) != 0 {
		t = ((((uint32(*(*uint8)(unsafe.Pointer(buf + 3))) << 8) | uint32(*(*uint8)(unsafe.Pointer(buf + 2)))) << 16) | ((uint32(*(*uint8)(unsafe.Pointer(buf + 1))) << 8) | uint32(*(*uint8)(unsafe.Pointer(buf)))))
		*(*uint32)(unsafe.Pointer(buf)) = t
		buf += uintptr(4)
	}
}

// The four core functions - F1 is optimized somewhat

// #define F1(x, y, z) (x & y | ~x & z)

// This is the central step in the MD5 algorithm.

// The core of the MD5 algorithm, this alters an existing MD5 hash to
// reflect the addition of 16 longwords of new data.  MD5Update blocks
// the data and converts bytes into longwords for this routine.
func MD5Transform(tls *libc.TLS, buf uintptr, in uintptr) { /* test_md5.c:94:13: */
	var a uint32
	var b uint32
	var c uint32
	var d uint32

	a = *(*uint32)(unsafe.Pointer(buf))
	b = *(*uint32)(unsafe.Pointer(buf + 1*4))
	c = *(*uint32)(unsafe.Pointer(buf + 2*4))
	d = *(*uint32)(unsafe.Pointer(buf + 3*4))

	a = a + (((d ^ (b & (c ^ d))) + *(*uint32)(unsafe.Pointer(in))) + 0xd76aa478)
	a = ((a << 7) | (a >> (32 - 7)))
	a = a + (b)
	d = d + (((c ^ (a & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + 1*4))) + 0xe8c7b756)
	d = ((d << 12) | (d >> (32 - 12)))
	d = d + (a)
	c = c + (((b ^ (d & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + 2*4))) + uint32(0x242070db))
	c = ((c << 17) | (c >> (32 - 17)))
	c = c + (d)
	b = b + (((a ^ (c & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + 3*4))) + 0xc1bdceee)
	b = ((b << 22) | (b >> (32 - 22)))
	b = b + (c)
	a = a + (((d ^ (b & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + 4*4))) + 0xf57c0faf)
	a = ((a << 7) | (a >> (32 - 7)))
	a = a + (b)
	d = d + (((c ^ (a & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + 5*4))) + uint32(0x4787c62a))
	d = ((d << 12) | (d >> (32 - 12)))
	d = d + (a)
	c = c + (((b ^ (d & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + 6*4))) + 0xa8304613)
	c = ((c << 17) | (c >> (32 - 17)))
	c = c + (d)
	b = b + (((a ^ (c & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + 7*4))) + 0xfd469501)
	b = ((b << 22) | (b >> (32 - 22)))
	b = b + (c)
	a = a + (((d ^ (b & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + 8*4))) + uint32(0x698098d8))
	a = ((a << 7) | (a >> (32 - 7)))
	a = a + (b)
	d = d + (((c ^ (a & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + 9*4))) + 0x8b44f7af)
	d = ((d << 12) | (d >> (32 - 12)))
	d = d + (a)
	c = c + (((b ^ (d & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + 10*4))) + 0xffff5bb1)
	c = ((c << 17) | (c >> (32 - 17)))
	c = c + (d)
	b = b + (((a ^ (c & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + 11*4))) + 0x895cd7be)
	b = ((b << 22) | (b >> (32 - 22)))
	b = b + (c)
	a = a + (((d ^ (b & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + 12*4))) + uint32(0x6b901122))
	a = ((a << 7) | (a >> (32 - 7)))
	a = a + (b)
	d = d + (((c ^ (a & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + 13*4))) + 0xfd987193)
	d = ((d << 12) | (d >> (32 - 12)))
	d = d + (a)
	c = c + (((b ^ (d & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + 14*4))) + 0xa679438e)
	c = ((c << 17) | (c >> (32 - 17)))
	c = c + (d)
	b = b + (((a ^ (c & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + 15*4))) + uint32(0x49b40821))
	b = ((b << 22) | (b >> (32 - 22)))
	b = b + (c)

	a = a + (((c ^ (d & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + 1*4))) + 0xf61e2562)
	a = ((a << 5) | (a >> (32 - 5)))
	a = a + (b)
	d = d + (((b ^ (c & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + 6*4))) + 0xc040b340)
	d = ((d << 9) | (d >> (32 - 9)))
	d = d + (a)
	c = c + (((a ^ (b & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + 11*4))) + uint32(0x265e5a51))
	c = ((c << 14) | (c >> (32 - 14)))
	c = c + (d)
	b = b + (((d ^ (a & (c ^ d))) + *(*uint32)(unsafe.Pointer(in))) + 0xe9b6c7aa)
	b = ((b << 20) | (b >> (32 - 20)))
	b = b + (c)
	a = a + (((c ^ (d & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + 5*4))) + 0xd62f105d)
	a = ((a << 5) | (a >> (32 - 5)))
	a = a + (b)
	d = d + (((b ^ (c & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + 10*4))) + uint32(0x02441453))
	d = ((d << 9) | (d >> (32 - 9)))
	d = d + (a)
	c = c + (((a ^ (b & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + 15*4))) + 0xd8a1e681)
	c = ((c << 14) | (c >> (32 - 14)))
	c = c + (d)
	b = b + (((d ^ (a & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + 4*4))) + 0xe7d3fbc8)
	b = ((b << 20) | (b >> (32 - 20)))
	b = b + (c)
	a = a + (((c ^ (d & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + 9*4))) + uint32(0x21e1cde6))
	a = ((a << 5) | (a >> (32 - 5)))
	a = a + (b)
	d = d + (((b ^ (c & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + 14*4))) + 0xc33707d6)
	d = ((d << 9) | (d >> (32 - 9)))
	d = d + (a)
	c = c + (((a ^ (b & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + 3*4))) + 0xf4d50d87)
	c = ((c << 14) | (c >> (32 - 14)))
	c = c + (d)
	b = b + (((d ^ (a & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + 8*4))) + uint32(0x455a14ed))
	b = ((b << 20) | (b >> (32 - 20)))
	b = b + (c)
	a = a + (((c ^ (d & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + 13*4))) + 0xa9e3e905)
	a = ((a << 5) | (a >> (32 - 5)))
	a = a + (b)
	d = d + (((b ^ (c & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + 2*4))) + 0xfcefa3f8)
	d = ((d << 9) | (d >> (32 - 9)))
	d = d + (a)
	c = c + (((a ^ (b & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + 7*4))) + uint32(0x676f02d9))
	c = ((c << 14) | (c >> (32 - 14)))
	c = c + (d)
	b = b + (((d ^ (a & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + 12*4))) + 0x8d2a4c8a)
	b = ((b << 20) | (b >> (32 - 20)))
	b = b + (c)

	a = a + ((((b ^ c) ^ d) + *(*uint32)(unsafe.Pointer(in + 5*4))) + 0xfffa3942)
	a = ((a << 4) | (a >> (32 - 4)))
	a = a + (b)
	d = d + ((((a ^ b) ^ c) + *(*uint32)(unsafe.Pointer(in + 8*4))) + 0x8771f681)
	d = ((d << 11) | (d >> (32 - 11)))
	d = d + (a)
	c = c + ((((d ^ a) ^ b) + *(*uint32)(unsafe.Pointer(in + 11*4))) + uint32(0x6d9d6122))
	c = ((c << 16) | (c >> (32 - 16)))
	c = c + (d)
	b = b + ((((c ^ d) ^ a) + *(*uint32)(unsafe.Pointer(in + 14*4))) + 0xfde5380c)
	b = ((b << 23) | (b >> (32 - 23)))
	b = b + (c)
	a = a + ((((b ^ c) ^ d) + *(*uint32)(unsafe.Pointer(in + 1*4))) + 0xa4beea44)
	a = ((a << 4) | (a >> (32 - 4)))
	a = a + (b)
	d = d + ((((a ^ b) ^ c) + *(*uint32)(unsafe.Pointer(in + 4*4))) + uint32(0x4bdecfa9))
	d = ((d << 11) | (d >> (32 - 11)))
	d = d + (a)
	c = c + ((((d ^ a) ^ b) + *(*uint32)(unsafe.Pointer(in + 7*4))) + 0xf6bb4b60)
	c = ((c << 16) | (c >> (32 - 16)))
	c = c + (d)
	b = b + ((((c ^ d) ^ a) + *(*uint32)(unsafe.Pointer(in + 10*4))) + 0xbebfbc70)
	b = ((b << 23) | (b >> (32 - 23)))
	b = b + (c)
	a = a + ((((b ^ c) ^ d) + *(*uint32)(unsafe.Pointer(in + 13*4))) + uint32(0x289b7ec6))
	a = ((a << 4) | (a >> (32 - 4)))
	a = a + (b)
	d = d + ((((a ^ b) ^ c) + *(*uint32)(unsafe.Pointer(in))) + 0xeaa127fa)
	d = ((d << 11) | (d >> (32 - 11)))
	d = d + (a)
	c = c + ((((d ^ a) ^ b) + *(*uint32)(unsafe.Pointer(in + 3*4))) + 0xd4ef3085)
	c = ((c << 16) | (c >> (32 - 16)))
	c = c + (d)
	b = b + ((((c ^ d) ^ a) + *(*uint32)(unsafe.Pointer(in + 6*4))) + uint32(0x04881d05))
	b = ((b << 23) | (b >> (32 - 23)))
	b = b + (c)
	a = a + ((((b ^ c) ^ d) + *(*uint32)(unsafe.Pointer(in + 9*4))) + 0xd9d4d039)
	a = ((a << 4) | (a >> (32 - 4)))
	a = a + (b)
	d = d + ((((a ^ b) ^ c) + *(*uint32)(unsafe.Pointer(in + 12*4))) + 0xe6db99e5)
	d = ((d << 11) | (d >> (32 - 11)))
	d = d + (a)
	c = c + ((((d ^ a) ^ b) + *(*uint32)(unsafe.Pointer(in + 15*4))) + uint32(0x1fa27cf8))
	c = ((c << 16) | (c >> (32 - 16)))
	c = c + (d)
	b = b + ((((c ^ d) ^ a) + *(*uint32)(unsafe.Pointer(in + 2*4))) + 0xc4ac5665)
	b = ((b << 23) | (b >> (32 - 23)))
	b = b + (c)

	a = a + (((c ^ (b | ^d)) + *(*uint32)(unsafe.Pointer(in))) + 0xf4292244)
	a = ((a << 6) | (a >> (32 - 6)))
	a = a + (b)
	d = d + (((b ^ (a | ^c)) + *(*uint32)(unsafe.Pointer(in + 7*4))) + uint32(0x432aff97))
	d = ((d << 10) | (d >> (32 - 10)))
	d = d + (a)
	c = c + (((a ^ (d | ^b)) + *(*uint32)(unsafe.Pointer(in + 14*4))) + 0xab9423a7)
	c = ((c << 15) | (c >> (32 - 15)))
	c = c + (d)
	b = b + (((d ^ (c | ^a)) + *(*uint32)(unsafe.Pointer(in + 5*4))) + 0xfc93a039)
	b = ((b << 21) | (b >> (32 - 21)))
	b = b + (c)
	a = a + (((c ^ (b | ^d)) + *(*uint32)(unsafe.Pointer(in + 12*4))) + uint32(0x655b59c3))
	a = ((a << 6) | (a >> (32 - 6)))
	a = a + (b)
	d = d + (((b ^ (a | ^c)) + *(*uint32)(unsafe.Pointer(in + 3*4))) + 0x8f0ccc92)
	d = ((d << 10) | (d >> (32 - 10)))
	d = d + (a)
	c = c + (((a ^ (d | ^b)) + *(*uint32)(unsafe.Pointer(in + 10*4))) + 0xffeff47d)
	c = ((c << 15) | (c >> (32 - 15)))
	c = c + (d)
	b = b + (((d ^ (c | ^a)) + *(*uint32)(unsafe.Pointer(in + 1*4))) + 0x85845dd1)
	b = ((b << 21) | (b >> (32 - 21)))
	b = b + (c)
	a = a + (((c ^ (b | ^d)) + *(*uint32)(unsafe.Pointer(in + 8*4))) + uint32(0x6fa87e4f))
	a = ((a << 6) | (a >> (32 - 6)))
	a = a + (b)
	d = d + (((b ^ (a | ^c)) + *(*uint32)(unsafe.Pointer(in + 15*4))) + 0xfe2ce6e0)
	d = ((d << 10) | (d >> (32 - 10)))
	d = d + (a)
	c = c + (((a ^ (d | ^b)) + *(*uint32)(unsafe.Pointer(in + 6*4))) + 0xa3014314)
	c = ((c << 15) | (c >> (32 - 15)))
	c = c + (d)
	b = b + (((d ^ (c | ^a)) + *(*uint32)(unsafe.Pointer(in + 13*4))) + uint32(0x4e0811a1))
	b = ((b << 21) | (b >> (32 - 21)))
	b = b + (c)
	a = a + (((c ^ (b | ^d)) + *(*uint32)(unsafe.Pointer(in + 4*4))) + 0xf7537e82)
	a = ((a << 6) | (a >> (32 - 6)))
	a = a + (b)
	d = d + (((b ^ (a | ^c)) + *(*uint32)(unsafe.Pointer(in + 11*4))) + 0xbd3af235)
	d = ((d << 10) | (d >> (32 - 10)))
	d = d + (a)
	c = c + (((a ^ (d | ^b)) + *(*uint32)(unsafe.Pointer(in + 2*4))) + uint32(0x2ad7d2bb))
	c = ((c << 15) | (c >> (32 - 15)))
	c = c + (d)
	b = b + (((d ^ (c | ^a)) + *(*uint32)(unsafe.Pointer(in + 9*4))) + 0xeb86d391)
	b = ((b << 21) | (b >> (32 - 21)))
	b = b + (c)

	*(*uint32)(unsafe.Pointer(buf)) += (a)
	*(*uint32)(unsafe.Pointer(buf + 1*4)) += (b)
	*(*uint32)(unsafe.Pointer(buf + 2*4)) += (c)
	*(*uint32)(unsafe.Pointer(buf + 3*4)) += (d)
}

// Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
// initialization constants.
func MD5Init(tls *libc.TLS, ctx uintptr) { /* test_md5.c:180:13: */
	(*MD5Context)(unsafe.Pointer(ctx)).FisInit = 1
	*(*uint32)(unsafe.Pointer((ctx + 4 /* &.buf */))) = uint32(0x67452301)
	*(*uint32)(unsafe.Pointer((ctx + 4 /* &.buf */) + 1*4)) = 0xefcdab89
	*(*uint32)(unsafe.Pointer((ctx + 4 /* &.buf */) + 2*4)) = 0x98badcfe
	*(*uint32)(unsafe.Pointer((ctx + 4 /* &.buf */) + 3*4)) = uint32(0x10325476)
	*(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */))) = uint32(0)
	*(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */) + 1*4)) = uint32(0)
}

// Update context to reflect the concatenation of another buffer full
// of bytes.
func MD5Update(tls *libc.TLS, ctx uintptr, buf uintptr, len uint32) { /* test_md5.c:195:6: */
	var t uint32

	// Update bitcount

	t = *(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */)))
	if (libc.AssignPtrUint32((ctx + 20 /* &.bits */), (t + (len << 3)))) < t {
		*(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */) + 1*4))++
	} // Carry from low to high
	*(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */) + 1*4)) += (len >> 29)

	t = ((t >> 3) & uint32(0x3f)) // Bytes already in shsInfo->data

	// Handle any leading odd-sized chunks

	if t != 0 {
		var p uintptr = (ctx + 28 /* &.in */ + uintptr(t))

		t = (uint32(64) - t)
		if len < t {
			libc.Xmemcpy(tls, p, buf, len)
			return
		}
		libc.Xmemcpy(tls, p, buf, t)
		byteReverse(tls, ctx+28 /* &.in */, uint32(16))
		MD5Transform(tls, ctx+4 /* &.buf */, ctx+28 /* &.in */)
		buf += uintptr(t)
		len = len - (t)
	}

	// Process data in 64-byte chunks

	for len >= uint32(64) {
		libc.Xmemcpy(tls, ctx+28 /* &.in */, buf, uint32(64))
		byteReverse(tls, ctx+28 /* &.in */, uint32(16))
		MD5Transform(tls, ctx+4 /* &.buf */, ctx+28 /* &.in */)
		buf += uintptr(64)
		len = len - (uint32(64))
	}

	// Handle any remaining bytes of data.

	libc.Xmemcpy(tls, ctx+28 /* &.in */, buf, len)
}

// Final wrapup - pad to 64-byte boundary with the bit pattern
// 1 0* (64-bit count of bits processed, MSB-first)
func MD5Final(tls *libc.TLS, digest uintptr, ctx uintptr) { /* test_md5.c:243:13: */
	var count uint32
	var p uintptr

	// Compute number of bytes mod 64
	count = ((*(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */))) >> 3) & uint32(0x3F))

	// Set the first char of padding to 0x80.  This is safe since there is
	//            always at least one byte free
	p = ((ctx + 28 /* &.in */) + uintptr(count))
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(0x80)

	// Bytes of padding needed to make 64 bytes
	count = ((uint32(64 - 1)) - count)

	// Pad out to 56 mod 64
	if count < uint32(8) {
		// Two lots of padding:  Pad the first block to 64 bytes
		libc.Xmemset(tls, p, 0, count)
		byteReverse(tls, ctx+28 /* &.in */, uint32(16))
		MD5Transform(tls, ctx+4 /* &.buf */, ctx+28 /* &.in */)

		// Now fill the next block with 56 bytes
		libc.Xmemset(tls, ctx+28 /* &.in */, 0, uint32(56))
	} else {
		// Pad block to 56 bytes
		libc.Xmemset(tls, p, 0, (count - uint32(8)))
	}
	byteReverse(tls, ctx+28 /* &.in */, uint32(14))

	// Append length in bits and transform
	libc.Xmemcpy(tls, ((ctx + 28 /* &.in */) + uintptr((14 * 4))), ctx+20 /* &.bits */, uint32(8))

	MD5Transform(tls, ctx+4 /* &.buf */, ctx+28 /* &.in */)
	byteReverse(tls, ctx+4 /* &.buf */, uint32(4))
	libc.Xmemcpy(tls, digest, ctx+4 /* &.buf */, uint32(16))
}

// Convert a 128-bit MD5 digest into a 32-digit base-16 number.
func MD5DigestToBase16(tls *libc.TLS, digest uintptr, zBuf uintptr) { /* test_md5.c:284:13: */
	var i int32
	var j int32

	for j = libc.AssignInt32(&i, 0); i < 16; i++ {
		var a int32 = int32(*(*uint8)(unsafe.Pointer(digest + uintptr(i))))
		*(*int8)(unsafe.Pointer(zBuf + uintptr(libc.PostIncInt32(&j, 1)))) = zEncode[((a >> 4) & 0xf)]
		*(*int8)(unsafe.Pointer(zBuf + uintptr(libc.PostIncInt32(&j, 1)))) = zEncode[(a & 0xf)]
	}
	*(*int8)(unsafe.Pointer(zBuf + uintptr(j))) = int8(0)
}

var zEncode = *(*[17]int8)(unsafe.Pointer(ts + 30627 /* "0123456789abcdef" */)) /* test_md5.c:285:21 */

// Convert a 128-bit MD5 digest into sequency of eight 5-digit integers
// each representing 16 bits of the digest and separated from each
// other by a "-" character.
func MD5DigestToBase10x8(tls *libc.TLS, digest uintptr, zDigest uintptr) { /* test_md5.c:302:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var j int32
	var x uint32
	for i = libc.AssignInt32(&j, 0); i < 16; i = i + (2) {
		x = (uint32((int32(*(*uint8)(unsafe.Pointer(digest + uintptr(i)))) * 256) + int32(*(*uint8)(unsafe.Pointer(digest + uintptr((i + 1)))))))
		if i > 0 {
			*(*int8)(unsafe.Pointer(zDigest + uintptr(libc.PostIncInt32(&j, 1)))) = int8('-')
		}
		sqlite3.Xsqlite3_snprintf(tls, (50 - j), (zDigest + uintptr(j)), ts+33937 /* "%05u" */, libc.VaList(bp, x))
		j = j + (5)
	}
	*(*int8)(unsafe.Pointer(zDigest + uintptr(j))) = int8(0)
}

// A TCL command for md5.  The argument is the text to be hashed.  The
// Result is the hash in base64.
func md5_cmd(tls *libc.TLS, cd uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test_md5.c:318:26: */
	bp := tls.Alloc(206)
	defer tls.Free(206)

	// var ctx MD5Context at bp+48, 92

	// var digest [16]uint8 at bp+140, 16

	// var zBuf [50]int8 at bp+156, 50

	var converter uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+14992 /* " TEXT\"" */, uintptr(0)))
		return TCL_ERROR
	}
	MD5Init(tls, bp+48 /* &ctx */)
	MD5Update(tls, bp+48 /* &ctx */, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	MD5Final(tls, bp+140 /* &digest[0] */, bp+48 /* &ctx */)
	converter = cd
	(*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(&converter)))(tls, bp+140 /* &digest[0] */, bp+156 /* &zBuf[0] */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+156 /* &zBuf[0] */, uintptr(0)))
	return TCL_OK
}

// A TCL command to take the md5 hash of a file.  The argument is the
// name of the file.
func md5file_cmd(tls *libc.TLS, cd uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test_md5.c:347:26: */
	bp := tls.Alloc(10428)
	defer tls.Free(10428)

	var in uintptr
	var ofst int32
	var amt int32
	// var ctx MD5Context at bp+80, 92

	var converter uintptr
	// var digest [16]uint8 at bp+10412, 16

	// var zBuf [10240]int8 at bp+172, 10240

	if (argc != 2) && (argc != 4) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+33942 /* " FILENAME [OFFSE..." */, uintptr(0)))
		return TCL_ERROR
	}
	if argc == 4 {
		ofst = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
		amt = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
	} else {
		ofst = 0
		amt = 2147483647
	}
	in = libc.Xfopen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+4263 /* "rb" */)
	if in == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+33966 /* "unable to open f..." */, *(*uintptr)(unsafe.Pointer(argv + 1*4)),
			ts+33988 /* "\" for reading" */, uintptr(0)))
		return TCL_ERROR
	}
	libc.Xfseek(tls, in, int32(ofst), SEEK_SET)
	MD5Init(tls, bp+80 /* &ctx */)
	for amt > 0 {
		var n int32
		n = int32(libc.Xfread(tls, bp+172 /* &zBuf[0] */, uint32(1), func() uint32 {
			if uint32(unsafe.Sizeof([10240]int8{})) <= uint32(amt) {
				return uint32(unsafe.Sizeof([10240]int8{}))
			}
			return uint32(amt)
		}(), in))
		if n <= 0 {
			break
		}
		MD5Update(tls, bp+80 /* &ctx */, bp+172 /* zBuf */, uint32(n))
		amt = amt - (n)
	}
	libc.Xfclose(tls, in)
	MD5Final(tls, bp+10412 /* &digest[0] */, bp+80 /* &ctx */)
	converter = cd
	(*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(&converter)))(tls, bp+10412 /* &digest[0] */, bp+172 /* &zBuf[0] */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+172 /* &zBuf[0] */, uintptr(0)))
	return TCL_OK
}

// Register the four new TCL commands for generating MD5 checksums
// with the TCL interpreter.
func Md5_Init(tls *libc.TLS, interp uintptr) int32 { /* test_md5.c:400:5: */
	tcl.XTcl_CreateCommand(tls, interp, ts+34002 /* "md5" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase16})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+34006 /* "md5-10x8" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase10x8})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+34015 /* "md5file" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5file_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase16})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+34023 /* "md5file-10x8" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5file_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase10x8})), uintptr(0))
	return TCL_OK
}

// During testing, the special md5sum() aggregate function is available.
// inside SQLite.  The following routines implement that function.
func md5step(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_md5.c:416:13: */
	var p uintptr
	var i int32
	if argc < 1 {
		return
	}
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(MD5Context{})))
	if p == uintptr(0) {
		return
	}
	if !((*MD5Context)(unsafe.Pointer(p)).FisInit != 0) {
		MD5Init(tls, p)
	}
	for i = 0; i < argc; i++ {
		var zData uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
		if zData != 0 {
			MD5Update(tls, p, zData, uint32(int32(libc.Xstrlen(tls, zData))))
		}
	}
}

func md5finalize(tls *libc.TLS, context uintptr) { /* test_md5.c:432:13: */
	bp := tls.Alloc(49)
	defer tls.Free(49)

	var p uintptr
	// var digest [16]uint8 at bp, 16

	// var zBuf [33]int8 at bp+16, 33

	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(MD5Context{})))
	MD5Final(tls, bp /* &digest[0] */, p)
	MD5DigestToBase16(tls, bp /* &digest[0] */, bp+16 /* &zBuf[0] */)
	sqlite3.Xsqlite3_result_text(tls, context, bp+16 /* &zBuf[0] */, -1, libc.UintptrFromInt32(-1))
}

func Md5_Register(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pThunk uintptr) int32 { /* test_md5.c:441:5: */
	var rc int32 = sqlite3.Xsqlite3_create_function(tls, db, ts+34036 /* "md5sum" */, -1, SQLITE_UTF8, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{md5step})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{md5finalize})))
	sqlite3.Xsqlite3_overload_function(tls, db, ts+34036 /* "md5sum" */, -1) // To exercise this API
	return rc
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// These should be defined to be the same as the values in
// sqliteInt.h.  They are defined separately here so that
// the multiplex VFS shim can be built as a loadable
// module.

// Maximum chunk number

// First chunk for rollback journal files

//*********************** Shim Definitions *****************************

// This is the limit on the chunk size.  It may be changed by calling
// the xFileControl() interface.  It will be rounded up to a
// multiple of MAX_PAGE_SIZE.  We default it here to 2GiB less 64KiB.

// This used to be the default limit on number of chunks, but
// it is no longer enforced. There is currently no limit to the
// number of chunks.
//
// May be changed by calling the xFileControl() interface.

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type multiplexGroup1 = struct {
	FaReal     uintptr
	FnReal     int32
	FzName     uintptr
	FnName     int32
	Fflags     int32
	FszChunk   uint32
	FbEnabled  uint8
	FbTruncate uint8
	_          [2]byte
} /* test_multiplex.c:106:9 */

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// These should be defined to be the same as the values in
// sqliteInt.h.  They are defined separately here so that
// the multiplex VFS shim can be built as a loadable
// module.

// Maximum chunk number

// First chunk for rollback journal files

//*********************** Shim Definitions *****************************

// This is the limit on the chunk size.  It may be changed by calling
// the xFileControl() interface.  It will be rounded up to a
// multiple of MAX_PAGE_SIZE.  We default it here to 2GiB less 64KiB.

// This used to be the default limit on number of chunks, but
// it is no longer enforced. There is currently no limit to the
// number of chunks.
//
// May be changed by calling the xFileControl() interface.

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type multiplexGroup = multiplexGroup1 /* test_multiplex.c:106:31 */
type multiplexConn1 = struct {
	Fbase   sqlite3_file
	FpGroup uintptr
} /* test_multiplex.c:107:9 */

type multiplexConn = multiplexConn1 /* test_multiplex.c:107:30 */

// A "multiplex group" is a collection of files that collectively
// makeup a single SQLite DB file.  This allows the size of the DB
// to exceed the limits imposed by the file system.
//
// There is an instance of the following object for each defined multiplex
// group.
type multiplexReal = struct {
	Fp uintptr
	Fz uintptr
} /* test_multiplex.c:106:9 */

//************************ Global Variables *********************************
// All global variables used by this file are containing within the following
// gMultiplex structure.
var gMultiplex struct {
	FpOrigVfs      uintptr
	FsThisVfs      sqlite3_vfs
	FsIoMethodsV1  sqlite3_io_methods
	FsIoMethodsV2  sqlite3_io_methods
	FisInitialized int32
} /* test_multiplex.c:176:3: */

//************************ Utility Routines ********************************
// Compute a string length that is limited to what can be stored in
// lower 30 bits of a 32-bit signed integer.
//
// The value returned will never be negative.  Nor will it ever be greater
// than the actual length of the string.  For very long strings (greater
// than 1GiB) the value returned might be less than the true string length.
func multiplexStrlen30(tls *libc.TLS, z uintptr) int32 { /* test_multiplex.c:187:12: */
	var z2 uintptr = z
	if z == uintptr(0) {
		return 0
	}
	for *(*int8)(unsafe.Pointer(z2)) != 0 {
		z2++
	}
	return (0x3fffffff & ((int32(z2) - int32(z)) / 1))
}

// Generate the file-name for chunk iChunk of the group with base name
// zBase. The file-name is written to buffer zOut before returning. Buffer
// zOut must be allocated by the caller so that it is at least (nBase+5)
// bytes in size, where nBase is the length of zBase, not including the
// nul-terminator.
//
// If iChunk is 0 (or 400 - the number for the first journal file chunk),
// the output is a copy of the input string. Otherwise, if
// SQLITE_ENABLE_8_3_NAMES is not defined or the input buffer does not contain
// a "." character, then the output is a copy of the input string with the
// three-digit zero-padded decimal representation if iChunk appended to it.
// For example:
//
//   zBase="test.db", iChunk=4  ->  zOut="test.db004"
//
// Or, if SQLITE_ENABLE_8_3_NAMES is defined and the input buffer contains
// a "." character, then everything after the "." is replaced by the
// three-digit representation of iChunk.
//
//   zBase="test.db", iChunk=4  ->  zOut="test.004"
//
// The output buffer string is terminated by 2 0x00 bytes. This makes it safe
// to pass to sqlite3_uri_parameter() and similar.
func multiplexFilename(tls *libc.TLS, zBase uintptr, nBase int32, flags int32, iChunk int32, zOut uintptr) { /* test_multiplex.c:219:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var n int32 = nBase
	libc.Xmemcpy(tls, zOut, zBase, (uint32(n + 1)))
	if (iChunk != 0) && (iChunk <= MX_CHUNK_NUMBER) {
		sqlite3.Xsqlite3_snprintf(tls, 4, (zOut + uintptr(n)), ts+34043 /* "%03d" */, libc.VaList(bp, iChunk))
		n = n + (3)
	}

	*(*int8)(unsafe.Pointer(zOut + uintptr((n + 1)))) = int8(0)
}

// Compute the filename for the iChunk-th chunk
func multiplexSubFilename(tls *libc.TLS, pGroup uintptr, iChunk int32) int32 { /* test_multiplex.c:256:12: */
	if iChunk >= (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal {
		var p uintptr
		p = sqlite3.Xsqlite3_realloc64(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal, (uint64((uint32(iChunk + 1)) * uint32(unsafe.Sizeof(multiplexReal{})))))
		if p == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, (p + uintptr((*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal)*8), 0, (uint32(unsafe.Sizeof(multiplexReal{})) * (uint32((iChunk + 1) - (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal))))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal = p
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal = (iChunk + 1)
	}
	if ((*multiplexGroup)(unsafe.Pointer(pGroup)).FzName != 0) && ((*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz == uintptr(0)) {
		var z uintptr
		var n int32 = (*multiplexGroup)(unsafe.Pointer(pGroup)).FnName
		z = sqlite3.Xsqlite3_malloc64(tls, (uint64(n + 5)))
		if z == uintptr(0) {
			return SQLITE_NOMEM
		}
		multiplexFilename(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FzName, (*multiplexGroup)(unsafe.Pointer(pGroup)).FnName, (*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags, iChunk, z)
		(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*8)).Fz = sqlite3.Xsqlite3_create_filename(tls, z, ts+489 /* "" */, ts+489 /* "" */, 0, uintptr(0))
		sqlite3.Xsqlite3_free(tls, z)
		if (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz == uintptr(0) {
			return SQLITE_NOMEM
		}
	}
	return SQLITE_OK
}

// Translate an sqlite3_file* that is really a multiplexGroup* into
// the sqlite3_file* for the underlying original VFS.
//
// For chunk 0, the pGroup->flags determines whether or not a new file
// is created if it does not already exist.  For chunks 1 and higher, the
// file is created only if createFlag is 1.
func multiplexSubOpen(tls *libc.TLS, pGroup uintptr, iChunk int32, rc uintptr, pOutFlags uintptr, createFlag int32) uintptr { /* test_multiplex.c:289:21: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pSubOpen uintptr = uintptr(0)
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs // Real VFS

	*(*int32)(unsafe.Pointer(rc)) = multiplexSubFilename(tls, pGroup, iChunk)
	if ((*(*int32)(unsafe.Pointer(rc))) == SQLITE_OK) && ((libc.AssignUintptr(&pSubOpen, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fp)) == uintptr(0)) {
		var flags int32
		// var bExists int32 at bp+16, 4

		flags = (*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags
		if createFlag != 0 {
			flags = flags | (SQLITE_OPEN_CREATE)
		} else if iChunk == 0 {
			// Fall through
		} else if (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz == uintptr(0) {
			return uintptr(0)
		} else {
			*(*int32)(unsafe.Pointer(rc)) = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 32 /* &.xAccess */))))(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz,
				SQLITE_ACCESS_EXISTS, bp+16 /* &bExists */)
			if (*(*int32)(unsafe.Pointer(rc)) != 0) || !(*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) != 0) {
				if *(*int32)(unsafe.Pointer(rc)) != 0 {
					sqlite3.Xsqlite3_log(tls, *(*int32)(unsafe.Pointer(rc)), ts+34048, /* "multiplexor.xAcc..." */
						libc.VaList(bp, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz))
				}
				return uintptr(0)
			}
			flags = flags & (libc.CplInt32(SQLITE_OPEN_CREATE))
		}
		pSubOpen = sqlite3.Xsqlite3_malloc64(tls, uint64((*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FszOsFile))
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(rc)) = (SQLITE_IOERR | (int32(12) << 8))
			return uintptr(0)
		}
		(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*8)).Fp = pSubOpen
		*(*int32)(unsafe.Pointer(rc)) = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 24 /* &.xOpen */))))(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz, pSubOpen,
			flags, pOutFlags)
		if (*(*int32)(unsafe.Pointer(rc))) != SQLITE_OK {
			sqlite3.Xsqlite3_log(tls, *(*int32)(unsafe.Pointer(rc)), ts+34082, /* "multiplexor.xOpe..." */
				libc.VaList(bp+8, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz))
			sqlite3.Xsqlite3_free(tls, pSubOpen)
			(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*8)).Fp = uintptr(0)
			return uintptr(0)
		}
	}
	return pSubOpen
}

// Return the size, in bytes, of chunk number iChunk.  If that chunk
// does not exist, then return 0.  This function does not distingish between
// non-existant files and zero-length files.
func multiplexSubSize(tls *libc.TLS, pGroup uintptr, iChunk int32, rc uintptr) sqlite3_int64 { /* test_multiplex.c:357:22: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pSub uintptr
	*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)) = int64(0)

	if *(*int32)(unsafe.Pointer(rc)) != 0 {
		return int64(0)
	}
	pSub = multiplexSubOpen(tls, pGroup, iChunk, rc, uintptr(0), 0)
	if pSub == uintptr(0) {
		return int64(0)
	}
	*(*int32)(unsafe.Pointer(rc)) = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSub)).FpMethods + 24 /* &.xFileSize */))))(tls, pSub, bp /* &sz */)
	return *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */))
}

// This is the implementation of the multiplex_control() SQL function.
func multiplexControlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_multiplex.c:375:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32 = SQLITE_OK
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var op int32 = 0
	// var iVal int32 at bp, 4

	if !(db != 0) || (argc != 2) {
		rc = SQLITE_ERROR
	} else {
		// extract params
		op = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
		*(*int32)(unsafe.Pointer(bp /* iVal */)) = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		// map function op to file_control op
		switch op {
		case 1:
			op = MULTIPLEX_CTRL_ENABLE
			break
			fallthrough
		case 2:
			op = MULTIPLEX_CTRL_SET_CHUNK_SIZE
			break
			fallthrough
		case 3:
			op = MULTIPLEX_CTRL_SET_MAX_CHUNKS
			break
			fallthrough
		default:
			rc = SQLITE_NOTFOUND
			break
		}
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_file_control(tls, db, uintptr(0), op, bp /* &iVal */)
	}
	sqlite3.Xsqlite3_result_error_code(tls, context, rc)
}

// This is the entry point to register the auto-extension for the
// multiplex_control() function.
func multiplexFuncInit(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* test_multiplex.c:417:12: */
	var rc int32
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+34114 /* "multiplex_contro..." */, 2, SQLITE_ANY,
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{multiplexControlFunc})), uintptr(0), uintptr(0))
	return rc
}

// Close a single sub-file in the connection group.
func multiplexSubClose(tls *libc.TLS, pGroup uintptr, iChunk int32, pOrigVfs uintptr) { /* test_multiplex.c:431:13: */
	var pSubOpen uintptr = (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*8)).Fp
	if pSubOpen != 0 {
		(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 4 /* &.xClose */))))(tls, pSubOpen)
		if (pOrigVfs != 0) && ((*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz != 0) {
			(*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 28 /* &.xDelete */))))(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz, 0)
		}
		sqlite3.Xsqlite3_free(tls, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fp)
	}
	sqlite3.Xsqlite3_free_filename(tls, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz)
	libc.Xmemset(tls, ((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*8), 0, uint32(unsafe.Sizeof(multiplexReal{})))
}

// Deallocate memory held by a multiplexGroup
func multiplexFreeComponents(tls *libc.TLS, pGroup uintptr) { /* test_multiplex.c:451:13: */
	var i int32
	for i = 0; i < (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal; i++ {
		multiplexSubClose(tls, pGroup, i, uintptr(0))
	}
	sqlite3.Xsqlite3_free(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal)
	(*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal = uintptr(0)
	(*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal = 0
}

//************************ VFS Method Wrappers ****************************

// This is the xOpen method used for the "multiplex" VFS.
//
// Most of the work is done by the underlying original VFS.  This method
// simply links the new file into the appropriate multiplex group if it is a
// file that needs to be tracked.
func multiplexOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pConn uintptr, flags int32, pOutFlags uintptr) int32 { /* test_multiplex.c:469:12: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK // Result code
	var pMultiplexOpen uintptr                         // The new multiplex file descriptor
	var pGroup uintptr = uintptr(0)                    // Corresponding multiplexGroup object
	var pSubOpen uintptr = uintptr(0)                  // Real file descriptor
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs        // Real VFS
	var nName int32 = 0
	var sz int32 = 0
	var zToFree uintptr = uintptr(0)

	_ = pVfs
	libc.Xmemset(tls, pConn, 0, uint32((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile))

	// We need to create a group structure and manage
	// access to this group of files.
	pMultiplexOpen = pConn

	if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
		// allocate space for group
		if zName != 0 {
			nName = multiplexStrlen30(tls, zName)
		} else {
			nName = 0
		}
		sz = (int32((uint32(unsafe.Sizeof(multiplexGroup{})) + // multiplexGroup
			uint32(nName)) + uint32(1))) // zName
		pGroup = sqlite3.Xsqlite3_malloc64(tls, uint64(sz))
		if pGroup == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_NOMEM
		}
	}

	if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
		var zUri uintptr
		if (flags & SQLITE_OPEN_URI) != 0 {
			zUri = zName
		} else {
			zUri = uintptr(0)
		}
		// assign pointers to extra space allocated
		libc.Xmemset(tls, pGroup, 0, uint32(sz))
		(*multiplexConn)(unsafe.Pointer(pMultiplexOpen)).FpGroup = pGroup
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = libc.Uint8(libc.Uint8FromInt32(-1))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(sqlite3.Xsqlite3_uri_boolean(tls, zUri, ts+17962, /* "truncate" */
			(libc.Bool32((flags & SQLITE_OPEN_MAIN_DB) == 0))))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = uint32(int32(sqlite3.Xsqlite3_uri_int64(tls, zUri, ts+34132, /* "chunksize" */
			int64(SQLITE_MULTIPLEX_CHUNK_SIZE))))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = (((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk + uint32(0xffff)) & libc.Uint32FromInt32(libc.CplInt32(0xffff)))
		if zName != 0 {
			var p uintptr = (pGroup + 1*28)
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FzName = p
			libc.Xmemcpy(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FzName, zName, (uint32(nName + 1)))
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FnName = nName
		}
		if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled != 0 {
			for (uint32(sqlite3.Xsqlite3PendingByte) % (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk) >= ((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk - uint32(65536)) {
				*(*uint32)(unsafe.Pointer(pGroup + 20 /* &.szChunk */)) += (uint32(65536))
			}
		}
		(*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags = (flags & libc.CplInt32(SQLITE_OPEN_URI))
		*(*int32)(unsafe.Pointer(bp /* rc */)) = multiplexSubFilename(tls, pGroup, 1)
		if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
			pSubOpen = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, pOutFlags, 0)
			if (pSubOpen == uintptr(0)) && (*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) {
				*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_CANTOPEN
			}
		}
		if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
			// var sz64 sqlite3_int64 at bp+8, 8

			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 24 /* &.xFileSize */))))(tls, pSubOpen, bp+8 /* &sz64 */)
			if (*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (zName != 0) {
				// var bExists int32 at bp+16, 4

				if (flags & SQLITE_OPEN_SUPER_JOURNAL) != 0 {
					(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(0)
				} else if *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) == int64(0) {
					if (flags & SQLITE_OPEN_MAIN_JOURNAL) != 0 {
						// If opening a main journal file and the first chunk is zero
						// bytes in size, delete any subsequent chunks from the
						// file-system.
						var iChunk int32 = 1
						for ok := true; ok; ok = ((*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) != 0)) {
							*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 32 /* &.xAccess */))))(tls, pOrigVfs,
								(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz, SQLITE_ACCESS_EXISTS, bp+16 /* &bExists */)
							if (*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) != 0) {
								*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 28 /* &.xDelete */))))(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz, 0)
								if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
									*(*int32)(unsafe.Pointer(bp /* rc */)) = multiplexSubFilename(tls, pGroup, libc.PreIncInt32(&iChunk, 1))
								}
							}
						}
					}
				} else {
					// If the first overflow file exists and if the size of the main file
					// is different from the chunk size, that means the chunk size is set
					// set incorrectly.  So fix it.
					//
					// Or, if the first overflow file does not exist and the main file is
					// larger than the chunk size, that means the chunk size is too small.
					// But we have no way of determining the intended chunk size, so
					// just disable the multiplexor all togethre.
					*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 32 /* &.xAccess */))))(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+1*8)).Fz,
						SQLITE_ACCESS_EXISTS, bp+16 /* &bExists */)
					*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) = (libc.Bool32(multiplexSubSize(tls, pGroup, 1, bp /* &rc */) > int64(0)))
					if ((((*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) != 0)) && (*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) == (*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) & int64(0xffff0000)))) && (*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) > int64(0))) &&
						(*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) != sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = uint32(int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */))))
					} else if ((*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && !(*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) != 0)) && (*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) > sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(0)
					}
				}
			}
		}

		if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
			if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FiVersion == 1 {
				(*sqlite3_file)(unsafe.Pointer(pConn)).FpMethods = (uintptr(unsafe.Pointer(&gMultiplex)) + 92 /* &.sIoMethodsV1 */)
			} else {
				(*sqlite3_file)(unsafe.Pointer(pConn)).FpMethods = (uintptr(unsafe.Pointer(&gMultiplex)) + 168 /* &.sIoMethodsV2 */)
			}
		} else {
			multiplexFreeComponents(tls, pGroup)
			sqlite3.Xsqlite3_free(tls, pGroup)
		}
	}
	sqlite3.Xsqlite3_free(tls, zToFree)
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// This is the xDelete method used for the "multiplex" VFS.
// It attempts to delete the filename specified.
func multiplexDelete(tls *libc.TLS, pVfs uintptr, zName uintptr, syncDir int32) int32 { /* test_multiplex.c:611:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs // Real VFS
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 28 /* &.xDelete */))))(tls, pOrigVfs, zName, syncDir)
	if rc == SQLITE_OK {
		// If the main chunk was deleted successfully, also delete any subsequent
		// chunks - starting with the last (highest numbered).
		var nName int32 = int32(libc.Xstrlen(tls, zName))
		var z uintptr
		z = sqlite3.Xsqlite3_malloc64(tls, (uint64(nName + 5)))
		if z == uintptr(0) {
			rc = (SQLITE_IOERR | (int32(12) << 8))
		} else {
			var iChunk int32 = 0
			// var bExists int32 at bp, 4

			for ok := true; ok; ok = ((rc == SQLITE_OK) && (*(*int32)(unsafe.Pointer(bp /* bExists */)) != 0)) {
				multiplexFilename(tls, zName, nName, SQLITE_OPEN_MAIN_JOURNAL, libc.PreIncInt32(&iChunk, 1), z)
				rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 32 /* &.xAccess */))))(tls, pOrigVfs, z, SQLITE_ACCESS_EXISTS, bp /* &bExists */)
			}
			for (rc == SQLITE_OK) && (iChunk > 1) {
				multiplexFilename(tls, zName, nName, SQLITE_OPEN_MAIN_JOURNAL, libc.PreDecInt32(&iChunk, 1), z)
				rc = (*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 28 /* &.xDelete */))))(tls, pOrigVfs, z, syncDir)
			}
			if rc == SQLITE_OK {
				iChunk = 0
				for ok1 := true; ok1; ok1 = ((rc == SQLITE_OK) && (*(*int32)(unsafe.Pointer(bp /* bExists */)) != 0)) {
					multiplexFilename(tls, zName, nName, SQLITE_OPEN_WAL, libc.PreIncInt32(&iChunk, 1), z)
					rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 32 /* &.xAccess */))))(tls, pOrigVfs, z, SQLITE_ACCESS_EXISTS, bp /* &bExists */)
				}
				for (rc == SQLITE_OK) && (iChunk > 1) {
					multiplexFilename(tls, zName, nName, SQLITE_OPEN_WAL, libc.PreDecInt32(&iChunk, 1), z)
					rc = (*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 28 /* &.xDelete */))))(tls, pOrigVfs, z, syncDir)
				}
			}
		}
		sqlite3.Xsqlite3_free(tls, z)
	}
	return rc
}

func multiplexAccess(tls *libc.TLS, a uintptr, b uintptr, c int32, d uintptr) int32 { /* test_multiplex.c:656:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 32 /* &.xAccess */))))(tls, gMultiplex.FpOrigVfs, b, c, d)
}

func multiplexFullPathname(tls *libc.TLS, a uintptr, b uintptr, c int32, d uintptr) int32 { /* test_multiplex.c:659:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 36 /* &.xFullPathname */))))(tls, gMultiplex.FpOrigVfs, b, c, d)
}

func multiplexDlOpen(tls *libc.TLS, a uintptr, b uintptr) uintptr { /* test_multiplex.c:662:13: */
	return (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((gMultiplex.FpOrigVfs + 40 /* &.xDlOpen */))))(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexDlError(tls *libc.TLS, a uintptr, b int32, c uintptr) { /* test_multiplex.c:665:13: */
	(*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer((gMultiplex.FpOrigVfs + 44 /* &.xDlError */))))(tls, gMultiplex.FpOrigVfs, b, c)
}

func multiplexDlSym(tls *libc.TLS, a uintptr, b uintptr, c uintptr) uintptr { /* test_multiplex.c:668:13: */
	return (*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((gMultiplex.FpOrigVfs + 48 /* &.xDlSym */))))(tls, gMultiplex.FpOrigVfs, b, c)
}

func multiplexDlClose(tls *libc.TLS, a uintptr, b uintptr) { /* test_multiplex.c:671:13: */
	(*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer((gMultiplex.FpOrigVfs + 52 /* &.xDlClose */))))(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexRandomness(tls *libc.TLS, a uintptr, b int32, c uintptr) int32 { /* test_multiplex.c:674:12: */
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 56 /* &.xRandomness */))))(tls, gMultiplex.FpOrigVfs, b, c)
}

func multiplexSleep(tls *libc.TLS, a uintptr, b int32) int32 { /* test_multiplex.c:677:12: */
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 60 /* &.xSleep */))))(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexCurrentTime(tls *libc.TLS, a uintptr, b uintptr) int32 { /* test_multiplex.c:680:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 64 /* &.xCurrentTime */))))(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexGetLastError(tls *libc.TLS, a uintptr, b int32, c uintptr) int32 { /* test_multiplex.c:683:12: */
	if (*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxGetLastError != 0 {
		return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 68 /* &.xGetLastError */))))(tls, gMultiplex.FpOrigVfs, b, c)
	} else {
		return 0
	}
	return int32(0)
}

func multiplexCurrentTimeInt64(tls *libc.TLS, a uintptr, b uintptr) int32 { /* test_multiplex.c:690:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 72 /* &.xCurrentTimeInt64 */))))(tls, gMultiplex.FpOrigVfs, b)
}

//*********************** I/O Method Wrappers ******************************

// xClose requests get passed through to the original VFS.
// We loop over all open chunk handles and close them.
// The group structure for this file is unlinked from
// our list of groups and freed.
func multiplexClose(tls *libc.TLS, pConn uintptr) int32 { /* test_multiplex.c:701:12: */
	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	var rc int32 = SQLITE_OK
	multiplexFreeComponents(tls, pGroup)
	sqlite3.Xsqlite3_free(tls, pGroup)
	return rc
}

// Pass xRead requests thru to the original VFS after
// determining the correct chunk to operate on.
// Break up reads across chunk boundaries.
func multiplexRead(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_multiplex.c:714:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (SQLITE_IOERR | (int32(1) << 8))
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 8 /* &.xRead */))))(tls, pSubOpen, pBuf, iAmt, iOfst)
		}
	} else {
		for iAmt > 0 {
			var i int32 = (int32(iOfst / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
			var pSubOpen uintptr
			pSubOpen = multiplexSubOpen(tls, pGroup, i, bp /* &rc */, uintptr(0), 1)
			if pSubOpen != 0 {
				var extra int32 = (int32((uint32((int32(iOfst % sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))) + iAmt)) - (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
				if extra < 0 {
					extra = 0
				}
				iAmt = iAmt - (extra)
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 8 /* &.xRead */))))(tls, pSubOpen, pBuf, iAmt,
					(iOfst % sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
				if *(*int32)(unsafe.Pointer(bp /* rc */)) != SQLITE_OK {
					break
				}
				pBuf = (pBuf + uintptr(iAmt))
				iOfst = iOfst + (sqlite3_int64(iAmt))
				iAmt = extra
			} else {
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (SQLITE_IOERR | (int32(1) << 8))
				break
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xWrite requests thru to the original VFS after
// determining the correct chunk to operate on.
// Break up writes across chunk boundaries.
func multiplexWrite(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_multiplex.c:759:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (SQLITE_IOERR | (int32(3) << 8))
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 12 /* &.xWrite */))))(tls, pSubOpen, pBuf, iAmt, iOfst)
		}
	} else {
		for (*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (iAmt > 0) {
			var i int32 = (int32(iOfst / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
			var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, i, bp /* &rc */, uintptr(0), 1)
			if pSubOpen != 0 {
				var extra int32 = (int32((uint32((int32(iOfst % sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))) + iAmt)) - (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
				if extra < 0 {
					extra = 0
				}
				iAmt = iAmt - (extra)
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 12 /* &.xWrite */))))(tls, pSubOpen, pBuf, iAmt,
					(iOfst % sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
				pBuf = (pBuf + uintptr(iAmt))
				iOfst = iOfst + (sqlite3_int64(iAmt))
				iAmt = extra
			}
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xTruncate requests thru to the original VFS after
// determining the correct chunk to operate on.  Delete any
// chunks above the truncate mark.
func multiplexTruncate(tls *libc.TLS, pConn uintptr, size sqlite3_int64) int32 { /* test_multiplex.c:799:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (SQLITE_IOERR | (int32(6) << 8))
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 16 /* &.xTruncate */))))(tls, pSubOpen, size)
		}
	} else {
		var i int32
		var iBaseGroup int32 = (int32(size / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
		var pSubOpen uintptr
		var pOrigVfs uintptr = gMultiplex.FpOrigVfs // Real VFS
		// delete the chunks above the truncate limit
		for i = ((*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal - 1); (i > iBaseGroup) && (*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK); i-- {
			if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate != 0 {
				multiplexSubClose(tls, pGroup, i, pOrigVfs)
			} else {
				pSubOpen = multiplexSubOpen(tls, pGroup, i, bp /* &rc */, uintptr(0), 0)
				if pSubOpen != 0 {
					*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 16 /* &.xTruncate */))))(tls, pSubOpen, int64(0))
				}
			}
		}
		if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
			pSubOpen = multiplexSubOpen(tls, pGroup, iBaseGroup, bp /* &rc */, uintptr(0), 0)
			if pSubOpen != 0 {
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 16 /* &.xTruncate */))))(tls, pSubOpen, (size % sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
			}
		}
		if *(*int32)(unsafe.Pointer(bp /* rc */)) != 0 {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (SQLITE_IOERR | (int32(6) << 8))
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xSync requests through to the original VFS without change
func multiplexSync(tls *libc.TLS, pConn uintptr, flags int32) int32 { /* test_multiplex.c:839:12: */
	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	var rc int32 = SQLITE_OK
	var i int32
	for i = 0; i < (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal; i++ {
		var pSubOpen uintptr = (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(i)*8)).Fp
		if pSubOpen != 0 {
			var rc2 int32 = (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 20 /* &.xSync */))))(tls, pSubOpen, flags)
			if rc2 != SQLITE_OK {
				rc = rc2
			}
		}
	}
	return rc
}

// Pass xFileSize requests through to the original VFS.
// Aggregate the size of all the chunks before returning.
func multiplexFileSize(tls *libc.TLS, pConn uintptr, pSize uintptr) int32 { /* test_multiplex.c:857:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var i int32
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (SQLITE_IOERR | (int32(7) << 8))
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 24 /* &.xFileSize */))))(tls, pSubOpen, pSize)
		}
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pSize)) = int64(0)
		for i = 0; *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK; i++ {
			var sz sqlite3_int64 = multiplexSubSize(tls, pGroup, i, bp /* &rc */)
			if sz == int64(0) {
				break
			}
			*(*sqlite3_int64)(unsafe.Pointer(pSize)) = ((sqlite3_int64(i) * sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)) + sz)
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xLock requests through to the original VFS unchanged.
func multiplexLock(tls *libc.TLS, pConn uintptr, lock int32) int32 { /* test_multiplex.c:882:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 28 /* &.xLock */))))(tls, pSubOpen, lock)
	}
	return SQLITE_BUSY
}

// Pass xUnlock requests through to the original VFS unchanged.
func multiplexUnlock(tls *libc.TLS, pConn uintptr, lock int32) int32 { /* test_multiplex.c:894:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 32 /* &.xUnlock */))))(tls, pSubOpen, lock)
	}
	return (SQLITE_IOERR | (int32(8) << 8))
}

// Pass xCheckReservedLock requests through to the original VFS unchanged.
func multiplexCheckReservedLock(tls *libc.TLS, pConn uintptr, pResOut uintptr) int32 { /* test_multiplex.c:906:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 36 /* &.xCheckReservedLock */))))(tls, pSubOpen, pResOut)
	}
	return (SQLITE_IOERR | (int32(14) << 8))
}

// Pass xFileControl requests through to the original VFS unchanged,
// except for any MULTIPLEX_CTRL_* requests here.
func multiplexFileControl(tls *libc.TLS, pConn uintptr, op int32, pArg uintptr) int32 { /* test_multiplex.c:919:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = SQLITE_ERROR
	var pSubOpen uintptr

	if !(gMultiplex.FisInitialized != 0) {
		return SQLITE_MISUSE
	}
	switch op {
	case MULTIPLEX_CTRL_ENABLE:
		if pArg != 0 {
			var bEnabled int32 = *(*int32)(unsafe.Pointer(pArg))
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(bEnabled)
			*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = SQLITE_OK
		}
		break
	case MULTIPLEX_CTRL_SET_CHUNK_SIZE:
		if pArg != 0 {
			var szChunk uint32 = *(*uint32)(unsafe.Pointer(pArg))
			if szChunk < uint32(1) {
				*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = SQLITE_MISUSE
			} else {
				// Round up to nearest multiple of MAX_PAGE_SIZE.
				szChunk = (szChunk + (uint32(MAX_PAGE_SIZE - 1)))
				szChunk = szChunk & (libc.Uint32FromInt32(libc.CplInt32((MAX_PAGE_SIZE - 1))))
				(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = szChunk
				*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = SQLITE_OK
			}
		}
		break
	case MULTIPLEX_CTRL_SET_MAX_CHUNKS:
		*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = SQLITE_OK
		break
	case SQLITE_FCNTL_SIZE_HINT:
		fallthrough
	case SQLITE_FCNTL_CHUNK_SIZE:
		// no-op these
		*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = SQLITE_OK
		break
	case SQLITE_FCNTL_PRAGMA:
		{
			var aFcntl uintptr = pArg
			// EVIDENCE-OF: R-29875-31678 The argument to the SQLITE_FCNTL_PRAGMA
			// file control is an array of pointers to strings (char**) in which the
			// second element of the array is the name of the pragma and the third
			// element is the argument to the pragma or NULL if the pragma has no
			// argument.
			if (*(*uintptr)(unsafe.Pointer(aFcntl + 1*4)) != 0) && (sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*4)), ts+34142 /* "multiplex_trunca..." */) == 0) {
				if (*(*uintptr)(unsafe.Pointer(aFcntl + 2*4)) != 0) && (*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(aFcntl + 2*4)))) != 0) {
					if (sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*4)), ts+4039 /* "on" */) == 0) ||
						(sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*4)), ts+28325 /* "1" */) == 0) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(1)
					} else if (sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*4)), ts+4403 /* "off" */) == 0) ||
						(sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*4)), ts+13873 /* "0" */) == 0) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(0)
					}
				}
				// EVIDENCE-OF: R-27806-26076 The handler for an SQLITE_FCNTL_PRAGMA
				// file control can optionally make the first element of the char**
				// argument point to a string obtained from sqlite3_mprintf() or the
				// equivalent and that string will become the result of the pragma
				// or the error message if the pragma fails.
				*(*uintptr)(unsafe.Pointer(aFcntl)) = sqlite3.Xsqlite3_mprintf(tls, func() uintptr {
					if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate != 0 {
						return ts + 4039 /* "on" */
					}
					return ts + 4403 /* "off" */
				}(), 0)
				*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = SQLITE_OK
				break
			}
			// If the multiplexor does not handle the pragma, pass it through
			// into the default case.

		}
		fallthrough
	default:
		pSubOpen = multiplexSubOpen(tls, pGroup, 0, bp+8 /* &rc */, uintptr(0), 0)
		if pSubOpen != 0 {
			*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 40 /* &.xFileControl */))))(tls, pSubOpen, op, pArg)
			if (op == SQLITE_FCNTL_VFSNAME) && (*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) == SQLITE_OK) {
				*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+34161 /* "multiplex/%z" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(pArg))))
			}
		}
		break
	}
	return *(*int32)(unsafe.Pointer(bp + 8 /* rc */))
}

// Pass xSectorSize requests through to the original VFS unchanged.
func multiplexSectorSize(tls *libc.TLS, pConn uintptr) int32 { /* test_multiplex.c:1004:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if (pSubOpen != 0) && ((*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSectorSize != 0) {
		return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 44 /* &.xSectorSize */))))(tls, pSubOpen)
	}
	return DEFAULT_SECTOR_SIZE
}

// Pass xDeviceCharacteristics requests through to the original VFS unchanged.
func multiplexDeviceCharacteristics(tls *libc.TLS, pConn uintptr) int32 { /* test_multiplex.c:1016:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 48 /* &.xDeviceCharacteristics */))))(tls, pSubOpen)
	}
	return 0
}

// Pass xShmMap requests through to the original VFS unchanged.
func multiplexShmMap(tls *libc.TLS, pConn uintptr, iRegion int32, szRegion int32, bExtend int32, pp uintptr) int32 { /* test_multiplex.c:1028:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 52 /* &.xShmMap */))))(tls, pSubOpen, iRegion, szRegion, bExtend, libc.AtomicLoadUintptr(&pp))
	}
	return SQLITE_IOERR
}

// Pass xShmLock requests through to the original VFS unchanged.
func multiplexShmLock(tls *libc.TLS, pConn uintptr, ofst int32, n int32, flags int32) int32 { /* test_multiplex.c:1046:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 56 /* &.xShmLock */))))(tls, pSubOpen, ofst, n, flags)
	}
	return SQLITE_BUSY
}

// Pass xShmBarrier requests through to the original VFS unchanged.
func multiplexShmBarrier(tls *libc.TLS, pConn uintptr) { /* test_multiplex.c:1063:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 60 /* &.xShmBarrier */))))(tls, pSubOpen)
	}
}

// Pass xShmUnmap requests through to the original VFS unchanged.
func multiplexShmUnmap(tls *libc.TLS, pConn uintptr, deleteFlag int32) int32 { /* test_multiplex.c:1074:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 64 /* &.xShmUnmap */))))(tls, pSubOpen, deleteFlag)
	}
	return SQLITE_OK
}

//************************* Public Interfaces ****************************
// CAPI: Initialize the multiplex VFS shim - sqlite3_multiplex_initialize()
//
// Use the VFS named zOrigVfsName as the VFS that does the actual work.
// Use the default if zOrigVfsName==NULL.
//
// The multiplex VFS shim is named "multiplex".  It will become the default
// VFS if makeDefault is non-zero.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once
// during start-up.
func sqlite3_multiplex_initialize(tls *libc.TLS, zOrigVfsName uintptr, makeDefault int32) int32 { /* test_multiplex.c:1097:5: */
	var pOrigVfs uintptr
	if gMultiplex.FisInitialized != 0 {
		return SQLITE_MISUSE
	}
	pOrigVfs = sqlite3.Xsqlite3_vfs_find(tls, zOrigVfsName)
	if pOrigVfs == uintptr(0) {
		return SQLITE_ERROR
	}

	gMultiplex.FisInitialized = 1
	gMultiplex.FpOrigVfs = pOrigVfs
	gMultiplex.FsThisVfs = *(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&gMultiplex)) + 4 /* &.sThisVfs */ + 4 /* &.szOsFile */)) += int32((uint32(unsafe.Sizeof(multiplexConn{}))))
	gMultiplex.FsThisVfs.FzName = ts + 34174 /* "multiplex" */
	gMultiplex.FsThisVfs.FxOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{multiplexOpen}))
	gMultiplex.FsThisVfs.FxDelete = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{multiplexDelete}))
	gMultiplex.FsThisVfs.FxAccess = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{multiplexAccess}))
	gMultiplex.FsThisVfs.FxFullPathname = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{multiplexFullPathname}))
	gMultiplex.FsThisVfs.FxDlOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	}{multiplexDlOpen}))
	gMultiplex.FsThisVfs.FxDlError = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{multiplexDlError}))
	gMultiplex.FsThisVfs.FxDlSym = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	}{multiplexDlSym}))
	gMultiplex.FsThisVfs.FxDlClose = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{multiplexDlClose}))
	gMultiplex.FsThisVfs.FxRandomness = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{multiplexRandomness}))
	gMultiplex.FsThisVfs.FxSleep = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexSleep}))
	gMultiplex.FsThisVfs.FxCurrentTime = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexCurrentTime}))
	gMultiplex.FsThisVfs.FxGetLastError = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{multiplexGetLastError}))
	gMultiplex.FsThisVfs.FxCurrentTimeInt64 = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexCurrentTimeInt64}))

	gMultiplex.FsIoMethodsV1.FiVersion = 1
	gMultiplex.FsIoMethodsV1.FxClose = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{multiplexClose}))
	gMultiplex.FsIoMethodsV1.FxRead = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{multiplexRead}))
	gMultiplex.FsIoMethodsV1.FxWrite = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{multiplexWrite}))
	gMultiplex.FsIoMethodsV1.FxTruncate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	}{multiplexTruncate}))
	gMultiplex.FsIoMethodsV1.FxSync = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexSync}))
	gMultiplex.FsIoMethodsV1.FxFileSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexFileSize}))
	gMultiplex.FsIoMethodsV1.FxLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexLock}))
	gMultiplex.FsIoMethodsV1.FxUnlock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexUnlock}))
	gMultiplex.FsIoMethodsV1.FxCheckReservedLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexCheckReservedLock}))
	gMultiplex.FsIoMethodsV1.FxFileControl = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{multiplexFileControl}))
	gMultiplex.FsIoMethodsV1.FxSectorSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{multiplexSectorSize}))
	gMultiplex.FsIoMethodsV1.FxDeviceCharacteristics = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{multiplexDeviceCharacteristics}))
	gMultiplex.FsIoMethodsV2 = gMultiplex.FsIoMethodsV1
	gMultiplex.FsIoMethodsV2.FiVersion = 2
	gMultiplex.FsIoMethodsV2.FxShmMap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	}{multiplexShmMap}))
	gMultiplex.FsIoMethodsV2.FxShmLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	}{multiplexShmLock}))
	gMultiplex.FsIoMethodsV2.FxShmBarrier = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{multiplexShmBarrier}))
	gMultiplex.FsIoMethodsV2.FxShmUnmap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexShmUnmap}))
	sqlite3.Xsqlite3_vfs_register(tls, (uintptr(unsafe.Pointer(&gMultiplex)) + 4 /* &.sThisVfs */), makeDefault)

	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{multiplexFuncInit})))

	return SQLITE_OK
}

// CAPI: Shutdown the multiplex system - sqlite3_multiplex_shutdown()
//
// All SQLite database connections must be closed before calling this
// routine.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once while
// shutting down in order to free all remaining multiplex groups.
func sqlite3_multiplex_shutdown(tls *libc.TLS, eForce int32) int32 { /* test_multiplex.c:1158:5: */
	var rc int32 = SQLITE_OK
	if gMultiplex.FisInitialized == 0 {
		return SQLITE_MISUSE
	}
	gMultiplex.FisInitialized = 0
	sqlite3.Xsqlite3_vfs_unregister(tls, (uintptr(unsafe.Pointer(&gMultiplex)) + 4 /* &.sThisVfs */))
	libc.Xmemset(tls, uintptr(unsafe.Pointer(&gMultiplex)), 0, uint32(unsafe.Sizeof(gMultiplex)))
	return rc
}

// tclcmd: sqlite3_multiplex_initialize NAME MAKEDEFAULT
func test_multiplex_initialize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_multiplex.c:1183:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zName uintptr // Name of new multiplex VFS
	// var makeDefault int32 at bp, 4
	// True to make the new VFS the default
	var rc int32 // Value returned by multiplex_initialize()

	_ = clientData

	// Process arguments
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+34184 /* "NAME MAKEDEFAULT" */)
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp /* &makeDefault */) != 0 {
		return TCL_ERROR
	}
	if int32(*(*int8)(unsafe.Pointer(zName))) == 0 {
		zName = uintptr(0)
	}

	// Call sqlite3_multiplex_initialize()
	rc = sqlite3_multiplex_initialize(tls, zName, *(*int32)(unsafe.Pointer(bp /* makeDefault */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

// tclcmd: sqlite3_multiplex_shutdown
func test_multiplex_shutdown(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_multiplex.c:1214:26: */
	var rc int32 // Value returned by multiplex_shutdown()

	_ = clientData

	if (objc == 2) && (libc.Xstrcmp(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), ts+34201 /* "-force" */) != 0) {
		objc = 3
	}
	if (objc != 1) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+34208 /* "?-force?" */)
		return TCL_ERROR
	}

	// Call sqlite3_multiplex_shutdown()
	rc = sqlite3_multiplex_shutdown(tls, (libc.Bool32(objc == 2)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

// Tclcmd: test_multiplex_control HANDLE DBNAME SUB-COMMAND ?INT-VALUE?
func test_multiplex_control(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_multiplex.c:1242:26: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var rc int32 // Return code from file_control()
	// var idx int32 at bp+120, 4
	// Index in aSub[]
	// var cmdInfo Tcl_CmdInfo at bp+40, 32
	// Command info structure for HANDLE
	var db uintptr // Underlying db handle for HANDLE
	*(*int32)(unsafe.Pointer(bp + 124 /* iValue */)) = 0
	var pArg uintptr = uintptr(0)

	*(*[4]struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp + 72 /* aSub */)) = [4]struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	}{
		{FzName: ts + 34217 /* "enable" */, Fop: MULTIPLEX_CTRL_ENABLE, Fargtype: 1},
		{FzName: ts + 34224 /* "chunk_size" */, Fop: MULTIPLEX_CTRL_SET_CHUNK_SIZE, Fargtype: 1},
		{FzName: ts + 34235 /* "max_chunks" */, Fop: MULTIPLEX_CTRL_SET_MAX_CHUNKS, Fargtype: 1},
		{},
	}

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+34246 /* "HANDLE DBNAME SU..." */)
		return TCL_ERROR
	}

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+40 /* &cmdInfo */) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+34282 /* "expected databas..." */, 0))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), ts+11634 /* "\"" */, 0))
		return TCL_ERROR
	} else {
		db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 40 /* &cmdInfo */)).FobjClientData))
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+72 /* &aSub[0] */, int32(unsafe.Sizeof(struct {
			FzName   uintptr
			Fop      int32
			Fargtype int32
		}{})), ts+1875 /* "sub-command" */, 0, bp+120 /* &idx */)
	if rc != TCL_OK {
		return rc
	}

	switch (*struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp + 72 /* &aSub */ + uintptr(*(*int32)(unsafe.Pointer(bp + 120 /* idx */)))*12)).Fargtype {
	case 1:
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+124 /* &iValue */) != 0 {
			return TCL_ERROR
		}
		pArg = bp + 124 /* &iValue */
		break
	default:
		tcl.XTcl_WrongNumArgs(tls, interp, 4, objv, ts+2384 /* "SUB-COMMAND" */)
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_file_control(tls, db, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), (*struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp+72 /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 120 /* idx */)))*12)).Fop, pArg)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	if rc == SQLITE_OK {
		return TCL_OK
	}
	return TCL_ERROR
}

// This routine registers the custom TCL commands defined in this
// module.  This should be the only procedure visible from outside
// of this module.
func Sqlitemultiplex_Init(tls *libc.TLS, interp uintptr) int32 { /* test_multiplex.c:1306:5: */
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aCmd7)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd7[i].FzName, aCmd7[i].FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

var aCmd7 = [3]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 34314 /* "sqlite3_multiple..." */, FxProc: 0},
	{FzName: ts + 34343 /* "sqlite3_multiple..." */, FxProc: 0},
	{FzName: ts + 34370 /* "sqlite3_multiple..." */, FxProc: 0},
} /* test_multiplex.c:1310:5 */

// CAPI3REF: Standard File Control Opcodes
// KEYWORDS: {file control opcodes} {file control opcode}
//
// These integer constants are opcodes for the xFileControl method
// of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]
// interface.
//
// <ul>
// <li>[[SQLITE_FCNTL_LOCKSTATE]]
// The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This
// opcode causes the xFileControl method to write the current state of
// the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],
// [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])
// into an integer that the pArg argument points to. This capability
// is used during testing and is only available when the SQLITE_TEST
// compile-time option is used.
//
// <li>[[SQLITE_FCNTL_SIZE_HINT]]
// The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS
// layer a hint of how large the database file will grow to be during the
// current transaction.  This hint is not guaranteed to be accurate but it
// is often close.  The underlying VFS might choose to preallocate database
// file space based on this hint in order to help writes to the database
// file run faster.
//
// <li>[[SQLITE_FCNTL_SIZE_LIMIT]]
// The [SQLITE_FCNTL_SIZE_LIMIT] opcode is used by in-memory VFS that
// implements [sqlite3_deserialize()] to set an upper bound on the size
// of the in-memory database.  The argument is a pointer to a [sqlite3_int64].
// If the integer pointed to is negative, then it is filled in with the
// current limit.  Otherwise the limit is set to the larger of the value
// of the integer pointed to and the current database size.  The integer
// pointed to is set to the new limit.
//
// <li>[[SQLITE_FCNTL_CHUNK_SIZE]]
// The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFS
// extends and truncates the database file in chunks of a size specified
// by the user. The fourth argument to [sqlite3_file_control()] should
// point to an integer (type int) containing the new chunk-size to use
// for the nominated database. Allocating database file space in large
// chunks (say 1MB at a time), may reduce file-system fragmentation and
// improve performance on some systems.
//
// <li>[[SQLITE_FCNTL_FILE_POINTER]]
// The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with a particular database
// connection.  See also [SQLITE_FCNTL_JOURNAL_POINTER].
//
// <li>[[SQLITE_FCNTL_JOURNAL_POINTER]]
// The [SQLITE_FCNTL_JOURNAL_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with the journal file (either
// the [rollback journal] or the [write-ahead log]) for a particular database
// connection.  See also [SQLITE_FCNTL_FILE_POINTER].
//
// <li>[[SQLITE_FCNTL_SYNC_OMITTED]]
// No longer in use.
//
// <li>[[SQLITE_FCNTL_SYNC]]
// The [SQLITE_FCNTL_SYNC] opcode is generated internally by SQLite and
// sent to the VFS immediately before the xSync method is invoked on a
// database file descriptor. Or, if the xSync method is not invoked
// because the user has configured SQLite with
// [PRAGMA synchronous | PRAGMA synchronous=OFF] it is invoked in place
// of the xSync method. In most cases, the pointer argument passed with
// this file-control is NULL. However, if the database file is being synced
// as part of a multi-database commit, the argument points to a nul-terminated
// string containing the transactions super-journal file name. VFSes that
// do not need this signal should silently ignore this opcode. Applications
// should not call [sqlite3_file_control()] with this opcode as doing so may
// disrupt the operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_COMMIT_PHASETWO]]
// The [SQLITE_FCNTL_COMMIT_PHASETWO] opcode is generated internally by SQLite
// and sent to the VFS after a transaction has been committed immediately
// but before the database is unlocked. VFSes that do not need this signal
// should silently ignore this opcode. Applications should not call
// [sqlite3_file_control()] with this opcode as doing so may disrupt the
// operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]
// ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automatic
// retry counts and intervals for certain disk I/O operations for the
// windows [VFS] in order to provide robustness in the presence of
// anti-virus programs.  By default, the windows VFS will retry file read,
// file write, and file delete operations up to 10 times, with a delay
// of 25 milliseconds before the first retry and with the delay increasing
// by an additional 25 milliseconds with each subsequent retry.  This
// opcode allows these two values (10 retries and 25 milliseconds of delay)
// to be adjusted.  The values are changed for all database connections
// within the same process.  The argument is a pointer to an array of two
// integers where the first integer is the new retry count and the second
// integer is the delay.  If either integer is negative, then the setting
// is not changed but instead the prior value of that setting is written
// into the array entry, allowing the current retry settings to be
// interrogated.  The zDbName parameter is ignored.
//
// <li>[[SQLITE_FCNTL_PERSIST_WAL]]
// ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query the
// persistent [WAL | Write Ahead Log] setting.  By default, the auxiliary
// write ahead log ([WAL file]) and shared memory
// files used for transaction control
// are automatically deleted when the latest connection to the database
// closes.  Setting persistent WAL mode causes those files to persist after
// close.  Persisting the files is useful when other processes that do not
// have write permission on the directory containing the database file want
// to read the database file, as the WAL and shared memory files must exist
// in order for the database to be readable.  The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable persistent WAL mode or 1 to enable persistent
// WAL mode.  If the integer is -1, then it is overwritten with the current
// WAL persistence setting.
//
// <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]
// ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query the
// persistent "powersafe-overwrite" or "PSOW" setting.  The PSOW setting
// determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of the
// xDeviceCharacteristics methods. The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable zero-damage mode or 1 to enable zero-damage
// mode.  If the integer is -1, then it is overwritten with the current
// zero-damage mode setting.
//
// <li>[[SQLITE_FCNTL_OVERWRITE]]
// ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after opening
// a write transaction to indicate that, unless it is rolled back for some
// reason, the entire database file will be overwritten by the current
// transaction. This is used by VACUUM operations.
//
// <li>[[SQLITE_FCNTL_VFSNAME]]
// ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names of
// all [VFSes] in the VFS stack.  The names are of all VFS shims and the
// final bottom-level VFS are written into memory obtained from
// [sqlite3_malloc()] and the result is stored in the char* variable
// that the fourth parameter of [sqlite3_file_control()] points to.
// The caller is responsible for freeing the memory when done.  As with
// all file-control actions, there is no guarantee that this will actually
// do anything.  Callers should initialize the char* variable to a NULL
// pointer in case this file-control is not implemented.  This file-control
// is intended for diagnostic use only.
//
// <li>[[SQLITE_FCNTL_VFS_POINTER]]
// ^The [SQLITE_FCNTL_VFS_POINTER] opcode finds a pointer to the top-level
// [VFSes] currently in use.  ^(The argument X in
// sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be
// of type "[sqlite3_vfs] **".  This opcodes will set *X
// to a pointer to the top-level VFS.)^
// ^When there are multiple VFS shims in the stack, this opcode finds the
// upper-most shim only.
//
// <li>[[SQLITE_FCNTL_PRAGMA]]
// ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA]
// file control is sent to the open [sqlite3_file] object corresponding
// to the database file to which the pragma statement refers. ^The argument
// to the [SQLITE_FCNTL_PRAGMA] file control is an array of
// pointers to strings (char**) in which the second element of the array
// is the name of the pragma and the third element is the argument to the
// pragma or NULL if the pragma has no argument.  ^The handler for an
// [SQLITE_FCNTL_PRAGMA] file control can optionally make the first element
// of the char** argument point to a string obtained from [sqlite3_mprintf()]
// or the equivalent and that string will become the result of the pragma or
// the error message if the pragma fails. ^If the
// [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal
// [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]
// file control returns [SQLITE_OK], then the parser assumes that the
// VFS has handled the PRAGMA itself and the parser generates a no-op
// prepared statement if result string is NULL, or that returns a copy
// of the result string if the string is non-NULL.
// ^If the [SQLITE_FCNTL_PRAGMA] file control returns
// any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means
// that the VFS encountered an error while handling the [PRAGMA] and the
// compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]
// file control occurs at the beginning of pragma statement analysis and so
// it is able to override built-in [PRAGMA] statements.
//
// <li>[[SQLITE_FCNTL_BUSYHANDLER]]
// ^The [SQLITE_FCNTL_BUSYHANDLER]
// file-control may be invoked by SQLite on the database file handle
// shortly after it is opened in order to provide a custom VFS with access
// to the connection's busy-handler callback. The argument is of type (void**)
// - an array of two (void *) values. The first (void *) actually points
// to a function of type (int (*)(void *)). In order to invoke the connection's
// busy-handler, this function should be invoked with the second (void *) in
// the array as the only argument. If it returns non-zero, then the operation
// should be retried. If it returns zero, the custom VFS should abandon the
// current operation.
//
// <li>[[SQLITE_FCNTL_TEMPFILENAME]]
// ^Applications can invoke the [SQLITE_FCNTL_TEMPFILENAME] file-control
// to have SQLite generate a
// temporary filename using the same algorithm that is followed to generate
// temporary filenames for TEMP tables and other internal uses.  The
// argument should be a char** which will be filled with the filename
// written into memory obtained from [sqlite3_malloc()].  The caller should
// invoke [sqlite3_free()] on the result to avoid a memory leak.
//
// <li>[[SQLITE_FCNTL_MMAP_SIZE]]
// The [SQLITE_FCNTL_MMAP_SIZE] file control is used to query or set the
// maximum number of bytes that will be used for memory-mapped I/O.
// The argument is a pointer to a value of type sqlite3_int64 that
// is an advisory maximum number of bytes in the file to memory map.  The
// pointer is overwritten with the old value.  The limit is not changed if
// the value originally pointed to is negative, and so the current limit
// can be queried by passing in a pointer to a negative number.  This
// file-control is used internally to implement [PRAGMA mmap_size].
//
// <li>[[SQLITE_FCNTL_TRACE]]
// The [SQLITE_FCNTL_TRACE] file control provides advisory information
// to the VFS about what the higher layers of the SQLite stack are doing.
// This file control is used by some VFS activity tracing [shims].
// The argument is a zero-terminated string.  Higher layers in the
// SQLite stack may generate instances of this file control if
// the [SQLITE_USE_FCNTL_TRACE] compile-time option is enabled.
//
// <li>[[SQLITE_FCNTL_HAS_MOVED]]
// The [SQLITE_FCNTL_HAS_MOVED] file control interprets its argument as a
// pointer to an integer and it writes a boolean into that integer depending
// on whether or not the file has been renamed, moved, or deleted since it
// was first opened.
//
// <li>[[SQLITE_FCNTL_WIN32_GET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_GET_HANDLE] opcode can be used to obtain the
// underlying native file handle associated with a file handle.  This file
// control interprets its argument as a pointer to a native file handle and
// writes the resulting value there.
//
// <li>[[SQLITE_FCNTL_WIN32_SET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_SET_HANDLE] opcode is used for debugging.  This
// opcode causes the xFileControl method to swap the file handle with the one
// pointed to by the pArg argument.  This capability is used during testing
// and only needs to be supported when SQLITE_TEST is defined.
//
// <li>[[SQLITE_FCNTL_WAL_BLOCK]]
// The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it might
// be advantageous to block on the next WAL lock if the lock is not immediately
// available.  The WAL subsystem issues this signal during rare
// circumstances in order to fix a problem with priority inversion.
// Applications should <em>not</em> use this file-control.
//
// <li>[[SQLITE_FCNTL_ZIPVFS]]
// The [SQLITE_FCNTL_ZIPVFS] opcode is implemented by zipvfs only. All other
// VFS should return SQLITE_NOTFOUND for this opcode.
//
// <li>[[SQLITE_FCNTL_RBU]]
// The [SQLITE_FCNTL_RBU] opcode is implemented by the special VFS used by
// the RBU extension only.  All other VFS should return SQLITE_NOTFOUND for
// this opcode.
//
// <li>[[SQLITE_FCNTL_BEGIN_ATOMIC_WRITE]]
// If the [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] opcode returns SQLITE_OK, then
// the file descriptor is placed in "batch write mode", which
// means all subsequent write operations will be deferred and done
// atomically at the next [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].  Systems
// that do not support batch atomic writes will return SQLITE_NOTFOUND.
// ^Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to
// the closing [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] or
// [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE], SQLite will make
// no VFS interface calls on the same [sqlite3_file] file descriptor
// except for calls to the xWrite method and the xFileControl method
// with [SQLITE_FCNTL_SIZE_HINT].
//
// <li>[[SQLITE_FCNTL_COMMIT_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be performed atomically.
// This file control returns [SQLITE_OK] if and only if the writes were
// all performed successfully and have been committed to persistent storage.
// ^Regardless of whether or not it is successful, this file control takes
// the file descriptor out of batch write mode so that all subsequent
// write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be rolled back.
// ^This file control takes the file descriptor out of batch write mode
// so that all subsequent write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]
// The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode is used to configure a VFS
// to block for up to M milliseconds before failing when attempting to
// obtain a file lock using the xLock or xShmLock methods of the VFS.
// The parameter is a pointer to a 32-bit signed integer that contains
// the value that M is to be set to. Before returning, the 32-bit signed
// integer is overwritten with the previous value of M.
//
// <li>[[SQLITE_FCNTL_DATA_VERSION]]
// The [SQLITE_FCNTL_DATA_VERSION] opcode is used to detect changes to
// a database file.  The argument is a pointer to a 32-bit unsigned integer.
// The "data version" for the pager is written into the pointer.  The
// "data version" changes whenever any change occurs to the corresponding
// database file, either through SQL statements on the same database
// connection or through transactions committed by separate database
// connections possibly in other processes. The [sqlite3_total_changes()]
// interface can be used to find if any database on the connection has changed,
// but that interface responds to changes on TEMP as well as MAIN and does
// not provide a mechanism to detect changes to MAIN only.  Also, the
// [sqlite3_total_changes()] interface responds to internal changes only and
// omits changes made by other database connections.  The
// [PRAGMA data_version] command provides a mechanism to detect changes to
// a single attached database that occur due to other database connections,
// but omits changes implemented by the database connection on which it is
// called.  This file control is the only mechanism to detect changes that
// happen either internally or externally and that are associated with
// a particular attached database.
//
// <li>[[SQLITE_FCNTL_CKPT_START]]
// The [SQLITE_FCNTL_CKPT_START] opcode is invoked from within a checkpoint
// in wal mode before the client starts to copy pages from the wal
// file to the database file.
//
// <li>[[SQLITE_FCNTL_CKPT_DONE]]
// The [SQLITE_FCNTL_CKPT_DONE] opcode is invoked from within a checkpoint
// in wal mode after the client has finished copying pages from the wal
// file to the database file, but before the *-shm file is updated to
// record the fact that the pages have been checkpointed.
// </ul>
//
// <li>[[SQLITE_FCNTL_EXTERNAL_READER]]
// The EXPERIMENTAL [SQLITE_FCNTL_EXTERNAL_READER] opcode is used to detect
// whether or not there is a database client in another process with a wal-mode
// transaction open on the database or not. It is only available on unix.The
// (void*) argument passed with this file-control should be a pointer to a
// value of type (int). The integer value is set to 1 if the database is a wal
// mode database and there exists at least one client in another process that
// currently has an SQL transaction open on the database. It is set to 0 if
// the database is not a wal-mode db, or if there is no such connection in any
// other process. This opcode cannot be used to detect transactions opened
// by clients within the current process, only within other processes.
// </ul>
//
// <li>[[SQLITE_FCNTL_CKSM_FILE]]
// Used by the cksmvfs VFS module only.
// </ul>

// deprecated names

// CAPI3REF: Mutex Handle
//
// The mutex module within SQLite defines [sqlite3_mutex] to be an
// abstract type for a mutex object.  The SQLite core never looks
// at the internal representation of an [sqlite3_mutex].  It only
// deals with pointers to the [sqlite3_mutex] object.
//
// Mutexes are created using [sqlite3_mutex_alloc()].
type sqlite3_mutex = sqlite3_mutex1 /* sqlite3.h:1206:30 */

var aName = [15]uintptr{
	ts + 34396 /* "fast" */, ts + 34401 /* "recursive" */, ts + 34411 /* "static_main" */, ts + 34423, /* "static_mem" */
	ts + 34434 /* "static_open" */, ts + 34446 /* "static_prng" */, ts + 34458 /* "static_lru" */, ts + 34469, /* "static_pmem" */
	ts + 34481 /* "static_app1" */, ts + 34493 /* "static_app2" */, ts + 34505 /* "static_app3" */, ts + 34517, /* "static_vfs1" */
	ts + 34529 /* "static_vfs2" */, ts + 34541 /* "static_vfs3" */, uintptr(0),
} /* test_mutex.c:32:19 */

// State variables
type test_mutex_globals = struct {
	FisInstalled int32
	FdisableInit int32
	FdisableTry  int32
	FisInit      int32
	Fm           sqlite3_mutex_methods
	FaCounter    [14]int32
	FaStatic     [12]sqlite3_mutex
} /* test_mutex.c:46:8 */

// State variables
var g3 = test_mutex_globals{} /* test_mutex.c:54:3 */

// Return true if the countable mutex is currently held
func counterMutexHeld(tls *libc.TLS, p uintptr) int32 { /* test_mutex.c:57:12: */
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 28 /* &.xMutexHeld */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Return true if the countable mutex is not currently held
func counterMutexNotheld(tls *libc.TLS, p uintptr) int32 { /* test_mutex.c:62:12: */
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 32 /* &.xMutexNotheld */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Initialize the countable mutex interface
// Or, if g.disableInit is non-zero, then do not initialize but instead
// return the value of g.disableInit as the result code.  This can be used
// to simulate an initialization failure.
func counterMutexInit(tls *libc.TLS) int32 { /* test_mutex.c:71:12: */
	var rc int32
	if g3.FdisableInit != 0 {
		return g3.FdisableInit
	}
	rc = (*(*func(*libc.TLS) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ /* &.xMutexInit */))))(tls)
	g3.FisInit = 1
	return rc
}

// Uninitialize the mutex subsystem
func counterMutexEnd(tls *libc.TLS) int32 { /* test_mutex.c:82:12: */
	g3.FisInit = 0
	return (*(*func(*libc.TLS) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 4 /* &.xMutexEnd */))))(tls)
}

// Allocate a countable mutex
func counterMutexAlloc(tls *libc.TLS, eType int32) uintptr { /* test_mutex.c:90:22: */
	var pReal uintptr
	var pRet uintptr = uintptr(0)

	pReal = (*(*func(*libc.TLS, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 8 /* &.xMutexAlloc */))))(tls, eType)
	if !(pReal != 0) {
		return uintptr(0)
	}

	if (eType == SQLITE_MUTEX_FAST) || (eType == SQLITE_MUTEX_RECURSIVE) {
		pRet = libc.Xmalloc(tls, uint32(unsafe.Sizeof(sqlite3_mutex{})))
	} else {
		var eStaticType int32 = (eType - ((SQLITE_MUTEX_STATIC_VFS3 + 1) - ((SQLITE_MUTEX_STATIC_VFS3 + 1) - (SQLITE_MUTEX_RECURSIVE + 1))))

		pRet = ((uintptr(unsafe.Pointer(&g3)) + 108 /* &.aStatic */) + uintptr(eStaticType)*8)
	}

	(*sqlite3_mutex)(unsafe.Pointer(pRet)).FeType = eType
	(*sqlite3_mutex)(unsafe.Pointer(pRet)).FpReal = pReal
	return pRet
}

// Free a countable mutex
func counterMutexFree(tls *libc.TLS, p uintptr) { /* test_mutex.c:118:13: */

	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 12 /* &.xMutexFree */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
	if ((*sqlite3_mutex)(unsafe.Pointer(p)).FeType == SQLITE_MUTEX_FAST) || ((*sqlite3_mutex)(unsafe.Pointer(p)).FeType == SQLITE_MUTEX_RECURSIVE) {
		libc.Xfree(tls, p)
	}
}

// Enter a countable mutex.  Block until entry is safe.
func counterMutexEnter(tls *libc.TLS, p uintptr) { /* test_mutex.c:129:13: */

	*(*int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 52 /* &.aCounter */) + uintptr((*sqlite3_mutex)(unsafe.Pointer(p)).FeType)*4))++
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 16 /* &.xMutexEnter */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Try to enter a mutex.  Return true on success.
func counterMutexTry(tls *libc.TLS, p uintptr) int32 { /* test_mutex.c:140:12: */

	*(*int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 52 /* &.aCounter */) + uintptr((*sqlite3_mutex)(unsafe.Pointer(p)).FeType)*4))++
	if g3.FdisableTry != 0 {
		return SQLITE_BUSY
	}
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 20 /* &.xMutexTry */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Leave a mutex
func counterMutexLeave(tls *libc.TLS, p uintptr) { /* test_mutex.c:151:13: */

	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 24 /* &.xMutexLeave */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// sqlite3_shutdown
func test_shutdown(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:159:26: */
	var rc int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_shutdown(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// sqlite3_initialize
func test_initialize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:180:26: */
	var rc int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_initialize(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// install_mutex_counters BOOLEAN
func test_install_mutex_counters(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:201:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var rc int32 = SQLITE_OK
	// var isInstall int32 at bp+56, 4

	*(*sqlite3_mutex_methods)(unsafe.Pointer(bp + 60 /* counter_methods */)) = sqlite3_mutex_methods{
		FxMutexInit: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{counterMutexInit})),
		FxMutexEnd:  *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{counterMutexEnd})),
		FxMutexAlloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32) uintptr
		}{counterMutexAlloc})),
		FxMutexFree:  *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{counterMutexFree})),
		FxMutexEnter: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{counterMutexEnter})),
		FxMutexTry: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{counterMutexTry})),
		FxMutexLeave: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{counterMutexLeave})),
		FxMutexHeld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{counterMutexHeld})),
		FxMutexNotheld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{counterMutexNotheld})),
	}

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17896 /* "BOOLEAN" */)
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+56 /* &isInstall */) {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 56 /* isInstall */)) == g3.FisInstalled {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+34553 /* "mutex counters a..." */, 0))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 56 /* isInstall */)) != 0 {
				return ts + 34573 /* "already installe..." */
			}
			return ts + 34591 /* "not installed" */
		}(), 0))
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 56 /* isInstall */)) != 0 {

		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMUTEX, libc.VaList(bp+32, (uintptr(unsafe.Pointer(&g3))+16 /* &.m */)))
		if rc == SQLITE_OK {
			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp+40, bp+60 /* &counter_methods */))
		}
		g3.FdisableTry = 0
	} else {

		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp+48, (uintptr(unsafe.Pointer(&g3))+16 /* &.m */)))
		libc.Xmemset(tls, (uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */), 0, uint32(unsafe.Sizeof(sqlite3_mutex_methods{})))
	}

	if rc == SQLITE_OK {
		g3.FisInstalled = *(*int32)(unsafe.Pointer(bp + 56 /* isInstall */))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// read_mutex_counters
func test_read_mutex_counters(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:262:26: */
	var pRet uintptr
	var ii int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
	for ii = 0; ii < (SQLITE_MUTEX_STATIC_VFS3 + 1); ii++ {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, aName[ii], -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 52 /* &.aCounter */) + uintptr(ii)*4))))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pRet
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return TCL_OK
}

// clear_mutex_counters
func test_clear_mutex_counters(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:291:26: */
	var ii int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	for ii = 0; ii < (SQLITE_MUTEX_STATIC_VFS3 + 1); ii++ {
		*(*int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 52 /* &.aCounter */) + uintptr(ii)*4)) = 0
	}
	return TCL_OK
}

// Create and free a mutex.  Return the mutex pointer.  The pointer
// will be invalid since the mutex has already been freed.  The
// return pointer just checks to see if the mutex really was allocated.
func test_alloc_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:315:26: */
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var p uintptr = sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_FAST)
	// var zBuf [100]int8 at bp+24, 100

	sqlite3.Xsqlite3_mutex_free(tls, p)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+24 /* &zBuf[0] */, ts+13021 /* "%p" */, libc.VaList(bp, p))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+8, bp+24 /* &zBuf[0] */, uintptr(0)))
	return TCL_OK
}

// sqlite3_config OPTION
//
// OPTION can be either one of the keywords:
//
//            SQLITE_CONFIG_SINGLETHREAD
//            SQLITE_CONFIG_MULTITHREAD
//            SQLITE_CONFIG_SERIALIZED
//
// Or OPTION can be an raw integer.
func test_config(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:342:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	*(*[4]ConfigOption)(unsafe.Pointer(bp /* aOpt */)) = [4]ConfigOption{
		{FzName: ts + 34605 /* "singlethread" */, FiValue: SQLITE_CONFIG_SINGLETHREAD},
		{FzName: ts + 34618 /* "multithread" */, FiValue: SQLITE_CONFIG_MULTITHREAD},
		{FzName: ts + 34630 /* "serialized" */, FiValue: SQLITE_CONFIG_SERIALIZED},
		{},
	}
	var s int32 = int32(unsafe.Sizeof(ConfigOption{}))
	// var i int32 at bp+32, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &aOpt[0] */, s, ts+17204 /* "flag" */, 0, bp+32 /* &i */) != 0 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+32 /* &i */) != 0 {
			return TCL_ERROR
		}
	} else {
		*(*int32)(unsafe.Pointer(bp + 32 /* i */)) = (*ConfigOption)(unsafe.Pointer(bp /* &aOpt */ + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* i */)))*8)).FiValue
	}

	rc = sqlite3.Xsqlite3_config(tls, *(*int32)(unsafe.Pointer(bp + 32 /* i */)), 0)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

type ConfigOption = struct {
	FzName  uintptr
	FiValue int32
} /* test_mutex.c:348:3 */

func getDbPointer1(tls *libc.TLS, pInterp uintptr, pObj uintptr) uintptr { /* test_mutex.c:379:16: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var db uintptr
	// var info Tcl_CmdInfo at bp, 32

	var zCmd uintptr = tcl.XTcl_GetString(tls, pObj)
	if tcl.XTcl_GetCommandInfo(tls, pInterp, zCmd, bp /* &info */) != 0 {
		db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp /* &info */)).FobjClientData))
	} else {
		db = sqlite3TestTextToPtr(tls, zCmd)
	}

	return db
}

func getStaticMutexPointer(tls *libc.TLS, pInterp uintptr, pObj uintptr) uintptr { /* test_mutex.c:392:22: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var iMutex int32 at bp, 4

	if tcl.XTcl_GetIndexFromObjStruct(tls, pInterp, pObj, uintptr(unsafe.Pointer(&aName)), int32(unsafe.Sizeof(uintptr(0))), ts+34641 /* "mutex name" */, 0, bp /* &iMutex */) != 0 {
		return uintptr(0)
	}

	return counterMutexAlloc(tls, *(*int32)(unsafe.Pointer(bp /* iMutex */)))
}

func test_enter_static_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:404:26: */
	var pMutex uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10397 /* "NAME" */)
		return TCL_ERROR
	}
	pMutex = getStaticMutexPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if !(pMutex != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_enter(tls, pMutex)
	return TCL_OK
}

func test_leave_static_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:423:26: */
	var pMutex uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10397 /* "NAME" */)
		return TCL_ERROR
	}
	pMutex = getStaticMutexPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if !(pMutex != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_leave(tls, pMutex)
	return TCL_OK
}

func test_enter_db_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:442:26: */
	var db uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	db = getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if !(db != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_enter(tls, sqlite3.Xsqlite3_db_mutex(tls, db))
	return TCL_OK
}

func test_leave_db_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:461:26: */
	var db uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	db = getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if !(db != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_leave(tls, sqlite3.Xsqlite3_db_mutex(tls, db))
	return TCL_OK
}

func Sqlitetest_mutex_Init(tls *libc.TLS, interp uintptr) int32 { /* test_mutex.c:480:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aCmd8)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd8[i].FzName, aCmd8[i].FxProc, uintptr(0), uintptr(0))
	}

	tcl.XTcl_LinkVar(tls, interp, ts+34652, /* "disable_mutex_in..." */
		(uintptr(unsafe.Pointer(&g3)) + 4 /* &.disableInit */), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+34671, /* "disable_mutex_tr..." */
		(uintptr(unsafe.Pointer(&g3)) + 8 /* &.disableTry */), TCL_LINK_INT)
	return SQLITE_OK
}

var aCmd8 = [11]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 34689 /* "sqlite3_shutdown" */, FxProc: 0},
	{FzName: ts + 34706 /* "sqlite3_initiali..." */, FxProc: 0},
	{FzName: ts + 34725 /* "sqlite3_config" */, FxProc: 0},

	{FzName: ts + 34740 /* "enter_static_mut..." */, FxProc: 0},
	{FzName: ts + 34759 /* "leave_static_mut..." */, FxProc: 0},

	{FzName: ts + 34778 /* "enter_db_mutex" */, FxProc: 0},
	{FzName: ts + 34793 /* "leave_db_mutex" */, FxProc: 0},

	{FzName: ts + 34808 /* "alloc_dealloc_mu..." */, FxProc: 0},
	{FzName: ts + 34828 /* "install_mutex_co..." */, FxProc: 0},
	{FzName: ts + 34851 /* "read_mutex_count..." */, FxProc: 0},
	{FzName: ts + 34871 /* "clear_mutex_coun..." */, FxProc: 0},
} /* test_mutex.c:484:5 */

// Maximum pathname length supported by the fs backend.

// Name used to identify this VFS.

type fs_real_file1 = struct {
	FpFile     uintptr
	FzName     uintptr
	FnDatabase int32
	FnJournal  int32
	FnBlob     int32
	FnRef      int32
	FpNext     uintptr
	FppThis    uintptr
} /* test_onefile.c:97:9 */

// Maximum pathname length supported by the fs backend.

// Name used to identify this VFS.

type fs_real_file = fs_real_file1 /* test_onefile.c:97:29 */

type fs_file1 = struct {
	Fbase  sqlite3_file
	FeType int32
	FpReal uintptr
} /* test_onefile.c:109:9 */

type fs_file = fs_file1 /* test_onefile.c:109:24 */

type tmp_file1 = struct {
	Fbase   sqlite3_file
	FnSize  int32
	FnAlloc int32
	FzAlloc uintptr
} /* test_onefile.c:116:9 */

type tmp_file = tmp_file1 /* test_onefile.c:116:25 */

type fs_vfs_t1 = struct {
	Fbase      sqlite3_vfs
	FpFileList uintptr
	FpParent   uintptr
} /* test_onefile.c:176:9 */

type fs_vfs_t = fs_vfs_t1 /* test_onefile.c:176:25 */

var fs_vfs = fs_vfs_t{
	Fbase: sqlite3_vfs{
		FiVersion:      1,          // pNext
		FzName:         ts + 30488, /* "fs" */ // pAppData
		FxOpen:         0,          // xOpen
		FxDelete:       0,          // xDelete
		FxAccess:       0,          // xAccess
		FxFullPathname: 0,          // xFullPathname
		FxDlOpen:       0,          // xDlOpen
		FxDlError:      0,          // xDlError
		FxDlSym:        0,          // xDlSym
		FxDlClose:      0,          // xDlClose
		FxRandomness:   0,          // xRandomness
		FxSleep:        0,          // xSleep
		FxCurrentTime:  0,          // xCurrentTimeInt64
	}, // pParent
} /* test_onefile.c:183:17 */

var fs_io_methods = sqlite3_io_methods{
	FiVersion:               1, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xShmUnmap
} /* test_onefile.c:208:27 */

var tmp_io_methods = sqlite3_io_methods{
	FiVersion:               1, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xShmUnmap
} /* test_onefile.c:229:27 */

// Useful macros used in several places

// Close a tmp-file.
func tmpClose(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:257:12: */
	var pTmp uintptr = pFile
	sqlite3.Xsqlite3_free(tls, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc)
	return SQLITE_OK
}

// Read data from a tmp-file.
func tmpRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:266:12: */
	var pTmp uintptr = pFile
	if (sqlite_int64(iAmt) + iOfst) > sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize) {
		return (SQLITE_IOERR | (int32(2) << 8))
	}
	libc.Xmemcpy(tls, zBuf, ((*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc + uintptr(iOfst)), uint32(iAmt))
	return SQLITE_OK
}

// Write data to a tmp-file.
func tmpWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:283:12: */
	var pTmp uintptr = pFile
	if (sqlite_int64(iAmt) + iOfst) > sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc) {
		var nNew int32 = (int32(int64(2) * ((sqlite_int64(iAmt) + iOfst) + sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc))))
		var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc, nNew)
		if !(zNew != 0) {
			return SQLITE_NOMEM
		}
		(*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc = zNew
		(*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc = nNew
	}
	libc.Xmemcpy(tls, ((*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc + uintptr(iOfst)), zBuf, uint32(iAmt))
	(*tmp_file)(unsafe.Pointer(pTmp)).FnSize = func() int32 {
		if (sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize)) > (iOfst + sqlite_int64(iAmt)) {
			return (*tmp_file)(unsafe.Pointer(pTmp)).FnSize
		}
		return (int32(iOfst + sqlite_int64(iAmt)))
	}()
	return SQLITE_OK
}

// Truncate a tmp-file.
func tmpTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_onefile.c:307:12: */
	var pTmp uintptr = pFile
	(*tmp_file)(unsafe.Pointer(pTmp)).FnSize = func() int32 {
		if (sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize)) < (size) {
			return (*tmp_file)(unsafe.Pointer(pTmp)).FnSize
		}
		return int32(size)
	}()
	return SQLITE_OK
}

// Sync a tmp-file.
func tmpSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_onefile.c:316:12: */
	return SQLITE_OK
}

// Return the current file-size of a tmp-file.
func tmpFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_onefile.c:323:12: */
	var pTmp uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize)
	return SQLITE_OK
}

// Lock a tmp-file.
func tmpLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:332:12: */
	return SQLITE_OK
}

// Unlock a tmp-file.
func tmpUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:339:12: */
	return SQLITE_OK
}

// Check if another file-handle holds a RESERVED lock on a tmp-file.
func tmpCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_onefile.c:346:12: */
	*(*int32)(unsafe.Pointer(pResOut)) = 0
	return SQLITE_OK
}

// File control method. For custom operations on a tmp-file.
func tmpFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_onefile.c:354:12: */
	return SQLITE_OK
}

// Return the sector-size in bytes for a tmp-file.
func tmpSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:361:12: */
	return 0
}

// Return the device characteristic flags supported by a tmp-file.
func tmpDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:368:12: */
	return 0
}

// Close an fs-file.
func fsClose1(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:375:12: */
	var rc int32 = SQLITE_OK
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal

	// Decrement the real_file ref-count.
	(*fs_real_file)(unsafe.Pointer(pReal)).FnRef--

	// When the ref-count reaches 0, destroy the structure
	if (*fs_real_file)(unsafe.Pointer(pReal)).FnRef == 0 {
		*(*uintptr)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FppThis)) = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext
		if (*fs_real_file)(unsafe.Pointer(pReal)).FpNext != 0 {
			(*fs_real_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpNext)).FppThis = (*fs_real_file)(unsafe.Pointer(pReal)).FppThis
		}
		rc = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods + 4 /* &.xClose */))))(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile)
		sqlite3.Xsqlite3_free(tls, pReal)
	}

	return rc
}

// Read data from an fs-file.
func fsRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:400:12: */
	var rc int32 = SQLITE_OK
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pF uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	if (((*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE) && ((sqlite_int64(iAmt) + iOfst) > sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase))) ||
		(((*fs_file)(unsafe.Pointer(p)).FeType == JOURNAL_FILE) && ((sqlite_int64(iAmt) + iOfst) > sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal))) {
		rc = (SQLITE_IOERR | (int32(2) << 8))
	} else if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods + 8 /* &.xRead */))))(tls, pF, zBuf, iAmt, (iOfst + int64(BLOCKSIZE)))
	} else {
		// Journal file.
		var iRem int32 = iAmt
		var iBuf int32 = 0
		var ii int32 = int32(iOfst)
		for (iRem > 0) && (rc == SQLITE_OK) {
			var iRealOff int32 = (((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - (BLOCKSIZE * ((ii / BLOCKSIZE) + 1))) + (ii % BLOCKSIZE))
			var iRealAmt int32 = func() int32 {
				if (iRem) < (BLOCKSIZE - (iRealOff % BLOCKSIZE)) {
					return iRem
				}
				return (BLOCKSIZE - (iRealOff % BLOCKSIZE))
			}()

			rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods + 8 /* &.xRead */))))(tls, pF, ((zBuf) + uintptr(iBuf)), iRealAmt, int64(iRealOff))
			ii = ii + (iRealAmt)
			iBuf = iBuf + (iRealAmt)
			iRem = iRem - (iRealAmt)
		}
	}

	return rc
}

// Write data to an fs-file.
func fsWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:439:12: */
	var rc int32 = SQLITE_OK
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pF uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		if ((sqlite_int64(iAmt) + iOfst) + int64(BLOCKSIZE)) > (sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal)) {
			rc = SQLITE_FULL
		} else {
			rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods + 12 /* &.xWrite */))))(tls, pF, zBuf, iAmt, (iOfst + int64(BLOCKSIZE)))
			if rc == SQLITE_OK {
				(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = func() int32 {
					if (sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase)) > (sqlite_int64(iAmt) + iOfst) {
						return (*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase
					}
					return (int32(sqlite_int64(iAmt) + iOfst))
				}()
			}
		}
	} else {
		// Journal file.
		var iRem int32 = iAmt
		var iBuf int32 = 0
		var ii int32 = int32(iOfst)
		for (iRem > 0) && (rc == SQLITE_OK) {
			var iRealOff int32 = (((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - (BLOCKSIZE * ((ii / BLOCKSIZE) + 1))) + (ii % BLOCKSIZE))
			var iRealAmt int32 = func() int32 {
				if (iRem) < (BLOCKSIZE - (iRealOff % BLOCKSIZE)) {
					return iRem
				}
				return (BLOCKSIZE - (iRealOff % BLOCKSIZE))
			}()

			if iRealOff < ((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase + BLOCKSIZE) {
				rc = SQLITE_FULL
			} else {
				rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods + 12 /* &.xWrite */))))(tls, pF, ((zBuf) + uintptr(iBuf)), iRealAmt, int64(iRealOff))
				ii = ii + (iRealAmt)
				iBuf = iBuf + (iRealAmt)
				iRem = iRem - (iRealAmt)
			}
		}
		if rc == SQLITE_OK {
			(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = func() int32 {
				if (sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal)) > (sqlite_int64(iAmt) + iOfst) {
					return (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal
				}
				return (int32(sqlite_int64(iAmt) + iOfst))
			}()
		}
	}

	return rc
}

// Truncate an fs-file.
func fsTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_onefile.c:488:12: */
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = func() int32 {
			if (sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase)) < (size) {
				return (*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase
			}
			return int32(size)
		}()
	} else {
		(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = func() int32 {
			if (sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal)) < (size) {
				return (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal
			}
			return int32(size)
		}()
	}
	return SQLITE_OK
}

// Sync an fs-file.
func fsSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_onefile.c:502:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pRealFile uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile
	var rc int32 = SQLITE_OK

	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		// var zSize [4]uint8 at bp, 4

		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */)) = (uint8((uint32((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase) & 0xFF000000) >> 24))
		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */ + 1)) = (uint8(((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x00FF0000) >> 16))
		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */ + 2)) = (uint8(((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x0000FF00) >> 8))
		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */ + 3)) = (uint8((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x000000FF))
		rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 12 /* &.xWrite */))))(tls, pRealFile, bp /* &zSize[0] */, 4, int64(0))
	}
	if rc == SQLITE_OK {
		rc = (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 20 /* &.xSync */))))(tls, pRealFile, (flags & (libc.CplInt32(SQLITE_SYNC_DATAONLY))))
	}

	return rc
}

// Return the current file-size of an fs-file.
func fsFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_onefile.c:526:12: */
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase)
	} else {
		*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal)
	}
	return SQLITE_OK
}

// Lock an fs-file.
func fsLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:540:12: */
	return SQLITE_OK
}

// Unlock an fs-file.
func fsUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:547:12: */
	return SQLITE_OK
}

// Check if another file-handle holds a RESERVED lock on an fs-file.
func fsCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_onefile.c:554:12: */
	*(*int32)(unsafe.Pointer(pResOut)) = 0
	return SQLITE_OK
}

// File control method. For custom operations on an fs-file.
func fsFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_onefile.c:562:12: */
	if op == SQLITE_FCNTL_PRAGMA {
		return SQLITE_NOTFOUND
	}
	return SQLITE_OK
}

// Return the sector-size in bytes for an fs-file.
func fsSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:570:12: */
	return BLOCKSIZE
}

// Return the device characteristic flags supported by an fs-file.
func fsDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:577:12: */
	return 0
}

// Open an fs file handle.
func fsOpen1(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_onefile.c:584:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pFsVfs uintptr
	var p uintptr
	var pReal uintptr
	var eType int32
	var nName int32
	var rc int32
	var p2 uintptr
	// var zS [4]uint8 at bp+8, 4

	var real_flags int32
	// var size sqlite3_int64 at bp, 8

	var pRealFile uintptr
	var pParent uintptr
	pFsVfs = pVfs
	p = pFile
	pReal = uintptr(0)
	rc = SQLITE_OK

	if !(0 == (flags & (SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_MAIN_JOURNAL))) {
		goto __1
	}
	p2 = pFile
	libc.Xmemset(tls, p2, 0, uint32(unsafe.Sizeof(tmp_file{})))
	(*tmp_file)(unsafe.Pointer(p2)).Fbase.FpMethods = uintptr(unsafe.Pointer(&tmp_io_methods))
	return SQLITE_OK
__1:
	;

	eType = func() int32 {
		if (flags & (SQLITE_OPEN_MAIN_DB)) != 0 {
			return DATABASE_FILE
		}
		return JOURNAL_FILE
	}()
	(*fs_file)(unsafe.Pointer(p)).Fbase.FpMethods = uintptr(unsafe.Pointer(&fs_io_methods))
	(*fs_file)(unsafe.Pointer(p)).FeType = eType

	nName = (int32(libc.Xstrlen(tls, zName)) - (func() int32 {
		if eType == JOURNAL_FILE {
			return 8
		}
		return 0
	}()))
	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
__2:
	if !((pReal != 0) && (libc.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zName, uint32(nName)) != 0)) {
		goto __4
	}
	goto __3
__3:
	pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext
	goto __2
	goto __4
__4:
	;

	if !(!(pReal != 0)) {
		goto __5
	}
	real_flags = ((flags & libc.CplInt32(SQLITE_OPEN_MAIN_DB)) | SQLITE_OPEN_TEMP_DB)
	pParent = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpParent

	pReal = sqlite3.Xsqlite3_malloc(tls, (int32(uint32(unsafe.Sizeof(fs_real_file{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile))))
	if !(!(pReal != 0)) {
		goto __6
	}
	rc = SQLITE_NOMEM
	goto open_out
__6:
	;
	libc.Xmemset(tls, pReal, 0, (uint32(unsafe.Sizeof(fs_real_file{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)))
	(*fs_real_file)(unsafe.Pointer(pReal)).FzName = zName
	(*fs_real_file)(unsafe.Pointer(pReal)).FpFile = (pReal + 1*32)

	rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 24 /* &.xOpen */))))(tls, pParent, zName, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile, real_flags, pOutFlags)
	if !(rc != SQLITE_OK) {
		goto __7
	}
	goto open_out
__7:
	;
	pRealFile = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 24 /* &.xFileSize */))))(tls, pRealFile, bp /* &size */)
	if !(rc != SQLITE_OK) {
		goto __8
	}
	goto open_out
__8:
	;
	if !(*(*sqlite3_int64)(unsafe.Pointer(bp /* size */)) == int64(0)) {
		goto __9
	}
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 12 /* &.xWrite */))))(tls, pRealFile, ts+34892 /* "\x00" */, 1, (int64(BLOBSIZE - 1)))
	(*fs_real_file)(unsafe.Pointer(pReal)).FnBlob = BLOBSIZE
	goto __10
__9:
	(*fs_real_file)(unsafe.Pointer(pReal)).FnBlob = int32(*(*sqlite3_int64)(unsafe.Pointer(bp /* size */)))
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 8 /* &.xRead */))))(tls, pRealFile, bp+8 /* &zS[0] */, 4, int64(0))
	(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = ((((int32(*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */))) << 24) + (int32(*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + 1))) << 16)) + (int32(*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + 2))) << 8)) + int32(*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + 3))))
	if !(rc == SQLITE_OK) {
		goto __11
	}
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 8 /* &.xRead */))))(tls, pRealFile, bp+8 /* &zS[0] */, 4, (int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - 4)))
	if !((((*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */)) != 0) || (*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + 1)) != 0)) || (*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + 2)) != 0)) || (*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + 3)) != 0)) {
		goto __12
	}
	(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = (*fs_real_file)(unsafe.Pointer(pReal)).FnBlob
__12:
	;
__11:
	;
__10:
	;

	if !(rc == SQLITE_OK) {
		goto __13
	}
	(*fs_real_file)(unsafe.Pointer(pReal)).FpNext = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	if !((*fs_real_file)(unsafe.Pointer(pReal)).FpNext != 0) {
		goto __14
	}
	(*fs_real_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpNext)).FppThis = (pReal + 24 /* &.pNext */)
__14:
	;
	(*fs_real_file)(unsafe.Pointer(pReal)).FppThis = (pFsVfs + 88 /* &.pFileList */)
	(*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList = pReal
__13:
	;
__5:
	;

open_out:
	if !(pReal != 0) {
		goto __15
	}
	if !(rc == SQLITE_OK) {
		goto __16
	}
	(*fs_file)(unsafe.Pointer(p)).FpReal = pReal
	(*fs_real_file)(unsafe.Pointer(pReal)).FnRef++
	goto __17
__16:
	if !((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods != 0) {
		goto __18
	}
	(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods + 4 /* &.xClose */))))(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile)
__18:
	;
	sqlite3.Xsqlite3_free(tls, pReal)
__17:
	;
__15:
	;
	return rc
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func fsDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_onefile.c:686:12: */
	var rc int32 = SQLITE_OK
	var pFsVfs uintptr = pVfs
	var pReal uintptr
	var pF uintptr
	var nName int32 = (int32(libc.Xstrlen(tls, zPath)) - 8)

	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	for ; (pReal != 0) && (libc.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zPath, uint32(nName)) != 0); pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext {
	}
	if pReal != 0 {
		pF = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile
		rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods + 12 /* &.xWrite */))))(tls, pF, ts+34894 /* "\x00\x00\x00\x00" */, 4, (int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - BLOCKSIZE)))
		if rc == SQLITE_OK {
			(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = 0
		}
	}
	return rc
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func fsAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_onefile.c:712:12: */
	var pFsVfs uintptr = pVfs
	var pReal uintptr
	var isJournal int32 = 0
	var nName int32 = int32(libc.Xstrlen(tls, zPath))

	if flags != SQLITE_ACCESS_EXISTS {
		var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
		return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 32 /* &.xAccess */))))(tls, pParent, zPath, flags, pResOut)
	}

	if (nName > 8) && (libc.Xstrcmp(tls, ts+32244 /* "-journal" */, (zPath+uintptr((nName-8)))) == 0) {
		nName = nName - (8)
		isJournal = 1
	}

	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	for ; (pReal != 0) && (libc.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zPath, uint32(nName)) != 0); pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext {
	}

	*(*int32)(unsafe.Pointer(pResOut)) = (libc.Bool32((pReal != 0) && (!(isJournal != 0) || ((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal > 0))))
	return SQLITE_OK
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (FS_MAX_PATHNAME+1) bytes.
func fsFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_onefile.c:746:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 36 /* &.xFullPathname */))))(tls, pParent, zPath, nOut, zOut)
}

// Open the dynamic library located at zPath and return a handle.
func fsDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr { /* test_onefile.c:759:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((pParent + 40 /* &.xDlOpen */))))(tls, pParent, zPath)
}

// Populate the buffer zErrMsg (size nByte bytes) with a human readable
// utf-8 string describing the most recent error encountered associated
// with dynamic libraries.
func fsDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* test_onefile.c:769:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	(*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer((pParent + 44 /* &.xDlError */))))(tls, pParent, nByte, zErrMsg)
}

// Return a pointer to the symbol zSymbol in the dynamic library pHandle.
func fsDlSym(tls *libc.TLS, pVfs uintptr, pH uintptr, zSym uintptr) uintptr { /* test_onefile.c:777:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((pParent + 48 /* &.xDlSym */))))(tls, pParent, pH, zSym)
}

// Close the dynamic library handle pHandle.
func fsDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) { /* test_onefile.c:785:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	(*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer((pParent + 52 /* &.xDlClose */))))(tls, pParent, pHandle)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func fsRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_onefile.c:794:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 56 /* &.xRandomness */))))(tls, pParent, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func fsSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* test_onefile.c:803:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer((pParent + 60 /* &.xSleep */))))(tls, pParent, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func fsCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_onefile.c:811:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pParent + 64 /* &.xCurrentTime */))))(tls, pParent, pTimeOut)
}

// This procedure registers the fs vfs with SQLite. If the argument is
// true, the fs vfs becomes the new default vfs. It is the only publicly
// available function in this file.
func fs_register(tls *libc.TLS) int32 { /* test_onefile.c:821:5: */
	if fs_vfs.FpParent != 0 {
		return SQLITE_OK
	}
	fs_vfs.FpParent = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	fs_vfs.Fbase.FmxPathname = (*sqlite3_vfs)(unsafe.Pointer(fs_vfs.FpParent)).FmxPathname
	fs_vfs.Fbase.FszOsFile = func() int32 {
		if (uint32(unsafe.Sizeof(tmp_file{}))) > (uint32(unsafe.Sizeof(fs_file{}))) {
			return int32(unsafe.Sizeof(tmp_file{}))
		}
		return int32(unsafe.Sizeof(fs_file{}))
	}()
	return sqlite3.Xsqlite3_vfs_register(tls, (uintptr(unsafe.Pointer(&fs_vfs)) /* &.base */), 0)
}

func SqlitetestOnefile_Init(tls *libc.TLS) int32 { /* test_onefile.c:830:7: */
	return fs_register(tls)
}

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// Maximum pathname length supported by the vfslog backend.

type VfslogVfs1 = struct {
	Fbase        sqlite3_vfs
	FpVfs        uintptr
	FiNextFileId int32
	FpLog        uintptr
	_            [4]byte
	FiOffset     sqlite3_int64
	FnBuf        int32
	FaBuf        [8192]int8
	_            [4]byte
} /* test_osinst.c:117:9 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// Maximum pathname length supported by the vfslog backend.

type VfslogVfs = VfslogVfs1 /* test_osinst.c:117:26 */
type VfslogFile1 = struct {
	Fbase    sqlite3_file
	FpReal   uintptr
	FpVfslog uintptr
	FiFileId int32
} /* test_osinst.c:118:9 */

type VfslogFile = VfslogFile1 /* test_osinst.c:118:27 */

var vfslog_vfs = sqlite3_vfs{
	FiVersion:          1,                                  // iVersion
	FszOsFile:          int32(unsafe.Sizeof(VfslogFile{})), // szOsFile
	FmxPathname:        INST_MAX_PATHNAME,                  // pAppData
	FxOpen:             0,                                  // xOpen
	FxDelete:           0,                                  // xDelete
	FxAccess:           0,                                  // xAccess
	FxFullPathname:     0,                                  // xFullPathname
	FxDlOpen:           0,                                  // xDlOpen
	FxDlError:          0,                                  // xDlError
	FxDlSym:            0,                                  // xDlSym
	FxDlClose:          0,                                  // xDlClose
	FxRandomness:       0,                                  // xRandomness
	FxSleep:            0,                                  // xSleep
	FxCurrentTime:      0,                                  // xCurrentTime
	FxGetLastError:     0,                                  // xGetLastError
	FxCurrentTimeInt64: 0,                                  // xCurrentTime
} /* test_osinst.c:180:20 */

var vfslog_io_methods = sqlite3_io_methods{
	FiVersion:               2, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
} /* test_osinst.c:202:27 */

// Convenience macros for operations on timevals.
//    NOTE: `timercmp' does not work for >= or <=.

func vfslog_time(tls *libc.TLS) sqlite3_uint64 { /* test_osinst.c:224:23: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var sTime timeval at bp, 8

	libc.Xgettimeofday(tls, bp /* &sTime */, uintptr(0))
	return (sqlite3_uint64((*timeval)(unsafe.Pointer(bp /* &sTime */)).Ftv_usec) + (sqlite3_uint64((*timeval)(unsafe.Pointer(bp /* &sTime */)).Ftv_sec) * uint64(1000000)))
}

// Close an vfslog-file.
func vfslogClose(tls *libc.TLS, pFile uintptr) int32 { /* test_osinst.c:256:12: */
	var t sqlite3_uint64
	var rc int32 = SQLITE_OK
	var p uintptr = pFile

	t = vfslog_time(tls)
	if (*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		rc = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 4 /* &.xClose */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	}
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_CLOSE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

// Read data from an vfslog-file.
func vfslogRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_osinst.c:273:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 8 /* &.xRead */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_READ, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, iAmt, int32(iOfst))
	return rc
}

// Write data to an vfslog-file.
func vfslogWrite(tls *libc.TLS, pFile uintptr, z uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_osinst.c:292:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 12 /* &.xWrite */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, z, iAmt, iOfst)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_WRITE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, iAmt, int32(iOfst))
	return rc
}

// Truncate an vfslog-file.
func vfslogTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_osinst.c:311:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 16 /* &.xTruncate */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, size)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_TRUNCATE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, int32(size))
	return rc
}

// Sync an vfslog-file.
func vfslogSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_osinst.c:325:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 20 /* &.xSync */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, flags)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SYNC, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, flags, 0)
	return rc
}

// Return the current file-size of an vfslog-file.
func vfslogFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_osinst.c:339:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 24 /* &.xFileSize */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, pSize)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_FILESIZE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, int32(*(*sqlite_int64)(unsafe.Pointer(pSize))))
	return rc
}

// Lock an vfslog-file.
func vfslogLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_osinst.c:353:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 28 /* &.xLock */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, eLock)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_LOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, eLock, 0)
	return rc
}

// Unlock an vfslog-file.
func vfslogUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_osinst.c:367:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 32 /* &.xUnlock */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, eLock)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_UNLOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, eLock, 0)
	return rc
}

// Check if another file-handle holds a RESERVED lock on an vfslog-file.
func vfslogCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_osinst.c:381:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 36 /* &.xCheckReservedLock */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, pResOut)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_CHECKRESERVEDLOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, *(*int32)(unsafe.Pointer(pResOut)), 0)
	return rc
}

// File control method. For custom operations on an vfslog-file.
func vfslogFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_osinst.c:395:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = pFile
	var rc int32 = (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 40 /* &.xFileControl */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, op, pArg)
	if (op == SQLITE_FCNTL_VFSNAME) && (rc == SQLITE_OK) {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+34899 /* "vfslog/%z" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

// Return the sector-size in bytes for an vfslog-file.
func vfslogSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_osinst.c:407:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 44 /* &.xSectorSize */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SECTORSIZE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

// Return the device characteristic flags supported by an vfslog-file.
func vfslogDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_osinst.c:421:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 48 /* &.xDeviceCharacteristics */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_DEVCHAR, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test_osinst.c:432:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 56 /* &.xShmLock */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, ofst, n, flags)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMLOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogShmMap(tls *libc.TLS, pFile uintptr, iRegion int32, szRegion int32, isWrite int32, pp uintptr) int32 { /* test_osinst.c:442:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 52 /* &.xShmMap */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, iRegion, szRegion, isWrite, libc.AtomicLoadUintptr(&pp))
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMMAP, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogShmBarrier(tls *libc.TLS, pFile uintptr) { /* test_osinst.c:458:13: */
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 60 /* &.xShmBarrier */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMBARRIER, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), SQLITE_OK, 0, 0)
}

func vfslogShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 { /* test_osinst.c:466:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 64 /* &.xShmUnmap */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, deleteFlag)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMUNMAP, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

// Open an vfslog file handle.
func vfslogOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_osinst.c:481:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	var pLog uintptr = pVfs

	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&vfslog_io_methods))
	(*VfslogFile)(unsafe.Pointer(p)).FpReal = (p + 1*16)
	(*VfslogFile)(unsafe.Pointer(p)).FpVfslog = pVfs
	(*VfslogFile)(unsafe.Pointer(p)).FiFileId = libc.PreIncInt32(&(*VfslogVfs)(unsafe.Pointer(pLog)).FiNextFileId, 1)

	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 24 /* &.xOpen */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zName, (*VfslogFile)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	t = (vfslog_time(tls) - t)

	vfslog_call(tls, pVfs, OS_OPEN, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	vfslog_string(tls, pVfs, zName)
	return rc
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func vfslogDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_osinst.c:512:12: */
	var rc int32
	var t sqlite3_uint64
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 28 /* &.xDelete */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, dirSync)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, pVfs, OS_DELETE, 0, int64(t), rc, dirSync, 0)
	vfslog_string(tls, pVfs, zPath)
	return rc
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func vfslogAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_osinst.c:527:12: */
	var rc int32
	var t sqlite3_uint64
	t = vfslog_time(tls)
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 32 /* &.xAccess */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, flags, pResOut)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, pVfs, OS_ACCESS, 0, int64(t), rc, flags, *(*int32)(unsafe.Pointer(pResOut)))
	vfslog_string(tls, pVfs, zPath)
	return rc
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (INST_MAX_PATHNAME+1) bytes.
func vfslogFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_osinst.c:548:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 36 /* &.xFullPathname */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, nOut, zOut)
}

// Open the dynamic library located at zPath and return a handle.
func vfslogDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr { /* test_osinst.c:560:13: */
	return (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 40 /* &.xDlOpen */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath)
}

// Populate the buffer zErrMsg (size nByte bytes) with a human readable
// utf-8 string describing the most recent error encountered associated
// with dynamic libraries.
func vfslogDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* test_osinst.c:569:13: */
	(*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 44 /* &.xDlError */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nByte, zErrMsg)
}

// Return a pointer to the symbol zSymbol in the dynamic library pHandle.
func vfslogDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr { /* test_osinst.c:576:13: */
	return (*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 48 /* &.xDlSym */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, p, zSym)
}

// Close the dynamic library handle pHandle.
func vfslogDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) { /* test_osinst.c:583:13: */
	(*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 52 /* &.xDlClose */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, pHandle)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func vfslogRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_osinst.c:591:12: */
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 56 /* &.xRandomness */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func vfslogSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* test_osinst.c:599:12: */
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 60 /* &.xSleep */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func vfslogCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_osinst.c:606:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 64 /* &.xCurrentTime */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, pTimeOut)
}

func vfslogGetLastError(tls *libc.TLS, pVfs uintptr, a int32, b uintptr) int32 { /* test_osinst.c:610:12: */
	return (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 68 /* &.xGetLastError */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, a, b)
}

func vfslogCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, p uintptr) int32 { /* test_osinst.c:613:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 72 /* &.xCurrentTimeInt64 */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, p)
}

func vfslog_flush(tls *libc.TLS, p uintptr) { /* test_osinst.c:617:13: */

	var pending int32 = libc.AtomicLoadInt32(&sqlite3.Xsqlite3_io_error_pending)
	var persist int32 = sqlite3.Xsqlite3_io_error_persist
	var diskfull int32 = sqlite3.Xsqlite3_diskfull_pending

	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, int32(0))
	sqlite3.Xsqlite3_io_error_persist = 0
	sqlite3.Xsqlite3_diskfull_pending = 0

	if (*VfslogVfs)(unsafe.Pointer(p)).FnBuf != 0 {
		(*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods + 12 /* &.xWrite */))))(tls, (*VfslogVfs)(unsafe.Pointer(p)).FpLog, p+116 /* &.aBuf */, (*VfslogVfs)(unsafe.Pointer(p)).FnBuf, (*VfslogVfs)(unsafe.Pointer(p)).FiOffset)
		*(*sqlite3_int64)(unsafe.Pointer(p + 104 /* &.iOffset */)) += (sqlite3_int64((*VfslogVfs)(unsafe.Pointer(p)).FnBuf))
		(*VfslogVfs)(unsafe.Pointer(p)).FnBuf = 0
	}

	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, int32(pending))
	sqlite3.Xsqlite3_io_error_persist = persist
	sqlite3.Xsqlite3_diskfull_pending = diskfull
}

func put32bits(tls *libc.TLS, p uintptr, v uint32) { /* test_osinst.c:645:13: */
	*(*uint8)(unsafe.Pointer(p)) = (uint8(v >> 24))
	*(*uint8)(unsafe.Pointer(p + 1)) = (uint8(v >> 16))
	*(*uint8)(unsafe.Pointer(p + 2)) = (uint8(v >> 8))
	*(*uint8)(unsafe.Pointer(p + 3)) = uint8(v)
}

func vfslog_call(tls *libc.TLS, pVfs uintptr, eEvent int32, iFileid int32, nClick sqlite3_int64, return_code int32, size int32, offset int32) { /* test_osinst.c:652:13: */
	var p uintptr = pVfs
	var zRec uintptr
	if (uint32(24 + (*VfslogVfs)(unsafe.Pointer(p)).FnBuf)) > uint32(unsafe.Sizeof([8192]int8{})) {
		vfslog_flush(tls, p)
	}
	zRec = ((p + 116 /* &.aBuf */) + uintptr((*VfslogVfs)(unsafe.Pointer(p)).FnBuf))
	put32bits(tls, (zRec), uint32(eEvent))
	put32bits(tls, (zRec + 4), uint32(iFileid))
	put32bits(tls, (zRec + 8), (uint32(nClick & int64(0xffff))))
	put32bits(tls, (zRec + 12), uint32(return_code))
	put32bits(tls, (zRec + 16), uint32(size))
	put32bits(tls, (zRec + 20), uint32(offset))
	*(*int32)(unsafe.Pointer(p + 112 /* &.nBuf */)) += (24)
}

func vfslog_string(tls *libc.TLS, pVfs uintptr, zStr uintptr) { /* test_osinst.c:676:13: */
	var p uintptr = pVfs
	var zRec uintptr
	var nStr int32
	if zStr != 0 {
		nStr = int32(libc.Xstrlen(tls, zStr))
	} else {
		nStr = 0
	}
	if (uint32((4 + nStr) + (*VfslogVfs)(unsafe.Pointer(p)).FnBuf)) > uint32(unsafe.Sizeof([8192]int8{})) {
		vfslog_flush(tls, p)
	}
	zRec = ((p + 116 /* &.aBuf */) + uintptr((*VfslogVfs)(unsafe.Pointer(p)).FnBuf))
	put32bits(tls, (zRec), uint32(nStr))
	if zStr != 0 {
		libc.Xmemcpy(tls, (zRec + 4), zStr, uint32(nStr))
	}
	*(*int32)(unsafe.Pointer(p + 112 /* &.nBuf */)) += (4 + nStr)
}

func vfslog_finalize(tls *libc.TLS, p uintptr) { /* test_osinst.c:691:13: */
	if (*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods != 0 {
		vfslog_flush(tls, p)
		(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods + 4 /* &.xClose */))))(tls, (*VfslogVfs)(unsafe.Pointer(p)).FpLog)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func sqlite3_vfslog_finalize(tls *libc.TLS, zVfs uintptr) int32 { /* test_osinst.c:699:5: */
	var pVfs uintptr
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, zVfs)
	if !(pVfs != 0) || ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{vfslogOpen}))) {
		return SQLITE_ERROR
	}
	sqlite3.Xsqlite3_vfs_unregister(tls, pVfs)
	vfslog_finalize(tls, pVfs)
	return SQLITE_OK
}

func sqlite3_vfslog_new(tls *libc.TLS, zVfs uintptr, zParentVfs uintptr, zLog uintptr) int32 { /* test_osinst.c:710:5: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	var pParent uintptr
	var nByte int32
	// var flags int32 at bp, 4

	var rc int32
	var zFile uintptr
	var nVfs int32

	pParent = sqlite3.Xsqlite3_vfs_find(tls, zParentVfs)
	if !(pParent != 0) {
		return SQLITE_ERROR
	}

	nVfs = int32(libc.Xstrlen(tls, zVfs))
	nByte = (int32(((((uint32(unsafe.Sizeof(VfslogVfs{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)) + uint32(nVfs)) + uint32(1)) + uint32((*sqlite3_vfs)(unsafe.Pointer(pParent)).FmxPathname)) + uint32(1)))
	p = sqlite3.Xsqlite3_malloc(tls, nByte)
	libc.Xmemset(tls, p, 0, uint32(nByte))

	(*VfslogVfs)(unsafe.Pointer(p)).FpVfs = pParent
	(*VfslogVfs)(unsafe.Pointer(p)).FpLog = (p + 1*8312)
	libc.Xmemcpy(tls, (p /* &.base */), uintptr(unsafe.Pointer(&vfslog_vfs)), uint32(unsafe.Sizeof(sqlite3_vfs{})))
	(*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName = (((*VfslogVfs)(unsafe.Pointer(p)).FpLog) + uintptr((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile))
	*(*int32)(unsafe.Pointer(p /* &.base */ + 4 /* &.szOsFile */)) += ((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)
	libc.Xmemcpy(tls, (*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName, zVfs, uint32(nVfs))

	zFile = ((*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName + uintptr((nVfs + 1)))
	(*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 36 /* &.xFullPathname */))))(tls, pParent, zLog, (*sqlite3_vfs)(unsafe.Pointer(pParent)).FmxPathname, zFile)

	*(*int32)(unsafe.Pointer(bp /* flags */)) = ((SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE) | SQLITE_OPEN_SUPER_JOURNAL)
	(*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pParent + 28 /* &.xDelete */))))(tls, pParent, zFile, 0)
	rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 24 /* &.xOpen */))))(tls, pParent, zFile, (*VfslogVfs)(unsafe.Pointer(p)).FpLog, *(*int32)(unsafe.Pointer(bp /* flags */)), bp /* &flags */)
	if rc == SQLITE_OK {
		libc.Xmemcpy(tls, p+116 /* &.aBuf */, ts+34909 /* "sqlite_ostrace1...." */, uint32(20))
		(*VfslogVfs)(unsafe.Pointer(p)).FiOffset = int64(0)
		(*VfslogVfs)(unsafe.Pointer(p)).FnBuf = 20
		rc = sqlite3.Xsqlite3_vfs_register(tls, p, 1)
	}
	if rc != 0 {
		vfslog_finalize(tls, p)
	}
	return rc
}

func sqlite3_vfslog_annotate(tls *libc.TLS, zVfs uintptr, zMsg uintptr) int32 { /* test_osinst.c:758:5: */
	var pVfs uintptr
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, zVfs)
	if !(pVfs != 0) || ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{vfslogOpen}))) {
		return SQLITE_ERROR
	}
	vfslog_call(tls, pVfs, OS_ANNOTATE, 0, int64(0), 0, 0, 0)
	vfslog_string(tls, pVfs, zMsg)
	return SQLITE_OK
}

func vfslog_eventname(tls *libc.TLS, eEvent int32) uintptr { /* test_osinst.c:769:19: */
	var zEvent uintptr = uintptr(0)

	switch eEvent {
	case OS_CLOSE:
		zEvent = ts + 34930 /* "xClose" */
		break
	case OS_READ:
		zEvent = ts + 34937 /* "xRead" */
		break
	case OS_WRITE:
		zEvent = ts + 34943 /* "xWrite" */
		break
	case OS_TRUNCATE:
		zEvent = ts + 34950 /* "xTruncate" */
		break
	case OS_SYNC:
		zEvent = ts + 27353 /* "xSync" */
		break
	case OS_FILESIZE:
		zEvent = ts + 34960 /* "xFilesize" */
		break
	case OS_LOCK:
		zEvent = ts + 34970 /* "xLock" */
		break
	case OS_UNLOCK:
		zEvent = ts + 34976 /* "xUnlock" */
		break
	case OS_CHECKRESERVEDLOCK:
		zEvent = ts + 34984 /* "xCheckResLock" */
		break
	case OS_FILECONTROL:
		zEvent = ts + 34998 /* "xFileControl" */
		break
	case OS_SECTORSIZE:
		zEvent = ts + 35011 /* "xSectorSize" */
		break
	case OS_DEVCHAR:
		zEvent = ts + 35023 /* "xDeviceChar" */
		break
	case OS_OPEN:
		zEvent = ts + 26925 /* "xOpen" */
		break
	case OS_DELETE:
		zEvent = ts + 35035 /* "xDelete" */
		break
	case OS_ACCESS:
		zEvent = ts + 35043 /* "xAccess" */
		break
	case OS_FULLPATHNAME:
		zEvent = ts + 35051 /* "xFullPathname" */
		break
	case OS_RANDOMNESS:
		zEvent = ts + 35065 /* "xRandomness" */
		break
	case OS_SLEEP:
		zEvent = ts + 35077 /* "xSleep" */
		break
	case OS_CURRENTTIME:
		zEvent = ts + 35084 /* "xCurrentTime" */
		break

	case OS_SHMUNMAP:
		zEvent = ts + 35097 /* "xShmUnmap" */
		break
	case OS_SHMLOCK:
		zEvent = ts + 35107 /* "xShmLock" */
		break
	case OS_SHMBARRIER:
		zEvent = ts + 35116 /* "xShmBarrier" */
		break
	case OS_SHMMAP:
		zEvent = ts + 35128 /* "xShmMap" */
		break

	case OS_ANNOTATE:
		zEvent = ts + 35136 /* "annotation" */
		break
	}

	return zEvent
}

type VfslogVtab1 = struct {
	Fbase  sqlite3_vtab
	FpFd   uintptr
	FnByte sqlite3_int64
	FzFile uintptr
	_      [4]byte
} /* test_osinst.c:804:9 */

type VfslogVtab = VfslogVtab1 /* test_osinst.c:804:27 */
type VfslogCsr1 = struct {
	Fbase       sqlite3_vtab_cursor
	_           [4]byte
	FiRowid     sqlite3_int64
	FiOffset    sqlite3_int64
	FzTransient uintptr
	FnFile      int32
	FazFile     uintptr
	FaBuf       [1024]uint8
	_           [4]byte
} /* test_osinst.c:805:9 */

type VfslogCsr = VfslogCsr1 /* test_osinst.c:805:26 */

func get32bits(tls *libc.TLS, p uintptr) uint32 { /* test_osinst.c:830:21: */
	return (uint32((((int32(*(*uint8)(unsafe.Pointer(p))) << 24) + (int32(*(*uint8)(unsafe.Pointer(p + 1))) << 16)) + (int32(*(*uint8)(unsafe.Pointer(p + 2))) << 8)) + int32(*(*uint8)(unsafe.Pointer(p + 3)))))
}

// The argument must point to a buffer containing a nul-terminated string.
// If the string begins with an SQL quote character it is overwritten by
// the dequoted version. Otherwise the buffer is left unmodified.
func dequote(tls *libc.TLS, z uintptr) { /* test_osinst.c:839:13: */
	var quote int8 // Quote character (if any )
	quote = *(*int8)(unsafe.Pointer(z))
	if (((int32(quote) == '[') || (int32(quote) == '\'')) || (int32(quote) == '"')) || (int32(quote) == '`') {
		var iIn int32 = 1  // Index of next byte to read from input
		var iOut int32 = 0 // Index of next byte to write to output
		if int32(quote) == '[' {
			quote = int8(']')
		}
		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(quote) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr((iIn + 1))))) != int32(quote) {
					break
				}
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = quote
				iIn = iIn + (2)
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
			}
		}
		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

// Connect to or create a vfslog virtual table.
func vlogConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_osinst.c:863:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pVfs uintptr // VFS used to read log file
	// var flags int32 at bp+8, 4
	// flags passed to pVfs->xOpen()
	var p uintptr
	var rc int32
	var nByte int32
	var zFile uintptr

	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	nByte = (int32((uint32(unsafe.Sizeof(VfslogVtab{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile)) + uint32((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname)))
	p = sqlite3.Xsqlite3_malloc(tls, nByte)
	if p == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, p, 0, uint32(nByte))

	(*VfslogVtab)(unsafe.Pointer(p)).FpFd = (p + 1*32)
	(*VfslogVtab)(unsafe.Pointer(p)).FzFile = (((*VfslogVtab)(unsafe.Pointer(p)).FpFd) + uintptr((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile))

	zFile = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 3*4))))
	if !(zFile != 0) {
		sqlite3.Xsqlite3_free(tls, p)
		return SQLITE_NOMEM
	}
	dequote(tls, zFile)
	(*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 36 /* &.xFullPathname */))))(tls, pVfs, zFile, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname, (*VfslogVtab)(unsafe.Pointer(p)).FzFile)
	sqlite3.Xsqlite3_free(tls, zFile)

	*(*int32)(unsafe.Pointer(bp + 8 /* flags */)) = (SQLITE_OPEN_READWRITE | SQLITE_OPEN_SUPER_JOURNAL)
	rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 24 /* &.xOpen */))))(tls, pVfs, (*VfslogVtab)(unsafe.Pointer(p)).FzFile, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, *(*int32)(unsafe.Pointer(bp + 8 /* flags */)), bp+8 /* &flags */)

	if rc == SQLITE_OK {
		(*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods + 24 /* &.xFileSize */))))(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, (p + 16 /* &.nByte */))
		sqlite3.Xsqlite3_declare_vtab(tls, db,
			ts+35147 /* "CREATE TABLE xxx..." */)
		*(*uintptr)(unsafe.Pointer(ppVtab)) = (p /* &.base */)
	} else {
		sqlite3.Xsqlite3_free(tls, p)
	}

	return rc
}

// There is no "best-index". This virtual table always does a linear
// scan of the binary VFS log file.
func vlogBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_osinst.c:916:12: */
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
	return SQLITE_OK
}

// Disconnect from or destroy a vfslog virtual table.
func vlogDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test_osinst.c:924:12: */
	var p uintptr = pVtab
	if (*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods != 0 {
		(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods + 4 /* &.xClose */))))(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd)
		(*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods = uintptr(0)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

// Open a new vfslog cursor.
func vlogOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_osinst.c:937:12: */
	var pCsr uintptr // Newly allocated cursor object

	pCsr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(VfslogCsr{})))
	if !(pCsr != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCsr, 0, uint32(unsafe.Sizeof(VfslogCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCsr /* &.base */)
	return SQLITE_OK
}

// Close a vfslog cursor.
func vlogClose(tls *libc.TLS, pCursor uintptr) int32 { /* test_osinst.c:950:12: */
	var p uintptr = pCursor
	var i int32
	for i = 0; i < (*VfslogCsr)(unsafe.Pointer(p)).FnFile; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(p)).FazFile + uintptr(i)*4)))
	}
	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(p)).FazFile)
	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(p)).FzTransient)
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

// Move a vfslog cursor to the next entry in the file.
func vlogNext(tls *libc.TLS, pCursor uintptr) int32 { /* test_osinst.c:965:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCsr uintptr = pCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab
	var rc int32 = SQLITE_OK
	var nRead int32

	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient)
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient = uintptr(0)

	nRead = 24
	if ((*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset + sqlite3_int64(nRead)) <= (*VfslogVtab)(unsafe.Pointer(p)).FnByte {
		var eEvent int32
		rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods + 8 /* &.xRead */))))(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, pCsr+36 /* &.aBuf */, nRead, (*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset)

		eEvent = int32(get32bits(tls, pCsr+36 /* &.aBuf */))
		if (rc == SQLITE_OK) &&
			(((eEvent == OS_OPEN) || (eEvent == OS_DELETE)) || (eEvent == OS_ACCESS)) {
			// var buf [4]int8 at bp, 4

			rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods + 8 /* &.xRead */))))(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, bp /* &buf[0] */, 4, ((*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset + sqlite3_int64(nRead)))
			nRead = nRead + (4)
			if rc == SQLITE_OK {
				var nStr int32 = int32(get32bits(tls, bp /* buf */))
				var zStr uintptr = sqlite3.Xsqlite3_malloc(tls, (nStr + 1))
				rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods + 8 /* &.xRead */))))(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, zStr, nStr, ((*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset + sqlite3_int64(nRead)))
				*(*int8)(unsafe.Pointer(zStr + uintptr(nStr))) = int8(0)
				nRead = nRead + (nStr)

				if eEvent == OS_OPEN {
					var iFileid int32 = int32(get32bits(tls, ((pCsr + 36 /* &.aBuf */) + 4)))
					if iFileid >= (*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile {
						var nNew int32 = (int32(uint32(unsafe.Sizeof(uintptr(0))) * (uint32(iFileid + 1))))
						(*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile = sqlite3.Xsqlite3_realloc(tls, (*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile, nNew)
						nNew = int32(uint32(nNew) - (uint32(unsafe.Sizeof(uintptr(0))) * uint32((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile)))
						libc.Xmemset(tls, ((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile)*4), 0, uint32(nNew))
						(*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile = (iFileid + 1)
					}
					sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(iFileid)*4)))
					*(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(iFileid)*4)) = zStr
				} else {
					(*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient = zStr
				}
			}
		}
	}

	*(*sqlite3_int64)(unsafe.Pointer(pCsr + 8 /* &.iRowid */)) += (int64(1))
	*(*sqlite3_int64)(unsafe.Pointer(pCsr + 16 /* &.iOffset */)) += (sqlite3_int64(nRead))
	return rc
}

func vlogEof(tls *libc.TLS, pCursor uintptr) int32 { /* test_osinst.c:1016:12: */
	var pCsr uintptr = pCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab
	return (libc.Bool32((*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset >= (*VfslogVtab)(unsafe.Pointer(p)).FnByte))
}

func vlogFilter(tls *libc.TLS, pCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_osinst.c:1022:12: */
	var pCsr uintptr = pCursor
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FiRowid = int64(0)
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset = int64(20)
	return vlogNext(tls, pCursor)
}

func vlogColumn(tls *libc.TLS, pCursor uintptr, ctx uintptr, i int32) int32 { /* test_osinst.c:1033:12: */
	var val uint32
	var pCsr uintptr = pCursor

	val = get32bits(tls, ((pCsr + 36 /* &.aBuf */) + uintptr((4 * i))))

	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, vfslog_eventname(tls, int32(val)), -1, uintptr(0))
			break

		}
	case 1:
		{
			var zStr uintptr = (*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient
			if (val != uint32(0)) && (val < uint32((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile)) {
				zStr = *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(val)*4))
			}
			sqlite3.Xsqlite3_result_text(tls, ctx, zStr, -1, libc.UintptrFromInt32(-1))
			break

		}
	default:
		sqlite3.Xsqlite3_result_int(tls, ctx, int32(val))
		break
	}

	return SQLITE_OK
}

func vlogRowid(tls *libc.TLS, pCursor uintptr, pRowid uintptr) int32 { /* test_osinst.c:1065:12: */
	var pCsr uintptr = pCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*VfslogCsr)(unsafe.Pointer(pCsr)).FiRowid
	return SQLITE_OK
}

func sqlite3_vfslog_register(tls *libc.TLS, db uintptr) int32 { /* test_osinst.c:1071:5: */

	sqlite3.Xsqlite3_create_module(tls, db, ts+35202 /* "vfslog" */, uintptr(unsafe.Pointer(&vfslog_module)), uintptr(0))
	return SQLITE_OK
}

var vfslog_module = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_osinst.c:1072:25 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

func test_vfslog(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_osinst.c:1116:26: */
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var db uintptr
	// var cmdInfo Tcl_CmdInfo at bp+76, 32

	var rc int32 = SQLITE_ERROR
	// var iSub int32 at bp+72, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32418 /* "SUB-COMMAND ..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(unsafe.Pointer(&strs)), int32(unsafe.Sizeof(uintptr(0))), ts+1875 /* "sub-command" */, 0, bp+72 /* &iSub */) != 0 {
		return TCL_ERROR
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp + 72 /* iSub */))) {
	case uint32(0) /* VL_ANNOTATE */ :
		{
			var zVfs uintptr
			var zMsg uintptr
			if objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 3, objv, ts+35209 /* "VFS" */)
				return TCL_ERROR
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			zMsg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
			rc = sqlite3_vfslog_annotate(tls, zVfs, zMsg)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+35213 /* "failed" */, 0))
				return TCL_ERROR
			}
			break

		}
	case uint32(1) /* VL_FINALIZE */ :
		{
			var zVfs uintptr
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+35209 /* "VFS" */)
				return TCL_ERROR
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			rc = sqlite3_vfslog_finalize(tls, zVfs)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+35213 /* "failed" */, 0))
				return TCL_ERROR
			}
			break

		}

	case uint32(2) /* VL_NEW */ :
		{
			var zVfs uintptr
			var zParent uintptr
			var zLog uintptr
			if objc != 5 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+35220 /* "VFS PARENT LOGFI..." */)
				return TCL_ERROR
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
			zLog = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
			if int32(*(*int8)(unsafe.Pointer(zParent))) == 0 {
				zParent = uintptr(0)
			}
			rc = sqlite3_vfslog_new(tls, zVfs, zParent, zLog)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+35213 /* "failed" */, 0))
				return TCL_ERROR
			}
			break

		}

	case uint32(3) /* VL_REGISTER */ :
		{
			var zDb uintptr
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+1911 /* "DB" */)
				return TCL_ERROR
			}
			zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			if tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+76 /* &cmdInfo */) != 0 {
				db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 76 /* &cmdInfo */)).FobjClientData)).Fdb
				rc = sqlite3_vfslog_register(tls, db)
			}
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+35239 /* "bad sqlite3 hand..." */, zDb, uintptr(0)))
				return TCL_ERROR
			}
			break

		}
	}

	return TCL_OK
}

var strs = [5]uintptr{ts + 35260 /* "annotate" */, ts + 35269 /* "finalize" */, ts + 13689 /* "new" */, ts + 35278 /* "register" */, uintptr(0)} /* test_osinst.c:1127:21 */

func SqlitetestOsinst_Init(tls *libc.TLS, interp uintptr) int32 { /* test_osinst.c:1219:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+35202 /* "vfslog" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfslog})), uintptr(0), uintptr(0))
	return TCL_OK
}

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// Global data used by this test implementation.  There is no
// mutexing, which means this page cache will not work in a
// multi-threaded test.
type testpcacheGlobalType1 = struct {
	FpDummy        uintptr
	FnInstance     int32
	FdiscardChance uint32
	FprngSeed      uint32
	FhighStress    uint32
} /* test_pcache.c:33:9 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// Global data used by this test implementation.  There is no
// mutexing, which means this page cache will not work in a
// multi-threaded test.
type testpcacheGlobalType = testpcacheGlobalType1 /* test_pcache.c:33:37 */
var testpcacheGlobal testpcacheGlobalType         /* test_pcache.c:41:29: */

// Initializer.
//
// Verify that the initializer is only called when the system is
// uninitialized.  Allocate some memory and report SQLITE_NOMEM if
// the allocation fails.  This provides a means to test the recovery
// from a failed initialization attempt.  It also verifies that the
// the destructor always gets call - otherwise there would be a
// memory leak.
func testpcacheInit(tls *libc.TLS, pArg uintptr) int32 { /* test_pcache.c:53:12: */

	testpcacheGlobal.FpDummy = sqlite3.Xsqlite3_malloc(tls, 10)
	if testpcacheGlobal.FpDummy == uintptr(0) {
		return SQLITE_NOMEM
	}
	return SQLITE_OK
}

// Destructor
//
// Verify that this is only called after initialization.
// Free the memory allocated by the initializer.
func testpcacheShutdown(tls *libc.TLS, pArg uintptr) { /* test_pcache.c:67:13: */

	sqlite3.Xsqlite3_free(tls, testpcacheGlobal.FpDummy)
	testpcacheGlobal.FpDummy = uintptr(0)
}

// Number of pages in a cache.
//
// The number of pages is a hard upper bound in this test module.
// If more pages are requested, sqlite3PcacheFetch() returns NULL.
//
// If testing with in-memory temp tables, provide a larger pcache.
// Some of the test cases need this.

// Magic numbers used to determine validity of the page cache.

// Private implementation of a page cache.
type testpcache1 = struct {
	FszPage     int32
	FszExtra    int32
	FbPurgeable int32
	FnFree      int32
	FnPinned    int32
	FiRand      uint32
	FiMagic     uint32
	Fa          [217]struct {
		Fpage     sqlite3_pcache_page
		Fkey      uint32
		FisPinned int32
	}
} /* test_pcache.c:100:9 */

// Number of pages in a cache.
//
// The number of pages is a hard upper bound in this test module.
// If more pages are requested, sqlite3PcacheFetch() returns NULL.
//
// If testing with in-memory temp tables, provide a larger pcache.
// Some of the test cases need this.

// Magic numbers used to determine validity of the page cache.

// Private implementation of a page cache.
type testpcache = testpcache1 /* test_pcache.c:100:27 */
type testpcachePage = struct {
	Fpage     sqlite3_pcache_page
	Fkey      uint32
	FisPinned int32
} /* test_pcache.c:100:9 */

// Get a random number using the PRNG in the given page cache.
func testpcacheRandom(tls *libc.TLS, p uintptr) uint32 { /* test_pcache.c:119:17: */
	var x uint32 = uint32(0)
	var i int32
	for i = 0; i < 4; i++ {
		(*testpcache)(unsafe.Pointer(p)).FiRand = (((*testpcache)(unsafe.Pointer(p)).FiRand * uint32(69069)) + uint32(5))
		x = ((x << 8) | (((*testpcache)(unsafe.Pointer(p)).FiRand >> 16) & uint32(0xff)))
	}
	return x
}

// Allocate a new page cache instance.
func testpcacheCreate(tls *libc.TLS, szPage int32, szExtra int32, bPurgeable int32) uintptr { /* test_pcache.c:133:23: */
	var nMem int32
	var x uintptr
	var p uintptr
	var i int32

	szPage = ((szPage + 7) & libc.CplInt32(7))
	nMem = (int32(uint32(unsafe.Sizeof(testpcache{})) + (uint32(TESTPCACHE_NPAGE * (szPage + szExtra)))))
	p = sqlite3.Xsqlite3_malloc(tls, nMem)
	if p == uintptr(0) {
		return uintptr(0)
	}
	x = (p + 1*3500)
	(*testpcache)(unsafe.Pointer(p)).FszPage = szPage
	(*testpcache)(unsafe.Pointer(p)).FszExtra = szExtra
	(*testpcache)(unsafe.Pointer(p)).FnFree = TESTPCACHE_NPAGE
	(*testpcache)(unsafe.Pointer(p)).FnPinned = 0
	(*testpcache)(unsafe.Pointer(p)).FiRand = testpcacheGlobal.FprngSeed
	(*testpcache)(unsafe.Pointer(p)).FbPurgeable = bPurgeable
	(*testpcache)(unsafe.Pointer(p)).FiMagic = uint32(TESTPCACHE_VALID)
	i = 0
__1:
	if !(i < TESTPCACHE_NPAGE) {
		goto __3
	}
	{
		(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(i)*16)).Fkey = uint32(0)
		(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(i)*16)).FisPinned = 0
		(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(i)*16)).Fpage.FpBuf = x
		(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(i)*16)).Fpage.FpExtra = (x + uintptr(szPage))

	}
	goto __2
__2:
	i++
	x += (uintptr(szPage + szExtra))
	goto __1
	goto __3
__3:
	;
	testpcacheGlobal.FnInstance++
	return p
}

// Set the cache size
func testpcacheCachesize(tls *libc.TLS, pCache uintptr, newSize int32) { /* test_pcache.c:168:13: */
	var p uintptr = pCache
	_ = p

}

// Return the number of pages in the cache that are being used.
// This includes both pinned and unpinned pages.
func testpcachePagecount(tls *libc.TLS, pCache uintptr) int32 { /* test_pcache.c:179:12: */
	var p uintptr = pCache

	return (TESTPCACHE_NPAGE - (*testpcache)(unsafe.Pointer(p)).FnFree)
}

// Fetch a page.
func testpcacheFetch(tls *libc.TLS, pCache uintptr, key uint32, createFlag int32) uintptr { /* test_pcache.c:190:28: */
	var p uintptr = pCache
	var i int32
	var j int32

	// See if the page is already in cache.  Return immediately if it is
	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if (*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(i)*16)).Fkey == key {
			if !((*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(i)*16)).FisPinned != 0) {
				(*testpcache)(unsafe.Pointer(p)).FnPinned++

				(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(i)*16)).FisPinned = 1
			}
			return ((p + 28 /* &.a */) + uintptr(i)*16 /* &.page */)
		}
	}

	// If createFlag is 0, never allocate a new page
	if createFlag == 0 {
		return uintptr(0)
	}

	// If no pages are available, always fail
	if (*testpcache)(unsafe.Pointer(p)).FnPinned == TESTPCACHE_NPAGE {
		return uintptr(0)
	}

	// Do not allocate the last TESTPCACHE_RESERVE pages unless createFlag is 2
	if ((*testpcache)(unsafe.Pointer(p)).FnPinned >= (TESTPCACHE_NPAGE - TESTPCACHE_RESERVE)) && (createFlag < 2) {
		return uintptr(0)
	}

	// Do not allocate if highStress is enabled and createFlag is not 2.
	//
	// The highStress setting causes pagerStress() to be called much more
	// often, which exercises the pager logic more intensely.
	if (testpcacheGlobal.FhighStress != 0) && (createFlag < 2) {
		return uintptr(0)
	}

	// Find a free page to allocate if there are any free pages.
	// Withhold TESTPCACHE_RESERVE free pages until createFlag is 2.
	if ((*testpcache)(unsafe.Pointer(p)).FnFree > TESTPCACHE_RESERVE) || ((createFlag == 2) && ((*testpcache)(unsafe.Pointer(p)).FnFree > 0)) {
		j = (int32(testpcacheRandom(tls, p) % uint32(TESTPCACHE_NPAGE)))
		i = 0
	__1:
		if !(i < TESTPCACHE_NPAGE) {
			goto __3
		}
		{
			if (*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(j)*16)).Fkey == uint32(0) {
				(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(j)*16)).Fkey = key
				(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(j)*16)).FisPinned = 1
				libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(j)*16)).Fpage.FpBuf, 0, uint32((*testpcache)(unsafe.Pointer(p)).FszPage))
				libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(j)*16)).Fpage.FpExtra, 0, uint32((*testpcache)(unsafe.Pointer(p)).FszExtra))
				(*testpcache)(unsafe.Pointer(p)).FnPinned++
				(*testpcache)(unsafe.Pointer(p)).FnFree--

				return ((p + 28 /* &.a */) + uintptr(j)*16 /* &.page */)
			}

		}
		goto __2
	__2:
		i++
		j = ((j + 1) % TESTPCACHE_NPAGE)
		goto __1
		goto __3
	__3:

		// The prior loop always finds a freepage to allocate

	}

	// If this cache is not purgeable then we have to fail.
	if (*testpcache)(unsafe.Pointer(p)).FbPurgeable == 0 {
		return uintptr(0)
	}

	// If there are no free pages, recycle a page.  The page to
	// recycle is selected at random from all unpinned pages.
	j = (int32(testpcacheRandom(tls, p) % uint32(TESTPCACHE_NPAGE)))
	i = 0
__4:
	if !(i < TESTPCACHE_NPAGE) {
		goto __6
	}
	{
		if ((*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(j)*16)).Fkey > uint32(0)) && ((*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(j)*16)).FisPinned == 0) {
			(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(j)*16)).Fkey = key
			(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(j)*16)).FisPinned = 1
			libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(j)*16)).Fpage.FpBuf, 0, uint32((*testpcache)(unsafe.Pointer(p)).FszPage))
			libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(j)*16)).Fpage.FpExtra, 0, uint32((*testpcache)(unsafe.Pointer(p)).FszExtra))
			(*testpcache)(unsafe.Pointer(p)).FnPinned++

			return ((p + 28 /* &.a */) + uintptr(j)*16 /* &.page */)
		}

	}
	goto __5
__5:
	i++
	j = ((j + 1) % TESTPCACHE_NPAGE)
	goto __4
	goto __6
__6:
	;

	// The previous loop always finds a page to recycle.

	return uintptr(0)
}

// Unpin a page.
func testpcacheUnpin(tls *libc.TLS, pCache uintptr, pOldPage uintptr, discard int32) { /* test_pcache.c:289:13: */
	var p uintptr = pCache
	var i int32

	// Randomly discard pages as they are unpinned according to the
	// discardChance setting.  If discardChance is 0, the random discard
	// never happens.  If discardChance is 100, it always happens.
	if ((*testpcache)(unsafe.Pointer(p)).FbPurgeable != 0) &&
		((uint32(100) - testpcacheGlobal.FdiscardChance) <= (testpcacheRandom(tls, p) % uint32(100))) {
		discard = 1
	}

	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if ((p + 28 /* &.a */) + uintptr(i)*16 /* &.page */) == pOldPage {
			// The pOldPage pointer always points to a pinned page

			(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(i)*16)).FisPinned = 0
			(*testpcache)(unsafe.Pointer(p)).FnPinned--

			if discard != 0 {
				(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(i)*16)).Fkey = uint32(0)
				(*testpcache)(unsafe.Pointer(p)).FnFree++

			}
			return
		}
	}

	// The pOldPage pointer always points to a valid page

}

// Rekey a single page.
func testpcacheRekey(tls *libc.TLS, pCache uintptr, pOldPage uintptr, oldKey uint32, newKey uint32) { /* test_pcache.c:334:13: */
	var p uintptr = pCache
	var i int32

	// If there already exists another page at newKey, verify that
	// the other page is unpinned and discard it.
	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if (*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(i)*16)).Fkey == newKey {
			// The new key is never a page that is already pinned

			(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(i)*16)).Fkey = uint32(0)
			(*testpcache)(unsafe.Pointer(p)).FnFree++

			break
		}
	}

	// Find the page to be rekeyed and rekey it.
	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if (*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(i)*16)).Fkey == oldKey {
			// The oldKey and pOldPage parameters match

			// Page to be rekeyed must be pinned

			(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(i)*16)).Fkey = newKey
			return
		}
	}

	// Rekey is always given a valid page to work with

}

// Truncate the page cache.  Every page with a key of iLimit or larger
// is discarded.
func testpcacheTruncate(tls *libc.TLS, pCache uintptr, iLimit uint32) { /* test_pcache.c:382:13: */
	var p uintptr = pCache
	var i uint32

	for i = uint32(0); i < uint32(TESTPCACHE_NPAGE); i++ {
		if (*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(i)*16)).Fkey >= iLimit {
			(*testpcachePage)(unsafe.Pointer((p + 28 /* &.a */) + uintptr(i)*16)).Fkey = uint32(0)
			if (*testpcachePage)(unsafe.Pointer((p+28 /* &.a */)+uintptr(i)*16)).FisPinned != 0 {
				(*testpcache)(unsafe.Pointer(p)).FnPinned--

			}
			(*testpcache)(unsafe.Pointer(p)).FnFree++

		}
	}
}

// Destroy a page cache.
func testpcacheDestroy(tls *libc.TLS, pCache uintptr) { /* test_pcache.c:404:13: */
	var p uintptr = pCache

	(*testpcache)(unsafe.Pointer(p)).FiMagic = TESTPCACHE_CLEAR
	sqlite3.Xsqlite3_free(tls, p)
	testpcacheGlobal.FnInstance--
}

// Invoke this routine to register or unregister the testing pager cache
// implemented by this file.
//
// Install the test pager cache if installFlag is 1 and uninstall it if
// installFlag is 0.
//
// When installing, discardChance is a number between 0 and 100 that
// indicates the probability of discarding a page when unpinning the
// page.  0 means never discard (unless the discard flag is set).
// 100 means always discard.
func installTestPCache(tls *libc.TLS, installFlag int32, discardChance uint32, prngSeed uint32, highStress uint32) { /* test_pcache.c:427:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	testpcacheGlobal.FdiscardChance = discardChance
	testpcacheGlobal.FprngSeed = (prngSeed ^ (prngSeed << 16))
	testpcacheGlobal.FhighStress = highStress
	if installFlag != isInstalled {
		if installFlag != 0 {
			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETPCACHE2, libc.VaList(bp, uintptr(unsafe.Pointer(&defaultPcache))))

			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+8, uintptr(unsafe.Pointer(&testPcache))))
		} else {

			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+16, uintptr(unsafe.Pointer(&defaultPcache))))
		}
		isInstalled = installFlag
	}
}

var testPcache = sqlite3_pcache_methods2{
	FiVersion:   1,
	FpArg:       0,
	FxInit:      0,
	FxShutdown:  0,
	FxCreate:    0,
	FxCachesize: 0,
	FxPagecount: 0,
	FxFetch:     0,
	FxUnpin:     0,
	FxRekey:     0,
	FxTruncate:  0,
	FxDestroy:   0,
}                                         /* test_pcache.c:433:40 */
var defaultPcache sqlite3_pcache_methods2 /* test_pcache.c:447:34: */
var isInstalled int32 = 0                 /* test_pcache.c:448:14 */

// The following object serves the same role as FILE in the standard C
// library.  It represents an open connection to a file on disk for I/O.
//
// A single quota_FILE should not be used by two or more threads at the
// same time.  Multiple threads can be using different quota_FILE objects
// simultaneously, but not the same quota_FILE object.
type quota_FILE1 = struct {
	Ff     uintptr
	_      [4]byte
	FiOfst sqlite3_int64
	FpFile uintptr
	_      [4]byte
} /* test_quota.h:145:9 */

// The following object serves the same role as FILE in the standard C
// library.  It represents an open connection to a file on disk for I/O.
//
// A single quota_FILE should not be used by two or more threads at the
// same time.  Multiple threads can be using different quota_FILE objects
// simultaneously, but not the same quota_FILE object.
type quota_FILE = quota_FILE1 /* test_quota.h:145:27 */

// Define some macros helping to catch buffer overflows.

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type quotaGroup1 = struct {
	FzPattern  uintptr
	_          [4]byte
	FiLimit    sqlite3_int64
	FiSize     sqlite3_int64
	FxCallback uintptr
	FpArg      uintptr
	FxDestroy  uintptr
	FpNext     uintptr
	FppPrev    uintptr
	FpFiles    uintptr
} /* test_quota.h:145:9 */

// Define some macros helping to catch buffer overflows.

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type quotaGroup = quotaGroup1 /* test_quota.c:61:27 */
type quotaConn1 = struct {
	Fbase  sqlite3_file
	FpFile uintptr
} /* test_quota.c:62:9 */

type quotaConn = quotaConn1 /* test_quota.c:62:26 */
type quotaFile1 = struct {
	FzFilename     uintptr
	FpGroup        uintptr
	FiSize         sqlite3_int64
	FnRef          int32
	FdeleteOnClose int32
	FpNext         uintptr
	FppPrev        uintptr
} /* test_quota.h:145:9 */

type quotaFile = quotaFile1 /* test_quota.c:63:26 */

//************************ Global Variables *********************************
// All global variables used by this file are containing within the following
// gQuota structure.
var gQuota struct {
	FpOrigVfs      uintptr
	FsThisVfs      sqlite3_vfs
	FsIoMethodsV1  sqlite3_io_methods
	FsIoMethodsV2  sqlite3_io_methods
	FisInitialized int32
	FpMutex        uintptr
	FpGroup        uintptr
} /* test_quota.c:183:3: */

//************************ Utility Routines ********************************
// Acquire and release the mutex used to serialize access to the
// list of quotaGroups.
func quotaEnter(tls *libc.TLS) { /* test_quota.c:190:13: */
	sqlite3.Xsqlite3_mutex_enter(tls, gQuota.FpMutex)
}

func quotaLeave(tls *libc.TLS) { /* test_quota.c:191:13: */
	sqlite3.Xsqlite3_mutex_leave(tls, gQuota.FpMutex)
}

// Count the number of open files in a quotaGroup
func quotaGroupOpenFileCount(tls *libc.TLS, pGroup uintptr) int32 { /* test_quota.c:195:12: */
	var N int32 = 0
	var pFile uintptr = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
	for pFile != 0 {
		if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
			N++
		}
		pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	}
	return N
}

// Remove a file from a quota group.
func quotaRemoveFile(tls *libc.TLS, pFile uintptr) { /* test_quota.c:207:13: */
	var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
	*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) -= ((*quotaFile)(unsafe.Pointer(pFile)).FiSize)
	*(*uintptr)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FppPrev)) = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	if (*quotaFile)(unsafe.Pointer(pFile)).FpNext != 0 {
		(*quotaFile)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FpNext)).FppPrev = (*quotaFile)(unsafe.Pointer(pFile)).FppPrev
	}
	sqlite3.Xsqlite3_free(tls, pFile)
}

// Remove all files from a quota group.  It is always the case that
// all files will be closed when this routine is called.
func quotaRemoveAllFiles(tls *libc.TLS, pGroup uintptr) { /* test_quota.c:218:13: */
	for (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles != 0 {

		quotaRemoveFile(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles)
	}
}

// If the reference count and threshold for a quotaGroup are both
// zero, then destroy the quotaGroup.
func quotaGroupDeref(tls *libc.TLS, pGroup uintptr) { /* test_quota.c:229:13: */
	if ((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit == int64(0)) && (quotaGroupOpenFileCount(tls, pGroup) == 0) {
		quotaRemoveAllFiles(tls, pGroup)
		*(*uintptr)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev)) = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
		if (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext != 0 {
			(*quotaGroup)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FpNext)).FppPrev = (*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev
		}
		if (*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy != 0 {
			(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((pGroup + 32 /* &.xDestroy */))))(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
		}
		sqlite3.Xsqlite3_free(tls, pGroup)
	}
}

// Return TRUE if string z matches glob pattern zGlob.
//
// Globbing rules:
//
//      '*'       Matches any sequence of zero or more characters.
//
//      '?'       Matches exactly one character.
//
//     [...]      Matches one character from the enclosed list of
//                characters.
//
//     [^...]     Matches one character not in the enclosed list.
//
//     /          Matches "/" or "\\"
//
func quotaStrglob(tls *libc.TLS, zGlob uintptr, z uintptr) int32 { /* test_quota.c:256:12: */
	var c int32
	var c2 int32
	var cx int32
	var invert int32
	var seen int32

	for (libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1)))))) != 0 {
		if c == '*' {
			for ((libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1)))))) == '*') || (c == '?') {
				if (c == '?') && ((int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))) == 0) {
					return 0
				}
			}
			if c == 0 {
				return 1
			} else if c == '[' {
				for (*(*int8)(unsafe.Pointer(z)) != 0) && (quotaStrglob(tls, (zGlob-uintptr(1)), z) == 0) {
					z++
				}
				return (libc.Bool32((int32(*(*int8)(unsafe.Pointer(z)))) != 0))
			}
			if c == '/' {
				cx = '\\'
			} else {
				cx = c
			}
			for (libc.AssignInt32(&c2, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))))) != 0 {
				for (c2 != c) && (c2 != cx) {
					c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
					if c2 == 0 {
						return 0
					}
				}
				if quotaStrglob(tls, zGlob, z) != 0 {
					return 1
				}
			}
			return 0
		} else if c == '?' {
			if (int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))) == 0 {
				return 0
			}
		} else if c == '[' {
			var prior_c int32 = 0
			seen = 0
			invert = 0
			c = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
			if c == 0 {
				return 0
			}
			c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			if c2 == '^' {
				invert = 1
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == ']' {
				if c == ']' {
					seen = 1
				}
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			for (c2 != 0) && (c2 != ']') {
				if (((c2 == '-') && (int32(*(*int8)(unsafe.Pointer(zGlob))) != ']')) && (int32(*(*int8)(unsafe.Pointer(zGlob))) != 0)) && (prior_c > 0) {
					c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
					if (c >= prior_c) && (c <= c2) {
						seen = 1
					}
					prior_c = 0
				} else {
					if c == c2 {
						seen = 1
					}
					prior_c = c2
				}
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if (c2 == 0) || ((seen ^ invert) == 0) {
				return 0
			}
		} else if c == '/' {
			if (int32(*(*int8)(unsafe.Pointer(z))) != '/') && (int32(*(*int8)(unsafe.Pointer(z))) != '\\') {
				return 0
			}
			z++
		} else {
			if c != (int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))) {
				return 0
			}
		}
	}
	return (libc.Bool32(int32(*(*int8)(unsafe.Pointer(z))) == 0))
}

// Find a quotaGroup given the filename.
//
// Return a pointer to the quotaGroup object. Return NULL if not found.
func quotaGroupFind(tls *libc.TLS, zFilename uintptr) uintptr { /* test_quota.c:329:19: */
	var p uintptr
	for p = gQuota.FpGroup; (p != 0) && (quotaStrglob(tls, (*quotaGroup)(unsafe.Pointer(p)).FzPattern, zFilename) == 0); p = (*quotaGroup)(unsafe.Pointer(p)).FpNext {
	}
	return p
}

// Translate an sqlite3_file* that is really a quotaConn* into
// the sqlite3_file* for the underlying original VFS.
func quotaSubOpen(tls *libc.TLS, pConn uintptr) uintptr { /* test_quota.c:339:21: */
	var p uintptr = pConn
	return (p + 1*8)
}

// Find a file in a quota group and return a pointer to that file.
// Return NULL if the file is not in the group.
func quotaFindFile(tls *libc.TLS, pGroup uintptr, zName uintptr, createFlag int32) uintptr { /* test_quota.c:347:18: */
	var pFile uintptr = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
	for (pFile != 0) && (libc.Xstrcmp(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, zName) != 0) {
		pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	}
	if (pFile == uintptr(0)) && (createFlag != 0) {
		var nName int32 = (int32(libc.Xstrlen(tls, zName) & size_t(0x3fffffff)))
		pFile = sqlite3.Xsqlite3_malloc(tls, (int32((uint32(unsafe.Sizeof(quotaFile{})) + uint32(nName)) + uint32(1))))
		if pFile != 0 {
			libc.Xmemset(tls, pFile, 0, uint32(unsafe.Sizeof(quotaFile{})))
			(*quotaFile)(unsafe.Pointer(pFile)).FzFilename = (pFile + 1*32)
			libc.Xmemcpy(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, zName, (uint32(nName + 1)))
			(*quotaFile)(unsafe.Pointer(pFile)).FpNext = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles != 0 {
				(*quotaFile)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles)).FppPrev = (pFile + 24 /* &.pNext */)
			}
			(*quotaFile)(unsafe.Pointer(pFile)).FppPrev = (pGroup + 44 /* &.pFiles */)
			(*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles = pFile
			(*quotaFile)(unsafe.Pointer(pFile)).FpGroup = pGroup
		}
	}
	return pFile
}

// Translate UTF8 to MBCS for use in fopen() calls.  Return a pointer to the
// translated text..  Call quota_mbcs_free() to deallocate any memory
// used to store the returned pointer when done.
func quota_utf8_to_mbcs(tls *libc.TLS, zUtf8 uintptr) uintptr { /* test_quota.c:377:13: */
	return zUtf8 // No-op on unix
}

// Deallocate any memory allocated by quota_utf8_to_mbcs().
func quota_mbcs_free(tls *libc.TLS, zOld uintptr) { /* test_quota.c:408:13: */
	// No-op on unix
}

//************************ VFS Method Wrappers ****************************
// This is the xOpen method used for the "quota" VFS.
//
// Most of the work is done by the underlying original VFS.  This method
// simply links the new file into the appropriate quota group if it is a
// file that needs to be tracked.
func quotaOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pConn uintptr, flags int32, pOutFlags uintptr) int32 { /* test_quota.c:424:12: */
	var rc int32                            // Result code
	var pQuotaOpen uintptr                  // The new quota file descriptor
	var pFile uintptr                       // Corresponding quotaFile obj
	var pGroup uintptr                      // The group file belongs to
	var pSubOpen uintptr                    // Real file descriptor
	var pOrigVfs uintptr = gQuota.FpOrigVfs // Real VFS

	// If the file is not a main database file or a WAL, then use the
	// normal xOpen method.
	if (flags & (SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_WAL)) == 0 {
		return (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 24 /* &.xOpen */))))(tls, pOrigVfs, zName, pConn, flags, pOutFlags)
	}

	// If the name of the file does not match any quota group, then
	// use the normal xOpen method.
	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zName)
	if pGroup == uintptr(0) {
		rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 24 /* &.xOpen */))))(tls, pOrigVfs, zName, pConn, flags, pOutFlags)
	} else {
		// If we get to this point, it means the file needs to be quota tracked.
		pQuotaOpen = pConn
		pSubOpen = quotaSubOpen(tls, pConn)
		rc = (*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 24 /* &.xOpen */))))(tls, pOrigVfs, zName, pSubOpen, flags, pOutFlags)
		if rc == SQLITE_OK {
			pFile = quotaFindFile(tls, pGroup, zName, 1)
			if pFile == uintptr(0) {
				quotaLeave(tls)
				(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 4 /* &.xClose */))))(tls, pSubOpen)
				return SQLITE_NOMEM
			}
			(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = (libc.Bool32((flags & SQLITE_OPEN_DELETEONCLOSE) != 0))
			(*quotaFile)(unsafe.Pointer(pFile)).FnRef++
			(*quotaConn)(unsafe.Pointer(pQuotaOpen)).FpFile = pFile
			if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FiVersion == 1 {
				(*quotaConn)(unsafe.Pointer(pQuotaOpen)).Fbase.FpMethods = (uintptr(unsafe.Pointer(&gQuota)) + 92 /* &.sIoMethodsV1 */)
			} else {
				(*quotaConn)(unsafe.Pointer(pQuotaOpen)).Fbase.FpMethods = (uintptr(unsafe.Pointer(&gQuota)) + 168 /* &.sIoMethodsV2 */)
			}
		}
	}
	quotaLeave(tls)
	return rc
}

// This is the xDelete method used for the "quota" VFS.
//
// If the file being deleted is part of the quota group, then reduce
// the size of the quota group accordingly.  And remove the file from
// the set of files in the quota group.
func quotaDelete(tls *libc.TLS, pVfs uintptr, zName uintptr, syncDir int32) int32 { /* test_quota.c:486:12: */
	var rc int32                            // Result code
	var pFile uintptr                       // Files in the quota
	var pGroup uintptr                      // The group file belongs to
	var pOrigVfs uintptr = gQuota.FpOrigVfs // Real VFS

	// Do the actual file delete
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 28 /* &.xDelete */))))(tls, pOrigVfs, zName, syncDir)

	// If the file just deleted is a member of a quota group, then remove
	// it from that quota group.
	if rc == SQLITE_OK {
		quotaEnter(tls)
		pGroup = quotaGroupFind(tls, zName)
		if pGroup != 0 {
			pFile = quotaFindFile(tls, pGroup, zName, 0)
			if pFile != 0 {
				if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
					(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = 1
				} else {
					quotaRemoveFile(tls, pFile)
					quotaGroupDeref(tls, pGroup)
				}
			}
		}
		quotaLeave(tls)
	}
	return rc
}

//*********************** I/O Method Wrappers ******************************

// xClose requests get passed through to the original VFS.  But we
// also have to unlink the quotaConn from the quotaFile and quotaGroup.
// The quotaFile and/or quotaGroup are freed if they are no longer in use.
func quotaClose(tls *libc.TLS, pConn uintptr) int32 { /* test_quota.c:528:12: */
	var p uintptr = pConn
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32
	rc = (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 4 /* &.xClose */))))(tls, pSubOpen)
	quotaEnter(tls)
	(*quotaFile)(unsafe.Pointer(pFile)).FnRef--
	if (*quotaFile)(unsafe.Pointer(pFile)).FnRef == 0 {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		if (*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose != 0 {
			(*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 28 /* &.xDelete */))))(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
			quotaRemoveFile(tls, pFile)
		}
		quotaGroupDeref(tls, pGroup)
	}
	quotaLeave(tls)
	return rc
}

// Pass xRead requests directory thru to the original VFS without
// further processing.
func quotaRead(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_quota.c:551:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 8 /* &.xRead */))))(tls, pSubOpen, pBuf, iAmt, iOfst)
}

// Check xWrite requests to see if they expand the file.  If they do,
// the perform a quota check before passing them through to the
// original VFS.
func quotaWrite(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_quota.c:565:12: */
	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var iEnd sqlite3_int64 = (iOfst + sqlite3_int64(iAmt))
	var pGroup uintptr
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var szNew sqlite3_int64

	if (*quotaFile)(unsafe.Pointer(pFile)).FiSize < iEnd {
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		szNew = (((*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize) + iEnd)
		if (szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit) && ((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0)) {
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback != 0 {
				(*(*func(*libc.TLS, uintptr, uintptr, sqlite3_int64, uintptr))(unsafe.Pointer((pGroup + 24 /* &.xCallback */))))(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, (pGroup + 8 /* &.iLimit */), szNew,
					(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
			}
			if (szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit) && ((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0)) {
				quotaLeave(tls)
				return SQLITE_FULL
			}
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiSize = szNew
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iEnd
		quotaLeave(tls)
	}
	return (*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 12 /* &.xWrite */))))(tls, pSubOpen, pBuf, iAmt, iOfst)
}

// Pass xTruncate requests thru to the original VFS.  If the
// success, update the file size.
func quotaTruncate(tls *libc.TLS, pConn uintptr, size sqlite3_int64) int32 { /* test_quota.c:602:12: */
	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32 = (*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 16 /* &.xTruncate */))))(tls, pSubOpen, size)
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pGroup uintptr
	if rc == SQLITE_OK {
		quotaEnter(tls)
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) -= ((*quotaFile)(unsafe.Pointer(pFile)).FiSize)
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = size
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) += (size)
		quotaLeave(tls)
	}
	return rc
}

// Pass xSync requests through to the original VFS without change
func quotaSync(tls *libc.TLS, pConn uintptr, flags int32) int32 { /* test_quota.c:621:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 20 /* &.xSync */))))(tls, pSubOpen, flags)
}

// Pass xFileSize requests through to the original VFS but then
// update the quotaGroup with the new size before returning.
func quotaFileSize(tls *libc.TLS, pConn uintptr, pSize uintptr) int32 { /* test_quota.c:629:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pGroup uintptr
	// var sz sqlite3_int64 at bp, 8

	var rc int32

	rc = (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 24 /* &.xFileSize */))))(tls, pSubOpen, bp /* &sz */)
	if rc == SQLITE_OK {
		quotaEnter(tls)
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) -= ((*quotaFile)(unsafe.Pointer(pFile)).FiSize)
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */))
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) += (*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)))
		quotaLeave(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pSize)) = *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */))
	}
	return rc
}

// Pass xLock requests through to the original VFS unchanged.
func quotaLock(tls *libc.TLS, pConn uintptr, lock int32) int32 { /* test_quota.c:652:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 28 /* &.xLock */))))(tls, pSubOpen, lock)
}

// Pass xUnlock requests through to the original VFS unchanged.
func quotaUnlock(tls *libc.TLS, pConn uintptr, lock int32) int32 { /* test_quota.c:659:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 32 /* &.xUnlock */))))(tls, pSubOpen, lock)
}

// Pass xCheckReservedLock requests through to the original VFS unchanged.
func quotaCheckReservedLock(tls *libc.TLS, pConn uintptr, pResOut uintptr) int32 { /* test_quota.c:666:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 36 /* &.xCheckReservedLock */))))(tls, pSubOpen, pResOut)
}

// Pass xFileControl requests through to the original VFS unchanged.
func quotaFileControl(tls *libc.TLS, pConn uintptr, op int32, pArg uintptr) int32 { /* test_quota.c:673:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32 = (*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 40 /* &.xFileControl */))))(tls, pSubOpen, op, pArg)
	if (op == SQLITE_FCNTL_VFSNAME) && (rc == SQLITE_OK) {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+35287 /* "quota/%z" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

// Pass xSectorSize requests through to the original VFS unchanged.
func quotaSectorSize(tls *libc.TLS, pConn uintptr) int32 { /* test_quota.c:686:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 44 /* &.xSectorSize */))))(tls, pSubOpen)
}

// Pass xDeviceCharacteristics requests through to the original VFS unchanged.
func quotaDeviceCharacteristics(tls *libc.TLS, pConn uintptr) int32 { /* test_quota.c:693:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 48 /* &.xDeviceCharacteristics */))))(tls, pSubOpen)
}

// Pass xShmMap requests through to the original VFS unchanged.
func quotaShmMap(tls *libc.TLS, pConn uintptr, iRegion int32, szRegion int32, bExtend int32, pp uintptr) int32 { /* test_quota.c:700:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 52 /* &.xShmMap */))))(tls, pSubOpen, iRegion, szRegion, bExtend, libc.AtomicLoadUintptr(&pp))
}

// Pass xShmLock requests through to the original VFS unchanged.
func quotaShmLock(tls *libc.TLS, pConn uintptr, ofst int32, n int32, flags int32) int32 { /* test_quota.c:713:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 56 /* &.xShmLock */))))(tls, pSubOpen, ofst, n, flags)
}

// Pass xShmBarrier requests through to the original VFS unchanged.
func quotaShmBarrier(tls *libc.TLS, pConn uintptr) { /* test_quota.c:725:13: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 60 /* &.xShmBarrier */))))(tls, pSubOpen)
}

// Pass xShmUnmap requests through to the original VFS unchanged.
func quotaShmUnmap(tls *libc.TLS, pConn uintptr, deleteFlag int32) int32 { /* test_quota.c:732:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 64 /* &.xShmUnmap */))))(tls, pSubOpen, deleteFlag)
}

//************************* Public Interfaces ****************************
// Initialize the quota VFS shim.  Use the VFS named zOrigVfsName
// as the VFS that does the actual work.  Use the default if
// zOrigVfsName==NULL.
//
// The quota VFS shim is named "quota".  It will become the default
// VFS if makeDefault is non-zero.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once
// during start-up.
func sqlite3_quota_initialize(tls *libc.TLS, zOrigVfsName uintptr, makeDefault int32) int32 { /* test_quota.c:749:5: */
	var pOrigVfs uintptr
	if gQuota.FisInitialized != 0 {
		return SQLITE_MISUSE
	}
	pOrigVfs = sqlite3.Xsqlite3_vfs_find(tls, zOrigVfsName)
	if pOrigVfs == uintptr(0) {
		return SQLITE_ERROR
	}

	gQuota.FpMutex = sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_FAST)
	if !(int32(gQuota.FpMutex) != 0) {
		return SQLITE_NOMEM
	}
	gQuota.FisInitialized = 1
	gQuota.FpOrigVfs = pOrigVfs
	gQuota.FsThisVfs = *(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs))
	gQuota.FsThisVfs.FxOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{quotaOpen}))
	gQuota.FsThisVfs.FxDelete = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{quotaDelete}))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&gQuota)) + 4 /* &.sThisVfs */ + 4 /* &.szOsFile */)) += int32((uint32(unsafe.Sizeof(quotaConn{}))))
	gQuota.FsThisVfs.FzName = ts + 35296 /* "quota" */
	gQuota.FsIoMethodsV1.FiVersion = 1
	gQuota.FsIoMethodsV1.FxClose = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{quotaClose}))
	gQuota.FsIoMethodsV1.FxRead = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{quotaRead}))
	gQuota.FsIoMethodsV1.FxWrite = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{quotaWrite}))
	gQuota.FsIoMethodsV1.FxTruncate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	}{quotaTruncate}))
	gQuota.FsIoMethodsV1.FxSync = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaSync}))
	gQuota.FsIoMethodsV1.FxFileSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{quotaFileSize}))
	gQuota.FsIoMethodsV1.FxLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaLock}))
	gQuota.FsIoMethodsV1.FxUnlock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaUnlock}))
	gQuota.FsIoMethodsV1.FxCheckReservedLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{quotaCheckReservedLock}))
	gQuota.FsIoMethodsV1.FxFileControl = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{quotaFileControl}))
	gQuota.FsIoMethodsV1.FxSectorSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{quotaSectorSize}))
	gQuota.FsIoMethodsV1.FxDeviceCharacteristics = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{quotaDeviceCharacteristics}))
	gQuota.FsIoMethodsV2 = gQuota.FsIoMethodsV1
	gQuota.FsIoMethodsV2.FiVersion = 2
	gQuota.FsIoMethodsV2.FxShmMap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	}{quotaShmMap}))
	gQuota.FsIoMethodsV2.FxShmLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	}{quotaShmLock}))
	gQuota.FsIoMethodsV2.FxShmBarrier = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{quotaShmBarrier}))
	gQuota.FsIoMethodsV2.FxShmUnmap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaShmUnmap}))
	sqlite3.Xsqlite3_vfs_register(tls, (uintptr(unsafe.Pointer(&gQuota)) + 4 /* &.sThisVfs */), makeDefault)
	return SQLITE_OK
}

// Shutdown the quota system.
//
// All SQLite database connections must be closed before calling this
// routine.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once while
// shutting down in order to free all remaining quota groups.
func sqlite3_quota_shutdown(tls *libc.TLS) int32 { /* test_quota.c:798:5: */
	var pGroup uintptr
	if gQuota.FisInitialized == 0 {
		return SQLITE_MISUSE
	}
	for pGroup = gQuota.FpGroup; pGroup != 0; pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext {
		if quotaGroupOpenFileCount(tls, pGroup) > 0 {
			return SQLITE_MISUSE
		}
	}
	for gQuota.FpGroup != 0 {
		pGroup = gQuota.FpGroup
		gQuota.FpGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit = int64(0)

		quotaGroupDeref(tls, pGroup)
	}
	gQuota.FisInitialized = 0
	sqlite3.Xsqlite3_mutex_free(tls, gQuota.FpMutex)
	sqlite3.Xsqlite3_vfs_unregister(tls, (uintptr(unsafe.Pointer(&gQuota)) + 4 /* &.sThisVfs */))
	libc.Xmemset(tls, uintptr(unsafe.Pointer(&gQuota)), 0, uint32(unsafe.Sizeof(gQuota)))
	return SQLITE_OK
}

// Create or destroy a quota group.
//
// The quota group is defined by the zPattern.  When calling this routine
// with a zPattern for a quota group that already exists, this routine
// merely updates the iLimit, xCallback, and pArg values for that quota
// group.  If zPattern is new, then a new quota group is created.
//
// If the iLimit for a quota group is set to zero, then the quota group
// is disabled and will be deleted when the last database connection using
// the quota group is closed.
//
// Calling this routine on a zPattern that does not exist and with a
// zero iLimit is a no-op.
//
// A quota group must exist with a non-zero iLimit prior to opening
// database connections if those connections are to participate in the
// quota group.  Creating a quota group does not affect database connections
// that are already open.
func sqlite3_quota_set(tls *libc.TLS, zPattern uintptr, iLimit sqlite3_int64, xCallback uintptr, pArg uintptr, xDestroy uintptr) int32 { /* test_quota.c:838:5: */
	var pGroup uintptr
	quotaEnter(tls)
	pGroup = gQuota.FpGroup
	for (pGroup != 0) && (libc.Xstrcmp(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, zPattern) != 0) {
		pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
	}
	if pGroup == uintptr(0) {
		var nPattern int32 = (int32(libc.Xstrlen(tls, zPattern) & size_t(0x3fffffff)))
		if iLimit <= int64(0) {
			quotaLeave(tls)
			return SQLITE_OK
		}
		pGroup = sqlite3.Xsqlite3_malloc(tls, (int32((uint32(unsafe.Sizeof(quotaGroup{})) + uint32(nPattern)) + uint32(1))))
		if pGroup == uintptr(0) {
			quotaLeave(tls)
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pGroup, 0, uint32(unsafe.Sizeof(quotaGroup{})))
		(*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern = (pGroup + 1*48)
		libc.Xmemcpy(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, zPattern, (uint32(nPattern + 1)))
		if gQuota.FpGroup != 0 {
			(*quotaGroup)(unsafe.Pointer(gQuota.FpGroup)).FppPrev = (pGroup + 36 /* &.pNext */)
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FpNext = gQuota.FpGroup
		(*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev = (uintptr(unsafe.Pointer(&gQuota)) + 252 /* &.pGroup */)
		gQuota.FpGroup = pGroup
	}
	(*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit = iLimit
	(*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback = xCallback
	if ((*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy != 0) && ((*quotaGroup)(unsafe.Pointer(pGroup)).FpArg != pArg) {
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer((pGroup + 32 /* &.xDestroy */))))(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
	}
	(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg = pArg
	(*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy = xDestroy
	quotaGroupDeref(tls, pGroup)
	quotaLeave(tls)
	return SQLITE_OK
}

// Bring the named file under quota management.  Or if it is already under
// management, update its size.
func sqlite3_quota_file(tls *libc.TLS, zFilename uintptr) int32 { /* test_quota.c:891:5: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var zFull uintptr = uintptr(0)
	var fd uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp /* outFlags */)) = 0
	// var iSize sqlite3_int64 at bp+8, 8

	var nAlloc int32 = ((gQuota.FsThisVfs.FszOsFile + gQuota.FsThisVfs.FmxPathname) + 2)

	// Allocate space for a file-handle and the full path for file zFilename
	fd = sqlite3.Xsqlite3_malloc(tls, nAlloc)
	if fd == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		zFull = ((fd) + uintptr(gQuota.FsThisVfs.FszOsFile))
		rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 36 /* &.xFullPathname */))))(tls, gQuota.FpOrigVfs, zFilename,
			(gQuota.FsThisVfs.FmxPathname + 1), zFull)
	}

	if rc == SQLITE_OK {
		*(*int8)(unsafe.Pointer(zFull + uintptr((libc.Xstrlen(tls, zFull) + size_t(1))))) = int8(0)
		rc = quotaOpen(tls, (uintptr(unsafe.Pointer(&gQuota)) + 4 /* &.sThisVfs */), zFull, fd,
			(SQLITE_OPEN_READONLY | SQLITE_OPEN_MAIN_DB), bp /* &outFlags */)
		if rc == SQLITE_OK {
			(*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods + 24 /* &.xFileSize */))))(tls, fd, bp+8 /* &iSize */)
			(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods + 4 /* &.xClose */))))(tls, fd)
		} else if rc == SQLITE_CANTOPEN {
			var pGroup uintptr
			var pFile uintptr
			quotaEnter(tls)
			pGroup = quotaGroupFind(tls, zFull)
			if pGroup != 0 {
				pFile = quotaFindFile(tls, pGroup, zFull, 0)
				if pFile != 0 {
					quotaRemoveFile(tls, pFile)
				}
			}
			quotaLeave(tls)
		}
	}

	sqlite3.Xsqlite3_free(tls, fd)
	return rc
}

// Open a potentially quotaed file for I/O.
func sqlite3_quota_fopen(tls *libc.TLS, zFilename uintptr, zMode uintptr) uintptr { /* test_quota.c:936:12: */
	var p uintptr
	var zFull uintptr
	var zFullTranslated uintptr
	var rc int32
	var pGroup uintptr
	var pFile uintptr
	p = uintptr(0)
	zFull = uintptr(0)
	zFullTranslated = uintptr(0)

	zFull = sqlite3.Xsqlite3_malloc(tls, (gQuota.FsThisVfs.FmxPathname + 1))
	if !(zFull == uintptr(0)) {
		goto __1
	}
	return uintptr(0)
__1:
	;
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 36 /* &.xFullPathname */))))(tls, gQuota.FpOrigVfs, zFilename,
		(gQuota.FsThisVfs.FmxPathname + 1), zFull)
	if !(rc != 0) {
		goto __2
	}
	goto quota_fopen_error
__2:
	;
	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(quota_FILE{})))
	if !(p == uintptr(0)) {
		goto __3
	}
	goto quota_fopen_error
__3:
	;
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(quota_FILE{})))
	zFullTranslated = quota_utf8_to_mbcs(tls, zFull)
	if !(zFullTranslated == uintptr(0)) {
		goto __4
	}
	goto quota_fopen_error
__4:
	;
	(*quota_FILE)(unsafe.Pointer(p)).Ff = libc.Xfopen(tls, zFullTranslated, zMode)
	if !((*quota_FILE)(unsafe.Pointer(p)).Ff == uintptr(0)) {
		goto __5
	}
	goto quota_fopen_error
__5:
	;
	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zFull)
	if !(pGroup != 0) {
		goto __6
	}
	pFile = quotaFindFile(tls, pGroup, zFull, 1)
	if !(pFile == uintptr(0)) {
		goto __7
	}
	quotaLeave(tls)
	goto quota_fopen_error
__7:
	;
	(*quotaFile)(unsafe.Pointer(pFile)).FnRef++
	(*quota_FILE)(unsafe.Pointer(p)).FpFile = pFile
__6:
	;
	quotaLeave(tls)
	sqlite3.Xsqlite3_free(tls, zFull)
	return p

quota_fopen_error:
	quota_mbcs_free(tls, zFullTranslated)
	sqlite3.Xsqlite3_free(tls, zFull)
	if !((p != 0) && ((*quota_FILE)(unsafe.Pointer(p)).Ff != 0)) {
		goto __8
	}
	libc.Xfclose(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
__8:
	;
	sqlite3.Xsqlite3_free(tls, p)
	return uintptr(0)
}

// Read content from a quota_FILE
func sqlite3_quota_fread(tls *libc.TLS, pBuf uintptr, size size_t, nmemb size_t, p uintptr) size_t { /* test_quota.c:985:8: */
	return libc.Xfread(tls, pBuf, size, nmemb, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Write content into a quota_FILE.  Invoke the quota callback and block
// the write if we exceed quota.
func sqlite3_quota_fwrite(tls *libc.TLS, pBuf uintptr, size size_t, nmemb size_t, p uintptr) size_t { /* test_quota.c:998:8: */
	var iOfst sqlite3_int64
	var iEnd sqlite3_int64
	var szNew sqlite3_int64
	var pFile uintptr
	var rc size_t

	iOfst = sqlite3_int64(libc.Xftell(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff))
	iEnd = (iOfst + (sqlite3_int64(size * nmemb)))
	pFile = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	if (pFile != 0) && ((*quotaFile)(unsafe.Pointer(pFile)).FiSize < iEnd) {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		szNew = (((*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize) + iEnd)
		if (szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit) && ((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0)) {
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback != 0 {
				(*(*func(*libc.TLS, uintptr, uintptr, sqlite3_int64, uintptr))(unsafe.Pointer((pGroup + 24 /* &.xCallback */))))(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, (pGroup + 8 /* &.iLimit */), szNew,
					(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
			}
			if (szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit) && ((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0)) {
				iEnd = (((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit - (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize) + (*quotaFile)(unsafe.Pointer(pFile)).FiSize)
				nmemb = (size_t((iEnd - iOfst) / sqlite3_int64(size)))
				iEnd = (iOfst + (sqlite3_int64(size * nmemb)))
				szNew = (((*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize) + iEnd)
			}
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiSize = szNew
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iEnd
		quotaLeave(tls)
	} else {
		pFile = uintptr(0)
	}
	rc = libc.Xfwrite(tls, pBuf, size, nmemb, (*quota_FILE)(unsafe.Pointer(p)).Ff)

	// If the write was incomplete, adjust the file size and group size
	// downward
	if (rc < nmemb) && (pFile != 0) {
		var nWritten size_t = rc
		var iNewEnd sqlite3_int64 = (iOfst + (sqlite3_int64(size * nWritten)))
		if iNewEnd < iEnd {
			iNewEnd = iEnd
		}
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FpGroup + 16 /* &.iSize */)) += (iNewEnd - (*quotaFile)(unsafe.Pointer(pFile)).FiSize)
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iNewEnd
		quotaLeave(tls)
	}
	return rc
}

// Close an open quota_FILE stream.
func sqlite3_quota_fclose(tls *libc.TLS, p uintptr) int32 { /* test_quota.c:1054:5: */
	var rc int32
	var pFile uintptr
	rc = libc.Xfclose(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	pFile = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	if pFile != 0 {
		quotaEnter(tls)
		(*quotaFile)(unsafe.Pointer(pFile)).FnRef--
		if (*quotaFile)(unsafe.Pointer(pFile)).FnRef == 0 {
			var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
			if (*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose != 0 {
				(*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 28 /* &.xDelete */))))(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
				quotaRemoveFile(tls, pFile)
			}
			quotaGroupDeref(tls, pGroup)
		}
		quotaLeave(tls)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return rc
}

// Flush memory buffers for a quota_FILE to disk.
func sqlite3_quota_fflush(tls *libc.TLS, p uintptr, doFsync int32) int32 { /* test_quota.c:1082:5: */
	var rc int32
	rc = libc.Xfflush(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	if (rc == 0) && (doFsync != 0) {
		rc = libc.Xfsync(tls, libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff))
	}
	return (libc.Bool32(rc != 0))
}

// Seek on a quota_FILE stream.
func sqlite3_quota_fseek(tls *libc.TLS, p uintptr, offset int32, whence int32) int32 { /* test_quota.c:1099:5: */
	return libc.Xfseek(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff, offset, whence)
}

// rewind a quota_FILE stream.
func sqlite3_quota_rewind(tls *libc.TLS, p uintptr) { /* test_quota.c:1106:6: */
	libc.Xrewind(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Tell the current location of a quota_FILE stream.
func sqlite3_quota_ftell(tls *libc.TLS, p uintptr) int32 { /* test_quota.c:1113:6: */
	return libc.Xftell(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Test the error indicator for the given file.
func sqlite3_quota_ferror(tls *libc.TLS, p uintptr) int32 { /* test_quota.c:1120:5: */
	return libc.Xferror(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Truncate a file to szNew bytes.
func sqlite3_quota_ftruncate(tls *libc.TLS, p uintptr, szNew sqlite3_int64) int32 { /* test_quota.c:1127:5: */
	var pFile uintptr = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	var rc int32
	if ((libc.AssignUintptr(&pFile, (*quota_FILE)(unsafe.Pointer(p)).FpFile)) != uintptr(0)) && ((*quotaFile)(unsafe.Pointer(pFile)).FiSize < szNew) {
		var pGroup uintptr
		if (*quotaFile)(unsafe.Pointer(pFile)).FiSize < szNew {
			// This routine cannot be used to extend a file that is under
			// quota management.  Only true truncation is allowed.
			return -1
		}
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) += (szNew - (*quotaFile)(unsafe.Pointer(pFile)).FiSize)
		quotaLeave(tls)
	}
	rc = libc.Xftruncate(tls, libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff), szNew)
	if (pFile != 0) && (rc == 0) {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) += (szNew - (*quotaFile)(unsafe.Pointer(pFile)).FiSize)
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = szNew
		quotaLeave(tls)
	}
	return rc
}

// Determine the time that the given file was last modified, in
// seconds size 1970.  Write the result into *pTime.  Return 0 on
// success and non-zero on any kind of error.
func sqlite3_quota_file_mtime(tls *libc.TLS, p uintptr, pTime uintptr) int32 { /* test_quota.c:1169:5: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var rc int32
	// var buf stat at bp, 104

	rc = libc.Xfstat(tls, libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff), bp /* &buf */)
	if rc == 0 {
		*(*time_t)(unsafe.Pointer(pTime)) = (*stat)(unsafe.Pointer(bp /* &buf */)).Fst_mtim.Ftv_sec
	}
	return rc
}

// Return the true size of the file, as reported by the operating
// system.
func sqlite3_quota_file_truesize(tls *libc.TLS, p uintptr) sqlite3_int64 { /* test_quota.c:1187:15: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var rc int32
	// var buf stat at bp, 104

	rc = libc.Xfstat(tls, libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff), bp /* &buf */)
	if rc == 0 {
		return (*stat)(unsafe.Pointer(bp /* &buf */)).Fst_size
	}
	return int64(-1)
}

// Return the size of the file, as it is known to the quota subsystem.
func sqlite3_quota_file_size(tls *libc.TLS, p uintptr) sqlite3_int64 { /* test_quota.c:1203:15: */
	if (*quota_FILE)(unsafe.Pointer(p)).FpFile != 0 {
		return (*quotaFile)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).FpFile)).FiSize
	}
	return int64(-1)
}

// Determine the amount of data in bytes available for reading
// in the given file.
func sqlite3_quota_file_available(tls *libc.TLS, p uintptr) int32 { /* test_quota.c:1211:6: */
	var f uintptr = (*quota_FILE)(unsafe.Pointer(p)).Ff
	var pos1 int32
	var pos2 int32
	var rc int32
	pos1 = libc.Xftell(tls, f)
	if pos1 < 0 {
		return -1
	}
	rc = libc.Xfseek(tls, f, 0, SEEK_END)
	if rc != 0 {
		return -1
	}
	pos2 = libc.Xftell(tls, f)
	if pos2 < 0 {
		return -1
	}
	rc = libc.Xfseek(tls, f, pos1, SEEK_SET)
	if rc != 0 {
		return -1
	}
	return (pos2 - pos1)
}

// Remove a managed file.  Update quotas accordingly.
func sqlite3_quota_remove(tls *libc.TLS, zFilename uintptr) int32 { /* test_quota.c:1229:5: */
	var zFull uintptr     // Full pathname for zFilename
	var nFull size_t      // Number of bytes in zFilename
	var rc int32          // Result code
	var pGroup uintptr    // Group containing zFilename
	var pFile uintptr     // A file in the group
	var pNextFile uintptr // next file in the group
	var diff int32        // Difference between filenames
	var c int8            // First character past end of pattern

	zFull = sqlite3.Xsqlite3_malloc(tls, (gQuota.FsThisVfs.FmxPathname + 1))
	if zFull == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 36 /* &.xFullPathname */))))(tls, gQuota.FpOrigVfs, zFilename,
		(gQuota.FsThisVfs.FmxPathname + 1), zFull)
	if rc != 0 {
		sqlite3.Xsqlite3_free(tls, zFull)
		return rc
	}

	// Figure out the length of the full pathname.  If the name ends with
	// / (or \ on windows) then remove the trailing /.
	nFull = libc.Xstrlen(tls, zFull)
	if (nFull > size_t(0)) && ((int32(*(*int8)(unsafe.Pointer(zFull + uintptr((nFull - size_t(1)))))) == '/') || (int32(*(*int8)(unsafe.Pointer(zFull + uintptr((nFull - size_t(1)))))) == '\\')) {
		nFull--
		*(*int8)(unsafe.Pointer(zFull + uintptr(nFull))) = int8(0)
	}

	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zFull)
	if pGroup != 0 {
		for pFile = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles; (pFile != 0) && (rc == SQLITE_OK); pFile = pNextFile {
			pNextFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
			diff = libc.Xstrncmp(tls, zFull, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, nFull)
			if (diff == 0) && ((((int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FzFilename + uintptr(nFull)))))) == 0) || (int32(c) == '/')) || (int32(c) == '\\')) {
				if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
					(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = 1
				} else {
					rc = (*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 28 /* &.xDelete */))))(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
					quotaRemoveFile(tls, pFile)
					quotaGroupDeref(tls, pGroup)
				}
			}
		}
	}
	quotaLeave(tls)
	sqlite3.Xsqlite3_free(tls, zFull)
	return rc
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Argument passed to a TCL quota-over-limit callback.
type TclQuotaCallback1 = struct {
	Finterp  uintptr
	FpScript uintptr
} /* test_quota.c:1293:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Argument passed to a TCL quota-over-limit callback.
type TclQuotaCallback = TclQuotaCallback1 /* test_quota.c:1293:33 */

// This is the callback from a quota-over-limit.
func tclQuotaCallback(tls *libc.TLS, zFilename uintptr, piLimit uintptr, iSize sqlite3_int64, pArg uintptr) { /* test_quota.c:1305:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var p uintptr        // Callback script object
	var pEval uintptr    // Script to evaluate
	var pVarname uintptr // Name of variable to pass as 2nd arg
	// var rnd uint32 at bp, 4
	// Random part of pVarname
	var rc int32 // Tcl error code

	p = pArg
	if p == uintptr(0) {
		return
	}

	pVarname = tcl.XTcl_NewStringObj(tls, ts+35302 /* "::piLimit_" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pVarname)).FrefCount++
	sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(uint32(0))), bp /* &rnd */)
	tcl.XTcl_AppendObjToObj(tls, pVarname, tcl.XTcl_NewIntObj(tls, (int32(*(*uint32)(unsafe.Pointer(bp /* rnd */))&uint32(0x7FFFFFFF)))))
	tcl.XTcl_ObjSetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pVarname, uintptr(0), tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(piLimit))), 0)

	pEval = tcl.XTcl_DuplicateObj(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls, zFilename, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, pVarname)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewWideIntObj(tls, iSize))
	rc = tcl.XTcl_EvalObjEx(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)

	if rc == TCL_OK {
		// var x Tcl_WideInt at bp+8, 8

		var pLimit uintptr = tcl.XTcl_ObjGetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pVarname, uintptr(0), 0)
		rc = tcl.XTcl_GetWideIntFromObj(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pLimit, bp+8 /* &x */)
		*(*sqlite3_int64)(unsafe.Pointer(piLimit)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* x */))
		tcl.XTcl_UnsetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetString(tls, pVarname), uintptr(0), 0)
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pVarname
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp)
	}
}

// Destructor for a TCL quota-over-limit callback.
func tclCallbackDestructor(tls *libc.TLS, pObj uintptr) { /* test_quota.c:1349:13: */
	var p uintptr = pObj
	if p != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TclQuotaCallback)(unsafe.Pointer(p)).FpScript
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// tclcmd: sqlite3_quota_initialize NAME MAKEDEFAULT
func test_quota_initialize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1360:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zName uintptr // Name of new quota VFS
	// var makeDefault int32 at bp, 4
	// True to make the new VFS the default
	var rc int32 // Value returned by quota_initialize()

	// Process arguments
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+34184 /* "NAME MAKEDEFAULT" */)
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp /* &makeDefault */) != 0 {
		return TCL_ERROR
	}
	if int32(*(*int8)(unsafe.Pointer(zName))) == 0 {
		zName = uintptr(0)
	}

	// Call sqlite3_quota_initialize()
	rc = sqlite3_quota_initialize(tls, zName, *(*int32)(unsafe.Pointer(bp /* makeDefault */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

// tclcmd: sqlite3_quota_shutdown
func test_quota_shutdown(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1389:26: */
	var rc int32 // Value returned by quota_shutdown()

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	// Call sqlite3_quota_shutdown()
	rc = sqlite3_quota_shutdown(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

// tclcmd: sqlite3_quota_set PATTERN LIMIT SCRIPT
func test_quota_set(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1412:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var zPattern uintptr // File pattern to configure
	// var iLimit Tcl_WideInt at bp, 8
	// Initial quota in bytes
	var pScript uintptr // Tcl script to invoke to increase quota
	var rc int32        // Value returned by quota_set()
	var p uintptr       // Callback object
	// var nScript int32 at bp+8, 4
	// Length of callback script
	var xDestroy uintptr // Optional destructor for pArg
	var xCallback uintptr

	// Process arguments
	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35313 /* "PATTERN LIMIT SC..." */)
		return TCL_ERROR
	}
	zPattern = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp /* &iLimit */) != 0 {
		return TCL_ERROR
	}
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))
	tcl.XTcl_GetStringFromObj(tls, pScript, bp+8 /* &nScript */)

	if *(*int32)(unsafe.Pointer(bp + 8 /* nScript */)) > 0 {
		// Allocate a TclQuotaCallback object
		p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(TclQuotaCallback{})))
		if !(p != 0) {
			tcl.XTcl_SetResult(tls, interp, ts+32182 /* "SQLITE_NOMEM" */, uintptr(0))
			return TCL_OK
		}
		libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(TclQuotaCallback{})))
		(*TclQuotaCallback)(unsafe.Pointer(p)).Finterp = interp
		(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
		(*TclQuotaCallback)(unsafe.Pointer(p)).FpScript = pScript
		xDestroy = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tclCallbackDestructor}))
		xCallback = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, sqlite3_int64, uintptr)
		}{tclQuotaCallback}))
	} else {
		p = uintptr(0)
		xDestroy = uintptr(0)
		xCallback = uintptr(0)
	}

	// Invoke sqlite3_quota_set()
	rc = sqlite3_quota_set(tls, zPattern, *(*Tcl_WideInt)(unsafe.Pointer(bp /* iLimit */)), xCallback, p, xDestroy)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// tclcmd: sqlite3_quota_file FILENAME
func test_quota_file(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1466:26: */
	var zFilename uintptr // File pattern to configure
	var rc int32          // Value returned by quota_file()

	// Process arguments
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32366 /* "FILENAME" */)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))

	// Invoke sqlite3_quota_file()
	rc = sqlite3_quota_file(tls, zFilename)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// tclcmd:  sqlite3_quota_dump
func test_quota_dump(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1492:26: */
	bp := tls.Alloc(1008)
	defer tls.Free(1008)

	var pResult uintptr
	var pGroupTerm uintptr
	var pFileTerm uintptr
	var pGroup uintptr
	var pFile uintptr

	pResult = tcl.XTcl_NewObj(tls)
	quotaEnter(tls)
	for pGroup = gQuota.FpGroup; pGroup != 0; pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext {
		pGroupTerm = tcl.XTcl_NewObj(tls)
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewStringObj(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewWideIntObj(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit))
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewWideIntObj(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize))
		for pFile = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles; pFile != 0; pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext {
			var i int32
			// var zTemp [1000]int8 at bp+8, 1000

			pFileTerm = tcl.XTcl_NewObj(tls)
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1000]int8{})), bp+8 /* &zTemp[0] */, ts /* "%s" */, libc.VaList(bp, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename))
			for i = 0; *(*int8)(unsafe.Pointer(bp + 8 /* &zTemp[0] */ + uintptr(i))) != 0; i++ {
				if int32(*(*int8)(unsafe.Pointer(bp + 8 /* &zTemp[0] */ + uintptr(i)))) == '\\' {
					*(*int8)(unsafe.Pointer(bp + 8 /* &zTemp[0] */ + uintptr(i))) = int8('/')
				}
			}
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewStringObj(tls, bp+8 /* &zTemp[0] */, -1))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, (*quotaFile)(unsafe.Pointer(pFile)).FiSize))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, int64((*quotaFile)(unsafe.Pointer(pFile)).FnRef)))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, int64((*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose)))
			tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm, pFileTerm)
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pResult, pGroupTerm)
	}
	quotaLeave(tls)
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

// tclcmd: sqlite3_quota_fopen FILENAME MODE
func test_quota_fopen(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1540:26: */
	bp := tls.Alloc(58)
	defer tls.Free(58)

	var zFilename uintptr // File pattern to configure
	var zMode uintptr     // Mode string
	var p uintptr         // Open string object
	// var zReturn [50]int8 at bp+8, 50
	// Name of pointer to return

	// Process arguments
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35334 /* "FILENAME MODE" */)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zMode = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	p = sqlite3_quota_fopen(tls, zFilename, zMode)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+8 /* &zReturn[0] */, ts+13021 /* "%p" */, libc.VaList(bp, p))
	tcl.XTcl_SetResult(tls, interp, bp+8 /* &zReturn[0] */, uintptr(1))
	return TCL_OK
}

// tclcmd: sqlite3_quota_fread HANDLE SIZE NELEM
func test_quota_fread(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1570:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var zBuf uintptr
	// var sz int32 at bp, 4

	// var nElem int32 at bp+4, 4

	var got size_t

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35348 /* "HANDLE SIZE NELE..." */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp /* &sz */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4 /* &nElem */) != 0 {
		return TCL_ERROR
	}
	zBuf = sqlite3.Xsqlite3_malloc(tls, ((*(*int32)(unsafe.Pointer(bp /* sz */)) * *(*int32)(unsafe.Pointer(bp + 4 /* nElem */))) + 1))
	if zBuf == uintptr(0) {
		tcl.XTcl_SetResult(tls, interp, ts+1930 /* "out of memory" */, uintptr(0))
		return TCL_ERROR
	}
	got = sqlite3_quota_fread(tls, zBuf, uint32(*(*int32)(unsafe.Pointer(bp /* sz */))), uint32(*(*int32)(unsafe.Pointer(bp + 4 /* nElem */))), p)
	*(*int8)(unsafe.Pointer(zBuf + uintptr((got * size_t(*(*int32)(unsafe.Pointer(bp /* sz */))))))) = int8(0)
	tcl.XTcl_SetResult(tls, interp, zBuf, uintptr(1))
	sqlite3.Xsqlite3_free(tls, zBuf)
	return TCL_OK
}

// tclcmd: sqlite3_quota_fwrite HANDLE SIZE NELEM CONTENT
func test_quota_fwrite(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1604:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var zBuf uintptr
	// var sz int32 at bp, 4

	// var nElem int32 at bp+4, 4

	var got size_t

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35366 /* "HANDLE SIZE NELE..." */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp /* &sz */) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4 /* &nElem */) != 0 {
		return TCL_ERROR
	}
	zBuf = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
	got = sqlite3_quota_fwrite(tls, zBuf, uint32(*(*int32)(unsafe.Pointer(bp /* sz */))), uint32(*(*int32)(unsafe.Pointer(bp + 4 /* nElem */))), p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(got)))
	return TCL_OK
}

// tclcmd: sqlite3_quota_fclose HANDLE
func test_quota_fclose(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1632:26: */
	var p uintptr
	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28086 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	rc = sqlite3_quota_fclose(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_fflush HANDLE ?HARDSYNC?
func test_quota_fflush(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1654:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp /* doSync */)) = 0

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35392 /* "HANDLE ?HARDSYNC..." */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if objc == 3 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp /* &doSync */) != 0 {
			return TCL_ERROR
		}
	}
	rc = sqlite3_quota_fflush(tls, p, *(*int32)(unsafe.Pointer(bp /* doSync */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_fseek HANDLE OFFSET WHENCE
func test_quota_fseek(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1680:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr
	// var ofst int32 at bp+16, 4

	var zWhence uintptr
	var whence int32
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35410 /* "HANDLE OFFSET WH..." */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16 /* &ofst */) != 0 {
		return TCL_ERROR
	}
	zWhence = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if libc.Xstrcmp(tls, zWhence, ts+35431 /* "SEEK_SET" */) == 0 {
		whence = SEEK_SET
	} else if libc.Xstrcmp(tls, zWhence, ts+35440 /* "SEEK_CUR" */) == 0 {
		whence = SEEK_CUR
	} else if libc.Xstrcmp(tls, zWhence, ts+35449 /* "SEEK_END" */) == 0 {
		whence = SEEK_END
	} else {
		tcl.XTcl_AppendResult(tls, interp,
			libc.VaList(bp, ts+35458 /* "WHENCE should be..." */, uintptr(0)))
		return TCL_ERROR
	}
	rc = sqlite3_quota_fseek(tls, p, int32(*(*int32)(unsafe.Pointer(bp + 16 /* ofst */))), whence)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_rewind HANDLE
func test_quota_rewind(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1718:26: */
	var p uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28086 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	sqlite3_quota_rewind(tls, p)
	return TCL_OK
}

// tclcmd: sqlite3_quota_ftell HANDLE
func test_quota_ftell(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1737:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28086 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	x = sqlite3_int64(sqlite3_quota_ftell(tls, p))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

// tclcmd: sqlite3_quota_ftruncate HANDLE SIZE
func test_quota_ftruncate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1758:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var x sqlite3_int64
	// var w Tcl_WideInt at bp, 8

	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35507 /* "HANDLE SIZE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp /* &w */) != 0 {
		return TCL_ERROR
	}
	x = *(*Tcl_WideInt)(unsafe.Pointer(bp /* w */))
	rc = sqlite3_quota_ftruncate(tls, p, x)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_file_size HANDLE
func test_quota_file_size(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1783:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28086 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	x = sqlite3_quota_file_size(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

// tclcmd: sqlite3_quota_file_truesize HANDLE
func test_quota_file_truesize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1804:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28086 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	x = sqlite3_quota_file_truesize(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

// tclcmd: sqlite3_quota_file_mtime HANDLE
func test_quota_file_mtime(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1825:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	// var t time_t at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28086 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	*(*time_t)(unsafe.Pointer(bp /* t */)) = 0
	sqlite3_quota_file_mtime(tls, p, bp /* &t */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(*(*time_t)(unsafe.Pointer(bp /* t */)))))
	return TCL_OK
}

// tclcmd: sqlite3_quota_remove FILENAME
func test_quota_remove(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1848:26: */
	var zFilename uintptr // File pattern to configure
	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32366 /* "FILENAME" */)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	rc = sqlite3_quota_remove(tls, zFilename)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_glob PATTERN TEXT
//
// Test the glob pattern matching.  Return 1 if TEXT matches PATTERN
// and return 0 if it does not.
func test_quota_glob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1872:26: */
	var zPattern uintptr // The glob pattern
	var zText uintptr    // Text to compare agains the pattern
	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35519 /* "PATTERN TEXT" */)
		return TCL_ERROR
	}
	zPattern = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zText = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	rc = quotaStrglob(tls, zPattern, zText)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_file_available HANDLE
//
// Return the number of bytes from the current file point to the end of
// the file.
func test_quota_file_available(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1898:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28086 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	x = sqlite3_int64(sqlite3_quota_file_available(tls, p))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

// tclcmd: sqlite3_quota_ferror HANDLE
//
// Return true if the file handle is in the error state.
func test_quota_ferror(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1921:26: */
	var p uintptr
	var x int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+28086 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	x = sqlite3_quota_ferror(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, x))
	return TCL_OK
}

// This routine registers the custom TCL commands defined in this
// module.  This should be the only procedure visible from outside
// of this module.
func Sqlitequota_Init(tls *libc.TLS, interp uintptr) int32 { /* test_quota.c:1944:5: */
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aCmd9)) / uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd9[i].FzName, aCmd9[i].FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

var aCmd9 = [21]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 35532 /* "sqlite3_quota_in..." */, FxProc: 0},
	{FzName: ts + 35557 /* "sqlite3_quota_sh..." */, FxProc: 0},
	{FzName: ts + 35580 /* "sqlite3_quota_se..." */, FxProc: 0},
	{FzName: ts + 35598 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 35617 /* "sqlite3_quota_du..." */, FxProc: 0},
	{FzName: ts + 35636 /* "sqlite3_quota_fo..." */, FxProc: 0},
	{FzName: ts + 35656 /* "sqlite3_quota_fr..." */, FxProc: 0},
	{FzName: ts + 35676 /* "sqlite3_quota_fw..." */, FxProc: 0},
	{FzName: ts + 35697 /* "sqlite3_quota_fc..." */, FxProc: 0},
	{FzName: ts + 35718 /* "sqlite3_quota_ff..." */, FxProc: 0},
	{FzName: ts + 35739 /* "sqlite3_quota_fs..." */, FxProc: 0},
	{FzName: ts + 35759 /* "sqlite3_quota_re..." */, FxProc: 0},
	{FzName: ts + 35780 /* "sqlite3_quota_ft..." */, FxProc: 0},
	{FzName: ts + 35800 /* "sqlite3_quota_ft..." */, FxProc: 0},
	{FzName: ts + 35824 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 35848 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 35876 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 35901 /* "sqlite3_quota_re..." */, FxProc: 0},
	{FzName: ts + 35922 /* "sqlite3_quota_gl..." */, FxProc: 0},
	{FzName: ts + 35941 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 35970 /* "sqlite3_quota_fe..." */, FxProc: 0},
} /* test_quota.c:1948:5 */

// Type used to cache parameter information for the "circle" r-tree geometry
// callback.
type Circle1 = struct {
	FaBox [2]struct {
		Fxmin float64
		Fxmax float64
		Fymin float64
		Fymax float64
	}
	Fcenterx    float64
	Fcentery    float64
	Fradius     float64
	FmxArea     float64
	FeScoreType int32
	_           [4]byte
} /* test_rtree.c:31:9 */

// Type used to cache parameter information for the "circle" r-tree geometry
// callback.
type Circle = Circle1 /* test_rtree.c:31:23 */
type Box = struct {
	Fxmin float64
	Fxmax float64
	Fymin float64
	Fymax float64
} /* test_rtree.c:31:9 */

// Destructor function for Circle objects allocated by circle_geom().
func circle_del(tls *libc.TLS, p uintptr) { /* test_rtree.c:49:13: */
	sqlite3.Xsqlite3_free(tls, p)
}

// Implementation of "circle" r-tree geometry callback.
func circle_geom(tls *libc.TLS, p uintptr, nCoord int32, aCoord uintptr, pRes uintptr) int32 { /* test_rtree.c:56:12: */
	var i int32         // Iterator variable
	var pCircle uintptr // Structure defining circular region
	var xmin float64
	var xmax float64 // X dimensions of box being tested
	var ymin float64
	var ymax float64 // X dimensions of box being tested

	xmin = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord))
	xmax = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 1*8))
	ymin = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 2*8))
	ymax = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 3*8))
	pCircle = (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser
	if pCircle == uintptr(0) {
		// If pUser is still 0, then the parameter values have not been tested
		// for correctness or stored into a Circle structure yet. Do this now.

		// This geometry callback is for use with a 2-dimensional r-tree table.
		// Return an error if the table does not have exactly 2 dimensions.
		if nCoord != 4 {
			return SQLITE_ERROR
		}

		// Test that the correct number of parameters (3) have been supplied,
		// and that the parameters are in range (that the radius of the circle
		// radius is greater than zero).
		if ((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam != 3) || (*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 2*8)) < 0.0) {
			return SQLITE_ERROR
		}

		// Allocate a structure to cache parameter data in. Return SQLITE_NOMEM
		// if the allocation fails.
		pCircle = libc.AssignPtrUintptr(p+12 /* &.pUser */, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Circle{}))))
		if !(pCircle != 0) {
			return SQLITE_NOMEM
		}
		(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{circle_del}))

		// Record the center and radius of the circular region. One way that
		// tested bounding boxes that intersect the circular region are detected
		// is by testing if each corner of the bounding box lies within radius
		// units of the center of the circle.
		(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam))
		(*Circle)(unsafe.Pointer(pCircle)).Fcentery = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 1*8))
		(*Circle)(unsafe.Pointer(pCircle)).Fradius = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 2*8))

		// Define two bounding box regions. The first, aBox[0], extends to
		// infinity in the X dimension. It covers the same range of the Y dimension
		// as the circular region. The second, aBox[1], extends to infinity in
		// the Y dimension and is constrained to the range of the circle in the
		// X dimension.
		//
		// Then imagine each box is split in half along its short axis by a line
		// that intersects the center of the circular region. A bounding box
		// being tested can be said to intersect the circular region if it contains
		// points from each half of either of the two infinite bounding boxes.
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */))).Fxmin = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */))).Fxmax = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */))).Fymin = ((*Circle)(unsafe.Pointer(pCircle)).Fcentery + (*Circle)(unsafe.Pointer(pCircle)).Fradius)
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */))).Fymax = ((*Circle)(unsafe.Pointer(pCircle)).Fcentery - (*Circle)(unsafe.Pointer(pCircle)).Fradius)
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */) + 1*32)).Fxmin = ((*Circle)(unsafe.Pointer(pCircle)).Fcenterx + (*Circle)(unsafe.Pointer(pCircle)).Fradius)
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */) + 1*32)).Fxmax = ((*Circle)(unsafe.Pointer(pCircle)).Fcenterx - (*Circle)(unsafe.Pointer(pCircle)).Fradius)
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */) + 1*32)).Fymin = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */) + 1*32)).Fymax = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Circle)(unsafe.Pointer(pCircle)).FmxArea = (((xmax - xmin) * (ymax - ymin)) + 1.0)
	}

	// Check if any of the 4 corners of the bounding-box being tested lie
	// inside the circular region. If they do, then the bounding-box does
	// intersect the region of interest. Set the output variable to true and
	// return SQLITE_OK in this case.
	for i = 0; i < 4; i++ {
		var x float64
		if (i & 0x01) != 0 {
			x = xmax
		} else {
			x = xmin
		}
		var y float64
		if (i & 0x02) != 0 {
			y = ymax
		} else {
			y = ymin
		}
		var d2 float64

		d2 = ((x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx) * (x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx))
		d2 = d2 + ((y - (*Circle)(unsafe.Pointer(pCircle)).Fcentery) * (y - (*Circle)(unsafe.Pointer(pCircle)).Fcentery))
		if d2 < ((*Circle)(unsafe.Pointer(pCircle)).Fradius * (*Circle)(unsafe.Pointer(pCircle)).Fradius) {
			*(*int32)(unsafe.Pointer(pRes)) = 1
			return SQLITE_OK
		}
	}

	// Check if the bounding box covers any other part of the circular region.
	// See comments above for a description of how this test works. If it does
	// cover part of the circular region, set the output variable to true
	// and return SQLITE_OK.
	for i = 0; i < 2; i++ {
		if (((xmin <= (*Box)(unsafe.Pointer((pCircle /* &.aBox */)+uintptr(i)*32)).Fxmin) &&
			(xmax >= (*Box)(unsafe.Pointer((pCircle /* &.aBox */)+uintptr(i)*32)).Fxmax)) &&
			(ymin <= (*Box)(unsafe.Pointer((pCircle /* &.aBox */)+uintptr(i)*32)).Fymin)) &&
			(ymax >= (*Box)(unsafe.Pointer((pCircle /* &.aBox */)+uintptr(i)*32)).Fymax) {
			*(*int32)(unsafe.Pointer(pRes)) = 1
			return SQLITE_OK
		}
	}

	// The specified bounding box does not intersect the circular region. Set
	// the output variable to zero and return SQLITE_OK.
	*(*int32)(unsafe.Pointer(pRes)) = 0
	return SQLITE_OK
}

// Implementation of "circle" r-tree geometry callback using the
// 2nd-generation interface that allows scoring.
//
// Two calling forms:
//
//          Qcircle(X,Y,Radius,eType)        -- All values are doubles
//          Qcircle('x:X y:Y r:R e:ETYPE')   -- Single string parameter
func circle_query_func(tls *libc.TLS, p uintptr) int32 { /* test_rtree.c:168:12: */
	var i int32         // Iterator variable
	var pCircle uintptr // Structure defining circular region
	var xmin float64
	var xmax float64 // X dimensions of box being tested
	var ymin float64
	var ymax float64      // X dimensions of box being tested
	var nWithin int32 = 0 // Number of corners inside the circle

	xmin = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord))
	xmax = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 1*8))
	ymin = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 2*8))
	ymax = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 3*8))
	pCircle = (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FpUser
	if pCircle == uintptr(0) {
		// If pUser is still 0, then the parameter values have not been tested
		// for correctness or stored into a Circle structure yet. Do this now.

		// This geometry callback is for use with a 2-dimensional r-tree table.
		// Return an error if the table does not have exactly 2 dimensions.
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnCoord != 4 {
			return SQLITE_ERROR
		}

		// Test that the correct number of parameters (1 or 4) have been supplied.
		if ((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam != 4) && ((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam != 1) {
			return SQLITE_ERROR
		}

		// Allocate a structure to cache parameter data in. Return SQLITE_NOMEM
		// if the allocation fails.
		pCircle = libc.AssignPtrUintptr(p+12 /* &.pUser */, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Circle{}))))
		if !(pCircle != 0) {
			return SQLITE_NOMEM
		}
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{circle_del}))

		// Record the center and radius of the circular region. One way that
		// tested bounding boxes that intersect the circular region are detected
		// is by testing if each corner of the bounding box lies within radius
		// units of the center of the circle.
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam == 4 {
			(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam))
			(*Circle)(unsafe.Pointer(pCircle)).Fcentery = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 1*8))
			(*Circle)(unsafe.Pointer(pCircle)).Fradius = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 2*8))
			(*Circle)(unsafe.Pointer(pCircle)).FeScoreType = int32(*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 3*8)))
		} else {
			var z uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FapSqlParam)))
			(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = 0.0
			(*Circle)(unsafe.Pointer(pCircle)).Fcentery = 0.0
			(*Circle)(unsafe.Pointer(pCircle)).Fradius = 0.0
			(*Circle)(unsafe.Pointer(pCircle)).FeScoreType = 0
			for (z != 0) && (*(*int8)(unsafe.Pointer(z)) != 0) {
				if (int32(*(*int8)(unsafe.Pointer(z))) == 'r') && (int32(*(*int8)(unsafe.Pointer(z + 1))) == ':') {
					(*Circle)(unsafe.Pointer(pCircle)).Fradius = libc.Xatof(tls, (z + 2))
				} else if (int32(*(*int8)(unsafe.Pointer(z))) == 'x') && (int32(*(*int8)(unsafe.Pointer(z + 1))) == ':') {
					(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = libc.Xatof(tls, (z + 2))
				} else if (int32(*(*int8)(unsafe.Pointer(z))) == 'y') && (int32(*(*int8)(unsafe.Pointer(z + 1))) == ':') {
					(*Circle)(unsafe.Pointer(pCircle)).Fcentery = libc.Xatof(tls, (z + 2))
				} else if (int32(*(*int8)(unsafe.Pointer(z))) == 'e') && (int32(*(*int8)(unsafe.Pointer(z + 1))) == ':') {
					(*Circle)(unsafe.Pointer(pCircle)).FeScoreType = int32(libc.Xatof(tls, (z + 2)))
				} else if int32(*(*int8)(unsafe.Pointer(z))) == ' ' {
					z++
					continue
				}
				for (int32(*(*int8)(unsafe.Pointer(z))) != 0) && (int32(*(*int8)(unsafe.Pointer(z))) != ' ') {
					z++
				}
				for int32(*(*int8)(unsafe.Pointer(z))) == ' ' {
					z++
				}
			}
		}
		if (*Circle)(unsafe.Pointer(pCircle)).Fradius < 0.0 {
			sqlite3.Xsqlite3_free(tls, pCircle)
			return SQLITE_NOMEM
		}

		// Define two bounding box regions. The first, aBox[0], extends to
		// infinity in the X dimension. It covers the same range of the Y dimension
		// as the circular region. The second, aBox[1], extends to infinity in
		// the Y dimension and is constrained to the range of the circle in the
		// X dimension.
		//
		// Then imagine each box is split in half along its short axis by a line
		// that intersects the center of the circular region. A bounding box
		// being tested can be said to intersect the circular region if it contains
		// points from each half of either of the two infinite bounding boxes.
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */))).Fxmin = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */))).Fxmax = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */))).Fymin = ((*Circle)(unsafe.Pointer(pCircle)).Fcentery + (*Circle)(unsafe.Pointer(pCircle)).Fradius)
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */))).Fymax = ((*Circle)(unsafe.Pointer(pCircle)).Fcentery - (*Circle)(unsafe.Pointer(pCircle)).Fradius)
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */) + 1*32)).Fxmin = ((*Circle)(unsafe.Pointer(pCircle)).Fcenterx + (*Circle)(unsafe.Pointer(pCircle)).Fradius)
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */) + 1*32)).Fxmax = ((*Circle)(unsafe.Pointer(pCircle)).Fcenterx - (*Circle)(unsafe.Pointer(pCircle)).Fradius)
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */) + 1*32)).Fymin = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Box)(unsafe.Pointer((pCircle /* &.aBox */) + 1*32)).Fymax = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Circle)(unsafe.Pointer(pCircle)).FmxArea = (float64(200.0) * 200.0)
	}

	// Check if any of the 4 corners of the bounding-box being tested lie
	// inside the circular region. If they do, then the bounding-box does
	// intersect the region of interest. Set the output variable to true and
	// return SQLITE_OK in this case.
	for i = 0; i < 4; i++ {
		var x float64
		if (i & 0x01) != 0 {
			x = xmax
		} else {
			x = xmin
		}
		var y float64
		if (i & 0x02) != 0 {
			y = ymax
		} else {
			y = ymin
		}
		var d2 float64

		d2 = ((x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx) * (x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx))
		d2 = d2 + ((y - (*Circle)(unsafe.Pointer(pCircle)).Fcentery) * (y - (*Circle)(unsafe.Pointer(pCircle)).Fcentery))
		if d2 < ((*Circle)(unsafe.Pointer(pCircle)).Fradius * (*Circle)(unsafe.Pointer(pCircle)).Fradius) {
			nWithin++
		}
	}

	// Check if the bounding box covers any other part of the circular region.
	// See comments above for a description of how this test works. If it does
	// cover part of the circular region, set the output variable to true
	// and return SQLITE_OK.
	if nWithin == 0 {
		for i = 0; i < 2; i++ {
			if (((xmin <= (*Box)(unsafe.Pointer((pCircle /* &.aBox */)+uintptr(i)*32)).Fxmin) &&
				(xmax >= (*Box)(unsafe.Pointer((pCircle /* &.aBox */)+uintptr(i)*32)).Fxmax)) &&
				(ymin <= (*Box)(unsafe.Pointer((pCircle /* &.aBox */)+uintptr(i)*32)).Fymin)) &&
				(ymax >= (*Box)(unsafe.Pointer((pCircle /* &.aBox */)+uintptr(i)*32)).Fymax) {
				nWithin = 1
				break
			}
		}
	}

	if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 1 {
		// Depth first search
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
	} else if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 2 {
		// Breadth first search
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = (sqlite3_rtree_dbl(100 - (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel))
	} else if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 3 {
		// Depth-first search, except sort the leaf nodes by area with
		// the largest area first
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel == 1 {
			(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = (1.0 - (((xmax - xmin) * (ymax - ymin)) / (*Circle)(unsafe.Pointer(pCircle)).FmxArea))
			if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore < 0.01 {
				(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = 0.01
			}
		} else {
			(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = 0.0
		}
	} else if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 4 {
		// Depth-first search, except exclude odd rowids
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
		if ((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiRowid & int64(1)) != 0 {
			nWithin = 0
		}
	} else {
		// Breadth-first search, except exclude odd rowids
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = (sqlite3_rtree_dbl(100 - (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel))
		if ((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiRowid & int64(1)) != 0 {
			nWithin = 0
		}
	}
	if nWithin == 0 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = NOT_WITHIN
	} else if nWithin >= 4 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = FULLY_WITHIN
	} else {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = PARTLY_WITHIN
	}
	return SQLITE_OK
}

// Implementation of "breadthfirstsearch" r-tree geometry callback using the
// 2nd-generation interface that allows scoring.
//
//     ... WHERE id MATCH breadthfirstsearch($x0,$x1,$y0,$y1) ...
//
// It returns all entries whose bounding boxes overlap with $x0,$x1,$y0,$y1.
func bfs_query_func(tls *libc.TLS, p uintptr) int32 { /* test_rtree.c:329:12: */
	var x0 float64
	var x1 float64
	var y0 float64
	var y1 float64 // Dimensions of box being tested
	var bx0 float64
	var bx1 float64
	var by0 float64
	var by1 float64 // Boundary of the query function

	if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam != 4 {
		return SQLITE_ERROR
	}
	x0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord))
	x1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 1*8))
	y0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 2*8))
	y1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 3*8))
	bx0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam))
	bx1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 1*8))
	by0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 2*8))
	by1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 3*8))
	(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = (sqlite3_rtree_dbl(100 - (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel))
	if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeParentWithin == FULLY_WITHIN {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = FULLY_WITHIN
	} else if (((x0 >= bx0) && (x1 <= bx1)) && (y0 >= by0)) && (y1 <= by1) {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = FULLY_WITHIN
	} else if (((x1 >= bx0) && (x0 <= bx1)) && (y1 >= by0)) && (y0 <= by1) {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = PARTLY_WITHIN
	} else {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = NOT_WITHIN
	}
	return SQLITE_OK
}

// END of implementation of "circle" geometry callback.
//
//

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// tcl.h --
//
//	This header file describes the externally-visible facilities of the
//	Tcl interpreter.
//
// Copyright (c) 1987-1994 The Regents of the University of California.
// Copyright (c) 1993-1996 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-2000 by Scriptics Corporation.
// Copyright (c) 2002 by Kevin B. Kenny.  All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Cube1 = struct {
	Fx      float64
	Fy      float64
	Fz      float64
	Fwidth  float64
	Fheight float64
	Fdepth  float64
} /* test_rtree.c:366:9 */

// END of implementation of "circle" geometry callback.
//
//

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// tcl.h --
//
//	This header file describes the externally-visible facilities of the
//	Tcl interpreter.
//
// Copyright (c) 1987-1994 The Regents of the University of California.
// Copyright (c) 1993-1996 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-2000 by Scriptics Corporation.
// Copyright (c) 2002 by Kevin B. Kenny.  All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Cube = Cube1 /* test_rtree.c:366:21 */

func cube_context_free(tls *libc.TLS, p uintptr) { /* test_rtree.c:376:13: */
	sqlite3.Xsqlite3_free(tls, p)
}

// The context pointer registered along with the 'cube' callback is
// always ((void *)&gHere). This is just to facilitate testing, it is not
// actually used for anything.
var gHere int32 = 42 /* test_rtree.c:385:12 */

// Implementation of a simple r-tree geom callback to test for intersection
// of r-tree rows with a "cube" shape. Cubes are defined by six scalar
// coordinates as follows:
//
//   cube(x, y, z, width, height, depth)
//
// The width, height and depth parameters must all be greater than zero.
func cube_geom(tls *libc.TLS, p uintptr, nCoord int32, aCoord uintptr, piRes uintptr) int32 { /* test_rtree.c:396:12: */
	var pCube uintptr = (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser

	if pCube == uintptr(0) {
		if (((((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam != 6) || (nCoord != 6)) ||
			(*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 3*8)) <= 0.0)) || (*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 4*8)) <= 0.0)) || (*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 5*8)) <= 0.0) {
			return SQLITE_ERROR
		}
		pCube = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Cube{})))
		if !(pCube != 0) {
			return SQLITE_NOMEM
		}
		(*Cube)(unsafe.Pointer(pCube)).Fx = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam))
		(*Cube)(unsafe.Pointer(pCube)).Fy = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 1*8))
		(*Cube)(unsafe.Pointer(pCube)).Fz = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 2*8))
		(*Cube)(unsafe.Pointer(pCube)).Fwidth = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 3*8))
		(*Cube)(unsafe.Pointer(pCube)).Fheight = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 4*8))
		(*Cube)(unsafe.Pointer(pCube)).Fdepth = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 5*8))

		(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser = pCube
		(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{cube_context_free}))
	}

	*(*int32)(unsafe.Pointer(piRes)) = 0
	if (((((*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord)) <= ((*Cube)(unsafe.Pointer(pCube)).Fx + (*Cube)(unsafe.Pointer(pCube)).Fwidth)) &&
		(*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 1*8)) >= (*Cube)(unsafe.Pointer(pCube)).Fx)) &&
		(*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 2*8)) <= ((*Cube)(unsafe.Pointer(pCube)).Fy + (*Cube)(unsafe.Pointer(pCube)).Fheight))) &&
		(*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 3*8)) >= (*Cube)(unsafe.Pointer(pCube)).Fy)) &&
		(*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 4*8)) <= ((*Cube)(unsafe.Pointer(pCube)).Fz + (*Cube)(unsafe.Pointer(pCube)).Fdepth))) &&
		(*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 5*8)) >= (*Cube)(unsafe.Pointer(pCube)).Fz) {
		*(*int32)(unsafe.Pointer(piRes)) = 1
	}

	return SQLITE_OK
}

func register_cube_geom(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_rtree.c:443:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_rtree_geometry_callback(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+35991 /* "cube" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{cube_geom})), uintptr(unsafe.Pointer(&gHere)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func register_circle_geom(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_rtree.c:471:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_rtree_geometry_callback(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+35996 /* "circle" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{circle_geom})), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_rtree_query_callback(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+36003, /* "Qcircle" */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr) int32
			}{circle_query_func})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_rtree_query_callback(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+36011, /* "breadthfirstsear..." */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr) int32
			}{bfs_query_func})), uintptr(0), uintptr(0))
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func Sqlitetestrtree_Init(tls *libc.TLS, interp uintptr) int32 { /* test_rtree.c:507:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+36030 /* "register_cube_ge..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_cube_geom})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+36049 /* "register_circle_..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_circle_geom})), uintptr(0), uintptr(0))
	return TCL_OK
}

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set5 = struct{ Ffds_bits [32]int32 } /* select.h:70:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

type schema_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
} /* test_schema.c:53:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

type schema_vtab = schema_vtab1 /* test_schema.c:53:28 */
type schema_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FpDbList     uintptr
	FpTableList  uintptr
	FpColumnList uintptr
	Frowid       int32
} /* test_schema.c:54:9 */

type schema_cursor = schema_cursor1 /* test_schema.c:54:30 */

// None of this works unless we have virtual tables.

// Table destructor for the schema module.
func schemaDestroy(tls *libc.TLS, pVtab uintptr) int32 { /* test_schema.c:79:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// Table constructor for the schema module.
func schemaCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_schema.c:87:12: */
	var rc int32 = SQLITE_NOMEM
	var pVtab uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(schema_vtab{})))
	if pVtab != 0 {
		libc.Xmemset(tls, pVtab, 0, uint32(unsafe.Sizeof(schema_vtab{})))
		(*schema_vtab)(unsafe.Pointer(pVtab)).Fdb = db
		rc = sqlite3.Xsqlite3_declare_vtab(tls, db /* Name of database (i.e. main, temp etc.) */ /* Name of table */ /* Column number (from left-to-right, 0 upward) */ /* Column name */ /* Specified type (i.e. VARCHAR(32)) */ /* Boolean. True if NOT NULL was specified */ /* Default value for this column */ /* True if this column is part of the primary key */, ts+36070 /* "CREATE TABLE x(d..." */)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	return rc
}

// Open a new cursor on the schema table.
func schemaOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_schema.c:110:12: */
	var rc int32 = SQLITE_NOMEM
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(schema_cursor{})))
	if pCur != 0 {
		libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(schema_cursor{})))
		*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
		rc = SQLITE_OK
	}
	return rc
}

// Close a schema table cursor.
func schemaClose(tls *libc.TLS, cur uintptr) int32 { /* test_schema.c:125:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList)
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList)
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Retrieve a column of data.
func schemaColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_schema.c:137:12: */
	var pCur uintptr = cur
	switch i {
	case 0:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 1))
		break
	case 1:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList, 0))
		break
	default:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList, (i-2)))
		break
	}
	return SQLITE_OK
}

// Retrieve the current rowid.
func schemaRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_schema.c:156:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite_int64((*schema_cursor)(unsafe.Pointer(pCur)).Frowid)
	return SQLITE_OK
}

func finalize(tls *libc.TLS, ppStmt uintptr) int32 { /* test_schema.c:162:12: */
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(ppStmt)))
	*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)
	return rc
}

func schemaEof(tls *libc.TLS, cur uintptr) int32 { /* test_schema.c:168:12: */
	var pCur uintptr = cur
	return func() int32 {
		if (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList != 0 {
			return 0
		}
		return 1
	}()
}

// Advance the cursor to the next row.
func schemaNext(tls *libc.TLS, cur uintptr) int32 { /* test_schema.c:176:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	var pCur uintptr
	var pVtab uintptr
	var zSql uintptr
	var pDbList uintptr
	rc = SQLITE_OK
	pCur = cur
	pVtab = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	zSql = uintptr(0)

__1:
	if !(!(int32((*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList) != 0) || (SQLITE_ROW != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList))) {
		goto __2
	}
	if !(SQLITE_OK != (libc.AssignInt32(&rc, finalize(tls, (pCur+12 /* &.pColumnList */))))) {
		goto __3
	}
	goto next_exit
__3:
	;

__4:
	if !(!(int32((*schema_cursor)(unsafe.Pointer(pCur)).FpTableList) != 0) || (SQLITE_ROW != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList))) {
		goto __5
	}
	if !(SQLITE_OK != (libc.AssignInt32(&rc, finalize(tls, (pCur+8 /* &.pTableList */))))) {
		goto __6
	}
	goto next_exit
__6:
	;

__7:
	if !(SQLITE_ROW != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList)) {
		goto __8
	}
	rc = finalize(tls, (pCur + 4 /* &.pDbList */))
	goto next_exit
	goto __7
__8:
	;

	// Set zSql to the SQL to pull the list of tables from the
	// sqlite_schema (or sqlite_temp_schema) table of the database
	// identified by the row pointed to by the SQL statement pCur->pDbList
	// (iterating through a "PRAGMA database_list;" statement).
	if !(sqlite3.Xsqlite3_column_int(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 0) == 1) {
		goto __9
	}
	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+36142 /* "SELECT name FROM..." */, 0)
	goto __10
__9:
	pDbList = (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList
	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+36197, /* "SELECT name FROM..." */
		libc.VaList(bp, sqlite3.Xsqlite3_column_text(tls, pDbList, 1)))
__10:
	;
	if !(!(zSql != 0)) {
		goto __11
	}
	rc = SQLITE_NOMEM
	goto next_exit
__11:
	;

	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, (pCur + 8 /* &.pTableList */), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != SQLITE_OK) {
		goto __12
	}
	goto next_exit
__12:
	;
	goto __4
__5:
	;

	// Set zSql to the SQL to the table_info pragma for the table currently
	// identified by the rows pointed to by statements pCur->pDbList and
	// pCur->pTableList.
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+36250, /* "PRAGMA %Q.table_..." */
		libc.VaList(bp+8, sqlite3.Xsqlite3_column_text(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 1),
			sqlite3.Xsqlite3_column_text(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList, 0)))

	if !(!(zSql != 0)) {
		goto __13
	}
	rc = SQLITE_NOMEM
	goto next_exit
__13:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, (pCur + 12 /* &.pColumnList */), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != SQLITE_OK) {
		goto __14
	}
	goto next_exit
__14:
	;
	goto __1
__2:
	;
	(*schema_cursor)(unsafe.Pointer(pCur)).Frowid++

next_exit:
	// TODO: Handle rc
	return rc
}

// Reset a schema table cursor.
func schemaFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_schema.c:247:12: */
	var rc int32
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var pCur uintptr = pVtabCursor
	(*schema_cursor)(unsafe.Pointer(pCur)).Frowid = 0
	finalize(tls, (pCur + 8 /* &.pTableList */))
	finalize(tls, (pCur + 12 /* &.pColumnList */))
	finalize(tls, (pCur + 4 /* &.pDbList */))
	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, ts+36275 /* "PRAGMA database_..." */, -1, (pCur + 4 /* &.pDbList */), uintptr(0))
	return func() int32 {
		if rc == SQLITE_OK {
			return schemaNext(tls, pVtabCursor)
		}
		return rc
	}()
}

// Analyse the WHERE condition.
func schemaBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_schema.c:266:12: */
	return SQLITE_OK
}

// A virtual table module that merely echos method calls into TCL
// variables.
var schemaModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_schema.c:274:23 */

// Register the schema virtual table module.
func register_schema_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_schema.c:309:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+4669 /* "schema" */, uintptr(unsafe.Pointer(&schemaModule)), uintptr(0))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetestschema_Init(tls *libc.TLS, interp uintptr) int32 { /* test_schema.c:330:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd12)) / uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd12[i].FzName,
			aObjCmd12[i].FxProc, aObjCmd12[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd12 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 36296 /* "register_schema_..." */, FxProc: 0},
} /* test_schema.c:335:5 */

// 2001-09-15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the SQLite library
// presents to client programs.  If a C-function, structure, datatype,
// or constant definition does not appear in this file, then it is
// not a published API of SQLite, is subject to change without
// notice, and should not be referenced by programs that use SQLite.
//
// Some of the definitions that are in this file are marked as
// "experimental".  Experimental interfaces are normally new
// features recently added to SQLite.  We do not anticipate changes
// to experimental interfaces but reserve the right to make minor changes
// if experience from use "in the wild" suggest such changes are prudent.
//
// The official C-language API documentation for SQLite is derived
// from comments in this file.  This file is the authoritative source
// on how SQLite interfaces are supposed to operate.
//
// The name of this file under configuration management is "sqlite.h.in".
// The makefile makes some minor changes to this file (such as inserting
// the version number) and changes its name to "sqlite3.h" as
// part of the build process.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

//******* End of fts5.h ********

// Messages are passed from client to server and back again as
// instances of the following structure.
type SqlMessage1 = struct {
	Fop           int32
	FpDb          uintptr
	FpStmt        uintptr
	FerrCode      int32
	FzIn          uintptr
	FnByte        int32
	FzOut         uintptr
	FpNext        uintptr
	FpPrev        uintptr
	FclientMutex  pthread_mutex_t
	_             [4]byte
	FclientWakeup pthread_cond_t
} /* test_server.c:221:9 */

// 2001-09-15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the SQLite library
// presents to client programs.  If a C-function, structure, datatype,
// or constant definition does not appear in this file, then it is
// not a published API of SQLite, is subject to change without
// notice, and should not be referenced by programs that use SQLite.
//
// Some of the definitions that are in this file are marked as
// "experimental".  Experimental interfaces are normally new
// features recently added to SQLite.  We do not anticipate changes
// to experimental interfaces but reserve the right to make minor changes
// if experience from use "in the wild" suggest such changes are prudent.
//
// The official C-language API documentation for SQLite is derived
// from comments in this file.  This file is the authoritative source
// on how SQLite interfaces are supposed to operate.
//
// The name of this file under configuration management is "sqlite.h.in".
// The makefile makes some minor changes to this file (such as inserting
// the version number) and changes its name to "sqlite3.h" as
// part of the build process.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

//******* End of fts5.h ********

// Messages are passed from client to server and back again as
// instances of the following structure.
type SqlMessage = SqlMessage1 /* test_server.c:221:27 */

// Legal values for SqlMessage.op

// State information about the server is stored in a static variable
// named "g" as follows:
type ServerState = struct {
	FqueueMutex   pthread_mutex_t
	FserverMutex  pthread_mutex_t
	FserverWakeup pthread_cond_t
	FserverHalt   int32
	FpQueueHead   uintptr
	FpQueueTail   uintptr
	_             [4]byte
} /* test_server.c:252:8 */

// Legal values for SqlMessage.op

// State information about the server is stored in a static variable
// named "g" as follows:
var g4 = ServerState{} /* test_server.c:259:3 */

// Send a message to the server.  Block until we get a reply.
//
// The mutex and condition variable in the message are uninitialized
// when this routine is called.  This routine takes care of
// initializing them and destroying them when it has finished.
func sendToServer(tls *libc.TLS, pMsg uintptr) { /* test_server.c:272:13: */
	// Initialize the mutex and condition variable on the message
	libc2.Xpthread_mutex_init(tls, (pMsg + 36 /* &.clientMutex */), uintptr(0))
	libc2.Xpthread_cond_init(tls, (pMsg + 64 /* &.clientWakeup */), uintptr(0))

	// Add the message to the head of the server's message queue.
	libc2.Xpthread_mutex_lock(tls, (uintptr(unsafe.Pointer(&g4)) /* &.queueMutex */))
	(*SqlMessage)(unsafe.Pointer(pMsg)).FpNext = g4.FpQueueHead
	if g4.FpQueueHead == uintptr(0) {
		g4.FpQueueTail = pMsg
	} else {
		(*SqlMessage)(unsafe.Pointer(g4.FpQueueHead)).FpPrev = pMsg
	}
	(*SqlMessage)(unsafe.Pointer(pMsg)).FpPrev = uintptr(0)
	g4.FpQueueHead = pMsg
	libc2.Xpthread_mutex_unlock(tls, (uintptr(unsafe.Pointer(&g4)) /* &.queueMutex */))

	// Signal the server that the new message has be queued, then
	// block waiting for the server to process the message.
	libc2.Xpthread_mutex_lock(tls, (pMsg + 36 /* &.clientMutex */))
	libc2.Xpthread_cond_signal(tls, (uintptr(unsafe.Pointer(&g4)) + 48 /* &.serverWakeup */))
	for (*SqlMessage)(unsafe.Pointer(pMsg)).Fop != MSG_Done {
		libc2.Xpthread_cond_wait(tls, (pMsg + 64 /* &.clientWakeup */), (pMsg + 36 /* &.clientMutex */))
	}
	libc2.Xpthread_mutex_unlock(tls, (pMsg + 36 /* &.clientMutex */))

	// Destroy the mutex and condition variable of the message.
	libc2.Xpthread_mutex_destroy(tls, (pMsg + 36 /* &.clientMutex */))
	libc2.Xpthread_cond_destroy(tls, (pMsg + 64 /* &.clientWakeup */))
}

// The following 6 routines are client-side implementations of the
// core SQLite interfaces:
//
//        sqlite3_open
//        sqlite3_prepare
//        sqlite3_step
//        sqlite3_reset
//        sqlite3_finalize
//        sqlite3_close
//
// Clients should use the following client-side routines instead of
// the core routines above.
//
//        sqlite3_client_open
//        sqlite3_client_prepare
//        sqlite3_client_step
//        sqlite3_client_reset
//        sqlite3_client_finalize
//        sqlite3_client_close
//
// Each of these routines creates a message for the desired operation,
// sends that message to the server, waits for the server to process
// then message and return a response.
func sqlite3_client_open(tls *libc.TLS, zDatabaseName uintptr, ppDb uintptr) int32 { /* test_server.c:332:5: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var msg SqlMessage at bp, 112

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Open
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FzIn = zDatabaseName
	sendToServer(tls, bp /* &msg */)
	*(*uintptr)(unsafe.Pointer(ppDb)) = (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpDb
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

func sqlite3_client_prepare(tls *libc.TLS, pDb uintptr, zSql uintptr, nByte int32, ppStmt uintptr, pzTail uintptr) int32 { /* test_server.c:340:5: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var msg SqlMessage at bp, 112

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Prepare
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpDb = pDb
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FzIn = zSql
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FnByte = nByte
	sendToServer(tls, bp /* &msg */)
	*(*uintptr)(unsafe.Pointer(ppStmt)) = (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpStmt
	if pzTail != 0 {
		*(*uintptr)(unsafe.Pointer(pzTail)) = (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FzOut
	}
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

func sqlite3_client_step(tls *libc.TLS, pStmt uintptr) int32 { /* test_server.c:357:5: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var msg SqlMessage at bp, 112

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Step
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpStmt = pStmt
	sendToServer(tls, bp /* &msg */)
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

func sqlite3_client_reset(tls *libc.TLS, pStmt uintptr) int32 { /* test_server.c:364:5: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var msg SqlMessage at bp, 112

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Reset
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpStmt = pStmt
	sendToServer(tls, bp /* &msg */)
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

func sqlite3_client_finalize(tls *libc.TLS, pStmt uintptr) int32 { /* test_server.c:371:5: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var msg SqlMessage at bp, 112

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Finalize
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpStmt = pStmt
	sendToServer(tls, bp /* &msg */)
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

func sqlite3_client_close(tls *libc.TLS, pDb uintptr) int32 { /* test_server.c:378:5: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var msg SqlMessage at bp, 112

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Close
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpDb = pDb
	sendToServer(tls, bp /* &msg */)
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

// This routine implements the server.  To start the server, first
// make sure g.serverHalt is false, then create a new detached thread
// on this procedure.  See the sqlite3_server_start() routine below
// for an example.  This procedure loops until g.serverHalt becomes
// true.
func sqlite3_server(tls *libc.TLS, NotUsed uintptr) uintptr { /* test_server.c:393:6: */
	if libc2.Xpthread_mutex_trylock(tls, (uintptr(unsafe.Pointer(&g4))+24 /* &.serverMutex */)) != 0 {
		return uintptr(0) // Another server is already running
	}
	sqlite3.Xsqlite3_enable_shared_cache(tls, 1)
	for !(g4.FserverHalt != 0) {
		var pMsg uintptr

		// Remove the last message from the message queue.
		libc2.Xpthread_mutex_lock(tls, (uintptr(unsafe.Pointer(&g4)) /* &.queueMutex */))
		for (g4.FpQueueTail == uintptr(0)) && (g4.FserverHalt == 0) {
			libc2.Xpthread_cond_wait(tls, (uintptr(unsafe.Pointer(&g4)) + 48 /* &.serverWakeup */), (uintptr(unsafe.Pointer(&g4)) /* &.queueMutex */))
		}
		pMsg = g4.FpQueueTail
		if pMsg != 0 {
			if (*SqlMessage)(unsafe.Pointer(pMsg)).FpPrev != 0 {
				(*SqlMessage)(unsafe.Pointer((*SqlMessage)(unsafe.Pointer(pMsg)).FpPrev)).FpNext = uintptr(0)
			} else {
				g4.FpQueueHead = uintptr(0)
			}
			g4.FpQueueTail = (*SqlMessage)(unsafe.Pointer(pMsg)).FpPrev
		}
		libc2.Xpthread_mutex_unlock(tls, (uintptr(unsafe.Pointer(&g4)) /* &.queueMutex */))
		if pMsg == uintptr(0) {
			break
		}

		// Process the message just removed
		libc2.Xpthread_mutex_lock(tls, (pMsg + 36 /* &.clientMutex */))
		switch (*SqlMessage)(unsafe.Pointer(pMsg)).Fop {
		case MSG_Open:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_open(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FzIn, (pMsg + 4 /* &.pDb */))
				break

			}
		case MSG_Prepare:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_prepare(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FpDb, (*SqlMessage)(unsafe.Pointer(pMsg)).FzIn, (*SqlMessage)(unsafe.Pointer(pMsg)).FnByte,
					(pMsg + 8 /* &.pStmt */), (pMsg + 24 /* &.zOut */))
				break

			}
		case MSG_Step:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_step(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FpStmt)
				break

			}
		case MSG_Reset:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_reset(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FpStmt)
				break

			}
		case MSG_Finalize:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_finalize(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FpStmt)
				break

			}
		case MSG_Close:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_close(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FpDb)
				break

			}
		}

		// Signal the client that the message has been processed.
		(*SqlMessage)(unsafe.Pointer(pMsg)).Fop = MSG_Done
		libc2.Xpthread_mutex_unlock(tls, (pMsg + 36 /* &.clientMutex */))
		libc2.Xpthread_cond_signal(tls, (pMsg + 64 /* &.clientWakeup */))
	}
	libc2.Xpthread_mutex_unlock(tls, (uintptr(unsafe.Pointer(&g4)) + 24 /* &.serverMutex */))
	return uintptr(0)
}

// Start a server thread if one is not already running.  If there
// is aleady a server thread running, the new thread will quickly
// die and this routine is effectively a no-op.
func sqlite3_server_start(tls *libc.TLS) { /* test_server.c:465:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var x pthread_t at bp, 4

	var rc int32
	g4.FserverHalt = 0
	rc = libc2.Xpthread_create(tls, bp /* &x */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{sqlite3_server})), uintptr(0))
	if rc == 0 {
		libc2.Xpthread_detach(tls, *(*pthread_t)(unsafe.Pointer(bp /* x */)))
	}
}

// A wrapper around sqlite3_server() that decrements the int variable
// pointed to by the first argument after the sqlite3_server() call
// returns.
func serverWrapper(tls *libc.TLS, pnDecr uintptr) uintptr { /* test_server.c:480:13: */
	var p uintptr = sqlite3_server(tls, uintptr(0))
	(*(*int32)(unsafe.Pointer(pnDecr)))--
	return p
}

// This function is the similar to sqlite3_server_start(), except that
// the integer pointed to by the first argument is decremented when
// the server thread exits.
func sqlite3_server_start2(tls *libc.TLS, pnDecr uintptr) { /* test_server.c:491:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var x pthread_t at bp, 4

	var rc int32
	g4.FserverHalt = 0
	rc = libc2.Xpthread_create(tls, bp /* &x */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{serverWrapper})), pnDecr)
	if rc == 0 {
		libc2.Xpthread_detach(tls, *(*pthread_t)(unsafe.Pointer(bp /* x */)))
	}
}

// If a server thread is running, then stop it.  If no server is
// running, this routine is effectively a no-op.
//
// This routine waits until the server has actually stopped before
// returning.
func sqlite3_server_stop(tls *libc.TLS) { /* test_server.c:508:6: */
	g4.FserverHalt = 1
	libc2.Xpthread_cond_broadcast(tls, (uintptr(unsafe.Pointer(&g4)) + 48 /* &.serverWakeup */))
	libc2.Xpthread_mutex_lock(tls, (uintptr(unsafe.Pointer(&g4)) + 24 /* &.serverMutex */))
	libc2.Xpthread_mutex_unlock(tls, (uintptr(unsafe.Pointer(&g4)) + 24 /* &.serverMutex */))
}

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//    If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//    error message with the error text for ERRNUM and abort.
//    (This is a GNU extension.)

// A structure to collect a busy-handler callback and argument and a count
// of the number of times it has been invoked.
type SuperlockBusy1 = struct {
	FxBusy    uintptr
	FpBusyArg uintptr
	FnBusy    int32
} /* test_superlock.c:29:1 */

type SuperlockBusy = SuperlockBusy1 /* test_superlock.c:34:30 */

// An instance of the following structure is allocated for each active
// superlock. The opaque handle returned by sqlite3demo_superlock() is
// actually a pointer to an instance of this structure.
type Superlock1 = struct {
	Fdb   uintptr
	FbWal int32
} /* test_superlock.c:41:1 */

type Superlock = Superlock1 /* test_superlock.c:45:26 */

// The pCtx pointer passed to this function is actually a pointer to a
// SuperlockBusy structure. Invoke the busy-handler function encapsulated
// by the structure and return the result.
func superlockBusyHandler(tls *libc.TLS, pCtx uintptr, UNUSED int32) int32 { /* test_superlock.c:52:12: */
	var pBusy uintptr = pCtx
	if (*SuperlockBusy)(unsafe.Pointer(pBusy)).FxBusy == uintptr(0) {
		return 0
	}
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer((pBusy /* &.xBusy */))))(tls, (*SuperlockBusy)(unsafe.Pointer(pBusy)).FpBusyArg, libc.PostIncInt32(&(*SuperlockBusy)(unsafe.Pointer(pBusy)).FnBusy, 1))
}

// This function is used to determine if the main database file for
// connection db is open in WAL mode or not. If no error occurs and the
// database file is in WAL mode, set *pbWal to true and return SQLITE_OK.
// If it is not in WAL mode, set *pbWal to false.
//
// If an error occurs, return an SQLite error code. The value of *pbWal
// is undefined in this case.
func superlockIsWal(tls *libc.TLS, pLock uintptr) int32 { /* test_superlock.c:67:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32 // Return Code
	// var pStmt uintptr at bp, 4
	// Compiled PRAGMA journal_mode statement

	rc = sqlite3.Xsqlite3_prepare(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+36319 /* "PRAGMA main.jour..." */, -1, bp /* &pStmt */, uintptr(0))
	if rc != SQLITE_OK {
		return rc
	}

	(*Superlock)(unsafe.Pointer(pLock)).FbWal = 0
	if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))) {
		var zMode uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 0)
		if ((zMode != 0) && (libc.Xstrlen(tls, zMode) == size_t(3))) && (sqlite3.Xsqlite3_strnicmp(tls, ts+29379 /* "wal" */, zMode, 3) == 0) {
			(*Superlock)(unsafe.Pointer(pLock)).FbWal = 1
		}
	}

	return sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
}

// Obtain an exclusive shm-lock on nByte bytes starting at offset idx
// of the file fd. If the lock cannot be obtained immediately, invoke
// the busy-handler until either it is obtained or the busy-handler
// callback returns 0.
func superlockShmLock(tls *libc.TLS, fd uintptr, idx int32, nByte int32, pBusy uintptr) int32 { /* test_superlock.c:91:12: */
	var rc int32
	var xShmLock uintptr = (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods)).FxShmLock
	for ok := true; ok; ok = ((rc == SQLITE_BUSY) && (superlockBusyHandler(tls, pBusy, 0) != 0)) {
		rc = (*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(&xShmLock)))(tls, fd, idx, nByte, (SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE))
	}
	return rc
}

// Obtain the extra locks on the database file required for WAL databases.
// Invoke the supplied busy-handler as required.
func superlockWalLock(tls *libc.TLS, db uintptr, pBusy uintptr) int32 { /* test_superlock.c:109:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32                                             // Return code
	*(*uintptr)(unsafe.Pointer(bp /* fd */)) = uintptr(0)    // Main database file handle
	*(*uintptr)(unsafe.Pointer(bp + 4 /* p */)) = uintptr(0) // Pointer to first page of shared memory

	// Obtain a pointer to the sqlite3_file object open on the main db file.
	rc = sqlite3.Xsqlite3_file_control(tls, db, ts+85 /* "main" */, SQLITE_FCNTL_FILE_POINTER, bp /* &fd */)
	if rc != SQLITE_OK {
		return rc
	}

	// Obtain the "recovery" lock. Normally, this lock is only obtained by
	// clients running database recovery.
	rc = superlockShmLock(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 2, 1, pBusy)
	if rc != SQLITE_OK {
		return rc
	}

	// Zero the start of the first shared-memory page. This means that any
	// clients that open read or write transactions from this point on will
	// have to run recovery before proceeding. Since they need the "recovery"
	// lock that this process is holding to do that, no new read or write
	// transactions may now be opened. Nor can a checkpoint be run, for the
	// same reason.
	rc = (*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* fd */)))).FpMethods + 52 /* &.xShmMap */))))(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 0, (32 * 1024), 1, bp+4 /* &p */)
	if rc != SQLITE_OK {
		return rc
	}
	libc.Xmemset(tls, libc.AtomicLoadPUintptr(bp+4 /* p */), 0, uint32(32))

	// Obtain exclusive locks on all the "read-lock" slots. Once these locks
	// are held, it is guaranteed that there are no active reader, writer or
	// checkpointer clients.
	rc = superlockShmLock(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 3, (SQLITE_SHM_NLOCK - 3), pBusy)
	return rc
}

// Release a superlock held on a database file. The argument passed to
// this function must have been obtained from a successful call to
// sqlite3demo_superlock().
func sqlite3demo_superunlock(tls *libc.TLS, pLock uintptr) { /* test_superlock.c:151:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pLock
	if (*Superlock)(unsafe.Pointer(p)).FbWal != 0 {
		var rc int32 // Return code
		var flags int32 = (SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE)
		*(*uintptr)(unsafe.Pointer(bp /* fd */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_file_control(tls, (*Superlock)(unsafe.Pointer(p)).Fdb, ts+85 /* "main" */, SQLITE_FCNTL_FILE_POINTER, bp /* &fd */)
		if rc == SQLITE_OK {
			(*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* fd */)))).FpMethods + 56 /* &.xShmLock */))))(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 2, 1, flags)
			(*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* fd */)))).FpMethods + 56 /* &.xShmLock */))))(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 3, (SQLITE_SHM_NLOCK - 3), flags)
		}
	}
	sqlite3.Xsqlite3_close(tls, (*Superlock)(unsafe.Pointer(p)).Fdb)
	sqlite3.Xsqlite3_free(tls, p)
}

// Obtain a superlock on the database file identified by zPath, using the
// locking primitives provided by VFS zVfs. If successful, SQLITE_OK is
// returned and output variable *ppLock is populated with an opaque handle
// that may be used with sqlite3demo_superunlock() to release the lock.
//
// If an error occurs, *ppLock is set to 0 and an SQLite error code
// (e.g. SQLITE_BUSY) is returned.
//
// If a required lock cannot be obtained immediately and the xBusy parameter
// to this function is not NULL, then xBusy is invoked in the same way
// as a busy-handler registered with SQLite (using sqlite3_busy_handler())
// until either the lock can be obtained or the busy-handler function returns
// 0 (indicating "give up").
func sqlite3demo_superlock(tls *libc.TLS, zPath uintptr, zVfs uintptr, xBusy uintptr, pBusyArg uintptr, ppLock uintptr) int32 { /* test_superlock.c:182:5: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*SuperlockBusy)(unsafe.Pointer(bp /* busy */)) = SuperlockBusy{} // Busy handler wrapper object
	var rc int32                                                       // Return code
	var pLock uintptr

	pLock = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Superlock{})))
	if !(pLock != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pLock, 0, uint32(unsafe.Sizeof(Superlock{})))

	// Open a database handle on the file to superlock.
	rc = sqlite3.Xsqlite3_open_v2(tls,
		zPath, (pLock /* &.db */), (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE), zVfs)

	// Install a busy-handler and execute a BEGIN EXCLUSIVE. If this is not
	// a WAL database, this is all we need to do.
	//
	// A wrapper function is used to invoke the busy-handler instead of
	// registering the busy-handler function supplied by the user directly
	// with SQLite. This is because the same busy-handler function may be
	// invoked directly later on when attempting to obtain the extra locks
	// required in WAL mode. By using the wrapper, we are able to guarantee
	// that the "nBusy" integer parameter passed to the users busy-handler
	// represents the total number of busy-handler invocations made within
	// this call to sqlite3demo_superlock(), including any made during the
	// "BEGIN EXCLUSIVE".
	if rc == SQLITE_OK {
		(*SuperlockBusy)(unsafe.Pointer(bp /* &busy */)).FxBusy = xBusy
		(*SuperlockBusy)(unsafe.Pointer(bp /* &busy */)).FpBusyArg = pBusyArg
		sqlite3.Xsqlite3_busy_handler(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) int32
		}{superlockBusyHandler})), bp /* &busy */)
		rc = sqlite3.Xsqlite3_exec(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+12906 /* "BEGIN EXCLUSIVE" */, uintptr(0), uintptr(0), uintptr(0))
	}

	// If the BEGIN EXCLUSIVE was executed successfully and this is a WAL
	// database, call superlockWalLock() to obtain the extra locks required
	// to prevent readers, writers and/or checkpointers from accessing the
	// db while this process is holding the superlock.
	//
	// Before attempting any WAL locks, commit the transaction started above
	// to drop the WAL read and write locks currently held. Otherwise, the
	// new WAL locks may conflict with the old.
	if rc == SQLITE_OK {
		if (SQLITE_OK == (libc.AssignInt32(&rc, superlockIsWal(tls, pLock)))) && ((*Superlock)(unsafe.Pointer(pLock)).FbWal != 0) {
			rc = sqlite3.Xsqlite3_exec(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+11310 /* "COMMIT" */, uintptr(0), uintptr(0), uintptr(0))
			if rc == SQLITE_OK {
				rc = superlockWalLock(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, bp /* &busy */)
			}
		}
	}

	if rc != SQLITE_OK {
		sqlite3demo_superunlock(tls, pLock)
		*(*uintptr)(unsafe.Pointer(ppLock)) = uintptr(0)
	} else {
		*(*uintptr)(unsafe.Pointer(ppLock)) = pLock
	}

	return rc
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type InterpAndScript1 = struct {
	Finterp  uintptr
	FpScript uintptr
} /* test_superlock.c:268:1 */

type InterpAndScript = InterpAndScript1 /* test_superlock.c:272:32 */

func superunlock_del(tls *libc.TLS, cd ClientData) { /* test_superlock.c:274:27: */
	sqlite3demo_superunlock(tls, cd)
}

func superunlock_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_superlock.c:278:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+489 /* "" */)
		return TCL_ERROR
	}
	tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
	return TCL_OK
}

func superlock_busy(tls *libc.TLS, pCtx uintptr, nBusy int32) int32 { /* test_superlock.c:292:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	var pEval uintptr                            // Script to evaluate
	*(*int32)(unsafe.Pointer(bp /* iVal */)) = 0 // Value to return

	pEval = tcl.XTcl_DuplicateObj(tls, (*InterpAndScript)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewIntObj(tls, nBusy))
	tcl.XTcl_EvalObjEx(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
	tcl.XTcl_GetIntFromObj(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetObjResult(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp), bp /* &iVal */)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* iVal */))
}

// Tclcmd: sqlite3demo_superlock CMDNAME PATH VFS BUSY-HANDLER-SCRIPT
func superlock_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_superlock.c:310:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var pLock uintptr at bp+24, 4
	// Lock context
	var zPath uintptr
	var zVfs uintptr = uintptr(0)
	*(*InterpAndScript)(unsafe.Pointer(bp + 16 /* busy */)) = InterpAndScript{}
	var xBusy uintptr = uintptr(0) // Busy handler callback
	var rc int32                   // Return code from sqlite3demo_superlock()

	if (objc < 3) || (objc > 5) {
		tcl.XTcl_WrongNumArgs(tls,
			interp, 1, objv, ts+36344 /* "CMDNAME PATH ?VF..." */)
		return TCL_ERROR
	}

	zPath = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))

	if objc > 3 {
		zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
		if libc.Xstrlen(tls, zVfs) == size_t(0) {
			zVfs = uintptr(0)
		}
	}
	if objc > 4 {
		(*InterpAndScript)(unsafe.Pointer(bp + 16 /* &busy */)).Finterp = interp
		(*InterpAndScript)(unsafe.Pointer(bp + 16 /* &busy */)).FpScript = *(*uintptr)(unsafe.Pointer(objv + 4*4))
		xBusy = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) int32
		}{superlock_busy}))
	}

	rc = sqlite3demo_superlock(tls, zPath, zVfs, xBusy, bp+16 /* &busy */, bp+24 /* &pLock */)

	if rc != SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return TCL_ERROR
	}

	tcl.XTcl_CreateObjCommand(tls,
		interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{superunlock_cmd})), *(*uintptr)(unsafe.Pointer(bp + 24 /* pLock */)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{superunlock_del})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	return TCL_OK
}

func SqliteSuperlock_Init(tls *libc.TLS, interp uintptr) int32 { /* test_superlock.c:359:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+36385 /* "sqlite3demo_supe..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{superlock_cmd})), uintptr(0), uintptr(0))
	return TCL_OK
}

// Define error_t.
//    Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type error_t = int32 /* error_t.h:22:13 */

type TestSyscallGlobal = struct {
	FbPersist         int32
	FnCount           int32
	FnFail            int32
	Fpgsz             int32
	Forig_getpagesize sqlite3_syscall_ptr
} /* test_syscall.c:97:8 */

var gSyscall = TestSyscallGlobal{} /* test_syscall.c:103:3 */

type TestSyscallArray = struct {
	FzName         uintptr
	FxTest         sqlite3_syscall_ptr
	FxOrig         sqlite3_syscall_ptr
	Fdefault_errno int32
	Fcustom_errno  int32
} /* test_syscall.c:127:1 */

var aSyscall = [19]TestSyscallArray{
	/*  0 */ {FzName: ts + 36407 /* "open" */, FxTest: 0, Fdefault_errno: EACCES},
	/*  1 */ {FzName: ts + 10125 /* "close" */, FxTest: 0},
	/*  2 */ {FzName: ts + 36412 /* "access" */, FxTest: 0},
	/*  3 */ {FzName: ts + 36419 /* "getcwd" */, FxTest: 0},
	/*  4 */ {FzName: ts + 36426 /* "stat" */, FxTest: 0},
	/*  5 */ {FzName: ts + 36431 /* "fstat" */, FxTest: 0},
	/*  6 */ {FzName: ts + 36437 /* "ftruncate" */, FxTest: 0, Fdefault_errno: EIO},
	/*  7 */ {FzName: ts + 36447 /* "fcntl" */, FxTest: 0, Fdefault_errno: EACCES},
	/*  8 */ {FzName: ts + 24630 /* "read" */, FxTest: 0},
	/*  9 */ {FzName: ts + 36453 /* "pread" */, FxTest: 0},
	/* 10 */ {FzName: ts + 36459 /* "pread64" */, FxTest: 0},
	/* 11 */ {FzName: ts + 24635 /* "write" */, FxTest: 0},
	/* 12 */ {FzName: ts + 36467 /* "pwrite" */, FxTest: 0},
	/* 13 */ {FzName: ts + 36474 /* "pwrite64" */, FxTest: 0},
	/* 14 */ {FzName: ts + 36483 /* "fchmod" */, FxTest: 0},
	/* 15 */ {FzName: ts + 36490 /* "fallocate" */, FxTest: 0},
	/* 16 */ {FzName: ts + 28466 /* "mmap" */, FxTest: 0},
	/* 17 */ {FzName: ts + 36500 /* "mremap" */, FxTest: 0},
	{},
} /* test_syscall.c:133:3 */

// This function is called exactly once from within each invocation of a
// system call wrapper in this file. It returns 1 if the function should
// fail, or 0 if it should succeed.
func tsIsFail(tls *libc.TLS) int32 { /* test_syscall.c:181:12: */
	gSyscall.FnCount--
	if (gSyscall.FnCount == 0) || ((gSyscall.FnFail != 0) && (gSyscall.FbPersist != 0)) {
		gSyscall.FnFail++
		return 1
	}
	return 0
}

// Return the current error-number value for function zFunc. zFunc must be
// the name of a system call in the aSyscall[] table.
//
// Usually, the current error-number is the value that errno should be set
// to if the named system call fails. The exception is "fallocate". See
// comments above the implementation of ts_fallocate() for details.
func tsErrno(tls *libc.TLS, zFunc uintptr) int32 { /* test_syscall.c:198:12: */
	var i int32
	var nFunc int32 = int32(libc.Xstrlen(tls, zFunc))
	for i = 0; aSyscall[i].FzName != 0; i++ {
		if libc.Xstrlen(tls, aSyscall[i].FzName) != size_t(nFunc) {
			continue
		}
		if libc.Xmemcmp(tls, aSyscall[i].FzName, zFunc, uint32(nFunc)) != 0 {
			continue
		}
		return aSyscall[i].Fcustom_errno
	}

	return 0
}

/*
** A wrapper around tsIsFail(). If tsIsFail() returns non-zero, set the
** value of errno before returning.
 */
func tsIsFailErrno(tls *libc.TLS, zFunc uintptr) int32 { /* test_syscall.c:215:12: */
	if tsIsFail(tls) != 0 {
		(*(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))) = tsErrno(tls, zFunc)
		return 1
	}
	return 0
}

// A wrapper around open().
func ts_open(tls *libc.TLS, zFile uintptr, flags int32, mode int32) int32 { /* test_syscall.c:226:12: */
	if tsIsFailErrno(tls, ts+36407 /* "open" */) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, uintptr, int32, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 8 /* &.xOrig */))))(tls, zFile, flags, mode)
}

// A wrapper around close().
func ts_close(tls *libc.TLS, fd int32) int32 { /* test_syscall.c:236:12: */
	if tsIsFail(tls) != 0 {
		// Even if simulating an error, close the original file-descriptor.
		// This is to stop the test process from running out of file-descriptors
		// when running a long test. If a call to close() appears to fail, SQLite
		// never attempts to use the file-descriptor afterwards (or even to close
		// it a second time).
		(*(*func(*libc.TLS, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 1*20 + 8 /* &.xOrig */))))(tls, fd)
		return -1
	}
	return (*(*func(*libc.TLS, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 1*20 + 8 /* &.xOrig */))))(tls, fd)
}

// A wrapper around access().
func ts_access(tls *libc.TLS, zPath uintptr, mode int32) int32 { /* test_syscall.c:252:12: */
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 2*20 + 8 /* &.xOrig */))))(tls, zPath, mode)
}

// A wrapper around getcwd().
func ts_getcwd(tls *libc.TLS, zPath uintptr, nPath size_t) uintptr { /* test_syscall.c:262:13: */
	if tsIsFail(tls) != 0 {
		return uintptr(0)
	}
	return (*(*func(*libc.TLS, uintptr, size_t) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 3*20 + 8 /* &.xOrig */))))(tls, zPath, nPath)
}

// A wrapper around stat().
func ts_stat(tls *libc.TLS, zPath uintptr, p uintptr) int32 { /* test_syscall.c:272:12: */
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 4*20 + 8 /* &.xOrig */))))(tls, zPath, p)
}

// A wrapper around fstat().
func ts_fstat(tls *libc.TLS, fd int32, p uintptr) int32 { /* test_syscall.c:282:12: */
	if tsIsFailErrno(tls, ts+36431 /* "fstat" */) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 5*20 + 8 /* &.xOrig */))))(tls, fd, p)
}

// A wrapper around ftruncate().
func ts_ftruncate(tls *libc.TLS, fd int32, n off_t) int32 { /* test_syscall.c:292:12: */
	if tsIsFailErrno(tls, ts+36437 /* "ftruncate" */) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, off_t) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 6*20 + 8 /* &.xOrig */))))(tls, fd, n)
}

// A wrapper around fcntl().
func ts_fcntl(tls *libc.TLS, fd int32, cmd int32, va uintptr) int32 { /* test_syscall.c:302:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var ap va_list
	_ = ap
	var pArg uintptr
	if tsIsFailErrno(tls, ts+36447 /* "fcntl" */) != 0 {
		return -1
	}
	ap = va
	pArg = libc.VaUintptr(&ap)
	return (*(*func(*libc.TLS, int32, int32, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 7*20 + 8 /* &.xOrig */))))(tls, fd, cmd, libc.VaList(bp, pArg))
}

// A wrapper around read().
func ts_read(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t) int32 { /* test_syscall.c:316:12: */
	if tsIsFailErrno(tls, ts+24630 /* "read" */) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 8*20 + 8 /* &.xOrig */))))(tls, fd, aBuf, nBuf)
}

// A wrapper around pread().
func ts_pread(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off off_t) int32 { /* test_syscall.c:326:12: */
	if tsIsFailErrno(tls, ts+36453 /* "pread" */) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t, off_t) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 9*20 + 8 /* &.xOrig */))))(tls, fd, aBuf, nBuf, off)
}

// A wrapper around pread64().
func ts_pread64(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off sqlite3_uint64) int32 { /* test_syscall.c:336:12: */
	if tsIsFailErrno(tls, ts+36459 /* "pread64" */) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 10*20 + 8 /* &.xOrig */))))(tls, fd, aBuf, nBuf, off)
}

// A wrapper around write().
func ts_write(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t) int32 { /* test_syscall.c:346:12: */
	if tsIsFailErrno(tls, ts+24635 /* "write" */) != 0 {
		if tsErrno(tls, ts+24635 /* "write" */) == EINTR {
			(*(*func(*libc.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 11*20 + 8 /* &.xOrig */))))(tls, fd, aBuf, (nBuf / size_t(2)))
		}
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 11*20 + 8 /* &.xOrig */))))(tls, fd, aBuf, nBuf)
}

// A wrapper around pwrite().
func ts_pwrite(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off off_t) int32 { /* test_syscall.c:357:12: */
	if tsIsFailErrno(tls, ts+36467 /* "pwrite" */) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t, off_t) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 12*20 + 8 /* &.xOrig */))))(tls, fd, aBuf, nBuf, off)
}

// A wrapper around pwrite64().
func ts_pwrite64(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off sqlite3_uint64) int32 { /* test_syscall.c:367:12: */
	if tsIsFailErrno(tls, ts+36474 /* "pwrite64" */) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 13*20 + 8 /* &.xOrig */))))(tls, fd, aBuf, nBuf, off)
}

// A wrapper around fchmod().
func ts_fchmod(tls *libc.TLS, fd int32, mode mode_t) int32 { /* test_syscall.c:377:12: */
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, mode_t) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 14*20 + 8 /* &.xOrig */))))(tls, fd, mode)
}

// A wrapper around fallocate().
//
// SQLite assumes that the fallocate() function is compatible with
// posix_fallocate(). According to the Linux man page (2009-09-30):
//
//   posix_fallocate() returns  zero on success, or an error number on
//   failure. Note that errno is not set.
func ts_fallocate(tls *libc.TLS, fd int32, off off_t, len off_t) int32 { /* test_syscall.c:393:12: */
	if tsIsFail(tls) != 0 {
		return tsErrno(tls, ts+36490 /* "fallocate" */)
	}
	return (*(*func(*libc.TLS, int32, off_t, off_t) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 15*20 + 8 /* &.xOrig */))))(tls, fd, off, len)
}

func ts_mmap(tls *libc.TLS, pAddr uintptr, nByte size_t, prot int32, flags int32, fd int32, iOff off_t) uintptr { /* test_syscall.c:400:13: */
	if tsIsFailErrno(tls, ts+28466 /* "mmap" */) != 0 {
		return libc.UintptrFromInt32(-1)
	}
	return (*(*func(*libc.TLS, uintptr, size_t, int32, int32, int32, off_t) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 16*20 + 8 /* &.xOrig */))))(tls, pAddr, nByte, prot, flags, fd, iOff)
}

func ts_mremap(tls *libc.TLS, a uintptr, b size_t, c size_t, d int32, va uintptr) uintptr { /* test_syscall.c:414:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var ap va_list
	_ = ap
	var pArg uintptr
	if tsIsFailErrno(tls, ts+36500 /* "mremap" */) != 0 {
		return libc.UintptrFromInt32(-1)
	}
	ap = va
	pArg = libc.VaUintptr(&ap)
	return (*(*func(*libc.TLS, uintptr, size_t, size_t, int32, uintptr) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + 17*20 + 8 /* &.xOrig */))))(tls, a, b, c, d, libc.VaList(bp, pArg))
}

func test_syscall_install(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:425:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pVfs uintptr
	// var nElem int32 at bp, 4

	var i int32
	// var apElem uintptr at bp+4, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+36507 /* "SYSCALL-LIST" */)
		return TCL_ERROR
	}
	if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp /* &nElem */, bp+4 /* &apElem */) != 0 {
		return TCL_ERROR
	}
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))

	for i = 0; i < *(*int32)(unsafe.Pointer(bp /* nElem */)); i++ {
		// var iCall int32 at bp+8, 4

		var rc int32 = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4 /* apElem */)) + uintptr(i)*4)), uintptr(unsafe.Pointer(&aSyscall)), int32(unsafe.Sizeof(TestSyscallArray{})), ts+36520 /* "system-call" */, 0, bp+8 /* &iCall */)
		if rc != 0 {
			return rc
		}
		if aSyscall[*(*int32)(unsafe.Pointer(bp + 8 /* iCall */))].FxOrig == uintptr(0) {
			aSyscall[*(*int32)(unsafe.Pointer(bp + 8 /* iCall */))].FxOrig = (*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer((pVfs + 80 /* &.xGetSystemCall */))))(tls, pVfs, aSyscall[*(*int32)(unsafe.Pointer(bp + 8 /* iCall */))].FzName)
			(*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 76 /* &.xSetSystemCall */))))(tls, pVfs, aSyscall[*(*int32)(unsafe.Pointer(bp + 8 /* iCall */))].FzName, aSyscall[*(*int32)(unsafe.Pointer(bp + 8 /* iCall */))].FxTest)
		}
		aSyscall[*(*int32)(unsafe.Pointer(bp + 8 /* iCall */))].Fcustom_errno = aSyscall[*(*int32)(unsafe.Pointer(bp + 8 /* iCall */))].Fdefault_errno
	}

	return TCL_OK
}

func test_syscall_uninstall(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:461:26: */
	var pVfs uintptr
	var i int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	for i = 0; aSyscall[i].FzName != 0; i++ {
		if aSyscall[i].FxOrig != 0 {
			(*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 76 /* &.xSetSystemCall */))))(tls, pVfs, aSyscall[i].FzName, uintptr(0))
			aSyscall[i].FxOrig = uintptr(0)
		}
	}
	return TCL_OK
}

func test_syscall_reset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:485:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pVfs uintptr
	var i int32
	var rc int32

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if objc == 2 {
		rc = (*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 76 /* &.xSetSystemCall */))))(tls, pVfs, uintptr(0), uintptr(0))
		for i = 0; aSyscall[i].FzName != 0; i++ {
			aSyscall[i].FxOrig = uintptr(0)
		}
	} else {
		// var nFunc int32 at bp, 4

		var zFunc uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp /* &nFunc */)
		rc = (*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 76 /* &.xSetSystemCall */))))(tls, pVfs, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), uintptr(0))
		for i = 0; (rc == SQLITE_OK) && (aSyscall[i].FzName != 0); i++ {
			if libc.Xstrlen(tls, aSyscall[i].FzName) != size_t(*(*int32)(unsafe.Pointer(bp /* nFunc */))) {
				continue
			}
			if libc.Xmemcmp(tls, aSyscall[i].FzName, zFunc, uint32(*(*int32)(unsafe.Pointer(bp /* nFunc */)))) != 0 {
				continue
			}
			aSyscall[i].FxOrig = uintptr(0)
		}
	}
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

func test_syscall_exists(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:523:26: */
	var pVfs uintptr
	var x sqlite3_syscall_ptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	x = (*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer((pVfs + 80 /* &.xGetSystemCall */))))(tls, pVfs, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))))

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (libc.Bool32((libc.Bool32(x != uintptr(0))) != 0))))
	return TCL_OK
}

func test_syscall_fault(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:544:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp /* nCount */)) = 0
	*(*int32)(unsafe.Pointer(bp + 4 /* bPersist */)) = 0

	if (objc != 2) && (objc != 4) {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+36532 /* "?COUNT PERSIST?" */)
		return TCL_ERROR
	}

	if objc == 4 {
		if (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp /* &nCount */) != 0) ||
			(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4 /* &bPersist */) != 0) {
			return TCL_ERROR
		}
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, gSyscall.FnFail))
	gSyscall.FnCount = *(*int32)(unsafe.Pointer(bp /* nCount */))
	gSyscall.FbPersist = *(*int32)(unsafe.Pointer(bp + 4 /* bPersist */))
	gSyscall.FnFail = 0
	return TCL_OK
}

func test_syscall_errno(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:573:26: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var iCall int32 at bp, 4

	// var iErrno int32 at bp+100, 4

	var rc int32

	*(*[12]Errno)(unsafe.Pointer(bp + 4 /* aErrno */)) = [12]Errno{
		{Fz: ts + 36548 /* "EACCES" */, Fi: EACCES},
		{Fz: ts + 36555 /* "EINTR" */, Fi: EINTR},
		{Fz: ts + 36561 /* "EIO" */, Fi: EIO},
		{Fz: ts + 36565 /* "EOVERFLOW" */, Fi: EOVERFLOW},
		{Fz: ts + 36575 /* "ENOMEM" */, Fi: ENOMEM},
		{Fz: ts + 36582 /* "EAGAIN" */, Fi: EAGAIN},
		{Fz: ts + 36589 /* "ETIMEDOUT" */, Fi: ETIMEDOUT},
		{Fz: ts + 36599 /* "EBUSY" */, Fi: EBUSY},
		{Fz: ts + 36605 /* "EPERM" */, Fi: EPERM},
		{Fz: ts + 36611 /* "EDEADLK" */, Fi: EDEADLK},
		{Fz: ts + 36619 /* "ENOLCK" */, Fi: ENOLCK},
		{},
	}

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+36626 /* "SYSCALL ERRNO" */)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(unsafe.Pointer(&aSyscall)), int32(unsafe.Sizeof(TestSyscallArray{})), ts+36520 /* "system-call" */, 0, bp /* &iCall */)
	if rc != TCL_OK {
		return rc
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4 /* &aErrno[0] */, int32(unsafe.Sizeof(Errno{})), ts+36640 /* "errno" */, 0, bp+100 /* &iErrno */)
	if rc != TCL_OK {
		return rc
	}

	aSyscall[*(*int32)(unsafe.Pointer(bp /* iCall */))].Fcustom_errno = (*Errno)(unsafe.Pointer(bp + 4 /* &aErrno */ + uintptr(*(*int32)(unsafe.Pointer(bp + 100 /* iErrno */)))*8)).Fi
	return TCL_OK
}

type Errno = struct {
	Fz uintptr
	Fi int32
} /* test_syscall.c:583:3 */

func test_syscall_list(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:619:26: */
	var zSys uintptr
	var pVfs uintptr
	var pList uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	pList = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pList)).FrefCount++
	for zSys = (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((pVfs + 84 /* &.xNextSystemCall */))))(tls, pVfs, uintptr(0)); zSys != uintptr(0); zSys = (*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((pVfs + 84 /* &.xNextSystemCall */))))(tls, pVfs, zSys) {
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, zSys, -1))
	}

	tcl.XTcl_SetObjResult(tls, interp, pList)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pList
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return TCL_OK
}

func test_syscall_defaultvfs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:649:26: */
	var pVfs uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+489 /* "" */)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName, -1))
	return TCL_OK
}

func ts_getpagesize(tls *libc.TLS) int32 { /* test_syscall.c:667:12: */
	return gSyscall.Fpgsz
}

func test_syscall_pagesize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:671:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	// var pgsz int32 at bp+16, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+36646 /* "PGSZ" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16 /* &pgsz */) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 16 /* pgsz */)) < 0 {
		if gSyscall.Forig_getpagesize != 0 {
			(*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 76 /* &.xSetSystemCall */))))(tls, pVfs, ts+36651 /* "getpagesize" */, gSyscall.Forig_getpagesize)
		}
	} else {
		if (*(*int32)(unsafe.Pointer(bp + 16 /* pgsz */)) < 512) || ((*(*int32)(unsafe.Pointer(bp + 16 /* pgsz */)) & (*(*int32)(unsafe.Pointer(bp + 16 /* pgsz */)) - 1)) != 0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+36663 /* "pgsz out of rang..." */, 0))
			return TCL_ERROR
		}
		gSyscall.Forig_getpagesize = (*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer((pVfs + 80 /* &.xGetSystemCall */))))(tls, pVfs, ts+36651 /* "getpagesize" */)
		gSyscall.Fpgsz = *(*int32)(unsafe.Pointer(bp + 16 /* pgsz */))
		(*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 76 /* &.xSetSystemCall */))))(tls,
			pVfs, ts+36651 /* "getpagesize" */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{ts_getpagesize})))
	}

	return TCL_OK
}

func test_syscall(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:706:26: */
	bp := tls.Alloc(100)
	defer tls.Free(100)

	*(*[10]SyscallCmd)(unsafe.Pointer(bp + 16 /* aCmd */)) = [10]SyscallCmd{
		{FzName: ts + 36681 /* "fault" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_fault}))},
		{FzName: ts + 36687 /* "install" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_install}))},
		{FzName: ts + 36695 /* "uninstall" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_uninstall}))},
		{FzName: ts + 7379 /* "reset" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_reset}))},
		{FzName: ts + 36640 /* "errno" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_errno}))},
		{FzName: ts + 13196 /* "exists" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_exists}))},
		{FzName: ts + 36705 /* "list" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_list}))},
		{FzName: ts + 36710 /* "defaultvfs" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_defaultvfs}))},
		{FzName: ts + 36721 /* "pagesize" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_pagesize}))},
		{},
	}
	// var iCmd int32 at bp+96, 4

	var rc int32
	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32418 /* "SUB-COMMAND ..." */)
		return TCL_ERROR
	}
	if ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion < 3) || ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall == uintptr(0)) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+36730 /* "VFS does not sup..." */, 0))
		rc = TCL_ERROR
	} else {
		rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
			*(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16 /* &aCmd[0] */, int32(unsafe.Sizeof(SyscallCmd{})), ts+1875 /* "sub-command" */, 0, bp+96 /* &iCmd */)
	}
	if rc != TCL_OK {
		return rc
	}
	return (*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer((bp + 16 /* &aCmd */ + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* iCmd */)))*8 + 4 /* &.xCmd */))))(tls, clientData, interp, objc, objv)
}

type SyscallCmd = struct {
	FzName uintptr
	FxCmd  uintptr
} /* test_syscall.c:712:3 */

func SqlitetestSyscall_Init(tls *libc.TLS, interp uintptr) int32 { /* test_syscall.c:747:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*[1]SyscallCmd)(unsafe.Pointer(bp /* aCmd */)) = [1]SyscallCmd{
		{FzName: ts + 36766 /* "test_syscall" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall}))},
	}
	var i int32

	for i = 0; uint32(i) < (uint32(unsafe.Sizeof([1]SyscallCmd{})) / uint32(unsafe.Sizeof(SyscallCmd{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, (*SyscallCmd)(unsafe.Pointer(bp /* &aCmd */ +uintptr(i)*8)).FzName, (*SyscallCmd)(unsafe.Pointer(bp /* &aCmd */ +uintptr(i)*8)).FxCmd, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

// This routine is the primary export of this file.
//
// Configure the interpreter passed as the first argument to have access
// to the commands and linked variables that make up:
//
//   * the [sqlite3] extension itself,
//
//   * If SQLITE_TCLMD5 or SQLITE_TEST is defined, the Md5 commands, and
//
//   * If SQLITE_TEST is set, the various test interfaces used by the Tcl
//     test suite.
func sqlite3TestInit(tls *libc.TLS, interp uintptr) uintptr { /* test_tclsh.c:58:12: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var cmdInfo Tcl_CmdInfo at bp+16, 32

	/* Since the primary use case for this binary is testing of SQLite,
	 ** be sure to generate core files if we crash */
	{
		// var x rlimit at bp, 16

		libc.Xgetrlimit(tls, RLIMIT_CORE, bp /* &x */)
		(*rlimit)(unsafe.Pointer(bp /* &x */)).Frlim_cur = (*rlimit)(unsafe.Pointer(bp /* &x */)).Frlim_max
		libc.Xsetrlimit(tls, RLIMIT_CORE, bp /* &x */)

	}

	if tcl.XTcl_GetCommandInfo(tls, interp, ts+13947 /* "sqlite3" */, bp+16 /* &cmdInfo */) == 0 {
		Sqlite3_Init(tls, interp)
	}
	Md5_Init(tls, interp)
	Sqliteconfig_Init(tls, interp)
	Sqlitetest1_Init(tls, interp)
	Sqlitetest2_Init(tls, interp)
	Sqlitetest3_Init(tls, interp)
	Sqlitetest4_Init(tls, interp)
	Sqlitetest5_Init(tls, interp)
	Sqlitetest6_Init(tls, interp)
	Sqlitetest7_Init(tls, interp)
	Sqlitetest8_Init(tls, interp)
	Sqlitetest9_Init(tls, interp)
	Sqlitetestasync_Init(tls, interp)
	Sqlitetest_autoext_Init(tls, interp)
	Sqlitetest_blob_Init(tls, interp)
	Sqlitetest_demovfs_Init(tls, interp)
	Sqlitetest_func_Init(tls, interp)
	Sqlitetest_hexio_Init(tls, interp)
	Sqlitetest_init_Init(tls, interp)
	Sqlitetest_malloc_Init(tls, interp)
	Sqlitetest_mutex_Init(tls, interp)
	Sqlitetestschema_Init(tls, interp)
	Sqlitetesttclvar_Init(tls, interp)
	Sqlitetestfs_Init(tls, interp)
	SqlitetestThread_Init(tls, interp)
	SqlitetestOnefile_Init(tls)
	SqlitetestOsinst_Init(tls, interp)
	Sqlitetestbackup_Init(tls, interp)
	Sqlitetestintarray_Init(tls, interp)
	Sqlitetestvfs_Init(tls, interp)
	Sqlitetestrtree_Init(tls, interp)
	Sqlitequota_Init(tls, interp)
	Sqlitemultiplex_Init(tls, interp)
	SqliteSuperlock_Init(tls, interp)
	SqlitetestSyscall_Init(tls, interp)
	Fts5tcl_Init(tls, interp)
	SqliteRbu_Init(tls, interp)
	Sqlitetesttcl_Init(tls, interp)

	TestExpert_Init(tls, interp)
	Sqlitetest_window_Init(tls, interp)
	Sqlitetestvdbecov_Init(tls, interp)

	tcl.XTcl_CreateObjCommand(tls,
		interp, ts+36779 /* "load_testfixture..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{load_testfixture_extensions})), uintptr(0), uintptr(0))
	return uintptr(0)
}

// tclcmd:   load_testfixture_extensions
func load_testfixture_extensions(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_tclsh.c:185:26: */
	var slave uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36807 /* "SLAVE" */)
		return TCL_ERROR
	}

	slave = tcl.XTcl_GetSlave(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if !(slave != 0) {
		return TCL_ERROR
	}

	sqlite3TestInit(tls, slave)
	return TCL_OK
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Characters that make up the idxStr created by xBestIndex for xFilter.

type tclvar_vtab1 = struct {
	Fbase   sqlite3_vtab
	Finterp uintptr
} /* test_tclvar.c:58:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Characters that make up the idxStr created by xBestIndex for xFilter.

type tclvar_vtab = tclvar_vtab1 /* test_tclvar.c:58:28 */
type tclvar_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FpList1 uintptr
	FpList2 uintptr
	Fi1     int32
	Fi2     int32
} /* test_tclvar.c:59:9 */

type tclvar_cursor = tclvar_cursor1 /* test_tclvar.c:59:30 */

// Methods for the tclvar module
func tclvarConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_tclvar.c:80:12: */
	var pVtab uintptr
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(tclvar_vtab{})))
	if pVtab == uintptr(0) {
		return SQLITE_NOMEM
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pVtab /* &.base */)
	(*tclvar_vtab)(unsafe.Pointer(pVtab)).Finterp = pAux
	sqlite3.Xsqlite3_declare_vtab(tls, db, uintptr(unsafe.Pointer(&zSchema)))
	return SQLITE_OK
}

var zSchema =

// Base name
// Array index
// Value
// base(index) name
*(*[100]int8)(unsafe.Pointer(ts + 36813 /* "CREATE TABLE x( ..." */)) /* test_tclvar.c:88:21 */

// Note that for this virtual table, the xCreate and xConnect
// methods are identical.

func tclvarDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test_tclvar.c:105:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// The xDisconnect and xDestroy methods are also the same

// Open a new tclvar cursor.
func tclvarOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_tclvar.c:114:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(tclvar_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return SQLITE_OK
}

// Close a tclvar cursor.
func tclvarClose(tls *libc.TLS, cur uintptr) int32 { /* test_tclvar.c:124:12: */
	var pCur uintptr = cur
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Returns 1 if data is ready, or 0 if not.
func next2(tls *libc.TLS, interp uintptr, pCur uintptr, pObj uintptr) int32 { /* test_tclvar.c:139:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr

	if pObj != 0 {
		if !(int32((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2) != 0) {
			p = tcl.XTcl_NewStringObj(tls, ts+36913 /* "array names" */, -1)
			(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, pObj)
			tcl.XTcl_EvalObjEx(tls, interp, p, TCL_EVAL_GLOBAL)
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = p
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = tcl.XTcl_GetObjResult(tls, interp)
			(*Tcl_Obj)(unsafe.Pointer((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2)).FrefCount++

		} else {
			*(*int32)(unsafe.Pointer(bp /* n */)) = 0
			(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2++
			tcl.XTcl_ListObjLength(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2, bp /* &n */)
			if (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 >= *(*int32)(unsafe.Pointer(bp /* n */)) {
				for ok1 := true; ok1; ok1 = 0 != 0 {
					var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = uintptr(0)
				(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 = 0
				return 0
			}
		}
	}

	return 1
}

func tclvarNext(tls *libc.TLS, cur uintptr) int32 { /* test_tclvar.c:168:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pObj uintptr at bp+4, 4

	*(*int32)(unsafe.Pointer(bp /* n */)) = 0
	var ok int32 = 0

	var pCur uintptr = cur
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab)).Finterp

	tcl.XTcl_ListObjLength(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, bp /* &n */)
	for !(ok != 0) && ((*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1 < *(*int32)(unsafe.Pointer(bp /* n */))) {
		tcl.XTcl_ListObjIndex(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1, bp+4 /* &pObj */)
		ok = next2(tls, interp, pCur, *(*uintptr)(unsafe.Pointer(bp + 4 /* pObj */)))
		if !(ok != 0) {
			(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1++
		}
	}

	return 0
}

func tclvarFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_tclvar.c:188:12: */
	var pCur uintptr = pVtabCursor
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab)).Finterp
	var p uintptr = tcl.XTcl_NewStringObj(tls, ts+36925 /* "tclvar_filter_cm..." */, -1)

	var zEq uintptr = ts + 489     /* "" */
	var zMatch uintptr = ts + 489  /* "" */
	var zGlob uintptr = ts + 489   /* "" */
	var zRegexp uintptr = ts + 489 /* "" */
	var zLike uintptr = ts + 489   /* "" */
	var i int32

	for i = 0; *(*int8)(unsafe.Pointer(idxStr + uintptr(i))) != 0; i++ {
		switch int32(*(*int8)(unsafe.Pointer(idxStr + uintptr(i)))) {
		case 'e':
			zEq = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			break
		case 'm':
			zMatch = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			break
		case 'g':
			zGlob = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			break
		case 'r':
			zRegexp = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			break
		case 'l':
			zLike = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			break
		default:

		}
	}

	(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zEq, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zMatch, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zGlob, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zRegexp, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zLike, -1))

	tcl.XTcl_EvalObjEx(tls, interp, p, TCL_EVAL_GLOBAL)
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = uintptr(0)
	}
	(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1 = 0
	(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 = 0
	(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 = tcl.XTcl_GetObjResult(tls, interp)
	(*Tcl_Obj)(unsafe.Pointer((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1)).FrefCount++

	for ok2 := true; ok2; ok2 = 0 != 0 {
		var _objPtr uintptr = p
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return tclvarNext(tls, pVtabCursor)
}

func tclvarColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_tclvar.c:250:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var p1 uintptr at bp+16, 4

	// var p2 uintptr at bp+20, 4

	var z1 uintptr
	var z2 uintptr = ts + 489 /* "" */
	var pCur uintptr = cur
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab)).Finterp

	tcl.XTcl_ListObjIndex(tls, interp, (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1, bp+16 /* &p1 */)
	tcl.XTcl_ListObjIndex(tls, interp, (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2, bp+20 /* &p2 */)
	z1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* p1 */)))
	if *(*uintptr)(unsafe.Pointer(bp + 20 /* p2 */)) != 0 {
		z2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(bp + 20 /* p2 */)))
	}
	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, z1, -1, libc.UintptrFromInt32(-1))
			break

		}
	case 1:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, z2, -1, libc.UintptrFromInt32(-1))
			break

		}
	case 2:
		{
			var pVal uintptr = tcl.XTcl_GetVar2Ex(tls, interp, z1, func() uintptr {
				if *(*int8)(unsafe.Pointer(z2)) != 0 {
					return z2
				}
				return uintptr(0)
			}(), TCL_GLOBAL_ONLY)
			sqlite3.Xsqlite3_result_text(tls, ctx, tcl.XTcl_GetString(tls, pVal), -1, libc.UintptrFromInt32(-1))
			break

		}
	case 3:
		{
			var z3 uintptr
			if *(*uintptr)(unsafe.Pointer(bp + 20 /* p2 */)) != 0 {
				z3 = sqlite3.Xsqlite3_mprintf(tls, ts+36943 /* "%s(%s)" */, libc.VaList(bp, z1, z2))
				sqlite3.Xsqlite3_result_text(tls, ctx, z3, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
			} else {
				sqlite3.Xsqlite3_result_text(tls, ctx, z1, -1, libc.UintptrFromInt32(-1))
			}
			break

		}
	}
	return SQLITE_OK
}

func tclvarRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_tclvar.c:292:12: */
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return SQLITE_OK
}

func tclvarEof(tls *libc.TLS, cur uintptr) int32 { /* test_tclvar.c:297:12: */
	var pCur uintptr = cur
	return func() int32 {
		if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
			return 0
		}
		return 1
	}()
}

// If nul-terminated string zStr does not already contain the character
// passed as the second argument, append it and return 0. Or, if there is
// already an instance of x in zStr, do nothing return 1;
//
// There is guaranteed to be enough room in the buffer pointed to by zStr
// for the new character and nul-terminator.
func tclvarAddToIdxstr(tls *libc.TLS, zStr uintptr, x int8) int32 { /* test_tclvar.c:310:12: */
	var i int32
	for i = 0; *(*int8)(unsafe.Pointer(zStr + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) == int32(x) {
			return 1
		}
	}
	*(*int8)(unsafe.Pointer(zStr + uintptr(i))) = x
	*(*int8)(unsafe.Pointer(zStr + uintptr((i + 1)))) = int8(0)
	return 0
}

// Return true if variable $::tclvar_set_omit exists and is set to true.
// False otherwise.
func tclvarSetOmit(tls *libc.TLS, interp uintptr) int32 { /* test_tclvar.c:324:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	*(*int32)(unsafe.Pointer(bp /* res */)) = 0
	var pRes uintptr
	rc = tcl.XTcl_Eval(tls, interp,
		ts+36950 /* "expr {[info exis..." */)
	if rc == TCL_OK {
		pRes = tcl.XTcl_GetObjResult(tls, interp)
		rc = tcl.XTcl_GetBooleanFromObj(tls, uintptr(0), pRes, bp /* &res */)
	}
	return (libc.Bool32((rc == TCL_OK) && (*(*int32)(unsafe.Pointer(bp /* res */)) != 0)))
}

// The xBestIndex() method. This virtual table supports the following
// operators:
//
//     name = ?                    (omit flag clear)
//     name MATCH ?                (omit flag set)
//     value GLOB ?                (omit flag set iff $::tclvar_set_omit)
//     value REGEXP ?              (omit flag set iff $::tclvar_set_omit)
//     value LIKE ?                (omit flag set iff $::tclvar_set_omit)
//
// For each constraint present, the corresponding TCLVAR_XXX character is
// appended to the idxStr value.
func tclvarBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_tclvar.c:351:12: */
	var pTab uintptr = tab
	var ii int32
	var zStr uintptr = sqlite3.Xsqlite3_malloc(tls, 32)
	var iStr int32 = 0

	if zStr == uintptr(0) {
		return SQLITE_NOMEM
	}
	*(*int8)(unsafe.Pointer(zStr)) = int8(0)

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		var pUsage uintptr

		pUsage = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8)
		if (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0 {
			// name = ?
			if (int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 0) {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('e')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(0)
				}
			}

			// name MATCH ?
			if (int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 0) {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('m')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
				}
			}

			// value GLOB ?
			if (int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_GLOB) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2) {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('g')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}

			// value REGEXP ?
			if (int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_REGEXP) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2) {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('r')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}

			// value LIKE ?
			if (int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_LIKE) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2) {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('l')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}
		}
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = zStr
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1

	return SQLITE_OK
}

// Invoked for any UPDATE, INSERT, or DELETE against a tclvar table
func tclvarUpdate(tls *libc.TLS, tab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 { /* test_tclvar.c:416:12: */
	var pTab uintptr = tab
	if argc == 1 {
		// A DELETE operation.  The variable to be deleted is stored in argv[0]
		var zVar uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zVar, uintptr(0), TCL_GLOBAL_ONLY)
		return SQLITE_OK
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		// An INSERT operation
		var zValue uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)))
		var zName uintptr
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 5*4))) != SQLITE_TEXT {
			(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+37011 /* "the 'fullname' c..." */, 0)
			return SQLITE_ERROR
		}
		zName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 5*4)))
		if zValue != 0 {
			tcl.XTcl_SetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zName, uintptr(0), zValue, TCL_GLOBAL_ONLY)
		} else {
			tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zName, uintptr(0), TCL_GLOBAL_ONLY)
		}
		return SQLITE_OK
	}
	if (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_TEXT) &&
		(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))) == SQLITE_TEXT) {
		// An UPDATE operation
		var zOldName uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var zNewName uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		var zValue uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)))

		if (libc.Xstrcmp(tls, zOldName, zNewName) != 0) || (zValue == uintptr(0)) {
			tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zOldName, uintptr(0), TCL_GLOBAL_ONLY)
		}
		if zValue != uintptr(0) {
			tcl.XTcl_SetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zNewName, uintptr(0), zValue, TCL_GLOBAL_ONLY)
		}
		return SQLITE_OK
	}
	(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+37046 /* "prohibited TCL v..." */, 0)
	return SQLITE_ERROR
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var tclvarModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRowid - read data
	FxUpdate:     0, // xRename
} /* test_tclvar.c:469:23 */

// Register the echo virtual table module.
func register_tclvar_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_tclvar.c:500:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32 = TCL_OK
	// var db uintptr at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+29292 /* "tclvar" */, uintptr(unsafe.Pointer(&tclvarModule)), interp)
	rc = tcl.XTcl_Eval(tls, interp,

		ts+37077 /* "proc like {patte..." */)
	return rc
}

// Register commands with the TCL interpreter.
func Sqlitetesttclvar_Init(tls *libc.TLS, interp uintptr) int32 { /* test_tclvar.c:546:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd13)) / uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd13[i].FzName,
			aObjCmd13[i].FxProc, aObjCmd13[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd13 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 37613 /* "register_tclvar_..." */, FxProc: 0},
} /* test_tclvar.c:552:5 */

// Define some macros helping to catch buffer overflows.

// One of these is allocated for each thread created by [sqlthread spawn].
type SqlThread1 = struct {
	Fparent   Tcl_ThreadId
	Finterp   uintptr
	FzScript  uintptr
	FzVarname uintptr
} /* test_thread.c:36:9 */

// Define some macros helping to catch buffer overflows.

// One of these is allocated for each thread created by [sqlthread spawn].
type SqlThread = SqlThread1 /* test_thread.c:36:26 */

// A custom Tcl_Event type used by this module. When the event is
// handled, script zScript is evaluated in interpreter interp. If
// the evaluation throws an exception (returns TCL_ERROR), then the
// error is handled by Tcl_BackgroundError(). If no error occurs,
// the result is simply discarded.
type EvalEvent1 = struct {
	Fbase    Tcl_Event
	FzScript uintptr
	Finterp  uintptr
} /* test_thread.c:51:9 */

// A custom Tcl_Event type used by this module. When the event is
// handled, script zScript is evaluated in interpreter interp. If
// the evaluation throws an exception (returns TCL_ERROR), then the
// error is handled by Tcl_BackgroundError(). If no error occurs,
// the result is simply discarded.
type EvalEvent = EvalEvent1 /* test_thread.c:51:26 */

// Handler for events of type EvalEvent.
func tclScriptEvent(tls *libc.TLS, evPtr uintptr, flags int32) int32 { /* test_thread.c:79:26: */
	var rc int32
	var p uintptr = evPtr
	rc = tcl.XTcl_Eval(tls, (*EvalEvent)(unsafe.Pointer(p)).Finterp, (*EvalEvent)(unsafe.Pointer(p)).FzScript)
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*EvalEvent)(unsafe.Pointer(p)).Finterp)
	}
	_ = flags
	return 1
}

// Register an EvalEvent to evaluate the script pScript in the
// parent interpreter/thread of SqlThread p.
func postToParent(tls *libc.TLS, p uintptr, pScript uintptr) { /* test_thread.c:94:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pEvent uintptr
	var zMsg uintptr
	// var nMsg int32 at bp, 4

	zMsg = tcl.XTcl_GetStringFromObj(tls, pScript, bp /* &nMsg */)
	pEvent = tcl.XTcl_Alloc(tls, ((uint32(unsafe.Sizeof(EvalEvent{})) + uint32(*(*int32)(unsafe.Pointer(bp /* nMsg */)))) + uint32(1)))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.FnextPtr = uintptr(0)
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.Fproc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{tclScriptEvent}))
	(*EvalEvent)(unsafe.Pointer(pEvent)).FzScript = (pEvent + 1*16)
	libc.Xmemcpy(tls, (*EvalEvent)(unsafe.Pointer(pEvent)).FzScript, zMsg, (uint32(*(*int32)(unsafe.Pointer(bp /* nMsg */)) + 1)))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Finterp = (*SqlThread)(unsafe.Pointer(p)).Finterp

	tcl.XTcl_ThreadQueueEvent(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent, pEvent, TCL_QUEUE_TAIL)
	tcl.XTcl_ThreadAlert(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent)
}

// The main function for threads created with [sqlthread spawn].
func tclScriptThread(tls *libc.TLS, pSqlThread ClientData) { /* test_thread.c:114:29: */
	var interp uintptr
	var pRes uintptr
	var pList uintptr
	var rc int32
	var p uintptr = pSqlThread

	interp = tcl.XTcl_CreateInterp(tls)
	tcl.XTcl_CreateObjCommand(tls, interp, ts+37636 /* "clock_seconds" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{clock_seconds_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+37650 /* "sqlthread" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{sqlthread_proc})), pSqlThread, uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+37660 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{blocking_step_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+37682 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(1), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+37710 /* "sqlite3_nonblock..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(0), uintptr(0))
	Sqlitetest1_Init(tls, interp)
	Sqlitetest_mutex_Init(tls, interp)
	Sqlite3_Init(tls, interp)

	rc = tcl.XTcl_Eval(tls, interp, (*SqlThread)(unsafe.Pointer(p)).FzScript)
	pRes = tcl.XTcl_GetObjResult(tls, interp)
	pList = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pList)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer(pRes)).FrefCount++

	if rc != TCL_OK {
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, ts+10309 /* "error" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, pRes)
		postToParent(tls, p, pList)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pList
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		pList = tcl.XTcl_NewObj(tls)
	}

	tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, ts+37741 /* "set" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, (*SqlThread)(unsafe.Pointer(p)).FzVarname, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pList, pRes)
	postToParent(tls, p, pList)

	tcl.XTcl_Free(tls, p)
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pList
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for ok2 := true; ok2; ok2 = 0 != 0 {
		var _objPtr uintptr = pRes
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_DeleteInterp(tls, interp)
	for tcl.XTcl_DoOneEvent(tls, ((libc.CplInt32((int32(1) << 1)))|(int32(1)<<1))) != 0 {
	}
	tcl.XTcl_ExitThread(tls, 0)

}

// sqlthread spawn VARNAME SCRIPT
//
//     Spawn a new thread with its own Tcl interpreter and run the
//     specified SCRIPT(s) in it. The thread terminates after running
//     the script. The result of the script is stored in the variable
//     VARNAME.
//
//     The caller can wait for the script to terminate using [vwait VARNAME].
func sqlthread_spawn(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:174:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var x Tcl_ThreadId at bp+24, 4

	var pNew uintptr
	var rc int32
	// var nVarname int32 at bp+16, 4

	var zVarname uintptr
	// var nScript int32 at bp+20, 4

	var zScript uintptr

	// Parameters for thread creation
	var nStack int32 = 0
	var flags int32 = 0000

	_ = clientData
	_ = objc

	zVarname = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16 /* &nVarname */)
	zScript = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+20 /* &nScript */)

	pNew = tcl.XTcl_Alloc(tls, (((uint32(unsafe.Sizeof(SqlThread{})) + uint32(*(*int32)(unsafe.Pointer(bp + 16 /* nVarname */)))) + uint32(*(*int32)(unsafe.Pointer(bp + 20 /* nScript */)))) + uint32(2)))
	(*SqlThread)(unsafe.Pointer(pNew)).FzVarname = (pNew + 1*16)
	(*SqlThread)(unsafe.Pointer(pNew)).FzScript = ((*SqlThread)(unsafe.Pointer(pNew)).FzVarname + uintptr((*(*int32)(unsafe.Pointer(bp + 16 /* nVarname */)) + 1)))
	libc.Xmemcpy(tls, (*SqlThread)(unsafe.Pointer(pNew)).FzVarname, zVarname, (uint32(*(*int32)(unsafe.Pointer(bp + 16 /* nVarname */)) + 1)))
	libc.Xmemcpy(tls, (*SqlThread)(unsafe.Pointer(pNew)).FzScript, zScript, (uint32(*(*int32)(unsafe.Pointer(bp + 20 /* nScript */)) + 1)))
	(*SqlThread)(unsafe.Pointer(pNew)).Fparent = tcl.XTcl_GetCurrentThread(tls)
	(*SqlThread)(unsafe.Pointer(pNew)).Finterp = interp

	rc = tcl.XTcl_CreateThread(tls, bp+24 /* &x */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{tclScriptThread})), pNew, nStack, flags)
	if rc != TCL_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37745 /* "Error in Tcl_Cre..." */, 0))
		tcl.XTcl_Free(tls, pNew)
		return TCL_ERROR
	}

	return TCL_OK
}

// sqlthread parent SCRIPT
//
//     This can be called by spawned threads only. It sends the specified
//     script back to the parent thread for execution. The result of
//     evaluating the SCRIPT is returned. The parent thread must enter
//     the event loop for this to work - otherwise the caller will
//     block indefinitely.
//
//     NOTE: At the moment, this doesn't work. FIXME.
func sqlthread_parent(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:227:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pEvent uintptr
	var zMsg uintptr
	// var nMsg int32 at bp+16, 4

	var p uintptr = clientData

	_ = objc

	if p == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37773 /* "no parent thread" */, 0))
		return TCL_ERROR
	}

	zMsg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16 /* &nMsg */)
	pEvent = tcl.XTcl_Alloc(tls, ((uint32(unsafe.Sizeof(EvalEvent{})) + uint32(*(*int32)(unsafe.Pointer(bp + 16 /* nMsg */)))) + uint32(1)))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.FnextPtr = uintptr(0)
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.Fproc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{tclScriptEvent}))
	(*EvalEvent)(unsafe.Pointer(pEvent)).FzScript = (pEvent + 1*16)
	libc.Xmemcpy(tls, (*EvalEvent)(unsafe.Pointer(pEvent)).FzScript, zMsg, (uint32(*(*int32)(unsafe.Pointer(bp + 16 /* nMsg */)) + 1)))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Finterp = (*SqlThread)(unsafe.Pointer(p)).Finterp
	tcl.XTcl_ThreadQueueEvent(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent, pEvent, TCL_QUEUE_TAIL)
	tcl.XTcl_ThreadAlert(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent)

	return TCL_OK
}

func xBusy(tls *libc.TLS, pArg uintptr, nBusy int32) int32 { /* test_thread.c:259:12: */
	_ = pArg
	_ = nBusy
	sqlite3.Xsqlite3_sleep(tls, 50)
	return 1 // Try again...
}

// sqlthread open
//
//     Open a database handle and return the string representation of
//     the pointer value.
func sqlthread_open(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:272:26: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	var zFilename uintptr
	// var db uintptr at bp+16, 4

	// var zBuf [100]int8 at bp+20, 100

	_ = clientData
	_ = objc

	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	sqlite3.Xsqlite3_open(tls, zFilename, bp+16 /* &db */)
	Md5_Register(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_busy_handler(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{xBusy})), uintptr(0))

	if sqlite3TestMakePointerStr(tls, interp, bp+20 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, bp+20 /* &zBuf[0] */, 0))

	return TCL_OK
}

// sqlthread open
//
//     Return the current thread-id (Tcl_GetCurrentThread()) cast to
//     an integer.
func sqlthread_id(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:306:26: */
	var id Tcl_ThreadId = tcl.XTcl_GetCurrentThread(tls)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(id)))
	_ = clientData
	_ = objc
	_ = objv
	return TCL_OK
}

// Dispatch routine for the sub-commands of [sqlthread].
func sqlthread_proc(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:324:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	*(*[5]struct {
		FzName  uintptr
		FxProc  uintptr
		FnArg   int32
		FzUsage uintptr
	})(unsafe.Pointer(bp /* aSub */)) = [5]struct {
		FzName  uintptr
		FxProc  uintptr
		FnArg   int32
		FzUsage uintptr
	}{
		{FzName: ts + 37790 /* "parent" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_parent})), FnArg: 1, FzUsage: ts + 11583 /* "SCRIPT" */},
		{FzName: ts + 37797 /* "spawn" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_spawn})), FnArg: 2, FzUsage: ts + 37803 /* "VARNAME SCRIPT" */},
		{FzName: ts + 36407 /* "open" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_open})), FnArg: 1, FzUsage: ts + 37818 /* "DBNAME" */},
		{FzName: ts + 37825 /* "id" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_id})), FzUsage: ts + 489 /* "" */},
		{},
	}
	var pSub uintptr
	var rc int32
	// var iIndex int32 at bp+80, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2384 /* "SUB-COMMAND" */)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp /* &aSub[0] */, int32(unsafe.Sizeof(struct {
			FzName  uintptr
			FxProc  uintptr
			FnArg   int32
			FzUsage uintptr
		}{})), ts+1875 /* "sub-command" */, 0, bp+80 /* &iIndex */)
	if rc != TCL_OK {
		return rc
	}
	pSub = (bp /* &aSub */ + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* iIndex */)))*16)

	if objc < ((*struct {
		FzName  uintptr
		FxProc  uintptr
		FnArg   int32
		FzUsage uintptr
	})(unsafe.Pointer(pSub)).FnArg + 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*struct {
			FzName  uintptr
			FxProc  uintptr
			FnArg   int32
			FzUsage uintptr
		})(unsafe.Pointer(pSub)).FzUsage)
		return TCL_ERROR
	}

	return (*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer((pSub + 4 /* &.xProc */))))(tls, clientData, interp, objc, objv)
}

/*
** The [clock_seconds] command. This is more or less the same as the
** regular tcl [clock seconds], except that it is available in testfixture
** when linked against both Tcl 8.4 and 8.5. Because [clock seconds] is
** implemented as a script in Tcl 8.5, it is not usually available to
** testfixture.
 */
func clock_seconds_proc(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:372:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var now Tcl_Time at bp, 8

	tcl.XTcl_GetTime(tls, bp /* &now */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32((*Tcl_Time)(unsafe.Pointer(bp /* &now */)).Fsec)))
	_ = clientData
	_ = objc
	_ = objv
	return TCL_OK
}

// A pointer to an instance of this structure is passed as the user-context
// pointer when registering for an unlock-notify callback.
type UnlockNotification1 = struct {
	Ffired int32
	_      [4]byte
	Fcond  pthread_cond_t
	Fmutex pthread_mutex_t
} /* test_thread.c:410:9 */

// A pointer to an instance of this structure is passed as the user-context
// pointer when registering for an unlock-notify callback.
type UnlockNotification = UnlockNotification1 /* test_thread.c:410:35 */

// This function is an unlock-notify callback registered with SQLite.
func unlock_notify_cb(tls *libc.TLS, apArg uintptr, nArg int32) { /* test_thread.c:420:13: */
	var i int32
	for i = 0; i < nArg; i++ {
		var p uintptr = *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*4))
		libc2.Xpthread_mutex_lock(tls, (p + 56 /* &.mutex */))
		(*UnlockNotification)(unsafe.Pointer(p)).Ffired = 1
		libc2.Xpthread_cond_signal(tls, (p + 8 /* &.cond */))
		libc2.Xpthread_mutex_unlock(tls, (p + 56 /* &.mutex */))
	}
}

// This function assumes that an SQLite API call (either sqlite3_prepare_v2()
// or sqlite3_step()) has just returned SQLITE_LOCKED. The argument is the
// associated database connection.
//
// This function calls sqlite3_unlock_notify() to register for an
// unlock-notify callback, then blocks until that callback is delivered
// and returns SQLITE_OK. The caller should then retry the failed operation.
//
// Or, if sqlite3_unlock_notify() indicates that to block would deadlock
// the system, then this function returns SQLITE_LOCKED immediately. In
// this case the caller should not retry the operation and should roll
// back the current transaction (if any).
func wait_for_unlock_notify(tls *libc.TLS, db uintptr) int32 { /* test_thread.c:445:12: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var rc int32
	// var un UnlockNotification at bp, 80

	// Initialize the UnlockNotification structure.
	(*UnlockNotification)(unsafe.Pointer(bp /* &un */)).Ffired = 0
	libc2.Xpthread_mutex_init(tls, (bp /* &un */ + 56 /* &.mutex */), uintptr(0))
	libc2.Xpthread_cond_init(tls, (bp /* &un */ + 8 /* &.cond */), uintptr(0))

	// Register for an unlock-notify callback.
	rc = sqlite3.Xsqlite3_unlock_notify(tls, db, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32)
	}{unlock_notify_cb})), bp /* &un */)

	// The call to sqlite3_unlock_notify() always returns either SQLITE_LOCKED
	// or SQLITE_OK.
	//
	// If SQLITE_LOCKED was returned, then the system is deadlocked. In this
	// case this function needs to return SQLITE_LOCKED to the caller so
	// that the current transaction can be rolled back. Otherwise, block
	// until the unlock-notify callback is invoked, then return SQLITE_OK.
	if rc == SQLITE_OK {
		libc2.Xpthread_mutex_lock(tls, (bp /* &un */ + 56 /* &.mutex */))
		if !((*UnlockNotification)(unsafe.Pointer(bp /* &un */)).Ffired != 0) {
			libc2.Xpthread_cond_wait(tls, (bp /* &un */ + 8 /* &.cond */), (bp /* &un */ + 56 /* &.mutex */))
		}
		libc2.Xpthread_mutex_unlock(tls, (bp /* &un */ + 56 /* &.mutex */))
	}

	// Destroy the mutex and condition variables.
	libc2.Xpthread_cond_destroy(tls, (bp /* &un */ + 8 /* &.cond */))
	libc2.Xpthread_mutex_destroy(tls, (bp /* &un */ + 56 /* &.mutex */))

	return rc
}

// This function is a wrapper around the SQLite function sqlite3_step().
// It functions in the same way as step(), except that if a required
// shared-cache lock cannot be obtained, this function may block waiting for
// the lock to become available. In this scenario the normal API step()
// function always returns SQLITE_LOCKED.
//
// If this function returns SQLITE_LOCKED, the caller should rollback
// the current transaction (if any) and try again later. Otherwise, the
// system may become deadlocked.
func sqlite3_blocking_step(tls *libc.TLS, pStmt uintptr) int32 { /* test_thread.c:492:5: */
	var rc int32
	for SQLITE_LOCKED == (libc.AssignInt32(&rc, sqlite3.Xsqlite3_step(tls, pStmt))) {
		rc = wait_for_unlock_notify(tls, sqlite3.Xsqlite3_db_handle(tls, pStmt))
		if rc != SQLITE_OK {
			break
		}
		sqlite3.Xsqlite3_reset(tls, pStmt)
	}
	return rc
}

// This function is a wrapper around the SQLite function sqlite3_prepare_v2().
// It functions in the same way as prepare_v2(), except that if a required
// shared-cache lock cannot be obtained, this function may block waiting for
// the lock to become available. In this scenario the normal API prepare_v2()
// function always returns SQLITE_LOCKED.
//
// If this function returns SQLITE_LOCKED, the caller should rollback
// the current transaction (if any) and try again later. Otherwise, the
// system may become deadlocked.
func sqlite3_blocking_prepare_v2(tls *libc.TLS, db uintptr, zSql uintptr, nSql int32, ppStmt uintptr, pz uintptr) int32 { /* test_thread.c:513:5: */
	var rc int32
	for SQLITE_LOCKED == (libc.AssignInt32(&rc, sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, nSql, ppStmt, pz))) {
		rc = wait_for_unlock_notify(tls, db)
		if rc != SQLITE_OK {
			break
		}
	}
	return rc
}

// END_SQLITE_BLOCKING_STEP

// Usage: sqlite3_blocking_step STMT
//
// Advance the statement to the next row.
func blocking_step_proc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:534:26: */
	var pStmt uintptr
	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16637 /* "STMT" */)
		return TCL_ERROR
	}

	pStmt = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	rc = sqlite3_blocking_step(tls, pStmt)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage: sqlite3_blocking_prepare_v2 DB sql bytes ?tailvar?
// Usage: sqlite3_nonblocking_prepare_v2 DB sql bytes ?tailvar?
func blocking_prepare_v2_proc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:560:26: */
	bp := tls.Alloc(146)
	defer tls.Free(146)

	// var db uintptr at bp+80, 4

	var zSql uintptr
	// var bytes int32 at bp+84, 4

	*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+96, 50

	var rc int32
	var isBlocking int32 = libc.BoolInt32(!(clientData == uintptr(0)))

	if (objc != 5) && (objc != 4) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14629, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+16683 /* " DB sql bytes ta..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+80 /* &db */) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+84 /* &bytes */) != 0 {
		return TCL_ERROR
	}

	if isBlocking != 0 {
		rc = sqlite3_blocking_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)), bp+88 /* &pStmt */, bp+92 /* &zTail */)
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)), bp+88 /* &pStmt */, bp+92 /* &zTail */)
	}

	if (*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)) != 0) && (objc >= 5) {
		if *(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) = (*(*int32)(unsafe.Pointer(bp + 84 /* bytes */)) - ((int32(*(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */))) - int32(zSql)) / 1))
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 92 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 84 /* bytes */))), 0)
	}
	if rc != SQLITE_OK {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+96 /* &zBuf[0] */, ts+37828 /* "%s " */, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc)))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+96 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+96 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+96 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

//
// End of implementation of [sqlite3_blocking_step].
//

// Register commands with the TCL interpreter.
func SqlitetestThread_Init(tls *libc.TLS, interp uintptr) int32 { /* test_thread.c:619:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+37650 /* "sqlthread" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{sqlthread_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+37636 /* "clock_seconds" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{clock_seconds_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+37660 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{blocking_step_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+37682 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(1), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+37710 /* "sqlite3_nonblock..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(0), uintptr(0))
	return TCL_OK
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

func Sqlitetestvdbecov_Init(tls *libc.TLS, interp uintptr) int32 { /* test_vdbecov.c:113:5: */
	return TCL_OK
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Testvfs1 = struct {
	FzName        uintptr
	FpParent      uintptr
	FpVfs         uintptr
	Finterp       uintptr
	FpScript      uintptr
	FpBuffer      uintptr
	FisNoshm      int32
	FisFullshm    int32
	Fmask         int32
	Fioerr_err    TestFaultInject
	Ffull_err     TestFaultInject
	Fcantopen_err TestFaultInject
	FiDevchar     int32
	FiSectorsize  int32
} /* test_vfs.c:37:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Testvfs = Testvfs1 /* test_vfs.c:37:24 */
type TestvfsBuffer1 = struct {
	FzFile uintptr
	Fpgsz  int32
	FaPage [1024]uintptr
	FpFile uintptr
	FpNext uintptr
} /* test_vfs.c:37:9 */

type TestvfsBuffer = TestvfsBuffer1 /* test_vfs.c:39:30 */
type TestvfsFile1 = struct {
	Fbase sqlite3_file
	FpFd  uintptr
} /* test_vfs.c:40:9 */

type TestvfsFile = TestvfsFile1 /* test_vfs.c:40:28 */
type TestvfsFd1 = struct {
	FpVfs       uintptr
	FzFilename  uintptr
	FpReal      uintptr
	FpShmId     uintptr
	FpShm       uintptr
	Fexcllock   u32
	Fsharedlock u32
	FpNext      uintptr
} /* test_vfs.c:37:9 */

type TestvfsFd = TestvfsFd1 /* test_vfs.c:41:26 */

type TestFaultInject1 = struct {
	FiCnt   int32
	FeFault int32
	FnFail  int32
} /* test_vfs.c:37:9 */

type TestFaultInject = TestFaultInject1 /* test_vfs.c:69:32 */

var tvfs_io_methods = sqlite3_io_methods{
	FiVersion:               3, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
	FxFetch:                 0,
	FxUnfetch:               0,
} /* test_vfs.c:204:27 */

func tvfsResultCode(tls *libc.TLS, p uintptr, pRc uintptr) int32 { /* test_vfs.c:226:12: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	*(*[9]errcode)(unsafe.Pointer(bp /* aCode */)) = [9]errcode{
		{FzCode: ts + 1988 /* "SQLITE_OK" */},
		{FeCode: SQLITE_ERROR, FzCode: ts + 1975 /* "SQLITE_ERROR" */},
		{FeCode: SQLITE_IOERR, FzCode: ts + 37832 /* "SQLITE_IOERR" */},
		{FeCode: SQLITE_LOCKED, FzCode: ts + 37845 /* "SQLITE_LOCKED" */},
		{FeCode: SQLITE_BUSY, FzCode: ts + 37859 /* "SQLITE_BUSY" */},
		{FeCode: SQLITE_READONLY, FzCode: ts + 37871 /* "SQLITE_READONLY" */},
		{FeCode: (SQLITE_READONLY | (int32(5) << 8)), FzCode: ts + 37887 /* "SQLITE_READONLY_..." */},
		{FeCode: SQLITE_NOTFOUND, FzCode: ts + 37912 /* "SQLITE_NOTFOUND" */},
		{FeCode: -1, FzCode: ts + 37928 /* "SQLITE_OMIT" */},
	}
	var z uintptr
	var i int32

	z = tcl.XTcl_GetStringResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	for i = 0; i < (int32(uint32(unsafe.Sizeof([9]errcode{})) / uint32(unsafe.Sizeof(errcode{})))); i++ {
		if 0 == libc.Xstrcmp(tls, z, (*errcode)(unsafe.Pointer(bp /* &aCode */ +uintptr(i)*8)).FzCode) {
			*(*int32)(unsafe.Pointer(pRc)) = (*errcode)(unsafe.Pointer(bp /* &aCode */ + uintptr(i)*8)).FeCode
			return 1
		}
	}

	return 0
}

type errcode = struct {
	FeCode int32
	FzCode uintptr
} /* test_vfs.c:227:3 */

func tvfsInjectFault(tls *libc.TLS, p uintptr) int32 { /* test_vfs.c:256:12: */
	var ret int32 = 0
	if (*TestFaultInject)(unsafe.Pointer(p)).FeFault != 0 {
		(*TestFaultInject)(unsafe.Pointer(p)).FiCnt--
		if ((*TestFaultInject)(unsafe.Pointer(p)).FiCnt == 0) || (((*TestFaultInject)(unsafe.Pointer(p)).FiCnt < 0) && ((*TestFaultInject)(unsafe.Pointer(p)).FeFault == FAULT_INJECT_PERSISTENT)) {
			ret = 1
			(*TestFaultInject)(unsafe.Pointer(p)).FnFail++
		}
	}
	return ret
}

func tvfsInjectIoerr(tls *libc.TLS, p uintptr) int32 { /* test_vfs.c:269:12: */
	return tvfsInjectFault(tls, (p + 36 /* &.ioerr_err */))
}

func tvfsInjectFullerr(tls *libc.TLS, p uintptr) int32 { /* test_vfs.c:273:12: */
	return tvfsInjectFault(tls, (p + 48 /* &.full_err */))
}

func tvfsInjectCantopenerr(tls *libc.TLS, p uintptr) int32 { /* test_vfs.c:276:12: */
	return tvfsInjectFault(tls, (p + 60 /* &.cantopen_err */))
}

func tvfsExecTcl(tls *libc.TLS, p uintptr, zMethod uintptr, arg1 uintptr, arg2 uintptr, arg3 uintptr, arg4 uintptr) { /* test_vfs.c:281:13: */
	var rc int32 // Return code from Tcl_EvalObj()
	var pEval uintptr

	pEval = tcl.XTcl_DuplicateObj(tls, (*Testvfs)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zMethod, -1))
	if arg1 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg1)
	}
	if arg2 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg2)
	}
	if arg3 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg3)
	}
	if arg4 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg4)
	}

	rc = tcl.XTcl_EvalObjEx(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
		tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	}
}

// Close an tvfs-file.
func tvfsClose(tls *libc.TLS, pFile uintptr) int32 { /* test_vfs.c:317:12: */
	var pTestfile uintptr = pFile
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_CLOSE_MASK) != 0) {
		tvfsExecTcl(tls, p, ts+34930, /* "xClose" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
	}

	if (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = uintptr(0)
	}
	if (*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods != 0 {
		tcl.XTcl_Free(tls, (*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)
	}
	sqlite3.Xsqlite3OsClose(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
	tcl.XTcl_Free(tls, pFd)
	(*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd = uintptr(0)
	return SQLITE_OK
}

// Read data from an tvfs-file.
func tvfsRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_vfs.c:344:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_READ_MASK) != 0) {
		tvfsExecTcl(tls, p, ts+34937, /* "xRead" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}
	if ((*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_READ_MASK) != 0)) && (tvfsInjectIoerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR
	}
	if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsRead(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, zBuf, iAmt, iOfst)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Write data to an tvfs-file.
func tvfsWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_vfs.c:371:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_WRITE_MASK) != 0) {
		tvfsExecTcl(tls, p, ts+34943, /* "xWrite" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewWideIntObj(tls, iOfst), tcl.XTcl_NewIntObj(tls, iAmt))
		tvfsResultCode(tls, p, bp /* &rc */)
		if *(*int32)(unsafe.Pointer(bp /* rc */)) < 0 {
			return SQLITE_OK
		}
	}

	if (*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (tvfsInjectFullerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_FULL
	}
	if ((*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_WRITE_MASK) != 0)) && (tvfsInjectIoerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR
	}

	if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsWrite(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, zBuf, iAmt, iOfst)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Truncate an tvfs-file.
func tvfsTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_vfs.c:406:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_TRUNCATE_MASK) != 0) {
		tvfsExecTcl(tls, p, ts+34950, /* "xTruncate" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}

	if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsTruncate(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, size)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Sync an tvfs-file.
func tvfsSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_vfs.c:427:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_SYNC_MASK) != 0) {
		var zFlags uintptr = uintptr(0)

		switch flags {
		case SQLITE_SYNC_NORMAL:
			zFlags = ts + 16088 /* "normal" */
			break
			fallthrough
		case SQLITE_SYNC_FULL:
			zFlags = ts + 17949 /* "full" */
			break
			fallthrough
		case (SQLITE_SYNC_NORMAL | SQLITE_SYNC_DATAONLY):
			zFlags = ts + 37940 /* "normal|dataonly" */
			break
			fallthrough
		case (SQLITE_SYNC_FULL | SQLITE_SYNC_DATAONLY):
			zFlags = ts + 37956 /* "full|dataonly" */
			break
			fallthrough
		default:

		}

		tvfsExecTcl(tls, p, ts+27353, /* "xSync" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewStringObj(tls, zFlags, -1), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}

	if (*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (tvfsInjectFullerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_FULL
	}

	if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsSync(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, flags)
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Return the current file-size of an tvfs-file.
func tvfsFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_vfs.c:471:12: */
	var p uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsFileSize(tls, (*TestvfsFd)(unsafe.Pointer(p)).FpReal, pSize)
}

// Lock an tvfs-file.
func tvfsLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_vfs.c:479:12: */
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_LOCK_MASK) != 0) {
		// var zLock [30]int8 at bp+8, 30

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8 /* &zLock[0] */, ts+1238 /* "%d" */, libc.VaList(bp, eLock))
		tvfsExecTcl(tls, p, ts+34970 /* "xLock" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			tcl.XTcl_NewStringObj(tls, bp+8 /* &zLock[0] */, -1), uintptr(0), uintptr(0))
	}
	return sqlite3.Xsqlite3OsLock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, eLock)
}

// Unlock an tvfs-file.
func tvfsUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_vfs.c:494:12: */
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_UNLOCK_MASK) != 0) {
		// var zLock [30]int8 at bp+8, 30

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8 /* &zLock[0] */, ts+1238 /* "%d" */, libc.VaList(bp, eLock))
		tvfsExecTcl(tls, p, ts+34976 /* "xUnlock" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			tcl.XTcl_NewStringObj(tls, bp+8 /* &zLock[0] */, -1), uintptr(0), uintptr(0))
	}
	if (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_WRITE_MASK) != 0) && (tvfsInjectIoerr(tls, p) != 0) {
		return (SQLITE_IOERR | (int32(8) << 8))
	}
	return sqlite3.Xsqlite3OsUnlock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, eLock)
}

// Check if another file-handle holds a RESERVED lock on an tvfs-file.
func tvfsCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_vfs.c:512:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_CKLOCK_MASK) != 0) {
		tvfsExecTcl(tls, p, ts+37970 /* "xCheckReservedLo..." */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			uintptr(0), uintptr(0), uintptr(0))
	}
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, pResOut)
}

// File control method. For custom operations on an tvfs-file.
func tvfsFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_vfs.c:525:12: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if op == SQLITE_FCNTL_PRAGMA {
		var argv uintptr = pArg
		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+10309 /* "error" */) == 0 {
			var rc int32 = SQLITE_ERROR
			if *(*uintptr)(unsafe.Pointer(argv + 2*4)) != 0 {
				var z uintptr = *(*uintptr)(unsafe.Pointer(argv + 2*4))
				var x int32 = libc.Xatoi(tls, z)
				if x != 0 {
					rc = x
					for (int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))]) & 0x04) != 0 {
						z++
					}
					for (int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))]) & 0x01) != 0 {
						z++
					}
				}
				if *(*int8)(unsafe.Pointer(z)) != 0 {
					*(*uintptr)(unsafe.Pointer(argv)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, z))
				}
			}
			return rc
		}
		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+4655 /* "filename" */) == 0 {
			*(*uintptr)(unsafe.Pointer(argv)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename))
			return SQLITE_OK
		}
	}
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_FCNTL_MASK) != 0) {
		*(*[3]Fcntl)(unsafe.Pointer(bp + 16 /* aF */)) = [3]Fcntl{
			{FiFnctl: SQLITE_FCNTL_BEGIN_ATOMIC_WRITE, FzFnctl: ts + 37989 /* "BEGIN_ATOMIC_WRI..." */},
			{FiFnctl: SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, FzFnctl: ts + 38008 /* "COMMIT_ATOMIC_WR..." */},
			{FiFnctl: SQLITE_FCNTL_ZIPVFS, FzFnctl: ts + 38028 /* "ZIPVFS" */},
		}
		var i int32
		for i = 0; uint32(i) < (uint32(unsafe.Sizeof([3]Fcntl{})) / uint32(unsafe.Sizeof(Fcntl{}))); i++ {
			if op == (*Fcntl)(unsafe.Pointer(bp+16 /* &aF */ +uintptr(i)*8)).FiFnctl {
				break
			}
		}
		if uint32(i) < (uint32(unsafe.Sizeof([3]Fcntl{})) / uint32(unsafe.Sizeof(Fcntl{}))) {
			*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = 0
			tvfsExecTcl(tls, p, ts+34998, /* "xFileControl" */
				tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
				tcl.XTcl_NewStringObj(tls, (*Fcntl)(unsafe.Pointer(bp+16 /* &aF */ +uintptr(i)*8)).FzFnctl, -1),
				uintptr(0), uintptr(0))
			tvfsResultCode(tls, p, bp+40 /* &rc */)
			if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) != 0 {
				return func() int32 {
					if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) < 0 {
						return SQLITE_OK
					}
					return *(*int32)(unsafe.Pointer(bp + 40 /* rc */))
				}()
			}
		}
	}
	return sqlite3.Xsqlite3OsFileControl(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, op, pArg)
}

type Fcntl = struct {
	FiFnctl int32
	FzFnctl uintptr
} /* test_vfs.c:550:5 */

// Return the sector-size in bytes for an tvfs-file.
func tvfsSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_vfs.c:579:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FiSectorsize >= 0 {
		return (*Testvfs)(unsafe.Pointer(p)).FiSectorsize
	}
	return sqlite3.Xsqlite3OsSectorSize(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
}

// Return the device characteristic flags supported by an tvfs-file.
func tvfsDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_vfs.c:591:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FiDevchar >= 0 {
		return (*Testvfs)(unsafe.Pointer(p)).FiDevchar
	}
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
}

// Open an tvfs file handle.
func tvfsOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_vfs.c:603:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var rc int32 at bp, 4

	var pTestfile uintptr = pFile
	var pFd uintptr
	var pId uintptr = uintptr(0)
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData

	pFd = tcl.XTcl_Alloc(tls, (uint32(unsafe.Sizeof(TestvfsFd{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent))).FszOsFile)))
	libc.Xmemset(tls, pFd, 0, (uint32(unsafe.Sizeof(TestvfsFd{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent))).FszOsFile)))
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = uintptr(0)
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = uintptr(0)
	(*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename = zName
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs = pVfs
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpReal = (pFd + 1*32)
	libc.Xmemset(tls, pTestfile, 0, uint32(unsafe.Sizeof(TestvfsFile{})))
	(*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd = pFd

	// Evaluate the Tcl script:
	//
	//   SCRIPT xOpen FILENAME KEY-VALUE-ARGS
	//
	// If the script returns an SQLite error code other than SQLITE_OK, an
	// error is returned to the caller. If it returns SQLITE_OK, the new
	// connection is named "anon". Otherwise, the value returned by the
	// script is used as the connection name.
	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_OPEN_MASK) != 0) {
		var pArg uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
		if (flags & SQLITE_OPEN_MAIN_DB) != 0 {
			var z uintptr = (zName + uintptr((libc.Xstrlen(tls, zName) + size_t(1))))
			for *(*int8)(unsafe.Pointer(z)) != 0 {
				tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, tcl.XTcl_NewStringObj(tls, z, -1))
				z += (uintptr(libc.Xstrlen(tls, z) + size_t(1)))
				tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, tcl.XTcl_NewStringObj(tls, z, -1))
				z += (uintptr(libc.Xstrlen(tls, z) + size_t(1)))
			}
		}
		tvfsExecTcl(tls, p, ts+26925 /* "xOpen" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), pArg, uintptr(0), uintptr(0))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pArg
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		if tvfsResultCode(tls, p, bp /* &rc */) != 0 {
			if *(*int32)(unsafe.Pointer(bp /* rc */)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		} else {
			pId = tcl.XTcl_GetObjResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
		}
	}

	if (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_OPEN_MASK) != 0) && (tvfsInjectIoerr(tls, p) != 0) {
		return SQLITE_IOERR
	}
	if tvfsInjectCantopenerr(tls, p) != 0 {
		return SQLITE_CANTOPEN
	}
	if tvfsInjectFullerr(tls, p) != 0 {
		return SQLITE_FULL
	}

	if !(pId != 0) {
		pId = tcl.XTcl_NewStringObj(tls, ts+38035 /* "anon" */, -1)
	}
	(*Tcl_Obj)(unsafe.Pointer(pId)).FrefCount++
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = pId
	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsOpen(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zName, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)).FpMethods != 0 {
		var pMethods uintptr
		var nByte int32

		if (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion > 1 {
			nByte = int32(unsafe.Sizeof(sqlite3_io_methods{}))
		} else {
			nByte = int32((uintptr(0) + 52 /* &.xShmMap */))
		}

		pMethods = tcl.XTcl_Alloc(tls, uint32(nByte))
		libc.Xmemcpy(tls, pMethods, uintptr(unsafe.Pointer(&tvfs_io_methods)), uint32(nByte))
		(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion = (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)).FpMethods)).FiVersion
		if (*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion > (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion {
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion
		}
		if ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion > 1) && ((*Testvfs)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData))).FisNoshm != 0) {
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmUnmap = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmLock = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmBarrier = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmMap = uintptr(0)
		}
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = pMethods
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func tvfsDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_vfs.c:702:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_DELETE_MASK) != 0) {
		tvfsExecTcl(tls, p, ts+35035, /* "xDelete" */
			tcl.XTcl_NewStringObj(tls, zPath, -1), tcl.XTcl_NewIntObj(tls, dirSync), uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}
	if *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsDelete(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, dirSync)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func tvfsAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_vfs.c:722:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_ACCESS_MASK) != 0) {
		// var rc int32 at bp, 4

		var zArg uintptr = uintptr(0)
		if flags == SQLITE_ACCESS_EXISTS {
			zArg = ts + 38040 /* "SQLITE_ACCESS_EX..." */
		}
		if flags == SQLITE_ACCESS_READWRITE {
			zArg = ts + 38061 /* "SQLITE_ACCESS_RE..." */
		}
		if flags == SQLITE_ACCESS_READ {
			zArg = ts + 38085 /* "SQLITE_ACCESS_RE..." */
		}
		tvfsExecTcl(tls, p, ts+35043, /* "xAccess" */
			tcl.XTcl_NewStringObj(tls, zPath, -1), tcl.XTcl_NewStringObj(tls, zArg, -1), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp /* &rc */) != 0 {
			if *(*int32)(unsafe.Pointer(bp /* rc */)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		} else {
			var interp uintptr = (*Testvfs)(unsafe.Pointer(p)).Finterp
			if TCL_OK == tcl.XTcl_GetBooleanFromObj(tls, uintptr(0), tcl.XTcl_GetObjResult(tls, interp), pResOut) {
				return SQLITE_OK
			}
		}
	}
	return sqlite3.Xsqlite3OsAccess(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, flags, pResOut)
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (DEVSYM_MAX_PATHNAME+1) bytes.
func tvfsFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_vfs.c:755:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_FULLPATHNAME_MASK) != 0) {
		// var rc int32 at bp, 4

		tvfsExecTcl(tls, p, ts+35051 /* "xFullPathname" */, tcl.XTcl_NewStringObj(tls, zPath, -1), uintptr(0), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp /* &rc */) != 0 {
			if *(*int32)(unsafe.Pointer(bp /* rc */)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		}
	}
	return sqlite3.Xsqlite3OsFullPathname(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, nOut, zOut)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func tvfsRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_vfs.c:808:12: */
	return sqlite3.Xsqlite3OsRandomness(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func tvfsSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* test_vfs.c:816:12: */
	return sqlite3.Xsqlite3OsSleep(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func tvfsCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_vfs.c:823:12: */
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent + 64 /* &.xCurrentTime */))))(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, pTimeOut)
}

func tvfsShmOpen(tls *libc.TLS, pFile uintptr) int32 { /* test_vfs.c:827:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK // Return code
	var pBuffer uintptr                                // Buffer to open connection to
	var pFd uintptr                                    // The testvfs file structure

	pFd = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	p = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	// Evaluate the Tcl script:
	//
	//   SCRIPT xShmOpen FILENAME
	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_SHMOPEN_MASK) != 0) {
		tvfsExecTcl(tls, p, ts+38104 /* "xShmOpen" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), uintptr(0), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp /* &rc */) != 0 {
			if *(*int32)(unsafe.Pointer(bp /* rc */)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		}
	}

	if (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_SHMOPEN_MASK) != 0) && (tvfsInjectIoerr(tls, p) != 0) {
		return SQLITE_IOERR
	}

	// Search for a TestvfsBuffer. Create a new one if required.
	for pBuffer = (*Testvfs)(unsafe.Pointer(p)).FpBuffer; pBuffer != 0; pBuffer = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext {
		if 0 == libc.Xstrcmp(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile) {
			break
		}
	}
	if !(pBuffer != 0) {
		var szName int32 = int32(libc.Xstrlen(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename))
		var nByte int32 = (int32((uint32(unsafe.Sizeof(TestvfsBuffer{})) + uint32(szName)) + uint32(1)))
		pBuffer = tcl.XTcl_Alloc(tls, uint32(nByte))
		libc.Xmemset(tls, pBuffer, 0, uint32(nByte))
		(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile = (pBuffer + 1*4112)
		libc.Xmemcpy(tls, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, (uint32(szName + 1)))
		(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext = (*Testvfs)(unsafe.Pointer(p)).FpBuffer
		(*Testvfs)(unsafe.Pointer(p)).FpBuffer = pBuffer
	}

	// Connect the TestvfsBuffer to the new TestvfsShm handle and return.
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpNext = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile
	(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile = pFd
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = pBuffer
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func tvfsAllocPage(tls *libc.TLS, p uintptr, iPage int32, pgsz int32) { /* test_vfs.c:877:13: */

	if *(*uintptr)(unsafe.Pointer((p + 8 /* &.aPage */) + uintptr(iPage)*4)) == uintptr(0) {
		*(*uintptr)(unsafe.Pointer((p + 8 /* &.aPage */) + uintptr(iPage)*4)) = tcl.XTcl_Alloc(tls, uint32(pgsz))
		libc.Xmemset(tls, *(*uintptr)(unsafe.Pointer((p + 8 /* &.aPage */) + uintptr(iPage)*4)), 0, uint32(pgsz))
		(*TestvfsBuffer)(unsafe.Pointer(p)).Fpgsz = pgsz
	}
}

func tvfsShmMap(tls *libc.TLS, pFile uintptr, iPage int32, pgsz int32, isWrite int32, pp uintptr) int32 { /* test_vfs.c:886:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		return (*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods + 52 /* &.xShmMap */))))(tls, pReal, iPage, pgsz, isWrite, libc.AtomicLoadUintptr(&pp))
	}

	if uintptr(0) == (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = tvfsShmOpen(tls, pFile)
		if *(*int32)(unsafe.Pointer(bp /* rc */)) != SQLITE_OK {
			return *(*int32)(unsafe.Pointer(bp /* rc */))
		}
	}

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_SHMMAP_MASK) != 0) {
		var pArg uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, iPage))
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, pgsz))
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, isWrite))
		tvfsExecTcl(tls, p, ts+35128, /* "xShmMap" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, pArg, uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pArg
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if ((*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_SHMMAP_MASK) != 0)) && (tvfsInjectIoerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR
	}

	if ((*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) && (isWrite != 0)) && !(int32(*(*uintptr)(unsafe.Pointer(((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm + 8 /* &.aPage */) + uintptr(iPage)*4))) != 0) {
		tvfsAllocPage(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm, iPage, pgsz)
	}
	if (*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK) || (*(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_READONLY) {
		*(*uintptr)(unsafe.Pointer(libc.AtomicLoadUintptr(&pp))) = *(*uintptr)(unsafe.Pointer(((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm + 8 /* &.aPage */) + uintptr(iPage)*4))
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func tvfsShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test_vfs.c:936:12: */
	bp := tls.Alloc(100)
	defer tls.Free(100)

	*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	var nLock int32
	// var zLock [80]int8 at bp+16, 80

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		return (*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods + 56 /* &.xShmLock */))))(tls, pReal, ofst, n, flags)
	}

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_SHMLOCK_MASK) != 0) {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([80]int8{})), bp+16 /* &zLock[0] */, ts+17484 /* "%d %d" */, libc.VaList(bp, ofst, n))
		nLock = int32(libc.Xstrlen(tls, bp+16 /* &zLock[0] */))
		if (flags & SQLITE_SHM_LOCK) != 0 {
			libc.Xstrcpy(tls, (bp + 16 /* &zLock */ + uintptr(nLock)), ts+38113 /* " lock" */)
		} else {
			libc.Xstrcpy(tls, (bp + 16 /* &zLock */ + uintptr(nLock)), ts+38119 /* " unlock" */)
		}
		nLock = nLock + (int32(libc.Xstrlen(tls, (bp + 16 /* &zLock */ + uintptr(nLock)))))
		if (flags & SQLITE_SHM_SHARED) != 0 {
			libc.Xstrcpy(tls, (bp + 16 /* &zLock */ + uintptr(nLock)), ts+38127 /* " shared" */)
		} else {
			libc.Xstrcpy(tls, (bp + 16 /* &zLock */ + uintptr(nLock)), ts+38135 /* " exclusive" */)
		}
		tvfsExecTcl(tls, p, ts+35107, /* "xShmLock" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewStringObj(tls, bp+16 /* &zLock[0] */, -1), uintptr(0))
		tvfsResultCode(tls, p, bp+96 /* &rc */)
	}

	if ((*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) == SQLITE_OK) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_SHMLOCK_MASK) != 0)) && (tvfsInjectIoerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = SQLITE_IOERR
	}

	if *(*int32)(unsafe.Pointer(bp + 96 /* rc */)) == SQLITE_OK {
		var isLock int32 = (flags & SQLITE_SHM_LOCK)
		var isExcl int32 = (flags & SQLITE_SHM_EXCLUSIVE)
		var mask u32 = (u32(((int32(1) << n) - 1) << ofst))
		if isLock != 0 {
			var p2 uintptr
			for p2 = (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FpFile; p2 != 0; p2 = (*TestvfsFd)(unsafe.Pointer(p2)).FpNext {
				if p2 == pFd {
					continue
				}
				if (((*TestvfsFd)(unsafe.Pointer(p2)).Fexcllock & mask) != 0) || ((isExcl != 0) && (((*TestvfsFd)(unsafe.Pointer(p2)).Fsharedlock & mask) != 0)) {
					*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = SQLITE_BUSY
					break
				}
			}
			if *(*int32)(unsafe.Pointer(bp + 96 /* rc */)) == SQLITE_OK {
				if isExcl != 0 {
					*(*u32)(unsafe.Pointer(pFd + 20 /* &.excllock */)) |= (mask)
				}
				if !(isExcl != 0) {
					*(*u32)(unsafe.Pointer(pFd + 24 /* &.sharedlock */)) |= (mask)
				}
			}
		} else {
			if isExcl != 0 {
				*(*u32)(unsafe.Pointer(pFd + 20 /* &.excllock */)) &= (^mask)
			}
			if !(isExcl != 0) {
				*(*u32)(unsafe.Pointer(pFd + 24 /* &.sharedlock */)) &= (^mask)
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
}

func tvfsShmBarrier(tls *libc.TLS, pFile uintptr) { /* test_vfs.c:1004:13: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_SHMBARRIER_MASK) != 0) {
		var z uintptr
		if (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm != 0 {
			z = (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile
		} else {
			z = ts + 489 /* "" */
		}
		tvfsExecTcl(tls, p, ts+35116 /* "xShmBarrier" */, tcl.XTcl_NewStringObj(tls, z, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
	}

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods + 60 /* &.xShmBarrier */))))(tls, pReal)
		return
	}
}

func tvfsShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 { /* test_vfs.c:1020:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	var pBuffer uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm
	var ppFd uintptr

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods + 64 /* &.xShmUnmap */))))(tls, pReal, deleteFlag)
	}

	if !(pBuffer != 0) {
		return SQLITE_OK
	}

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & TESTVFS_SHMCLOSE_MASK) != 0) {
		tvfsExecTcl(tls, p, ts+35097, /* "xShmUnmap" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}

	for ppFd = (pBuffer + 4104 /* &.pFile */); *(*uintptr)(unsafe.Pointer(ppFd)) != pFd; ppFd = (*(*uintptr)(unsafe.Pointer(ppFd)) + 28 /* &.pNext */) {
	}

	*(*uintptr)(unsafe.Pointer(ppFd)) = (*TestvfsFd)(unsafe.Pointer(pFd)).FpNext
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpNext = uintptr(0)

	if (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile == uintptr(0) {
		var i int32
		var pp uintptr
		for pp = (p + 20 /* &.pBuffer */); *(*uintptr)(unsafe.Pointer(pp)) != pBuffer; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 4108 /* &.pNext */) {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = (*TestvfsBuffer)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pp)))).FpNext
		for i = 0; *(*uintptr)(unsafe.Pointer((pBuffer + 8 /* &.aPage */) + uintptr(i)*4)) != 0; i++ {
			tcl.XTcl_Free(tls, *(*uintptr)(unsafe.Pointer((pBuffer + 8 /* &.aPage */) + uintptr(i)*4)))
		}
		tcl.XTcl_Free(tls, pBuffer)
	}
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = uintptr(0)

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func tvfsFetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, iAmt int32, pp uintptr) int32 { /* test_vfs.c:1065:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsFetch(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, iOfst, iAmt, pp)
}

func tvfsUnfetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, p uintptr) int32 { /* test_vfs.c:1075:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsUnfetch(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, iOfst, p)
}

func testvfs_obj_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1080:26: */
	bp := tls.Alloc(348)
	defer tls.Free(348)

	var p uintptr = cd
	*(*[10]TestvfsSubcmd)(unsafe.Pointer(bp + 96 /* aSubcmd */)) = [10]TestvfsSubcmd{
		{FzName: ts + 38146 /* "shm" */},
		{FzName: ts + 38150 /* "delete" */, FeCmd: uint32(1) /* CMD_DELETE */},
		{FzName: ts + 38157 /* "filter" */, FeCmd: uint32(2) /* CMD_FILTER */},
		{FzName: ts + 38164 /* "ioerr" */, FeCmd: uint32(3) /* CMD_IOERR */},
		{FzName: ts + 38170 /* "fullerr" */, FeCmd: uint32(7) /* CMD_FULLERR */},
		{FzName: ts + 38178 /* "cantopenerr" */, FeCmd: uint32(8) /* CMD_CANTOPENERR */},
		{FzName: ts + 38190 /* "script" */, FeCmd: uint32(4) /* CMD_SCRIPT */},
		{FzName: ts + 38197 /* "devchar" */, FeCmd: uint32(5) /* CMD_DEVCHAR */},
		{FzName: ts + 38205 /* "sectorsize" */, FeCmd: uint32(6) /* CMD_SECTORSIZE */},
		{},
	}
	// var i int32 at bp+176, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1860 /* "SUBCOMMAND ..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+96 /* &aSubcmd[0] */, int32(unsafe.Sizeof(TestvfsSubcmd{})), ts+38216 /* "subcommand" */, 0, bp+176 /* &i */) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_ResetResult(tls, interp)

	switch (*TestvfsSubcmd)(unsafe.Pointer(bp + 96 /* &aSubcmd */ + uintptr(*(*int32)(unsafe.Pointer(bp + 176 /* i */)))*8)).FeCmd {
	case uint32(0) /* CMD_SHM */ :
		{
			var pObj uintptr
			var rc int32
			var pBuffer uintptr
			var zName uintptr
			if (objc != 3) && (objc != 4) {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+38227 /* "FILE ?VALUE?" */)
				return TCL_ERROR
			}
			zName = tcl.XTcl_Alloc(tls, uint32((*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname))
			rc = (*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*Testvfs)(unsafe.Pointer(p)).FpParent + 36 /* &.xFullPathname */))))(tls,
				(*Testvfs)(unsafe.Pointer(p)).FpParent, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))),
				(*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname, zName)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+38240, /* "failed to get fu..." */
					tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), 0))
				tcl.XTcl_Free(tls, zName)
				return TCL_ERROR
			}
			for pBuffer = (*Testvfs)(unsafe.Pointer(p)).FpBuffer; pBuffer != 0; pBuffer = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext {
				if 0 == libc.Xstrcmp(tls, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile, zName) {
					break
				}
			}
			tcl.XTcl_Free(tls, zName)
			if !(pBuffer != 0) {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+38266 /* "no such file: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), 0))
				return TCL_ERROR
			}
			if objc == 4 {
				// var n int32 at bp+180, 4

				var a uintptr = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+180 /* &n */)
				var pgsz int32 = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).Fpgsz
				if pgsz == 0 {
					pgsz = 65536
				}
				for *(*int32)(unsafe.Pointer(bp + 176 /* i */)) = 0; (*(*int32)(unsafe.Pointer(bp + 176 /* i */)) * pgsz) < *(*int32)(unsafe.Pointer(bp + 180 /* n */)); *(*int32)(unsafe.Pointer(bp + 176 /* i */))++ {
					var nByte int32 = pgsz
					tvfsAllocPage(tls, pBuffer, *(*int32)(unsafe.Pointer(bp + 176 /* i */)), pgsz)
					if (*(*int32)(unsafe.Pointer(bp + 180 /* n */)) - (*(*int32)(unsafe.Pointer(bp + 176 /* i */)) * pgsz)) < pgsz {
						nByte = *(*int32)(unsafe.Pointer(bp + 180 /* n */))
					}
					libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer((pBuffer + 8 /* &.aPage */) + uintptr(*(*int32)(unsafe.Pointer(bp + 176 /* i */)))*4)), (a + uintptr((*(*int32)(unsafe.Pointer(bp + 176 /* i */)) * pgsz))), uint32(nByte))
				}
			}

			pObj = tcl.XTcl_NewObj(tls)
			for *(*int32)(unsafe.Pointer(bp + 176 /* i */)) = 0; *(*uintptr)(unsafe.Pointer((pBuffer + 8 /* &.aPage */) + uintptr(*(*int32)(unsafe.Pointer(bp + 176 /* i */)))*4)) != 0; *(*int32)(unsafe.Pointer(bp + 176 /* i */))++ {
				var pgsz int32 = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).Fpgsz
				if pgsz == 0 {
					pgsz = 65536
				}
				tcl.XTcl_AppendObjToObj(tls, pObj, tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer((pBuffer + 8 /* &.aPage */) + uintptr(*(*int32)(unsafe.Pointer(bp + 176 /* i */)))*4)), pgsz))
			}
			tcl.XTcl_SetObjResult(tls, interp, pObj)
			break

		}

	// TESTVFS filter METHOD-LIST
	//
	//     Activate special processing for those methods contained in the list
	case uint32(2) /* CMD_FILTER */ :
		{
			*(*uintptr)(unsafe.Pointer(bp + 188 /* apElem */)) = uintptr(0)
			*(*int32)(unsafe.Pointer(bp + 184 /* nElem */)) = 0
			var mask int32 = 0
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+31855 /* "LIST" */)
				return TCL_ERROR
			}
			if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+184 /* &nElem */, bp+188 /* &apElem */) != 0 {
				return TCL_ERROR
			}
			tcl.XTcl_ResetResult(tls, interp)
			for *(*int32)(unsafe.Pointer(bp + 176 /* i */)) = 0; *(*int32)(unsafe.Pointer(bp + 176 /* i */)) < *(*int32)(unsafe.Pointer(bp + 184 /* nElem */)); *(*int32)(unsafe.Pointer(bp + 176 /* i */))++ {
				var iMethod int32
				var zElem uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 188 /* apElem */)) + uintptr(*(*int32)(unsafe.Pointer(bp + 176 /* i */)))*4)))
				for iMethod = 0; iMethod < (int32(uint32(unsafe.Sizeof(vfsmethod)) / uint32(unsafe.Sizeof(VfsMethod{})))); iMethod++ {
					if libc.Xstrcmp(tls, zElem, vfsmethod[iMethod].FzName) == 0 {
						mask = mask | (vfsmethod[iMethod].Fmask)
						break
					}
				}
				if iMethod == (int32(uint32(unsafe.Sizeof(vfsmethod)) / uint32(unsafe.Sizeof(VfsMethod{})))) {
					tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+38281 /* "unknown method: " */, zElem, 0))
					return TCL_ERROR
				}
			}
			(*Testvfs)(unsafe.Pointer(p)).Fmask = mask
			break

		}

	//  TESTVFS script ?SCRIPT?
	//
	//  Query or set the script to be run when filtered VFS events
	//  occur.
	case uint32(4) /* CMD_SCRIPT */ :
		{
			if objc == 3 {
				// var nByte int32 at bp+192, 4

				if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
					for ok := true; ok; ok = 0 != 0 {
						var _objPtr uintptr = (*Testvfs)(unsafe.Pointer(p)).FpScript
						if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
							tcl.XTclFreeObj(tls, _objPtr)
						}
					}
					(*Testvfs)(unsafe.Pointer(p)).FpScript = uintptr(0)
				}
				tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+192 /* &nByte */)
				if *(*int32)(unsafe.Pointer(bp + 192 /* nByte */)) > 0 {
					(*Testvfs)(unsafe.Pointer(p)).FpScript = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
					(*Tcl_Obj)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpScript)).FrefCount++
				}
			} else if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12938 /* "?SCRIPT?" */)
				return TCL_ERROR
			}

			tcl.XTcl_ResetResult(tls, interp)
			if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
				tcl.XTcl_SetObjResult(tls, interp, (*Testvfs)(unsafe.Pointer(p)).FpScript)
			}

			break

		}

	// TESTVFS ioerr ?IFAIL PERSIST?
	//
	//   Where IFAIL is an integer and PERSIST is boolean.
	case uint32(8) /* CMD_CANTOPENERR */ :
		fallthrough
	case uint32(3) /* CMD_IOERR */ :
		fallthrough
	case uint32(7) /* CMD_FULLERR */ :
		{
			var pTest uintptr = uintptr(0)
			var iRet int32

			switch (*TestvfsSubcmd)(unsafe.Pointer(bp + 96 /* &aSubcmd */ + uintptr(*(*int32)(unsafe.Pointer(bp + 176 /* i */)))*8)).FeCmd {
			case uint32(3) /* CMD_IOERR */ :
				pTest = (p + 36 /* &.ioerr_err */)
				break
			case uint32(7) /* CMD_FULLERR */ :
				pTest = (p + 48 /* &.full_err */)
				break
			case uint32(8) /* CMD_CANTOPENERR */ :
				pTest = (p + 60 /* &.cantopen_err */)
				break
			default:
			}
			iRet = (*TestFaultInject)(unsafe.Pointer(pTest)).FnFail
			(*TestFaultInject)(unsafe.Pointer(pTest)).FnFail = 0
			(*TestFaultInject)(unsafe.Pointer(pTest)).FeFault = 0
			(*TestFaultInject)(unsafe.Pointer(pTest)).FiCnt = 0

			if objc == 4 {
				// var iCnt int32 at bp+196, 4

				// var iPersist int32 at bp+200, 4

				if (TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+196 /* &iCnt */)) ||
					(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+200 /* &iPersist */)) {
					return TCL_ERROR
				}
				(*TestFaultInject)(unsafe.Pointer(pTest)).FeFault = func() int32 {
					if *(*int32)(unsafe.Pointer(bp + 200 /* iPersist */)) != 0 {
						return FAULT_INJECT_PERSISTENT
					}
					return FAULT_INJECT_TRANSIENT
				}()
				(*TestFaultInject)(unsafe.Pointer(pTest)).FiCnt = *(*int32)(unsafe.Pointer(bp + 196 /* iCnt */))
			} else if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+38298 /* "?CNT PERSIST?" */)
				return TCL_ERROR
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iRet))
			break

		}

	case uint32(1) /* CMD_DELETE */ :
		{
			tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
			break

		}

	case uint32(5) /* CMD_DEVCHAR */ :
		{
			*(*[16]DeviceFlag)(unsafe.Pointer(bp + 212 /* aFlag */)) = [16]DeviceFlag{
				{FzName: ts + 38312 /* "default" */, FiValue: -1},
				{FzName: ts + 25907 /* "atomic" */, FiValue: SQLITE_IOCAP_ATOMIC},
				{FzName: ts + 25914 /* "atomic512" */, FiValue: SQLITE_IOCAP_ATOMIC512},
				{FzName: ts + 25924 /* "atomic1k" */, FiValue: SQLITE_IOCAP_ATOMIC1K},
				{FzName: ts + 25933 /* "atomic2k" */, FiValue: SQLITE_IOCAP_ATOMIC2K},
				{FzName: ts + 25942 /* "atomic4k" */, FiValue: SQLITE_IOCAP_ATOMIC4K},
				{FzName: ts + 25951 /* "atomic8k" */, FiValue: SQLITE_IOCAP_ATOMIC8K},
				{FzName: ts + 25960 /* "atomic16k" */, FiValue: SQLITE_IOCAP_ATOMIC16K},
				{FzName: ts + 25970 /* "atomic32k" */, FiValue: SQLITE_IOCAP_ATOMIC32K},
				{FzName: ts + 25980 /* "atomic64k" */, FiValue: SQLITE_IOCAP_ATOMIC64K},
				{FzName: ts + 25990 /* "sequential" */, FiValue: SQLITE_IOCAP_SEQUENTIAL},
				{FzName: ts + 26001 /* "safe_append" */, FiValue: SQLITE_IOCAP_SAFE_APPEND},
				{FzName: ts + 38320 /* "undeletable_when..." */, FiValue: SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN},
				{FzName: ts + 26013 /* "powersafe_overwr..." */, FiValue: SQLITE_IOCAP_POWERSAFE_OVERWRITE},
				{FzName: ts + 38342 /* "immutable" */, FiValue: SQLITE_IOCAP_IMMUTABLE},
				{},
			}
			var pRet uintptr
			var iFlag int32

			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+38352 /* "?ATTR-LIST?" */)
				return TCL_ERROR
			}
			if objc == 3 {
				var j int32
				var iNew int32 = 0
				*(*uintptr)(unsafe.Pointer(bp + 208 /* flags */)) = uintptr(0)
				*(*int32)(unsafe.Pointer(bp + 204 /* nFlags */)) = 0

				if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+204 /* &nFlags */, bp+208 /* &flags */) != 0 {
					return TCL_ERROR
				}

				for j = 0; j < *(*int32)(unsafe.Pointer(bp + 204 /* nFlags */)); j++ {
					*(*int32)(unsafe.Pointer(bp + 340 /* idx */)) = 0
					if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 208 /* flags */)) + uintptr(j)*4)), bp+212, /* &aFlag[0] */
						int32(unsafe.Sizeof(DeviceFlag{})), ts+17204 /* "flag" */, 0, bp+340 /* &idx */) != 0 {
						return TCL_ERROR
					}
					if ((*DeviceFlag)(unsafe.Pointer(bp+212 /* &aFlag */ +uintptr(*(*int32)(unsafe.Pointer(bp + 340 /* idx */)))*8)).FiValue < 0) && (*(*int32)(unsafe.Pointer(bp + 204 /* nFlags */)) > 1) {
						tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, ts+38364 /* "bad flags: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), 0))
						return TCL_ERROR
					}
					iNew = iNew | ((*DeviceFlag)(unsafe.Pointer(bp + 212 /* &aFlag */ + uintptr(*(*int32)(unsafe.Pointer(bp + 340 /* idx */)))*8)).FiValue)
				}

				(*Testvfs)(unsafe.Pointer(p)).FiDevchar = (iNew | 0x10000000)
			}

			pRet = tcl.XTcl_NewObj(tls)
			for iFlag = 0; uint32(iFlag) < (uint32(unsafe.Sizeof([16]DeviceFlag{})) / uint32(unsafe.Sizeof(DeviceFlag{}))); iFlag++ {
				if ((*Testvfs)(unsafe.Pointer(p)).FiDevchar & (*DeviceFlag)(unsafe.Pointer(bp+212 /* &aFlag */ +uintptr(iFlag)*8)).FiValue) != 0 {
					tcl.XTcl_ListObjAppendElement(tls,
						interp, pRet, tcl.XTcl_NewStringObj(tls, (*DeviceFlag)(unsafe.Pointer(bp+212 /* &aFlag */ +uintptr(iFlag)*8)).FzName, -1))
				}
			}
			tcl.XTcl_SetObjResult(tls, interp, pRet)

			break

		}

	case uint32(6) /* CMD_SECTORSIZE */ :
		{
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+38376 /* "?VALUE?" */)
				return TCL_ERROR
			}
			if objc == 3 {
				*(*int32)(unsafe.Pointer(bp + 344 /* iNew */)) = 0
				if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+344 /* &iNew */) != 0 {
					return TCL_ERROR
				}
				(*Testvfs)(unsafe.Pointer(p)).FiSectorsize = *(*int32)(unsafe.Pointer(bp + 344 /* iNew */))
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (*Testvfs)(unsafe.Pointer(p)).FiSectorsize))
			break

		}
	}

	return TCL_OK
}

type TestvfsSubcmd = struct {
	FzName uintptr
	FeCmd  uint32
} /* test_vfs.c:1092:3 */

type VfsMethod = struct {
	FzName uintptr
	Fmask  int32
} /* test_vfs.c:1179:14 */

var vfsmethod = [18]VfsMethod{
	{FzName: ts + 38104 /* "xShmOpen" */, Fmask: TESTVFS_SHMOPEN_MASK},
	{FzName: ts + 35107 /* "xShmLock" */, Fmask: TESTVFS_SHMLOCK_MASK},
	{FzName: ts + 35116 /* "xShmBarrier" */, Fmask: TESTVFS_SHMBARRIER_MASK},
	{FzName: ts + 35097 /* "xShmUnmap" */, Fmask: TESTVFS_SHMCLOSE_MASK},
	{FzName: ts + 35128 /* "xShmMap" */, Fmask: TESTVFS_SHMMAP_MASK},
	{FzName: ts + 27353 /* "xSync" */, Fmask: TESTVFS_SYNC_MASK},
	{FzName: ts + 35035 /* "xDelete" */, Fmask: TESTVFS_DELETE_MASK},
	{FzName: ts + 34943 /* "xWrite" */, Fmask: TESTVFS_WRITE_MASK},
	{FzName: ts + 34937 /* "xRead" */, Fmask: TESTVFS_READ_MASK},
	{FzName: ts + 34950 /* "xTruncate" */, Fmask: TESTVFS_TRUNCATE_MASK},
	{FzName: ts + 26925 /* "xOpen" */, Fmask: TESTVFS_OPEN_MASK},
	{FzName: ts + 34930 /* "xClose" */, Fmask: TESTVFS_CLOSE_MASK},
	{FzName: ts + 35043 /* "xAccess" */, Fmask: TESTVFS_ACCESS_MASK},
	{FzName: ts + 35051 /* "xFullPathname" */, Fmask: TESTVFS_FULLPATHNAME_MASK},
	{FzName: ts + 34976 /* "xUnlock" */, Fmask: TESTVFS_UNLOCK_MASK},
	{FzName: ts + 34970 /* "xLock" */, Fmask: TESTVFS_LOCK_MASK},
	{FzName: ts + 37970 /* "xCheckReservedLo..." */, Fmask: TESTVFS_CKLOCK_MASK},
	{FzName: ts + 34998 /* "xFileControl" */, Fmask: TESTVFS_FCNTL_MASK},
} /* test_vfs.c:1182:9 */

func testvfs_obj_del(tls *libc.TLS, cd ClientData) { /* test_vfs.c:1393:27: */
	var p uintptr = cd
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*Testvfs)(unsafe.Pointer(p)).FpScript
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_vfs_unregister(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs)
	libc.Xmemset(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs, 0, uint32(unsafe.Sizeof(sqlite3_vfs{})))
	tcl.XTcl_Free(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs)
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(Testvfs{})))
	tcl.XTcl_Free(tls, p)
}

// Usage:  testvfs VFSNAME ?SWITCHES?
//
// Switches are:
//
//   -noshm   BOOLEAN             (True to omit shm methods. Default false)
//   -default BOOLEAN             (True to make the vfs default. Default false)
//
// This command creates two things when it is invoked: an SQLite VFS, and
// a Tcl command. Both are named VFSNAME. The VFS is installed. It is not
// installed as the default VFS.
//
// The VFS passes all file I/O calls through to the underlying VFS.
//
// Whenever the xShmMap method of the VFS
// is invoked, the SCRIPT is executed as follows:
//
//   SCRIPT xShmMap    FILENAME ID
//
// The value returned by the invocation of SCRIPT above is interpreted as
// an SQLite error code and returned to SQLite. Either a symbolic
// "SQLITE_OK" or numeric "0" value may be returned.
//
// The contents of the shared-memory buffer associated with a given file
// may be read and set using the following command:
//
//   VFSNAME shm FILENAME ?NEWVALUE?
//
// When the xShmLock method is invoked by SQLite, the following script is
// run:
//
//   SCRIPT xShmLock    FILENAME ID LOCK
//
// where LOCK is of the form "OFFSET NBYTE lock/unlock shared/exclusive"
func testvfs_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1438:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var p uintptr    // New object
	var pVfs uintptr // New VFS
	var zVfs uintptr
	var nByte int32 // Bytes of space to allocate at p

	var i int32
	// var isNoshm int32 at bp+4, 4
	// True if -noshm is passed
	// var isFullshm int32 at bp+24, 4
	// True if -fullshm is passed
	// var isDefault int32 at bp+8, 4
	// True if -default is passed
	// var szOsFile int32 at bp+12, 4
	// Value passed to -szosfile
	// var mxPathname int32 at bp+16, 4
	// Value passed to -mxpathname
	// var iVersion int32 at bp+20, 4

	// var nSwitch int32 at bp, 4

	var zSwitch uintptr
	*(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */)) = 0
	*(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */)) = 0
	*(*int32)(unsafe.Pointer(bp + 8 /* isDefault */)) = 0
	*(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */)) = 0
	*(*int32)(unsafe.Pointer(bp + 16 /* mxPathname */)) = -1
	*(*int32)(unsafe.Pointer(bp + 20 /* iVersion */)) = 3 // Value passed to -iversion

	if !((objc < 2) || (0 != (objc % 2))) {
		goto __1
	}
	goto bad_args
__1:
	;
	i = 2
__2:
	if !(i < objc) {
		goto __4
	}
	zSwitch = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp /* &nSwitch */)

	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == libc.Xstrncmp(tls, ts+38384 /* "-noshm" */, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __5
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4)), bp+4 /* &isNoshm */) != 0) {
		goto __7
	}
	return TCL_ERROR
__7:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */)) != 0) {
		goto __8
	}
	*(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */)) = 0
__8:
	;
	goto __6
__5:
	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == libc.Xstrncmp(tls, ts+26283 /* "-default" */, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __9
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4)), bp+8 /* &isDefault */) != 0) {
		goto __11
	}
	return TCL_ERROR
__11:
	;
	goto __10
__9:
	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == libc.Xstrncmp(tls, ts+38391 /* "-szosfile" */, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __12
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4)), bp+12 /* &szOsFile */) != 0) {
		goto __14
	}
	return TCL_ERROR
__14:
	;
	goto __13
__12:
	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == libc.Xstrncmp(tls, ts+38401 /* "-mxpathname" */, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __15
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4)), bp+16 /* &mxPathname */) != 0) {
		goto __17
	}
	return TCL_ERROR
__17:
	;
	goto __16
__15:
	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == libc.Xstrncmp(tls, ts+38413 /* "-iversion" */, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __18
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4)), bp+20 /* &iVersion */) != 0) {
		goto __20
	}
	return TCL_ERROR
__20:
	;
	goto __19
__18:
	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == libc.Xstrncmp(tls, ts+38423 /* "-fullshm" */, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __21
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*4)), bp+24 /* &isFullshm */) != 0) {
		goto __23
	}
	return TCL_ERROR
__23:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */)) != 0) {
		goto __24
	}
	*(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */)) = 0
__24:
	;
	goto __22
__21:
	goto bad_args
__22:
	;
__19:
	;
__16:
	;
__13:
	;
__10:
	;
__6:
	;
	goto __3
__3:
	i = i + (2)
	goto __2
	goto __4
__4:
	;

	if !(uint32(*(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */))) < uint32(unsafe.Sizeof(TestvfsFile{}))) {
		goto __25
	}
	*(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */)) = int32(unsafe.Sizeof(TestvfsFile{}))
__25:
	;

	zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	nByte = (int32((uint32(unsafe.Sizeof(Testvfs{})) + uint32(int32(libc.Xstrlen(tls, zVfs)))) + uint32(1)))
	p = tcl.XTcl_Alloc(tls, uint32(nByte))
	libc.Xmemset(tls, p, 0, uint32(nByte))
	(*Testvfs)(unsafe.Pointer(p)).FiDevchar = -1
	(*Testvfs)(unsafe.Pointer(p)).FiSectorsize = -1

	// Create the new object command before querying SQLite for a default VFS
	// to use for 'real' IO operations. This is because creating the new VFS
	// may delete an existing [testvfs] VFS of the same name. If such a VFS
	// is currently the default, the new [testvfs] may end up calling the
	// methods of a deleted object.
	tcl.XTcl_CreateObjCommand(tls, interp, zVfs, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{testvfs_obj_cmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{testvfs_obj_del})))
	(*Testvfs)(unsafe.Pointer(p)).FpParent = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	(*Testvfs)(unsafe.Pointer(p)).Finterp = interp

	(*Testvfs)(unsafe.Pointer(p)).FzName = (p + 1*80)
	libc.Xmemcpy(tls, (*Testvfs)(unsafe.Pointer(p)).FzName, zVfs, (libc.Xstrlen(tls, zVfs) + size_t(1)))

	pVfs = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(sqlite3_vfs{})))
	libc.Xmemcpy(tls, pVfs, uintptr(unsafe.Pointer(&tvfs_vfs)), uint32(unsafe.Sizeof(sqlite3_vfs{})))
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData = p
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion = *(*int32)(unsafe.Pointer(bp + 20 /* iVersion */))
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName = (*Testvfs)(unsafe.Pointer(p)).FzName
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname = (*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname
	if !((*(*int32)(unsafe.Pointer(bp + 16 /* mxPathname */)) >= 0) && (*(*int32)(unsafe.Pointer(bp + 16 /* mxPathname */)) < (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname)) {
		goto __26
	}
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname = *(*int32)(unsafe.Pointer(bp + 16 /* mxPathname */))
__26:
	;
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile = *(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */))
	(*Testvfs)(unsafe.Pointer(p)).FpVfs = pVfs
	(*Testvfs)(unsafe.Pointer(p)).FisNoshm = *(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */))
	(*Testvfs)(unsafe.Pointer(p)).FisFullshm = *(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */))
	(*Testvfs)(unsafe.Pointer(p)).Fmask = TESTVFS_ALL_MASK

	sqlite3.Xsqlite3_vfs_register(tls, pVfs, *(*int32)(unsafe.Pointer(bp + 8 /* isDefault */)))

	return TCL_OK

bad_args:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38432 /* "VFSNAME ?-noshm ..." */)
	return TCL_ERROR
}

var tvfs_vfs = sqlite3_vfs{
	FiVersion:      3, // pAppData
	FxOpen:         0, // xOpen
	FxDelete:       0, // xDelete
	FxAccess:       0, // xAccess
	FxFullPathname: 0, // xDlClose
	FxRandomness:   0, // xRandomness
	FxSleep:        0, // xSleep
	FxCurrentTime:  0, // xNextSystemCall
} /* test_vfs.c:1444:22 */

// tclcmd: vfs_shmlock DB DBNAME (shared|exclusive) (lock|unlock) OFFSET N
func test_vfs_shmlock(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1586:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	*(*[3]uintptr)(unsafe.Pointer(bp + 4 /* azArg1 */)) = [3]uintptr{ts + 38536 /* "shared" */, ts + 13658 /* "exclusive" */, uintptr(0)}
	*(*[3]uintptr)(unsafe.Pointer(bp + 20 /* azArg2 */)) = [3]uintptr{ts + 38543 /* "lock" */, ts + 38548 /* "unlock" */, uintptr(0)}
	*(*uintptr)(unsafe.Pointer(bp /* db */)) = uintptr(0)
	var rc int32 = SQLITE_OK
	var zDbname uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 16 /* iArg1 */)) = 0
	*(*int32)(unsafe.Pointer(bp + 32 /* iArg2 */)) = 0
	*(*int32)(unsafe.Pointer(bp + 36 /* iOffset */)) = 0
	*(*int32)(unsafe.Pointer(bp + 40 /* n */)) = 0
	// var pFd uintptr at bp+44, 4

	if objc != 7 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,
			ts+38555 /* "DB DBNAME (share..." */)
		return TCL_ERROR
	}

	zDbname = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if ((((getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0) ||
		(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4 /* &azArg1[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+38607 /* "ARG" */, 0, bp+16 /* &iArg1 */) != 0)) ||
		(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+20 /* &azArg2[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+38607 /* "ARG" */, 0, bp+32 /* &iArg2 */) != 0)) ||
		(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*4)), bp+36 /* &iOffset */) != 0)) ||
		(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 6*4)), bp+40 /* &n */) != 0) {
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDbname, SQLITE_FCNTL_FILE_POINTER, bp+44 /* &pFd */)
	if *(*uintptr)(unsafe.Pointer(bp + 44 /* pFd */)) == uintptr(0) {
		return TCL_ERROR
	}
	rc = (*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44 /* pFd */)))).FpMethods + 56 /* &.xShmLock */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 44 /* pFd */)), *(*int32)(unsafe.Pointer(bp + 36 /* iOffset */)), *(*int32)(unsafe.Pointer(bp + 40 /* n */)),
		((func() int32 {
			if *(*int32)(unsafe.Pointer(bp + 16 /* iArg1 */)) == 0 {
				return SQLITE_SHM_SHARED
			}
			return SQLITE_SHM_EXCLUSIVE
		}()) |
			(func() int32 {
				if *(*int32)(unsafe.Pointer(bp + 32 /* iArg2 */)) == 0 {
					return SQLITE_SHM_LOCK
				}
				return SQLITE_SHM_UNLOCK
			}())))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return TCL_OK
}

func test_vfs_set_readmark(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1632:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	*(*uintptr)(unsafe.Pointer(bp + 16 /* db */)) = uintptr(0)
	var rc int32 = SQLITE_OK
	var zDbname uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 20 /* iSlot */)) = 0
	*(*int32)(unsafe.Pointer(bp + 24 /* iVal */)) = -1
	// var pFd uintptr at bp+28, 4

	*(*uintptr)(unsafe.Pointer(bp + 32 /* pShm */)) = uintptr(0)
	var aShm uintptr
	var iOff int32

	if (objc != 4) && (objc != 5) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38611 /* "DB DBNAME SLOT ?..." */)
		return TCL_ERROR
	}

	zDbname = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if ((getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16 /* &db */) != 0) ||
		(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+20 /* &iSlot */) != 0)) ||
		((objc == 5) && (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+24 /* &iVal */) != 0)) {
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zDbname, SQLITE_FCNTL_FILE_POINTER, bp+28 /* &pFd */)
	if *(*uintptr)(unsafe.Pointer(bp + 28 /* pFd */)) == uintptr(0) {
		return TCL_ERROR
	}
	rc = (*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 28 /* pFd */)))).FpMethods + 52 /* &.xShmMap */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 28 /* pFd */)), 0, (32 * 1024), 0, bp+32 /* &pShm */)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	if libc.AtomicLoadPUintptr(bp+32 /* pShm */) == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+38634 /* "*-shm is not yet..." */, 0))
		return TCL_ERROR
	}
	aShm = libc.AtomicLoadPUintptr(bp + 32 /* pShm */)
	iOff = (((12 * 2) + 1) + *(*int32)(unsafe.Pointer(bp + 20 /* iSlot */)))

	if objc == 5 {
		*(*u32)(unsafe.Pointer(aShm + uintptr(iOff)*4)) = u32(*(*int32)(unsafe.Pointer(bp + 24 /* iVal */)))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(*(*u32)(unsafe.Pointer(aShm + uintptr(iOff)*4)))))

	return TCL_OK
}

func Sqlitetestvfs_Init(tls *libc.TLS, interp uintptr) int32 { /* test_vfs.c:1685:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+38658 /* "testvfs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{testvfs_cmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+38666 /* "vfs_shmlock" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfs_shmlock})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+38678 /* "vfs_set_readmark" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfs_set_readmark})), uintptr(0), uintptr(0))
	return TCL_OK
}

// 2015 November 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This file contains code to implement most of the opendir() family of
// POSIX functions on Win32 using the MSVCRT.

type TestWindow1 = struct {
	FxStep    uintptr
	FxFinal   uintptr
	FxValue   uintptr
	FxInverse uintptr
	Finterp   uintptr
} /* test_window.c:24:9 */

type TestWindow = TestWindow1 /* test_window.c:24:27 */

type TestWindowCtx1 = struct{ FpVal uintptr } /* test_window.c:33:9 */

type TestWindowCtx = TestWindowCtx1 /* test_window.c:33:30 */

func doTestWindowStep(tls *libc.TLS, bInverse int32, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:38:13: */
	var i int32
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, ctx)
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, func() uintptr {
		if bInverse != 0 {
			return (*TestWindow)(unsafe.Pointer(p)).FxInverse
		}
		return (*TestWindow)(unsafe.Pointer(p)).FxStep
	}())
	var pCtx uintptr = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(TestWindowCtx{})))

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	if pCtx != 0 {
		var zResult uintptr
		var rc int32
		if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_DuplicateObj(tls, (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal))
		} else {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, ts+489 /* "" */, -1))
		}
		for i = 0; i < nArg; i++ {
			var pArg uintptr
			pArg = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*4))), -1)
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, pArg)
		}
		rc = tcl.XTcl_EvalObjEx(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
		if rc != TCL_OK {
			zResult = tcl.XTcl_GetStringResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp)
			sqlite3.Xsqlite3_result_error(tls, ctx, zResult, -1)
		} else {
			if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal = tcl.XTcl_DuplicateObj(tls, tcl.XTcl_GetObjResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp))
			(*Tcl_Obj)(unsafe.Pointer((*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal)).FrefCount++
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func doTestWindowFinalize(tls *libc.TLS, bValue int32, ctx uintptr) { /* test_window.c:76:13: */
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, ctx)
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, func() uintptr {
		if bValue != 0 {
			return (*TestWindow)(unsafe.Pointer(p)).FxValue
		}
		return (*TestWindow)(unsafe.Pointer(p)).FxFinal
	}())
	var pCtx uintptr = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(TestWindowCtx{})))

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	if pCtx != 0 {
		var zResult uintptr
		var rc int32
		if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_DuplicateObj(tls, (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal))
		} else {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, ts+489 /* "" */, -1))
		}

		rc = tcl.XTcl_EvalObjEx(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
		zResult = tcl.XTcl_GetStringResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp)
		if rc != TCL_OK {
			sqlite3.Xsqlite3_result_error(tls, ctx, zResult, -1)
		} else {
			sqlite3.Xsqlite3_result_text(tls, ctx, zResult, -1, libc.UintptrFromInt32(-1))
		}

		if bValue == 0 {
			if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal = uintptr(0)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func testWindowStep(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:107:13: */
	doTestWindowStep(tls, 0, ctx, nArg, apArg)
}

func testWindowInverse(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:114:13: */
	doTestWindowStep(tls, 1, ctx, nArg, apArg)
}

func testWindowFinal(tls *libc.TLS, ctx uintptr) { /* test_window.c:122:13: */
	doTestWindowFinalize(tls, 0, ctx)
}

func testWindowValue(tls *libc.TLS, ctx uintptr) { /* test_window.c:125:13: */
	doTestWindowFinalize(tls, 1, ctx)
}

func testWindowDestroy(tls *libc.TLS, pCtx uintptr) { /* test_window.c:129:13: */
	tcl.XTcl_Free(tls, pCtx)
}

// Usage: sqlite3_create_window_function DB NAME XSTEP XFINAL XVALUE XINVERSE
func test_create_window(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:136:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pNew uintptr
	// var db uintptr at bp, 4

	var zName uintptr
	var rc int32

	if objc != 7 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38695 /* "DB NAME XSTEP XF..." */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	pNew = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(TestWindow{})))
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(TestWindow{})))
	(*TestWindow)(unsafe.Pointer(pNew)).FxStep = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxFinal = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxValue = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 5*4)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxInverse = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 6*4)))
	(*TestWindow)(unsafe.Pointer(pNew)).Finterp = interp

	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxStep)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxFinal)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxValue)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxInverse)).FrefCount++

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName, -1, SQLITE_UTF8, pNew,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowDestroy})))
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}

	return TCL_OK
}

func test_create_window_misuse(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:179:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32

	if !(objc != 2) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
	return TCL_ERROR
__1:
	;
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+38732 /* "fff" */, -1, SQLITE_UTF8, uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	goto error
__3:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+38732 /* "fff" */, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __4
	}
	goto error
__4:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+38732 /* "fff" */, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __5
	}
	goto error
__5:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+38732 /* "fff" */, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), uintptr(0),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __6
	}
	goto error
__6:
	;

	return TCL_OK

error:
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, ts+38736 /* "misuse test erro..." */, -1))
	return TCL_ERROR
}

// xStep for sumint().
func sumintStep(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:225:13: */
	var pInt uintptr

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apArg))) != SQLITE_INTEGER {
		sqlite3.Xsqlite3_result_error(tls, ctx, ts+38754 /* "invalid argument" */, -1)
		return
	}
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(sqlite3_int64(0))))
	if pInt != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pInt)) += (sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apArg))))
	}
}

// xInverse for sumint().
func sumintInverse(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:246:13: */
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(sqlite3_int64(0))))
	*(*sqlite3_int64)(unsafe.Pointer(pInt)) -= (sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apArg))))
}

// xFinal for sumint().
func sumintFinal(tls *libc.TLS, ctx uintptr) { /* test_window.c:259:13: */
	var res sqlite3_int64 = int64(0)
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, 0)
	if pInt != 0 {
		res = *(*sqlite3_int64)(unsafe.Pointer(pInt))
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, res)
}

// xValue for sumint().
func sumintValue(tls *libc.TLS, ctx uintptr) { /* test_window.c:270:13: */
	var res sqlite3_int64 = int64(0)
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, 0)
	if pInt != 0 {
		res = *(*sqlite3_int64)(unsafe.Pointer(pInt))
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, res)
}

func test_create_sumint(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:278:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+38771 /* "sumint" */, 1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sumintStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sumintFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sumintValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sumintInverse})),
		uintptr(0))

	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	return TCL_OK
}

func test_override_sum(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:305:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var db uintptr at bp, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1911 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp /* &db */) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+38778 /* "sum" */, -1, SQLITE_UTF8, uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sumintStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sumintFinal})))

	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	return TCL_OK
}

func Sqlitetest_window_Init(tls *libc.TLS, interp uintptr) int32 { /* test_window.c:331:5: */
	var i int32
	for i = 0; uint32(i) < (uint32(unsafe.Sizeof(aObjCmd14)) / uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData int32
	}{}))); i++ {
		var c ClientData = uintptr(aObjCmd14[i].FclientData)
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd14[i].FzName, aObjCmd14[i].FxProc, c, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd14 = [4]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData int32
}{
	{FzName: ts + 38782 /* "sqlite3_create_w..." */, FxProc: 0},
	{FzName: ts + 38813 /* "test_create_wind..." */, FxProc: 0},
	{FzName: ts + 38848 /* "test_create_sumi..." */, FxProc: 0},
	{FzName: ts + 38867 /* "test_override_su..." */, FxProc: 0},
} /* test_window.c:336:5 */

// 2008 September 1
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// The code in this file contains sample implementations of the
// sqlite3_wsd_init() and sqlite3_wsd_find() functions required if the
// SQLITE_OMIT_WSD symbol is defined at build time.

func init() {
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 4 /* .xClose */)) = cfClose                                                         // test6.c:577:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 8 /* .xRead */)) = cfRead                             // test6.c:578:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 12 /* .xWrite */)) = cfWrite                          // test6.c:579:3:
	*(*func(*libc.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 16 /* .xTruncate */)) = cfTruncate                                    // test6.c:580:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 20 /* .xSync */)) = cfSync                                                   // test6.c:581:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 24 /* .xFileSize */)) = cfFileSize                                         // test6.c:582:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 28 /* .xLock */)) = cfLock                                                   // test6.c:583:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 32 /* .xUnlock */)) = cfUnlock                                               // test6.c:584:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 36 /* .xCheckReservedLock */)) = cfCheckReservedLock                       // test6.c:585:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 40 /* .xFileControl */)) = cfFileControl                            // test6.c:586:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 44 /* .xSectorSize */)) = cfSectorSize                                              // test6.c:587:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 48 /* .xDeviceCharacteristics */)) = cfDeviceCharacteristics                        // test6.c:588:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 52 /* .xShmMap */)) = cfShmMap                        // test6.c:589:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 56 /* .xShmLock */)) = cfShmLock                               // test6.c:590:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 60 /* .xShmBarrier */)) = cfShmBarrier                                                    // test6.c:591:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 64 /* .xShmUnmap */)) = cfShmUnmap                                           // test6.c:592:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 4 /* .xCreate */)) = csvtabCreate            // csv.c:874:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 8 /* .xConnect */)) = csvtabConnect          // csv.c:875:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 12 /* .xBestIndex */)) = csvtabBestIndex                                       // csv.c:876:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 16 /* .xDisconnect */)) = csvtabDisconnect                                              // csv.c:877:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 20 /* .xDestroy */)) = csvtabDisconnect                                                 // csv.c:878:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 24 /* .xOpen */)) = csvtabOpen                                                 // csv.c:879:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 28 /* .xClose */)) = csvtabClose                                                        // csv.c:880:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 32 /* .xFilter */)) = csvtabFilter                      // csv.c:881:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 36 /* .xNext */)) = csvtabNext                                                          // csv.c:882:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 40 /* .xEof */)) = csvtabEof                                                            // csv.c:883:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 44 /* .xColumn */)) = csvtabColumn                                      // csv.c:884:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 48 /* .xRowid */)) = csvtabRowid                                               // csv.c:885:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 4 /* .xCreate */)) = csvtabCreate   // csv.c:906:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 8 /* .xConnect */)) = csvtabConnect // csv.c:907:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 12 /* .xBestIndex */)) = csvtabBestIndex                              // csv.c:908:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 16 /* .xDisconnect */)) = csvtabDisconnect                                     // csv.c:909:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 20 /* .xDestroy */)) = csvtabDisconnect                                        // csv.c:910:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 24 /* .xOpen */)) = csvtabOpen                                        // csv.c:911:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 28 /* .xClose */)) = csvtabClose                                               // csv.c:912:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 32 /* .xFilter */)) = csvtabFilter             // csv.c:913:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 36 /* .xNext */)) = csvtabNext                                                 // csv.c:914:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 40 /* .xEof */)) = csvtabEof                                                   // csv.c:915:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 44 /* .xColumn */)) = csvtabColumn                             // csv.c:916:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 48 /* .xRowid */)) = csvtabRowid                                      // csv.c:917:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 52 /* .xUpdate */)) = csvtabUpdate                    // csv.c:918:3:
	*(*func(*libc.TLS, ClientData, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 8 /* .closeProc */)) = incrblobClose                              // tclsqlite.c:372:3:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 12 /* .inputProc */)) = incrblobInput             // tclsqlite.c:373:3:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 16 /* .outputProc */)) = incrblobOutput           // tclsqlite.c:374:3:
	*(*func(*libc.TLS, ClientData, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 20 /* .seekProc */)) = incrblobSeek                 // tclsqlite.c:375:3:
	*(*func(*libc.TLS, ClientData, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 32 /* .watchProc */)) = incrblobWatch                                     // tclsqlite.c:378:3:
	*(*func(*libc.TLS, ClientData, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 36 /* .getHandleProc */)) = incrblobHandle                 // tclsqlite.c:379:3:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 4 /* .xProc */)) = f5tCreateTokenizer                            // fts5_tcl.c:1129:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 16 /* .xProc */)) = f5tTokenizerReturn                              // fts5_tcl.c:1130:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 28 /* .xProc */)) = f5tTokenize                                     // fts5_tcl.c:1131:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 40 /* .xProc */)) = f5tCreateFunction                               // fts5_tcl.c:1132:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 52 /* .xProc */)) = f5tMayBeCorrupt                                 // fts5_tcl.c:1133:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 64 /* .xProc */)) = f5tTokenHash                                    // fts5_tcl.c:1134:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 76 /* .xProc */)) = f5tRegisterMatchinfo                            // fts5_tcl.c:1135:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 88 /* .xProc */)) = f5tRegisterTok                                  // fts5_tcl.c:1136:45:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 4 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{db_enter})) // test1.c:8289:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 12 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{db_leave})) // test1.c:8290:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 20 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_int})) // test1.c:8291:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 28 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_int64})) // test1.c:8292:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 36 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_long})) // test1.c:8293:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 44 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_str})) // test1.c:8294:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 52 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_snprintf_str})) // test1.c:8295:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 60 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_stronly})) // test1.c:8296:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 68 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_double})) // test1.c:8297:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 76 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_scaled})) // test1.c:8298:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 84 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_hexdouble})) // test1.c:8299:39:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 92 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_mprintf_z})) // test1.c:8300:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 100 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_mprintf_n})) // test1.c:8301:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 108 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_snprintf_int})) // test1.c:8302:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 116 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_last_rowid})) // test1.c:8303:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 124 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_printf})) // test1.c:8304:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 132 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_hex})) // test1.c:8305:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 140 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec})) // test1.c:8306:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 148 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_nr})) // test1.c:8307:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 156 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_get_table_printf})) // test1.c:8309:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 164 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_test_close})) // test1.c:8311:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 172 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_test_close_v2})) // test1.c:8312:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 180 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_create_function})) // test1.c:8313:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 188 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_create_aggregate})) // test1.c:8314:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 196 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_drop_modules})) // test1.c:8315:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 204 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_register_func})) // test1.c:8316:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 212 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_abort})) // test1.c:8317:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 220 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_bind})) // test1.c:8318:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 228 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_breakpoint})) // test1.c:8319:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 236 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_key})) // test1.c:8320:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 244 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_rekey})) // test1.c:8321:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 252 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_set_magic})) // test1.c:8322:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 260 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_interrupt})) // test1.c:8323:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 268 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{delete_function})) // test1.c:8324:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 276 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{delete_collation})) // test1.c:8325:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 284 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{get_autocommit})) // test1.c:8326:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 292 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_busy_timeout})) // test1.c:8327:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 300 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_printf})) // test1.c:8328:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 308 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_io_trace})) // test1.c:8329:39:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 316 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{clang_sanitize_address})) // test1.c:8330:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 4 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_open})) // test2.c:708:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 12 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_close})) // test2.c:709:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 20 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_commit})) // test2.c:710:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 28 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_rollback})) // test2.c:711:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 36 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_begin})) // test2.c:712:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 44 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_commit})) // test2.c:713:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 52 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_rollback})) // test2.c:714:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 60 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stats})) // test2.c:715:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 68 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_pagecount})) // test2.c:716:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 76 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_get})) // test2.c:717:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 84 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_lookup})) // test2.c:718:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 92 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_unref})) // test2.c:719:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 100 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_read})) // test2.c:720:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 108 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_write})) // test2.c:721:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 116 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_number})) // test2.c:722:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 124 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_truncate})) // test2.c:723:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 132 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{fake_big_file})) // test2.c:725:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 140 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{testBitvecBuiltinTest})) // test2.c:727:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 148 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{testPendingByte})) // test2.c:728:45:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 156 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{faultInstallCmd})) // test2.c:729:45:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 4 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_open})) // test3.c:666:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 12 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_close})) // test3.c:667:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 20 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_begin_transaction})) // test3.c:668:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 28 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_pager_stats})) // test3.c:669:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 36 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_cursor})) // test3.c:670:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 44 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_close_cursor})) // test3.c:671:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 52 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_next})) // test3.c:672:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 60 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_eof})) // test3.c:673:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 68 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_payload_size})) // test3.c:674:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 76 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_first})) // test3.c:675:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 84 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_varint_test})) // test3.c:676:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 92 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_from_db})) // test3.c:677:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 100 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_ismemdb})) // test3.c:678:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 108 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_set_cache_size})) // test3.c:679:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 4 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_create})) // test4.c:701:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 12 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_wait})) // test4.c:702:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 20 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_halt})) // test4.c:703:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 28 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_argc})) // test4.c:704:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 36 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_argv})) // test4.c:705:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 44 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_colname})) // test4.c:706:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 52 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_result})) // test4.c:707:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 60 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_error})) // test4.c:708:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 68 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_compile})) // test4.c:709:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 76 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_step})) // test4.c:710:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 84 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_finalize})) // test4.c:711:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 92 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_swap})) // test4.c:712:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 100 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_db_get})) // test4.c:713:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 108 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_db_put})) // test4.c:714:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 116 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_stmt_get})) // test4.c:715:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 4 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{binarize})) // test5.c:210:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 12 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_value_overhead})) // test5.c:211:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 20 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_translate})) // test5.c:212:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 28 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_translate_selftest})) // test5.c:213:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 4 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_create})) // test7.c:695:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 12 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_wait})) // test7.c:696:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 20 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_halt})) // test7.c:697:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 28 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_argc})) // test7.c:698:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 36 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_argv})) // test7.c:699:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 44 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_colname})) // test7.c:700:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 52 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_result})) // test7.c:701:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 60 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_error})) // test7.c:702:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 68 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_compile})) // test7.c:703:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 76 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_step})) // test7.c:704:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 84 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_reset})) // test7.c:705:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 92 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_finalize})) // test7.c:706:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 100 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_swap})) // test7.c:707:29:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 4 /* .xProc */)) = test_multiplex_initialize  // test_multiplex.c:1311:39:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 12 /* .xProc */)) = test_multiplex_shutdown   // test_multiplex.c:1312:37:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 20 /* .xProc */)) = test_multiplex_control // test_multiplex.c:1313:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 4 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_shutdown})) // test_mutex.c:485:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 12 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_initialize})) // test_mutex.c:486:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 20 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_config})) // test_mutex.c:487:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 28 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_enter_static_mutex})) // test_mutex.c:489:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 36 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_leave_static_mutex})) // test_mutex.c:490:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 44 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_enter_db_mutex})) // test_mutex.c:492:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 52 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_leave_db_mutex})) // test_mutex.c:493:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 60 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_alloc_mutex})) // test_mutex.c:495:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 68 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_install_mutex_counters})) // test_mutex.c:496:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 76 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_read_mutex_counters})) // test_mutex.c:497:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 84 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_clear_mutex_counters})) // test_mutex.c:498:34:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 4 /* .xProc */)) = test_quota_initialize                 // test_quota.c:1949:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 12 /* .xProc */)) = test_quota_shutdown                  // test_quota.c:1950:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 20 /* .xProc */)) = test_quota_set                       // test_quota.c:1951:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 28 /* .xProc */)) = test_quota_file                      // test_quota.c:1952:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 36 /* .xProc */)) = test_quota_dump                      // test_quota.c:1953:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 44 /* .xProc */)) = test_quota_fopen                     // test_quota.c:1954:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 52 /* .xProc */)) = test_quota_fread                     // test_quota.c:1955:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 60 /* .xProc */)) = test_quota_fwrite                    // test_quota.c:1956:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 68 /* .xProc */)) = test_quota_fclose                    // test_quota.c:1957:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 76 /* .xProc */)) = test_quota_fflush                    // test_quota.c:1958:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 84 /* .xProc */)) = test_quota_fseek                     // test_quota.c:1959:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 92 /* .xProc */)) = test_quota_rewind                    // test_quota.c:1960:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 100 /* .xProc */)) = test_quota_ftell                    // test_quota.c:1961:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 108 /* .xProc */)) = test_quota_ftruncate                // test_quota.c:1962:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 116 /* .xProc */)) = test_quota_file_size                // test_quota.c:1963:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 124 /* .xProc */)) = test_quota_file_truesize            // test_quota.c:1964:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 132 /* .xProc */)) = test_quota_file_mtime               // test_quota.c:1965:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 140 /* .xProc */)) = test_quota_remove                   // test_quota.c:1966:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 148 /* .xProc */)) = test_quota_glob                     // test_quota.c:1967:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 156 /* .xProc */)) = test_quota_file_available           // test_quota.c:1968:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 164 /* .xProc */)) = test_quota_ferror                   // test_quota.c:1969:38:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 4 /* .pInit */)) = sqlite3_amatch_init                     // test1.c:7586:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 12 /* .pInit */)) = sqlite3_appendvfs_init                 // test1.c:7587:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 20 /* .pInit */)) = sqlite3_carray_init                    // test1.c:7588:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 28 /* .pInit */)) = sqlite3_closure_init                   // test1.c:7589:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 36 /* .pInit */)) = sqlite3_csv_init                       // test1.c:7590:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 44 /* .pInit */)) = sqlite3_decimal_init                   // test1.c:7591:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 52 /* .pInit */)) = sqlite3_eval_init                      // test1.c:7592:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 60 /* .pInit */)) = sqlite3_explain_init                   // test1.c:7593:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 68 /* .pInit */)) = sqlite3_fileio_init                    // test1.c:7594:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 76 /* .pInit */)) = sqlite3_fuzzer_init                    // test1.c:7595:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 84 /* .pInit */)) = sqlite3_ieee_init                      // test1.c:7596:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 92 /* .pInit */)) = sqlite3_nextchar_init                  // test1.c:7597:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 100 /* .pInit */)) = sqlite3_percentile_init               // test1.c:7598:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 108 /* .pInit */)) = sqlite3_prefixes_init                 // test1.c:7600:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 116 /* .pInit */)) = sqlite3_regexp_init                   // test1.c:7602:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 124 /* .pInit */)) = sqlite3_remember_init                 // test1.c:7603:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 132 /* .pInit */)) = sqlite3_series_init                   // test1.c:7604:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 140 /* .pInit */)) = sqlite3_spellfix_init                 // test1.c:7605:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 148 /* .pInit */)) = sqlite3_totype_init                   // test1.c:7606:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 156 /* .pInit */)) = sqlite3_unionvtab_init                // test1.c:7607:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 164 /* .pInit */)) = sqlite3_wholenumber_init              // test1.c:7608:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 172 /* .pInit */)) = sqlite3_zipfile_init                  // test1.c:7610:32:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 8 /* .xFunc */)) = decimalFunc                                          // decimal.c:608:29:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 20 /* .xFunc */)) = decimalCmpFunc                                      // decimal.c:609:29:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 32 /* .xFunc */)) = decimalAddFunc                                      // decimal.c:610:29:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 44 /* .xFunc */)) = decimalSubFunc                                      // decimal.c:611:29:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 56 /* .xFunc */)) = decimalMulFunc                                      // decimal.c:612:29:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 12 /* .xFunc */)) = ieee754func                                        // ieee754.c:270:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 28 /* .xFunc */)) = ieee754func                                        // ieee754.c:271:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 44 /* .xFunc */)) = ieee754func                                        // ieee754.c:272:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 60 /* .xFunc */)) = ieee754func                                        // ieee754.c:273:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 76 /* .xFunc */)) = ieee754func_to_blob                                // ieee754.c:274:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 92 /* .xFunc */)) = ieee754func_from_blob                              // ieee754.c:275:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 12 /* .xFunc */)) = randStr                                            // test_func.c:675:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 28 /* .xFunc */)) = test_destructor                                    // test_func.c:676:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 44 /* .xFunc */)) = test_destructor16                                  // test_func.c:678:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 60 /* .xFunc */)) = testHexToUtf16be                                   // test_func.c:679:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 76 /* .xFunc */)) = testHexToUtf16le                                   // test_func.c:680:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 92 /* .xFunc */)) = testHexToUtf8                                      // test_func.c:682:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 108 /* .xFunc */)) = test_destructor_count                             // test_func.c:683:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 124 /* .xFunc */)) = test_auxdata                                      // test_func.c:684:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 140 /* .xFunc */)) = test_error                                        // test_func.c:685:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 156 /* .xFunc */)) = test_error                                        // test_func.c:686:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 172 /* .xFunc */)) = test_eval                                         // test_func.c:687:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 188 /* .xFunc */)) = test_isolation                                    // test_func.c:688:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 204 /* .xFunc */)) = counterFunc                                       // test_func.c:689:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 220 /* .xFunc */)) = real2hex                                          // test_func.c:690:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 236 /* .xFunc */)) = test_decode                                       // test_func.c:691:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 252 /* .xFunc */)) = test_extract                                      // test_func.c:692:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 268 /* .xFunc */)) = test_zeroblob                                     // test_func.c:693:62:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 284 /* .xFunc */)) = test_getsubtype                                   // test_func.c:694:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 300 /* .xFunc */)) = test_setsubtype                                   // test_func.c:695:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 316 /* .xFunc */)) = test_frombind                                     // test_func.c:696:48:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 4 /* .xProc */)) = test_sqlite3rbu                  // test_rbu.c:370:21:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 12 /* .xProc */)) = test_sqlite3rbu_vacuum          // test_rbu.c:371:28:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 20 /* .xProc */)) = test_sqlite3rbu_create_vfs      // test_rbu.c:372:32:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 28 /* .xProc */)) = test_sqlite3rbu_destroy_vfs     // test_rbu.c:373:33:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 36 /* .xProc */)) = test_sqlite3rbu_internal_test   // test_rbu.c:374:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 4 /* .xProc */)) = test_sqlite3_db_config             // test1.c:8337:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 16 /* .xProc */)) = test_sqlite3_txn_state            // test1.c:8338:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 28 /* .xProc */)) = test_bad_behavior              // test1.c:8339:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 32 /* .clientData */)) = uintptr(unsafe.Pointer(&iZero))                                              // test1.c:8339:61:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 40 /* .xProc */)) = test_register_dbstat_vtab         // test1.c:8340:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 52 /* .xProc */)) = get_sqlite_pointer                // test1.c:8341:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 64 /* .xProc */)) = test_intarray_addr                // test1.c:8342:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 76 /* .xProc */)) = test_int64array_addr              // test1.c:8343:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 88 /* .xProc */)) = test_doublearray_addr             // test1.c:8344:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 100 /* .xProc */)) = test_textarray_addr              // test1.c:8345:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 112 /* .xProc */)) = test_bind_int                    // test1.c:8346:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 124 /* .xProc */)) = test_bind_zeroblob               // test1.c:8347:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 136 /* .xProc */)) = test_bind_zeroblob64             // test1.c:8348:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 148 /* .xProc */)) = test_bind_int64                  // test1.c:8349:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 160 /* .xProc */)) = test_bind_double                 // test1.c:8350:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 172 /* .xProc */)) = test_bind_null                   // test1.c:8351:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 184 /* .xProc */)) = test_bind_text                   // test1.c:8352:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 196 /* .xProc */)) = test_bind_text16                 // test1.c:8353:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 208 /* .xProc */)) = test_bind_blob                   // test1.c:8354:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 220 /* .xProc */)) = test_carray_bind                 // test1.c:8356:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 232 /* .xProc */)) = test_bind_parameter_count        // test1.c:8358:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 244 /* .xProc */)) = test_bind_parameter_name         // test1.c:8359:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 256 /* .xProc */)) = test_bind_parameter_index        // test1.c:8360:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 268 /* .xProc */)) = test_clear_bindings              // test1.c:8361:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 280 /* .xProc */)) = test_sleep                       // test1.c:8362:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 292 /* .xProc */)) = test_errcode                     // test1.c:8363:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 304 /* .xProc */)) = test_ex_errcode                  // test1.c:8364:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 316 /* .xProc */)) = test_errmsg                      // test1.c:8365:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 328 /* .xProc */)) = test_errmsg16                    // test1.c:8366:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 340 /* .xProc */)) = test_open                        // test1.c:8367:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 352 /* .xProc */)) = test_open16                      // test1.c:8368:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 364 /* .xProc */)) = test_open_v2                     // test1.c:8369:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 376 /* .xProc */)) = test_complete16                  // test1.c:8370:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 388 /* .xProc */)) = test_normalize                   // test1.c:8371:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 400 /* .xProc */)) = test_prepare                     // test1.c:8373:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 412 /* .xProc */)) = test_prepare16                   // test1.c:8374:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 424 /* .xProc */)) = test_prepare_v2                  // test1.c:8375:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 436 /* .xProc */)) = test_prepare_v3                  // test1.c:8376:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 448 /* .xProc */)) = test_prepare_tkt3134             // test1.c:8377:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 460 /* .xProc */)) = test_prepare16_v2                // test1.c:8378:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 472 /* .xProc */)) = test_finalize                    // test1.c:8379:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 484 /* .xProc */)) = test_stmt_status                 // test1.c:8380:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 496 /* .xProc */)) = test_reset                       // test1.c:8381:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 508 /* .xProc */)) = test_expired                     // test1.c:8382:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 520 /* .xProc */)) = test_transfer_bind               // test1.c:8383:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 532 /* .xProc */)) = test_changes                     // test1.c:8384:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 544 /* .xProc */)) = test_step                        // test1.c:8385:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 556 /* .xProc */)) = test_sql                         // test1.c:8386:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 568 /* .xProc */)) = test_ex_sql                      // test1.c:8387:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 580 /* .xProc */)) = test_next_stmt                   // test1.c:8391:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 592 /* .xProc */)) = test_stmt_readonly               // test1.c:8392:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 604 /* .xProc */)) = test_stmt_isexplain              // test1.c:8393:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 616 /* .xProc */)) = test_stmt_busy                   // test1.c:8394:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 628 /* .xProc */)) = uses_stmt_journal                // test1.c:8395:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 640 /* .xProc */)) = test_release_memory              // test1.c:8397:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 652 /* .xProc */)) = test_db_release_memory           // test1.c:8398:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 664 /* .xProc */)) = test_db_cacheflush               // test1.c:8399:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 676 /* .xProc */)) = test_system_errno                // test1.c:8400:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 688 /* .xProc */)) = test_db_filename                 // test1.c:8401:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 700 /* .xProc */)) = test_db_readonly                 // test1.c:8402:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 712 /* .xProc */)) = test_soft_heap_limit             // test1.c:8403:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 724 /* .xProc */)) = test_soft_heap_limit             // test1.c:8404:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 736 /* .xProc */)) = test_hard_heap_limit             // test1.c:8405:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 748 /* .xProc */)) = test_thread_cleanup              // test1.c:8406:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 760 /* .xProc */)) = test_pager_refcounts             // test1.c:8407:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 772 /* .xProc */)) = test_load_extension           // test1.c:8409:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 784 /* .xProc */)) = test_enable_load              // test1.c:8410:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 796 /* .xProc */)) = test_extended_result_codes    // test1.c:8411:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 808 /* .xProc */)) = test_limit                    // test1.c:8412:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 820 /* .xProc */)) = test_dbconfig_maindbname_icecube // test1.c:8413:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 832 /* .xProc */)) = save_prng_state               // test1.c:8415:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 844 /* .xProc */)) = restore_prng_state            // test1.c:8416:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 856 /* .xProc */)) = reset_prng_state              // test1.c:8417:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 868 /* .xProc */)) = prng_seed                     // test1.c:8418:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 880 /* .xProc */)) = extra_schema_checks           // test1.c:8419:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 892 /* .xProc */)) = database_never_corrupt        // test1.c:8420:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 904 /* .xProc */)) = database_may_be_corrupt       // test1.c:8421:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 916 /* .xProc */)) = optimization_control             // test1.c:8422:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 928 /* .xProc */)) = runAsObjProc                     // test1.c:8431:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 940 /* .xProc */)) = test_column_count                // test1.c:8434:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 952 /* .xProc */)) = test_data_count                  // test1.c:8435:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 964 /* .xProc */)) = test_column_type                 // test1.c:8436:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 976 /* .xProc */)) = test_column_blob                 // test1.c:8437:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 988 /* .xProc */)) = test_column_double               // test1.c:8438:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1000 /* .xProc */)) = test_column_int64               // test1.c:8439:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1012 /* .xProc */)) = test_stmt_utf8                  // test1.c:8440:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1016 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_text})) // test1.c:8440:50:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1024 /* .xProc */)) = test_stmt_utf8 // test1.c:8441:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1028 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_name})) // test1.c:8441:50:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1036 /* .xProc */)) = test_stmt_int // test1.c:8442:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1040 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_int})) // test1.c:8442:50:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1048 /* .xProc */)) = test_stmt_int // test1.c:8443:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1052 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_bytes})) // test1.c:8443:50:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1060 /* .xProc */)) = test_stmt_utf8 // test1.c:8445:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1064 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_decltype})) // test1.c:8445:49:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1072 /* .xProc */)) = test_stmt_utf8 // test1.c:8448:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1076 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_database_name})) // test1.c:8448:49:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1084 /* .xProc */)) = test_stmt_utf8 // test1.c:8449:31:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1088 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_table_name})) // test1.c:8449:46:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1096 /* .xProc */)) = test_stmt_utf8 // test1.c:8450:32:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1100 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_origin_name})) // test1.c:8450:47:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1108 /* .xProc */)) = test_stmt_int // test1.c:8454:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1112 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_bytes16})) // test1.c:8454:49:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1120 /* .xProc */)) = test_stmt_utf16 // test1.c:8455:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1124 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_text16})) // test1.c:8455:51:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1132 /* .xProc */)) = test_stmt_utf16 // test1.c:8456:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1136 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_name16})) // test1.c:8456:51:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1144 /* .xProc */)) = add_alignment_test_collations // test1.c:8457:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1156 /* .xProc */)) = test_stmt_utf16               // test1.c:8459:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1160 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_decltype16})) // test1.c:8459:52:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1168 /* .xProc */)) = test_stmt_utf16 // test1.c:8463:3:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1172 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_database_name16})) // test1.c:8463:20:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1180 /* .xProc */)) = test_stmt_utf16 // test1.c:8464:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1184 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_table_name16})) // test1.c:8464:50:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1192 /* .xProc */)) = test_stmt_utf16 // test1.c:8465:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1196 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_origin_name16})) // test1.c:8465:51:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1204 /* .xProc */)) = test_create_collation_v2         // test1.c:8468:39:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1216 /* .xProc */)) = test_global_recover                 // test1.c:8469:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1228 /* .xProc */)) = working_64bit_int                // test1.c:8470:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1240 /* .xProc */)) = vfs_unlink_test                  // test1.c:8471:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1252 /* .xProc */)) = vfs_initfail_test                // test1.c:8472:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1264 /* .xProc */)) = vfs_unregister_all               // test1.c:8473:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1276 /* .xProc */)) = vfs_reregister_all               // test1.c:8474:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1288 /* .xProc */)) = file_control_test                // test1.c:8475:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1300 /* .xProc */)) = file_control_lasterrno_test      // test1.c:8476:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1312 /* .xProc */)) = file_control_lockproxy_test      // test1.c:8477:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1324 /* .xProc */)) = file_control_chunksize_test      // test1.c:8478:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1336 /* .xProc */)) = file_control_sizehint_test       // test1.c:8479:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1348 /* .xProc */)) = file_control_data_version        // test1.c:8480:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1360 /* .xProc */)) = file_control_persist_wal         // test1.c:8486:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1372 /* .xProc */)) = file_control_powersafe_overwrite // test1.c:8487:43:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1384 /* .xProc */)) = file_control_vfsname             // test1.c:8488:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1396 /* .xProc */)) = file_control_reservebytes        // test1.c:8489:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1408 /* .xProc */)) = file_control_tempfilename        // test1.c:8490:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1420 /* .xProc */)) = file_control_external_reader     // test1.c:8491:42:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1432 /* .xProc */)) = vfs_list                         // test1.c:8492:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1444 /* .xProc */)) = test_create_function_v2          // test1.c:8493:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1456 /* .xProc */)) = test_collate                        // test1.c:8497:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1468 /* .xProc */)) = test_collate_needed                 // test1.c:8498:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1480 /* .xProc */)) = test_function                       // test1.c:8499:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1492 /* .xProc */)) = test_utf16bin_collate               // test1.c:8500:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1504 /* .xProc */)) = test_errstr                         // test1.c:8502:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1516 /* .xProc */)) = tcl_variable_type                   // test1.c:8503:35:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1528 /* .xProc */)) = test_enable_shared               // test1.c:8505:39:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1540 /* .xProc */)) = sqlite3BtreeSharedCacheReport       // test1.c:8506:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1552 /* .xProc */)) = test_libversion_number           // test1.c:8508:37:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1564 /* .xProc */)) = test_table_column_metadata       // test1.c:8509:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1576 /* .xProc */)) = test_blob_reopen                 // test1.c:8511:31:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1588 /* .xProc */)) = test_pcache_stats                // test1.c:8513:30:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1600 /* .xProc */)) = test_unlock_notify               // test1.c:8515:33:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1612 /* .xProc */)) = test_wal_checkpoint              // test1.c:8517:36:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1624 /* .xProc */)) = test_wal_checkpoint_v2           // test1.c:8518:36:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1636 /* .xProc */)) = test_wal_autocheckpoint          // test1.c:8519:37:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1648 /* .xProc */)) = test_sqlite3_log                 // test1.c:8520:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1660 /* .xProc */)) = test_print_eqp                      // test1.c:8522:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1672 /* .xProc */)) = test_test_control                   // test1.c:8524:32:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1684 /* .xProc */)) = test_getrusage                      // test1.c:8526:21:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1696 /* .xProc */)) = tclLoadStaticExtensionCmd           // test1.c:8528:33:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1708 /* .xProc */)) = sorter_test_fakeheap                // test1.c:8529:32:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1720 /* .xProc */)) = sorter_test_sort4_helper            // test1.c:8530:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1732 /* .xProc */)) = vfsCurrentTimeInt64                 // test1.c:8544:44:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1744 /* .xProc */)) = test_snapshot_get                   // test1.c:8546:32:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1756 /* .xProc */)) = test_snapshot_open                  // test1.c:8547:33:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1768 /* .xProc */)) = test_snapshot_free                  // test1.c:8548:33:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1780 /* .xProc */)) = test_snapshot_cmp                   // test1.c:8549:32:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1792 /* .xProc */)) = test_snapshot_recover               // test1.c:8550:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1804 /* .xProc */)) = test_snapshot_get_blob              // test1.c:8551:37:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1816 /* .xProc */)) = test_snapshot_open_blob             // test1.c:8552:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1828 /* .xProc */)) = test_snapshot_cmp_blob              // test1.c:8553:37:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1840 /* .xProc */)) = test_delete_database                // test1.c:8555:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1852 /* .xProc */)) = test_atomic_batch_write             // test1.c:8556:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1864 /* .xProc */)) = test_mmap_warm                      // test1.c:8557:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1876 /* .xProc */)) = test_config_sorterref               // test1.c:8558:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1888 /* .xProc */)) = test_decode_hexdb                   // test1.c:8559:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1900 /* .xProc */)) = test_write_db                       // test1.c:8560:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1912 /* .xProc */)) = test_register_cksumvfs              // test1.c:8561:37:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1924 /* .xProc */)) = test_unregister_cksumvfs            // test1.c:8562:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd10)) + 4 /* .xProc */)) = test_intarray_create               // test_intarray.c:381:35:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd10)) + 16 /* .xProc */)) = test_intarray_bind                // test_intarray.c:382:33:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 4 /* .xProc */)) = test_malloc                           // test_malloc.c:1473:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 16 /* .xProc */)) = test_realloc                         // test_malloc.c:1474:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 28 /* .xProc */)) = test_free                            // test_malloc.c:1475:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 40 /* .xProc */)) = test_memset                          // test_malloc.c:1476:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 52 /* .xProc */)) = test_memget                          // test_malloc.c:1477:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 64 /* .xProc */)) = test_memory_used                     // test_malloc.c:1478:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 76 /* .xProc */)) = test_memory_highwater                // test_malloc.c:1479:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 88 /* .xProc */)) = test_memdebug_backtrace              // test_malloc.c:1480:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 100 /* .xProc */)) = test_memdebug_dump                  // test_malloc.c:1481:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 112 /* .xProc */)) = test_memdebug_fail                  // test_malloc.c:1482:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 124 /* .xProc */)) = test_memdebug_pending               // test_malloc.c:1483:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 136 /* .xProc */)) = test_memdebug_settitle              // test_malloc.c:1484:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 148 /* .xProc */)) = test_memdebug_malloc_count          // test_malloc.c:1485:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 160 /* .xProc */)) = test_memdebug_log                   // test_malloc.c:1486:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 172 /* .xProc */)) = test_config_pagecache               // test_malloc.c:1487:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 184 /* .xProc */)) = test_alt_pcache                     // test_malloc.c:1488:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 196 /* .xProc */)) = test_status                         // test_malloc.c:1489:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 208 /* .xProc */)) = test_db_status                      // test_malloc.c:1490:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 220 /* .xProc */)) = test_install_malloc_faultsim        // test_malloc.c:1491:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 232 /* .xProc */)) = test_config_heap                    // test_malloc.c:1492:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 244 /* .xProc */)) = test_config_heap_size               // test_malloc.c:1493:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 256 /* .xProc */)) = test_config_memstatus               // test_malloc.c:1494:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 268 /* .xProc */)) = test_config_lookaside               // test_malloc.c:1495:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 280 /* .xProc */)) = test_config_error                   // test_malloc.c:1496:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 292 /* .xProc */)) = test_config_uri                     // test_malloc.c:1497:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 304 /* .xProc */)) = test_config_cis                     // test_malloc.c:1498:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 316 /* .xProc */)) = test_config_pmasz                   // test_malloc.c:1499:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 328 /* .xProc */)) = test_db_config_lookaside            // test_malloc.c:1500:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 340 /* .xProc */)) = test_dump_memsys3                   // test_malloc.c:1501:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 352 /* .xProc */)) = test_dump_memsys3                   // test_malloc.c:1502:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 364 /* .xProc */)) = test_install_memsys3                // test_malloc.c:1503:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 376 /* .xProc */)) = test_vfs_oom_test                   // test_malloc.c:1504:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd12)) + 4 /* .xProc */)) = register_schema_module             // test_schema.c:336:34:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd13)) + 4 /* .xProc */)) = register_tclvar_module             // test_tclvar.c:553:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 4 /* .xProc */)) = test_create_window                    // test_window.c:337:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 16 /* .xProc */)) = test_create_window_misuse            // test_window.c:338:46:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 28 /* .xProc */)) = test_create_sumint                   // test_window.c:339:30:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 40 /* .xProc */)) = test_override_sum                    // test_window.c:340:29:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd2)) + 4 /* .xProc */)) = register_echo_module                // test8.c:1440:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd2)) + 16 /* .xProc */)) = declare_vtab                       // test8.c:1441:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 4 /* .xProc */)) = c_misuse_test                       // test9.c:194:28:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 16 /* .xProc */)) = c_realloc_test                     // test9.c:195:28:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 28 /* .xProc */)) = c_collation_test                   // test9.c:196:28:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd4)) + 4 /* .xProc */)) = register_tcl_module                 // test_bestindex.c:611:33:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 4 /* .xProc */)) = test_blob_open                      // test_blob.c:318:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 12 /* .xProc */)) = test_blob_close                    // test_blob.c:319:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 20 /* .xProc */)) = test_blob_bytes                    // test_blob.c:320:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 28 /* .xProc */)) = test_blob_read                     // test_blob.c:321:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 36 /* .xProc */)) = test_blob_write                    // test_blob.c:322:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd6)) + 4 /* .xProc */)) = register_fs_module                  // test_fs.c:908:32:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 4 /* .xProc */)) = autoinstall_test_funcs                 // test_func.c:938:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 12 /* .xProc */)) = abuse_create_function                 // test_func.c:939:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 20 /* .xProc */)) = install_fts3_rank_function            // test_func.c:940:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 4 /* .xProc */)) = hexio_read                             // test_hexio.c:451:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 12 /* .xProc */)) = hexio_write                           // test_hexio.c:452:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 20 /* .xProc */)) = hexio_get_int                         // test_hexio.c:453:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 28 /* .xProc */)) = hexio_render_int16                    // test_hexio.c:454:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 36 /* .xProc */)) = hexio_render_int32                    // test_hexio.c:455:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 44 /* .xProc */)) = utf8_to_utf8                          // test_hexio.c:456:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 52 /* .xProc */)) = read_fts3varint                       // test_hexio.c:457:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 60 /* .xProc */)) = make_fts3record                       // test_hexio.c:458:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 4 /* .xProc */)) = init_wrapper_install                // test_init.c:283:32:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 12 /* .xProc */)) = init_wrapper_query                 // test_init.c:284:32:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 20 /* .xProc */)) = init_wrapper_uninstall             // test_init.c:285:32:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 28 /* .xProc */)) = init_wrapper_clear                 // test_init.c:286:32:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 4 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32) int32
	}{ts_open})) // test_syscall.c:134:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 24 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) int32 }{ts_close})) // test_syscall.c:135:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 44 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{ts_access})) // test_syscall.c:136:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 64 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, size_t) uintptr
	}{ts_getcwd})) // test_syscall.c:137:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 84 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{ts_stat})) // test_syscall.c:138:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 104 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr) int32
	}{ts_fstat})) // test_syscall.c:139:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 124 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, off_t) int32
	}{ts_ftruncate})) // test_syscall.c:140:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 144 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, int32, uintptr) int32
	}{ts_fcntl})) // test_syscall.c:141:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 164 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t) int32
	}{ts_read})) // test_syscall.c:142:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 184 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, off_t) int32
	}{ts_pread})) // test_syscall.c:143:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 204 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) int32
	}{ts_pread64})) // test_syscall.c:144:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 224 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t) int32
	}{ts_write})) // test_syscall.c:145:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 244 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, off_t) int32
	}{ts_pwrite})) // test_syscall.c:146:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 264 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) int32
	}{ts_pwrite64})) // test_syscall.c:147:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 284 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, mode_t) int32
	}{ts_fchmod})) // test_syscall.c:148:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 304 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, off_t, off_t) int32
	}{ts_fallocate})) // test_syscall.c:149:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 324 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, size_t, int32, int32, int32, off_t) uintptr
	}{ts_mmap})) // test_syscall.c:150:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 344 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, size_t, size_t, int32, uintptr) uintptr
	}{ts_mremap})) // test_syscall.c:151:27:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 4 /* .xCreate */)) = amatchConnect            // amatch.c:1456:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 8 /* .xConnect */)) = amatchConnect           // amatch.c:1457:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 12 /* .xBestIndex */)) = amatchBestIndex                                        // amatch.c:1458:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 16 /* .xDisconnect */)) = amatchDisconnect                                               // amatch.c:1459:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 20 /* .xDestroy */)) = amatchDisconnect                                                  // amatch.c:1460:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 24 /* .xOpen */)) = amatchOpen                                                  // amatch.c:1461:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 28 /* .xClose */)) = amatchClose                                                         // amatch.c:1462:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 32 /* .xFilter */)) = amatchFilter                       // amatch.c:1463:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 36 /* .xNext */)) = amatchNext                                                           // amatch.c:1464:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 40 /* .xEof */)) = amatchEof                                                             // amatch.c:1465:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 44 /* .xColumn */)) = amatchColumn                                       // amatch.c:1466:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 48 /* .xRowid */)) = amatchRowid                                                // amatch.c:1467:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 52 /* .xUpdate */)) = amatchUpdate                              // amatch.c:1468:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 4 /* .xClose */)) = apndClose                                                         // appendvfs.c:204:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 8 /* .xRead */)) = apndRead                            // appendvfs.c:205:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 12 /* .xWrite */)) = apndWrite                         // appendvfs.c:206:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 16 /* .xTruncate */)) = apndTruncate                                   // appendvfs.c:207:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 20 /* .xSync */)) = apndSync                                                   // appendvfs.c:208:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 24 /* .xFileSize */)) = apndFileSize                                         // appendvfs.c:209:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 28 /* .xLock */)) = apndLock                                                   // appendvfs.c:210:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 32 /* .xUnlock */)) = apndUnlock                                               // appendvfs.c:211:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 36 /* .xCheckReservedLock */)) = apndCheckReservedLock                       // appendvfs.c:212:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 40 /* .xFileControl */)) = apndFileControl                            // appendvfs.c:213:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 44 /* .xSectorSize */)) = apndSectorSize                                              // appendvfs.c:214:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 48 /* .xDeviceCharacteristics */)) = apndDeviceCharacteristics                        // appendvfs.c:215:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 52 /* .xShmMap */)) = apndShmMap                        // appendvfs.c:216:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 56 /* .xShmLock */)) = apndShmLock                               // appendvfs.c:217:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 60 /* .xShmBarrier */)) = apndShmBarrier                                                    // appendvfs.c:218:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 64 /* .xShmUnmap */)) = apndShmUnmap                                           // appendvfs.c:219:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 68 /* .xFetch */)) = apndFetch                         // appendvfs.c:220:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 72 /* .xUnfetch */)) = apndUnfetch                            // appendvfs.c:221:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 24 /* .xOpen */)) = apndOpen                               // appendvfs.c:184:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 28 /* .xDelete */)) = apndDelete                                             // appendvfs.c:185:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 32 /* .xAccess */)) = apndAccess                                    // appendvfs.c:186:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 36 /* .xFullPathname */)) = apndFullPathname                        // appendvfs.c:187:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 40 /* .xDlOpen */)) = apndDlOpen                                                  // appendvfs.c:188:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 44 /* .xDlError */)) = apndDlError                                                 // appendvfs.c:189:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 48 /* .xDlSym */)) = apndDlSym                                           // appendvfs.c:190:3:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 52 /* .xDlClose */)) = apndDlClose                                                        // appendvfs.c:191:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 56 /* .xRandomness */)) = apndRandomness                                     // appendvfs.c:192:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 60 /* .xSleep */)) = apndSleep                                                        // appendvfs.c:193:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 64 /* .xCurrentTime */)) = apndCurrentTime                                          // appendvfs.c:194:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 68 /* .xGetLastError */)) = apndGetLastError                                 // appendvfs.c:195:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 72 /* .xCurrentTimeInt64 */)) = apndCurrentTimeInt64                                // appendvfs.c:196:3:
	*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 76 /* .xSetSystemCall */)) = apndSetSystemCall                 // appendvfs.c:197:3:
	*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 80 /* .xGetSystemCall */)) = apndGetSystemCall                        // appendvfs.c:198:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 84 /* .xNextSystemCall */)) = apndNextSystemCall                                  // appendvfs.c:199:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 8 /* .xConnect */)) = carrayConnect           // carray.c:368:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 12 /* .xBestIndex */)) = carrayBestIndex                                        // carray.c:369:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 16 /* .xDisconnect */)) = carrayDisconnect                                               // carray.c:370:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 24 /* .xOpen */)) = carrayOpen                                                  // carray.c:372:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 28 /* .xClose */)) = carrayClose                                                         // carray.c:373:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 32 /* .xFilter */)) = carrayFilter                       // carray.c:374:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 36 /* .xNext */)) = carrayNext                                                           // carray.c:375:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 40 /* .xEof */)) = carrayEof                                                             // carray.c:376:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 44 /* .xColumn */)) = carrayColumn                                       // carray.c:377:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 48 /* .xRowid */)) = carrayRowid                                                // carray.c:378:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 4 /* .xClose */)) = cksmClose                                                         // cksumvfs.c:274:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 8 /* .xRead */)) = cksmRead                            // cksumvfs.c:275:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 12 /* .xWrite */)) = cksmWrite                         // cksumvfs.c:276:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 16 /* .xTruncate */)) = cksmTruncate                                   // cksumvfs.c:277:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 20 /* .xSync */)) = cksmSync                                                   // cksumvfs.c:278:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 24 /* .xFileSize */)) = cksmFileSize                                         // cksumvfs.c:279:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 28 /* .xLock */)) = cksmLock                                                   // cksumvfs.c:280:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 32 /* .xUnlock */)) = cksmUnlock                                               // cksumvfs.c:281:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 36 /* .xCheckReservedLock */)) = cksmCheckReservedLock                       // cksumvfs.c:282:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 40 /* .xFileControl */)) = cksmFileControl                            // cksumvfs.c:283:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 44 /* .xSectorSize */)) = cksmSectorSize                                              // cksumvfs.c:284:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 48 /* .xDeviceCharacteristics */)) = cksmDeviceCharacteristics                        // cksumvfs.c:285:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 52 /* .xShmMap */)) = cksmShmMap                        // cksumvfs.c:286:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 56 /* .xShmLock */)) = cksmShmLock                               // cksumvfs.c:287:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 60 /* .xShmBarrier */)) = cksmShmBarrier                                                    // cksumvfs.c:288:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 64 /* .xShmUnmap */)) = cksmShmUnmap                                           // cksumvfs.c:289:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 68 /* .xFetch */)) = cksmFetch                         // cksumvfs.c:290:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 72 /* .xUnfetch */)) = cksmUnfetch                            // cksumvfs.c:291:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 24 /* .xOpen */)) = cksmOpen                               // cksumvfs.c:254:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 28 /* .xDelete */)) = cksmDelete                                             // cksumvfs.c:255:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 32 /* .xAccess */)) = cksmAccess                                    // cksumvfs.c:256:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 36 /* .xFullPathname */)) = cksmFullPathname                        // cksumvfs.c:257:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 40 /* .xDlOpen */)) = cksmDlOpen                                                  // cksumvfs.c:258:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 44 /* .xDlError */)) = cksmDlError                                                 // cksumvfs.c:259:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 48 /* .xDlSym */)) = cksmDlSym                                           // cksumvfs.c:260:3:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 52 /* .xDlClose */)) = cksmDlClose                                                        // cksumvfs.c:261:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 56 /* .xRandomness */)) = cksmRandomness                                     // cksumvfs.c:262:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 60 /* .xSleep */)) = cksmSleep                                                        // cksumvfs.c:263:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 64 /* .xCurrentTime */)) = cksmCurrentTime                                          // cksumvfs.c:264:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 68 /* .xGetLastError */)) = cksmGetLastError                                 // cksumvfs.c:265:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 72 /* .xCurrentTimeInt64 */)) = cksmCurrentTimeInt64                                // cksumvfs.c:266:3:
	*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 76 /* .xSetSystemCall */)) = cksmSetSystemCall                 // cksumvfs.c:267:3:
	*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 80 /* .xGetSystemCall */)) = cksmGetSystemCall                        // cksumvfs.c:268:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 84 /* .xNextSystemCall */)) = cksmNextSystemCall                                  // cksumvfs.c:269:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 4 /* .xCreate */)) = closureConnect          // closure.c:920:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 8 /* .xConnect */)) = closureConnect         // closure.c:921:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 12 /* .xBestIndex */)) = closureBestIndex                                      // closure.c:922:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 16 /* .xDisconnect */)) = closureDisconnect                                             // closure.c:923:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 20 /* .xDestroy */)) = closureDisconnect                                                // closure.c:924:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 24 /* .xOpen */)) = closureOpen                                                // closure.c:925:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 28 /* .xClose */)) = closureClose                                                       // closure.c:926:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 32 /* .xFilter */)) = closureFilter                     // closure.c:927:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 36 /* .xNext */)) = closureNext                                                         // closure.c:928:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 40 /* .xEof */)) = closureEof                                                           // closure.c:929:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 44 /* .xColumn */)) = closureColumn                                     // closure.c:930:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 48 /* .xRowid */)) = closureRowid                                              // closure.c:931:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 24 /* .xOpen */)) = cfOpen                                 // test6.c:857:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 28 /* .xDelete */)) = cfDelete                                               // test6.c:858:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 32 /* .xAccess */)) = cfAccess                                      // test6.c:859:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 36 /* .xFullPathname */)) = cfFullPathname                          // test6.c:860:5:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 40 /* .xDlOpen */)) = cfDlOpen                                                    // test6.c:861:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 44 /* .xDlError */)) = cfDlError                                                   // test6.c:862:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 48 /* .xDlSym */)) = cfDlSym                                             // test6.c:863:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 52 /* .xDlClose */)) = cfDlClose                                                          // test6.c:864:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 56 /* .xRandomness */)) = cfRandomness                                       // test6.c:865:5:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 60 /* .xSleep */)) = cfSleep                                                          // test6.c:866:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 64 /* .xCurrentTime */)) = cfCurrentTime                                            // test6.c:867:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 68 /* .xGetLastError */)) = cfGetLastError                                   // test6.c:868:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 4 /* .xClose */)) = devsymClose                                                     // test_devsym.c:229:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 8 /* .xRead */)) = devsymRead                         // test_devsym.c:230:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 12 /* .xWrite */)) = devsymWrite                      // test_devsym.c:231:3:
	*(*func(*libc.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 16 /* .xTruncate */)) = devsymTruncate                                // test_devsym.c:232:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 20 /* .xSync */)) = devsymSync                                               // test_devsym.c:233:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 24 /* .xFileSize */)) = devsymFileSize                                     // test_devsym.c:234:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 28 /* .xLock */)) = devsymLock                                               // test_devsym.c:235:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 32 /* .xUnlock */)) = devsymUnlock                                           // test_devsym.c:236:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 36 /* .xCheckReservedLock */)) = devsymCheckReservedLock                   // test_devsym.c:237:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 40 /* .xFileControl */)) = devsymFileControl                        // test_devsym.c:238:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 44 /* .xSectorSize */)) = devsymSectorSize                                          // test_devsym.c:239:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 48 /* .xDeviceCharacteristics */)) = devsymDeviceCharacteristics                    // test_devsym.c:240:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 52 /* .xShmMap */)) = devsymShmMap                    // test_devsym.c:241:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 56 /* .xShmLock */)) = devsymShmLock                           // test_devsym.c:242:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 60 /* .xShmBarrier */)) = devsymShmBarrier                                                // test_devsym.c:243:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 64 /* .xShmUnmap */)) = devsymShmUnmap                                       // test_devsym.c:244:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 24 /* .xOpen */)) = devsymOpen                           // test_devsym.c:428:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 28 /* .xDelete */)) = devsymDelete                                         // test_devsym.c:429:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 32 /* .xAccess */)) = devsymAccess                                // test_devsym.c:430:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 36 /* .xFullPathname */)) = devsymFullPathname                    // test_devsym.c:431:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 56 /* .xRandomness */)) = devsymRandomness                                 // test_devsym.c:443:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 60 /* .xSleep */)) = devsymSleep                                                    // test_devsym.c:444:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 64 /* .xCurrentTime */)) = devsymCurrentTime                                      // test_devsym.c:445:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 4 /* .xCreate */)) = echoCreate                 // test8.c:1302:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 8 /* .xConnect */)) = echoConnect               // test8.c:1303:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 12 /* .xBestIndex */)) = echoBestIndex                                            // test8.c:1304:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 16 /* .xDisconnect */)) = echoDisconnect                                                   // test8.c:1305:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 20 /* .xDestroy */)) = echoDestroy                                                         // test8.c:1306:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 24 /* .xOpen */)) = echoOpen                                                      // test8.c:1307:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 28 /* .xClose */)) = echoClose                                                             // test8.c:1308:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 32 /* .xFilter */)) = echoFilter                           // test8.c:1309:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 36 /* .xNext */)) = echoNext                                                               // test8.c:1310:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 40 /* .xEof */)) = echoEof                                                                 // test8.c:1311:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 44 /* .xColumn */)) = echoColumn                                           // test8.c:1312:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 48 /* .xRowid */)) = echoRowid                                                    // test8.c:1313:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 52 /* .xUpdate */)) = echoUpdate                                  // test8.c:1314:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 56 /* .xBegin */)) = echoBegin                                                             // test8.c:1315:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 60 /* .xSync */)) = echoSync                                                               // test8.c:1316:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 64 /* .xCommit */)) = echoCommit                                                           // test8.c:1317:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 68 /* .xRollback */)) = echoRollback                                                       // test8.c:1318:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 72 /* .xFindFunction */)) = echoFindFunction             // test8.c:1319:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 76 /* .xRename */)) = echoRename                                                  // test8.c:1320:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 4 /* .xCreate */)) = echoCreate               // test8.c:1325:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 8 /* .xConnect */)) = echoConnect             // test8.c:1326:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 12 /* .xBestIndex */)) = echoBestIndex                                          // test8.c:1327:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 16 /* .xDisconnect */)) = echoDisconnect                                                 // test8.c:1328:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 20 /* .xDestroy */)) = echoDestroy                                                       // test8.c:1329:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 24 /* .xOpen */)) = echoOpen                                                    // test8.c:1330:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 28 /* .xClose */)) = echoClose                                                           // test8.c:1331:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 32 /* .xFilter */)) = echoFilter                         // test8.c:1332:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 36 /* .xNext */)) = echoNext                                                             // test8.c:1333:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 40 /* .xEof */)) = echoEof                                                               // test8.c:1334:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 44 /* .xColumn */)) = echoColumn                                         // test8.c:1335:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 48 /* .xRowid */)) = echoRowid                                                  // test8.c:1336:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 52 /* .xUpdate */)) = echoUpdate                                // test8.c:1337:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 56 /* .xBegin */)) = echoBegin                                                           // test8.c:1338:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 60 /* .xSync */)) = echoSync                                                             // test8.c:1339:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 64 /* .xCommit */)) = echoCommit                                                         // test8.c:1340:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 68 /* .xRollback */)) = echoRollback                                                     // test8.c:1341:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 72 /* .xFindFunction */)) = echoFindFunction           // test8.c:1342:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 76 /* .xRename */)) = echoRename                                                // test8.c:1343:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 80 /* .xSavepoint */)) = echoSavepoint                                            // test8.c:1344:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 84 /* .xRelease */)) = echoRelease                                                // test8.c:1345:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 88 /* .xRollbackTo */)) = echoRollbackTo                                          // test8.c:1346:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 4 /* .xCreate */)) = expertConnect            // sqlite3expert.c:625:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 8 /* .xConnect */)) = expertConnect           // sqlite3expert.c:626:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 12 /* .xBestIndex */)) = expertBestIndex                                        // sqlite3expert.c:627:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 16 /* .xDisconnect */)) = expertDisconnect                                               // sqlite3expert.c:628:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 20 /* .xDestroy */)) = expertDisconnect                                                  // sqlite3expert.c:629:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 24 /* .xOpen */)) = expertOpen                                                  // sqlite3expert.c:630:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 28 /* .xClose */)) = expertClose                                                         // sqlite3expert.c:631:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 32 /* .xFilter */)) = expertFilter                       // sqlite3expert.c:632:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 36 /* .xNext */)) = expertNext                                                           // sqlite3expert.c:633:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 40 /* .xEof */)) = expertEof                                                             // sqlite3expert.c:634:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 44 /* .xColumn */)) = expertColumn                                       // sqlite3expert.c:635:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 48 /* .xRowid */)) = expertRowid                                                // sqlite3expert.c:636:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 52 /* .xUpdate */)) = expertUpdate                              // sqlite3expert.c:637:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 8 /* .xConnect */)) = explainConnect         // explain.c:274:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 12 /* .xBestIndex */)) = explainBestIndex                                      // explain.c:275:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 16 /* .xDisconnect */)) = explainDisconnect                                             // explain.c:276:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 24 /* .xOpen */)) = explainOpen                                                // explain.c:278:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 28 /* .xClose */)) = explainClose                                                       // explain.c:279:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 32 /* .xFilter */)) = explainFilter                     // explain.c:280:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 36 /* .xNext */)) = explainNext                                                         // explain.c:281:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 40 /* .xEof */)) = explainEof                                                           // explain.c:282:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 44 /* .xColumn */)) = explainColumn                                     // explain.c:283:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 48 /* .xRowid */)) = explainRowid                                              // explain.c:284:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 4 /* .xCreate */)) = fsConnect                    // test_fs.c:800:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 8 /* .xConnect */)) = fsConnect                   // test_fs.c:801:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 12 /* .xBestIndex */)) = fsBestIndex                                                // test_fs.c:802:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 16 /* .xDisconnect */)) = fsDisconnect                                                       // test_fs.c:803:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 20 /* .xDestroy */)) = fsDisconnect                                                          // test_fs.c:804:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 24 /* .xOpen */)) = fsOpen                                                          // test_fs.c:805:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 28 /* .xClose */)) = fsClose                                                                 // test_fs.c:806:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 32 /* .xFilter */)) = fsFilter                               // test_fs.c:807:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 36 /* .xNext */)) = fsNext                                                                   // test_fs.c:808:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 40 /* .xEof */)) = fsEof                                                                     // test_fs.c:809:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 44 /* .xColumn */)) = fsColumn                                               // test_fs.c:810:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 48 /* .xRowid */)) = fsRowid                                                        // test_fs.c:811:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 4 /* .xClose */)) = fsClose1                                                            // test_onefile.c:210:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 8 /* .xRead */)) = fsRead                                // test_onefile.c:211:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 12 /* .xWrite */)) = fsWrite                             // test_onefile.c:212:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 16 /* .xTruncate */)) = fsTruncate                                       // test_onefile.c:213:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 20 /* .xSync */)) = fsSync                                                       // test_onefile.c:214:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 24 /* .xFileSize */)) = fsFileSize                                             // test_onefile.c:215:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 28 /* .xLock */)) = fsLock                                                       // test_onefile.c:216:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 32 /* .xUnlock */)) = fsUnlock                                                   // test_onefile.c:217:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 36 /* .xCheckReservedLock */)) = fsCheckReservedLock                           // test_onefile.c:218:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 40 /* .xFileControl */)) = fsFileControl                                // test_onefile.c:219:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 44 /* .xSectorSize */)) = fsSectorSize                                                  // test_onefile.c:220:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 48 /* .xDeviceCharacteristics */)) = fsDeviceCharacteristics                            // test_onefile.c:221:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 24 /* .xOpen */)) = fsOpen1                                  // test_onefile.c:191:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 28 /* .xDelete */)) = fsDelete                                                 // test_onefile.c:192:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 32 /* .xAccess */)) = fsAccess                                        // test_onefile.c:193:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 36 /* .xFullPathname */)) = fsFullPathname                            // test_onefile.c:194:5:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 40 /* .xDlOpen */)) = fsDlOpen                                                      // test_onefile.c:195:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 44 /* .xDlError */)) = fsDlError                                                     // test_onefile.c:196:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 48 /* .xDlSym */)) = fsDlSym                                               // test_onefile.c:197:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 52 /* .xDlClose */)) = fsDlClose                                                            // test_onefile.c:198:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 56 /* .xRandomness */)) = fsRandomness                                         // test_onefile.c:199:5:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 60 /* .xSleep */)) = fsSleep                                                            // test_onefile.c:200:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 64 /* .xCurrentTime */)) = fsCurrentTime                                              // test_onefile.c:201:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 4 /* .xCreate */)) = fsdirConnect1             // test_fs.c:823:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 8 /* .xConnect */)) = fsdirConnect1            // test_fs.c:824:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 12 /* .xBestIndex */)) = fsdirBestIndex1                                         // test_fs.c:825:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 16 /* .xDisconnect */)) = fsdirDisconnect1                                                // test_fs.c:826:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 20 /* .xDestroy */)) = fsdirDisconnect1                                                   // test_fs.c:827:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 24 /* .xOpen */)) = fsdirOpen1                                                   // test_fs.c:828:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 28 /* .xClose */)) = fsdirClose1                                                          // test_fs.c:829:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 32 /* .xFilter */)) = fsdirFilter1                        // test_fs.c:830:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 36 /* .xNext */)) = fsdirNext1                                                            // test_fs.c:831:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 40 /* .xEof */)) = fsdirEof1                                                              // test_fs.c:832:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 44 /* .xColumn */)) = fsdirColumn1                                        // test_fs.c:833:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 48 /* .xRowid */)) = fsdirRowid1                                                 // test_fs.c:834:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 8 /* .xConnect */)) = fsdirConnect            // fileio.c:942:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 12 /* .xBestIndex */)) = fsdirBestIndex                                         // fileio.c:943:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 16 /* .xDisconnect */)) = fsdirDisconnect                                                // fileio.c:944:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 24 /* .xOpen */)) = fsdirOpen                                                   // fileio.c:946:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 28 /* .xClose */)) = fsdirClose                                                          // fileio.c:947:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 32 /* .xFilter */)) = fsdirFilter                        // fileio.c:948:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 36 /* .xNext */)) = fsdirNext                                                            // fileio.c:949:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 40 /* .xEof */)) = fsdirEof                                                              // fileio.c:950:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 44 /* .xColumn */)) = fsdirColumn                                        // fileio.c:951:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 48 /* .xRowid */)) = fsdirRowid                                                 // fileio.c:952:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 4 /* .xCreate */)) = fstreeConnect            // test_fs.c:846:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 8 /* .xConnect */)) = fstreeConnect           // test_fs.c:847:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 12 /* .xBestIndex */)) = fstreeBestIndex                                        // test_fs.c:848:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 16 /* .xDisconnect */)) = fstreeDisconnect                                               // test_fs.c:849:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 20 /* .xDestroy */)) = fstreeDisconnect                                                  // test_fs.c:850:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 24 /* .xOpen */)) = fstreeOpen                                                  // test_fs.c:851:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 28 /* .xClose */)) = fstreeClose                                                         // test_fs.c:852:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 32 /* .xFilter */)) = fstreeFilter                       // test_fs.c:853:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 36 /* .xNext */)) = fstreeNext                                                           // test_fs.c:854:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 40 /* .xEof */)) = fstreeEof                                                             // test_fs.c:855:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 44 /* .xColumn */)) = fstreeColumn                                       // test_fs.c:856:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 48 /* .xRowid */)) = fstreeRowid                                                // test_fs.c:857:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 4 /* .xCreate */)) = fts5tokConnectMethod   // fts5_test_tok.c:453:6:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 8 /* .xConnect */)) = fts5tokConnectMethod  // fts5_test_tok.c:454:6:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 12 /* .xBestIndex */)) = fts5tokBestIndexMethod                               // fts5_test_tok.c:455:6:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 16 /* .xDisconnect */)) = fts5tokDisconnectMethod                                      // fts5_test_tok.c:456:6:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 20 /* .xDestroy */)) = fts5tokDisconnectMethod                                         // fts5_test_tok.c:457:6:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 24 /* .xOpen */)) = fts5tokOpenMethod                                         // fts5_test_tok.c:458:6:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 28 /* .xClose */)) = fts5tokCloseMethod                                                // fts5_test_tok.c:459:6:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 32 /* .xFilter */)) = fts5tokFilterMethod              // fts5_test_tok.c:460:6:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 36 /* .xNext */)) = fts5tokNextMethod                                                  // fts5_test_tok.c:461:6:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 40 /* .xEof */)) = fts5tokEofMethod                                                    // fts5_test_tok.c:462:6:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 44 /* .xColumn */)) = fts5tokColumnMethod                              // fts5_test_tok.c:463:6:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 48 /* .xRowid */)) = fts5tokRowidMethod                                       // fts5_test_tok.c:464:6:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 4 /* .xCreate */)) = fuzzerConnect            // fuzzer.c:1149:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 8 /* .xConnect */)) = fuzzerConnect           // fuzzer.c:1150:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 12 /* .xBestIndex */)) = fuzzerBestIndex                                        // fuzzer.c:1151:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 16 /* .xDisconnect */)) = fuzzerDisconnect                                               // fuzzer.c:1152:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 20 /* .xDestroy */)) = fuzzerDisconnect                                                  // fuzzer.c:1153:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 24 /* .xOpen */)) = fuzzerOpen                                                  // fuzzer.c:1154:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 28 /* .xClose */)) = fuzzerClose                                                         // fuzzer.c:1155:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 32 /* .xFilter */)) = fuzzerFilter                       // fuzzer.c:1156:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 36 /* .xNext */)) = fuzzerNext                                                           // fuzzer.c:1157:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 40 /* .xEof */)) = fuzzerEof                                                             // fuzzer.c:1158:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 44 /* .xColumn */)) = fuzzerColumn                                       // fuzzer.c:1159:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 48 /* .xRowid */)) = fuzzerRowid                                                // fuzzer.c:1160:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 4 /* .xCreate */)) = intarrayCreate         // test_intarray.c:189:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 8 /* .xConnect */)) = intarrayCreate        // test_intarray.c:190:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 12 /* .xBestIndex */)) = intarrayBestIndex                                    // test_intarray.c:191:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 16 /* .xDisconnect */)) = intarrayDestroy                                              // test_intarray.c:192:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 20 /* .xDestroy */)) = intarrayDestroy                                                 // test_intarray.c:193:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 24 /* .xOpen */)) = intarrayOpen                                              // test_intarray.c:194:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 28 /* .xClose */)) = intarrayClose                                                     // test_intarray.c:195:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 32 /* .xFilter */)) = intarrayFilter                   // test_intarray.c:196:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 36 /* .xNext */)) = intarrayNext                                                       // test_intarray.c:197:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 40 /* .xEof */)) = intarrayEof                                                         // test_intarray.c:198:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 44 /* .xColumn */)) = intarrayColumn                                   // test_intarray.c:199:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 48 /* .xRowid */)) = intarrayRowid                                            // test_intarray.c:200:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 4 /* .xClose */)) = jtClose                                                             // test_journal.c:189:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 8 /* .xRead */)) = jtRead                                // test_journal.c:190:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 12 /* .xWrite */)) = jtWrite                             // test_journal.c:191:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 16 /* .xTruncate */)) = jtTruncate                                       // test_journal.c:192:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 20 /* .xSync */)) = jtSync                                                       // test_journal.c:193:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 24 /* .xFileSize */)) = jtFileSize                                             // test_journal.c:194:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 28 /* .xLock */)) = jtLock                                                       // test_journal.c:195:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 32 /* .xUnlock */)) = jtUnlock                                                   // test_journal.c:196:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 36 /* .xCheckReservedLock */)) = jtCheckReservedLock                           // test_journal.c:197:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 40 /* .xFileControl */)) = jtFileControl                                // test_journal.c:198:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 44 /* .xSectorSize */)) = jtSectorSize                                                  // test_journal.c:199:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 48 /* .xDeviceCharacteristics */)) = jtDeviceCharacteristics                            // test_journal.c:200:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 24 /* .xOpen */)) = jtOpen                                   // test_journal.c:172:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 28 /* .xDelete */)) = jtDelete                                                 // test_journal.c:173:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 32 /* .xAccess */)) = jtAccess                                        // test_journal.c:174:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 36 /* .xFullPathname */)) = jtFullPathname                            // test_journal.c:175:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 40 /* .xDlOpen */)) = jtDlOpen                                                      // test_journal.c:176:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 44 /* .xDlError */)) = jtDlError                                                     // test_journal.c:177:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 48 /* .xDlSym */)) = jtDlSym                                               // test_journal.c:178:3:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 52 /* .xDlClose */)) = jtDlClose                                                            // test_journal.c:179:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 56 /* .xRandomness */)) = jtRandomness                                         // test_journal.c:180:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 60 /* .xSleep */)) = jtSleep                                                            // test_journal.c:181:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 64 /* .xCurrentTime */)) = jtCurrentTime                                              // test_journal.c:182:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 68 /* .xGetLastError */)) = jtGetLastError                                     // test_journal.c:183:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 72 /* .xCurrentTimeInt64 */)) = jtCurrentTimeInt64                                    // test_journal.c:184:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 8 /* .xConnect */)) = prefixesConnect       // prefixes.c:230:21:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 12 /* .xBestIndex */)) = prefixesBestIndex                                    // prefixes.c:231:21:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 16 /* .xDisconnect */)) = prefixesDisconnect                                           // prefixes.c:232:21:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 24 /* .xOpen */)) = prefixesOpen                                              // prefixes.c:234:21:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 28 /* .xClose */)) = prefixesClose                                                     // prefixes.c:235:21:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 32 /* .xFilter */)) = prefixesFilter                   // prefixes.c:236:21:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 36 /* .xNext */)) = prefixesNext                                                       // prefixes.c:237:21:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 40 /* .xEof */)) = prefixesEof                                                         // prefixes.c:238:21:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 44 /* .xColumn */)) = prefixesColumn                                   // prefixes.c:239:21:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 48 /* .xRowid */)) = prefixesRowid                                            // prefixes.c:240:21:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&pzNeededCollation)) + 0)) = uintptr(unsafe.Pointer(&zNeededCollation))                                                           // test1.c:3130:34:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 4 /* .xCreate */)) = schemaCreate             // test_schema.c:276:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 8 /* .xConnect */)) = schemaCreate            // test_schema.c:277:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 12 /* .xBestIndex */)) = schemaBestIndex                                        // test_schema.c:278:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 16 /* .xDisconnect */)) = schemaDestroy                                                  // test_schema.c:279:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 20 /* .xDestroy */)) = schemaDestroy                                                     // test_schema.c:280:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 24 /* .xOpen */)) = schemaOpen                                                  // test_schema.c:281:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 28 /* .xClose */)) = schemaClose                                                         // test_schema.c:282:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 32 /* .xFilter */)) = schemaFilter                       // test_schema.c:283:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 36 /* .xNext */)) = schemaNext                                                           // test_schema.c:284:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 40 /* .xEof */)) = schemaEof                                                             // test_schema.c:285:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 44 /* .xColumn */)) = schemaColumn                                       // test_schema.c:286:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 48 /* .xRowid */)) = schemaRowid                                                // test_schema.c:287:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 8 /* .xConnect */)) = seriesConnect           // series.c:400:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 12 /* .xBestIndex */)) = seriesBestIndex                                        // series.c:401:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 16 /* .xDisconnect */)) = seriesDisconnect                                               // series.c:402:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 24 /* .xOpen */)) = seriesOpen                                                  // series.c:404:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 28 /* .xClose */)) = seriesClose                                                         // series.c:405:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 32 /* .xFilter */)) = seriesFilter                       // series.c:406:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 36 /* .xNext */)) = seriesNext                                                           // series.c:407:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 40 /* .xEof */)) = seriesEof                                                             // series.c:408:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 44 /* .xColumn */)) = seriesColumn                                       // series.c:409:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 48 /* .xRowid */)) = seriesRowid                                                // series.c:410:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 4 /* .xCreate */)) = spellfix1Create       // spellfix.c:2993:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 8 /* .xConnect */)) = spellfix1Connect     // spellfix.c:2994:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 12 /* .xBestIndex */)) = spellfix1BestIndex                                  // spellfix.c:2995:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 16 /* .xDisconnect */)) = spellfix1Disconnect                                         // spellfix.c:2996:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 20 /* .xDestroy */)) = spellfix1Destroy                                               // spellfix.c:2997:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 24 /* .xOpen */)) = spellfix1Open                                            // spellfix.c:2998:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 28 /* .xClose */)) = spellfix1Close                                                   // spellfix.c:2999:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 32 /* .xFilter */)) = spellfix1Filter                 // spellfix.c:3000:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 36 /* .xNext */)) = spellfix1Next                                                     // spellfix.c:3001:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 40 /* .xEof */)) = spellfix1Eof                                                       // spellfix.c:3002:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 44 /* .xColumn */)) = spellfix1Column                                 // spellfix.c:3003:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 48 /* .xRowid */)) = spellfix1Rowid                                          // spellfix.c:3004:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 52 /* .xUpdate */)) = spellfix1Update                        // spellfix.c:3005:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 76 /* .xRename */)) = spellfix1Rename                                        // spellfix.c:3011:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 4 /* .xCreate */)) = tclConnect                  // test_bestindex.c:551:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 8 /* .xConnect */)) = tclConnect                 // test_bestindex.c:552:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 12 /* .xBestIndex */)) = tclBestIndex                                              // test_bestindex.c:553:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 16 /* .xDisconnect */)) = tclDisconnect                                                     // test_bestindex.c:554:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 20 /* .xDestroy */)) = tclDisconnect                                                        // test_bestindex.c:555:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 24 /* .xOpen */)) = tclOpen                                                        // test_bestindex.c:556:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 28 /* .xClose */)) = tclClose                                                               // test_bestindex.c:557:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 32 /* .xFilter */)) = tclFilter                             // test_bestindex.c:558:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 36 /* .xNext */)) = tclNext                                                                 // test_bestindex.c:559:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 40 /* .xEof */)) = tclEof                                                                   // test_bestindex.c:560:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 44 /* .xColumn */)) = tclColumn                                             // test_bestindex.c:561:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 48 /* .xRowid */)) = tclRowid                                                      // test_bestindex.c:562:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 4 /* .xCreate */)) = tclvarConnect            // test_tclvar.c:471:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 8 /* .xConnect */)) = tclvarConnect           // test_tclvar.c:472:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 12 /* .xBestIndex */)) = tclvarBestIndex                                        // test_tclvar.c:473:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 16 /* .xDisconnect */)) = tclvarDisconnect                                               // test_tclvar.c:474:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 20 /* .xDestroy */)) = tclvarDisconnect                                                  // test_tclvar.c:475:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 24 /* .xOpen */)) = tclvarOpen                                                  // test_tclvar.c:476:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 28 /* .xClose */)) = tclvarClose                                                         // test_tclvar.c:477:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 32 /* .xFilter */)) = tclvarFilter                       // test_tclvar.c:478:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 36 /* .xNext */)) = tclvarNext                                                           // test_tclvar.c:479:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 40 /* .xEof */)) = tclvarEof                                                             // test_tclvar.c:480:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 44 /* .xColumn */)) = tclvarColumn                                       // test_tclvar.c:481:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 48 /* .xRowid */)) = tclvarRowid                                                // test_tclvar.c:482:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 52 /* .xUpdate */)) = tclvarUpdate                              // test_tclvar.c:483:3:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 4 /* .pArg */)) = uintptr(unsafe.Pointer(&testpcacheGlobal))                                                      // test_pcache.c:435:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 8 /* .xInit */)) = testpcacheInit                                                          // test_pcache.c:436:5:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 12 /* .xShutdown */)) = testpcacheShutdown                                                       // test_pcache.c:437:5:
	*(*func(*libc.TLS, int32, int32, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 16 /* .xCreate */)) = testpcacheCreate                                       // test_pcache.c:438:5:
	*(*func(*libc.TLS, uintptr, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 20 /* .xCachesize */)) = testpcacheCachesize                                              // test_pcache.c:439:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 24 /* .xPagecount */)) = testpcachePagecount                                               // test_pcache.c:440:5:
	*(*func(*libc.TLS, uintptr, uint32, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 28 /* .xFetch */)) = testpcacheFetch                                      // test_pcache.c:441:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 32 /* .xUnpin */)) = testpcacheUnpin                                             // test_pcache.c:442:5:
	*(*func(*libc.TLS, uintptr, uintptr, uint32, uint32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 36 /* .xRekey */)) = testpcacheRekey                                    // test_pcache.c:443:5:
	*(*func(*libc.TLS, uintptr, uint32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 40 /* .xTruncate */)) = testpcacheTruncate                                               // test_pcache.c:444:5:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 44 /* .xDestroy */)) = testpcacheDestroy                                                         // test_pcache.c:445:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 4 /* .xClose */)) = tmpClose                                                           // test_onefile.c:231:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 8 /* .xRead */)) = tmpRead                              // test_onefile.c:232:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 12 /* .xWrite */)) = tmpWrite                           // test_onefile.c:233:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 16 /* .xTruncate */)) = tmpTruncate                                     // test_onefile.c:234:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 20 /* .xSync */)) = tmpSync                                                     // test_onefile.c:235:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 24 /* .xFileSize */)) = tmpFileSize                                           // test_onefile.c:236:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 28 /* .xLock */)) = tmpLock                                                     // test_onefile.c:237:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 32 /* .xUnlock */)) = tmpUnlock                                                 // test_onefile.c:238:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 36 /* .xCheckReservedLock */)) = tmpCheckReservedLock                         // test_onefile.c:239:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 40 /* .xFileControl */)) = tmpFileControl                              // test_onefile.c:240:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 44 /* .xSectorSize */)) = tmpSectorSize                                                // test_onefile.c:241:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 48 /* .xDeviceCharacteristics */)) = tmpDeviceCharacteristics                          // test_onefile.c:242:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 4 /* .xClose */)) = tvfsClose                                                         // test_vfs.c:206:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 8 /* .xRead */)) = tvfsRead                            // test_vfs.c:207:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 12 /* .xWrite */)) = tvfsWrite                         // test_vfs.c:208:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 16 /* .xTruncate */)) = tvfsTruncate                                   // test_vfs.c:209:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 20 /* .xSync */)) = tvfsSync                                                   // test_vfs.c:210:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 24 /* .xFileSize */)) = tvfsFileSize                                         // test_vfs.c:211:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 28 /* .xLock */)) = tvfsLock                                                   // test_vfs.c:212:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 32 /* .xUnlock */)) = tvfsUnlock                                               // test_vfs.c:213:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 36 /* .xCheckReservedLock */)) = tvfsCheckReservedLock                       // test_vfs.c:214:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 40 /* .xFileControl */)) = tvfsFileControl                            // test_vfs.c:215:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 44 /* .xSectorSize */)) = tvfsSectorSize                                              // test_vfs.c:216:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 48 /* .xDeviceCharacteristics */)) = tvfsDeviceCharacteristics                        // test_vfs.c:217:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 52 /* .xShmMap */)) = tvfsShmMap                        // test_vfs.c:218:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 56 /* .xShmLock */)) = tvfsShmLock                               // test_vfs.c:219:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 60 /* .xShmBarrier */)) = tvfsShmBarrier                                                    // test_vfs.c:220:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 64 /* .xShmUnmap */)) = tvfsShmUnmap                                           // test_vfs.c:221:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 68 /* .xFetch */)) = tvfsFetch                         // test_vfs.c:222:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 72 /* .xUnfetch */)) = tvfsUnfetch                            // test_vfs.c:223:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 24 /* .xOpen */)) = tvfsOpen                               // test_vfs.c:1451:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 28 /* .xDelete */)) = tvfsDelete                                             // test_vfs.c:1452:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 32 /* .xAccess */)) = tvfsAccess                                    // test_vfs.c:1453:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 36 /* .xFullPathname */)) = tvfsFullPathname                        // test_vfs.c:1454:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 56 /* .xRandomness */)) = tvfsRandomness                                     // test_vfs.c:1466:5:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 60 /* .xSleep */)) = tvfsSleep                                                        // test_vfs.c:1467:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 64 /* .xCurrentTime */)) = tvfsCurrentTime                                          // test_vfs.c:1468:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 4 /* .xCreate */)) = unionConnect              // unionvtab.c:1332:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 8 /* .xConnect */)) = unionConnect             // unionvtab.c:1333:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 12 /* .xBestIndex */)) = unionBestIndex                                          // unionvtab.c:1334:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 16 /* .xDisconnect */)) = unionDisconnect                                                 // unionvtab.c:1335:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 20 /* .xDestroy */)) = unionDisconnect                                                    // unionvtab.c:1336:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 24 /* .xOpen */)) = unionOpen                                                    // unionvtab.c:1337:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 28 /* .xClose */)) = unionClose                                                           // unionvtab.c:1338:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 32 /* .xFilter */)) = unionFilter                         // unionvtab.c:1339:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 36 /* .xNext */)) = unionNext                                                             // unionvtab.c:1340:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 40 /* .xEof */)) = unionEof                                                               // unionvtab.c:1341:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 44 /* .xColumn */)) = unionColumn                                         // unionvtab.c:1342:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 48 /* .xRowid */)) = unionRowid                                                  // unionvtab.c:1343:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 4 /* .xClose */)) = vfslogClose                                                     // test_osinst.c:204:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 8 /* .xRead */)) = vfslogRead                        // test_osinst.c:205:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 12 /* .xWrite */)) = vfslogWrite                     // test_osinst.c:206:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 16 /* .xTruncate */)) = vfslogTruncate                               // test_osinst.c:207:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 20 /* .xSync */)) = vfslogSync                                               // test_osinst.c:208:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 24 /* .xFileSize */)) = vfslogFileSize                                     // test_osinst.c:209:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 28 /* .xLock */)) = vfslogLock                                               // test_osinst.c:210:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 32 /* .xUnlock */)) = vfslogUnlock                                           // test_osinst.c:211:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 36 /* .xCheckReservedLock */)) = vfslogCheckReservedLock                   // test_osinst.c:212:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 40 /* .xFileControl */)) = vfslogFileControl                        // test_osinst.c:213:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 44 /* .xSectorSize */)) = vfslogSectorSize                                          // test_osinst.c:214:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 48 /* .xDeviceCharacteristics */)) = vfslogDeviceCharacteristics                    // test_osinst.c:215:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 52 /* .xShmMap */)) = vfslogShmMap                    // test_osinst.c:216:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 56 /* .xShmLock */)) = vfslogShmLock                           // test_osinst.c:217:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 60 /* .xShmBarrier */)) = vfslogShmBarrier                                                // test_osinst.c:218:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 64 /* .xShmUnmap */)) = vfslogShmUnmap                                       // test_osinst.c:219:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 4 /* .xCreate */)) = vlogConnect             // test_osinst.c:1074:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 8 /* .xConnect */)) = vlogConnect            // test_osinst.c:1075:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 12 /* .xBestIndex */)) = vlogBestIndex                                         // test_osinst.c:1076:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 16 /* .xDisconnect */)) = vlogDisconnect                                                // test_osinst.c:1077:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 20 /* .xDestroy */)) = vlogDisconnect                                                   // test_osinst.c:1078:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 24 /* .xOpen */)) = vlogOpen                                                   // test_osinst.c:1079:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 28 /* .xClose */)) = vlogClose                                                          // test_osinst.c:1080:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 32 /* .xFilter */)) = vlogFilter                        // test_osinst.c:1081:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 36 /* .xNext */)) = vlogNext                                                            // test_osinst.c:1082:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 40 /* .xEof */)) = vlogEof                                                              // test_osinst.c:1083:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 44 /* .xColumn */)) = vlogColumn                                        // test_osinst.c:1084:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 48 /* .xRowid */)) = vlogRowid                                                 // test_osinst.c:1085:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 24 /* .xOpen */)) = vfslogOpen                           // test_osinst.c:187:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 28 /* .xDelete */)) = vfslogDelete                                         // test_osinst.c:188:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 32 /* .xAccess */)) = vfslogAccess                                // test_osinst.c:189:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 36 /* .xFullPathname */)) = vfslogFullPathname                    // test_osinst.c:190:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 40 /* .xDlOpen */)) = vfslogDlOpen                                              // test_osinst.c:191:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 44 /* .xDlError */)) = vfslogDlError                                             // test_osinst.c:192:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 48 /* .xDlSym */)) = vfslogDlSym                                       // test_osinst.c:193:3:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 52 /* .xDlClose */)) = vfslogDlClose                                                    // test_osinst.c:194:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 56 /* .xRandomness */)) = vfslogRandomness                                 // test_osinst.c:195:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 60 /* .xSleep */)) = vfslogSleep                                                    // test_osinst.c:196:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 64 /* .xCurrentTime */)) = vfslogCurrentTime                                      // test_osinst.c:197:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 68 /* .xGetLastError */)) = vfslogGetLastError                             // test_osinst.c:198:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 72 /* .xCurrentTimeInt64 */)) = vfslogCurrentTimeInt64                            // test_osinst.c:199:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 4 /* .xCreate */)) = wholenumberConnect  // wholenumber.c:238:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 8 /* .xConnect */)) = wholenumberConnect // wholenumber.c:239:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 12 /* .xBestIndex */)) = wholenumberBestIndex                              // wholenumber.c:240:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 16 /* .xDisconnect */)) = wholenumberDisconnect                                     // wholenumber.c:241:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 20 /* .xDestroy */)) = wholenumberDisconnect                                        // wholenumber.c:242:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 24 /* .xOpen */)) = wholenumberOpen                                        // wholenumber.c:243:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 28 /* .xClose */)) = wholenumberClose                                               // wholenumber.c:244:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 32 /* .xFilter */)) = wholenumberFilter             // wholenumber.c:245:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 36 /* .xNext */)) = wholenumberNext                                                 // wholenumber.c:246:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 40 /* .xEof */)) = wholenumberEof                                                   // wholenumber.c:247:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 44 /* .xColumn */)) = wholenumberColumn                             // wholenumber.c:248:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 48 /* .xRowid */)) = wholenumberRowid                                      // wholenumber.c:249:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 4 /* .xClose */)) = devsymClose                                                 // test_devsym.c:393:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 8 /* .xRead */)) = devsymRead                     // test_devsym.c:394:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 12 /* .xWrite */)) = writecrashWrite              // test_devsym.c:395:3:
	*(*func(*libc.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 16 /* .xTruncate */)) = devsymTruncate                            // test_devsym.c:396:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 20 /* .xSync */)) = devsymSync                                           // test_devsym.c:397:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 24 /* .xFileSize */)) = devsymFileSize                                 // test_devsym.c:398:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 28 /* .xLock */)) = devsymLock                                           // test_devsym.c:399:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 32 /* .xUnlock */)) = devsymUnlock                                       // test_devsym.c:400:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 36 /* .xCheckReservedLock */)) = devsymCheckReservedLock               // test_devsym.c:401:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 40 /* .xFileControl */)) = devsymFileControl                    // test_devsym.c:402:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 44 /* .xSectorSize */)) = writecrashSectorSize                                  // test_devsym.c:403:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 48 /* .xDeviceCharacteristics */)) = writecrashDeviceCharacteristics            // test_devsym.c:404:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 52 /* .xShmMap */)) = devsymShmMap                // test_devsym.c:405:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 56 /* .xShmLock */)) = devsymShmLock                       // test_devsym.c:406:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 60 /* .xShmBarrier */)) = devsymShmBarrier                                            // test_devsym.c:407:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 64 /* .xShmUnmap */)) = devsymShmUnmap                                   // test_devsym.c:408:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 24 /* .xOpen */)) = writecrashOpen                   // test_devsym.c:457:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 28 /* .xDelete */)) = devsymDelete                                     // test_devsym.c:458:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 32 /* .xAccess */)) = devsymAccess                            // test_devsym.c:459:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 36 /* .xFullPathname */)) = devsymFullPathname                // test_devsym.c:460:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 56 /* .xRandomness */)) = devsymRandomness                             // test_devsym.c:472:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 60 /* .xSleep */)) = devsymSleep                                                // test_devsym.c:473:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 64 /* .xCurrentTime */)) = devsymCurrentTime                                  // test_devsym.c:474:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 4 /* .xCreate */)) = zipfileConnect          // zipfile.c:2150:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 8 /* .xConnect */)) = zipfileConnect         // zipfile.c:2151:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 12 /* .xBestIndex */)) = zipfileBestIndex                                      // zipfile.c:2152:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 16 /* .xDisconnect */)) = zipfileDisconnect                                             // zipfile.c:2153:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 20 /* .xDestroy */)) = zipfileDisconnect                                                // zipfile.c:2154:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 24 /* .xOpen */)) = zipfileOpen                                                // zipfile.c:2155:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 28 /* .xClose */)) = zipfileClose                                                       // zipfile.c:2156:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 32 /* .xFilter */)) = zipfileFilter                     // zipfile.c:2157:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 36 /* .xNext */)) = zipfileNext                                                         // zipfile.c:2158:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 40 /* .xEof */)) = zipfileEof                                                           // zipfile.c:2159:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 44 /* .xColumn */)) = zipfileColumn                                     // zipfile.c:2160:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 52 /* .xUpdate */)) = zipfileUpdate                            // zipfile.c:2162:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 56 /* .xBegin */)) = zipfileBegin                                                       // zipfile.c:2163:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 64 /* .xCommit */)) = zipfileCommit                                                     // zipfile.c:2165:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 68 /* .xRollback */)) = zipfileRollback                                                 // zipfile.c:2166:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 72 /* .xFindFunction */)) = zipfileFindFunction       // zipfile.c:2167:5:
}

var ts1 = "%s\x00internal error!\x00SELECT * FROM main.%Q WHERE sample()\x00expert\x00PRAGMA table_xinfo=%Q\x00main\x00, \x00%Q\x00 COLLATE %Q\x00 COLLATE %s\x00 DESC\x00PRAGMA index_list=%Q\x00PRAGMA index_xInfo=%Q\x00%s_idx_%08x\x00CREATE INDEX '%q' ON %Q(%s)\x00CREATE INDEX %s ON %s(%s)\x00EXPLAIN QUERY PLAN %s\x00 USING INDEX \x00 USING COVERING INDEX \x00%s\n\x00%s;\n\x00SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_schema WHERE tbl_name = %Q AND type IN ('table', 'trigger') ORDER BY type;\x00ALTER TABLE temp.%Q RENAME TO %Q\x00INSERT INTO %Q VALUES(\x00%s?\x00\x00)\x00UPDATE %Q SET \x00%s%Q=?\x00DELETE FROM %Q\x00t592690916721053953805701627921227776\x00DROP TABLE t592690916721053953805701627921227776\x00SELECT type, name, sql, 1 FROM sqlite_schema WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%'  UNION ALL SELECT type, name, sql, 2 FROM sqlite_schema WHERE type = 'trigger'  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = 'view') ORDER BY 4, 1\x00CREATE TABLE x(\x00%s%Q COLLATE %s\x00CREATE VIRTUAL TABLE %Q USING expert(%Q)\x00SELECT max(i.seqno) FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l,   pragma_index_info(l.name) AS i WHERE s.type = 'table'\x00%sx.%Q IS rem(%d, x.%Q) COLLATE %s\x00%s%d\x00SELECT %s FROM %Q x ORDER BY %s\x00SELECT %s FROM temp.t592690916721053953805701627921227776 x ORDER BY %s\x00%d\x00 %d\x00DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\x00CREATE TABLE temp.t592690916721053953805701627921227776 AS SELECT * FROM %Q\x00SELECT s.rowid, s.name, l.name FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l WHERE s.type = 'table'\x00SELECT name, coll FROM pragma_index_xinfo(?) WHERE key\x00INSERT INTO sqlite_stat1 VALUES(?, ?, ?)\x00ANALYZE; PRAGMA writable_schema=1\x00rem\x00sample\x00ANALYZE sqlite_schema\x00:memory:\x00SELECT sql FROM sqlite_schema WHERE name NOT LIKE 'sqlite_%%' AND sql NOT LIKE 'CREATE VIRTUAL %%'\x00%s;%s%s\n\x00 -- stat1: \x00no such handle: \x00sql\x00TABLE\x00analyze\x00count\x00report\x00STMT EREPORT\x00destroy\x00SUBCOMMAND ...\x00sub-command\x00indexes\x00plan\x00candidates\x00DB\x00sqlite3expert%d\x00out of memory\x00sqlite3_expert_new\x00SQLITE_DONE\x00SQLITE_ERROR\x00SQLITE_OK\x00SELECT fts5(?1)\x00error: \x00fts5_api_ptr\x00f5t_2_%lld\x00xColumnCount\x00xRowCount\x00xColumnTotalSize\x00COL\x00xTokenize\x00TEXT SCRIPT\x00xPhraseCount\x00xPhraseSize\x00PHRASE\x00xInstCount\x00xInst\x00IDX\x00xRowid\x00xColumnText\x00xColumnSize\x00xQueryPhrase\x00PHRASE SCRIPT\x00xSetAuxdata\x00VALUE\x00xGetAuxdata\x00CLEAR\x00xSetAuxdataInt\x00INTEGER\x00xGetAuxdataInt\x00xPhraseForeach\x00IPHRASE COLVAR OFFVAR SCRIPT\x00xPhraseColumnForeach\x00IPHRASE COLVAR SCRIPT\x00SUB-COMMAND\x00f5t_%lld\x00bytearray\x00boolean\x00double\x00wideInt\x00int\x00DB NAME SCRIPT\x00?-subst? DB NAME TEXT\x00-subst\x00unrecognized option: \x00no such tokenizer: \x00error in tokenizer.xCreate()\x00error in tokenizer.xTokenize()\x00document\x00aux\x00query\x00prefixquery\x00invalid\x00-colocated\x00sqlite3_fts5_token may only be used by tokenizer callback\x00?-colocated? TEXT START END\x00error in fts5_api.xCreateTokenizer()\x00NSLOT TOKEN\x00sqlite3_fts5_create_tokenizer\x00sqlite3_fts5_token\x00sqlite3_fts5_tokenize\x00sqlite3_fts5_create_function\x00sqlite3_fts5_may_be_corrupt\x00sqlite3_fts5_token_hash\x00sqlite3_fts5_register_matchinfo\x00sqlite3_fts5_register_fts5tokenize\x00unrecognized matchinfo flag: %c\x00pcx\x00matchinfo\x00CREATE TABLE x(input HIDDEN, token, start, end, position)\x00fts5tokenize\x00apndvfs\x00Start-Of-SQLite3-\x00apnd(%lld)/%z\x00SQLite format 3\x00%s: cost must be between 1 and %d\x00%s: maximum string length is %d\x00%s: iLang must be between 0 and %d\x00?\x00SELECT * FROM %Q.%Q\x00%s: %s\x00%s: %s has %d columns, expected 4\x00vocabulary_table\x00vocabulary_word\x00vocabulary_language\x00edit_distances\x00unrecognized argument: [%s]\n\x00no edit_distances table specified\x00CREATE TABLE x(word,distance,language,command HIDDEN,nword HIDDEN)\x000123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz~\x00SELECT \"%w\" FROM \"%w\"\x00 WHERE \"%w\">=?1 AND \"%w\"=?2 ORDER BY 1\x00SELECT \"%w\" FROM \"%w\" WHERE \"%w\">=?1 ORDER BY 1\x00*\x00DELETE from %s is not allowed\x00UPDATE of %s is not allowed\x00INSERT INTO %s allowed for column [command] only\x00approximate_match\x00int32\x00int64\x00char*\x00CREATE TABLE x(value,pointer hidden,count hidden,ctype hidden)\x00carray-bind\x00carray\x00unknown datatype: %Q\x00inttoptr\x00cksmvfs\x00ZV-\x00checksum fault offset %lld of \"%s\"\x00checksum_verification\x00enable%\x00yes\x00on\x00page_size\x00cksm/%z\x00verify_checksum\x00tablename\x00idcolumn\x00parentcolumn\x00CREATE TABLE x(id,depth,root HIDDEN,tablename HIDDEN,idcolumn HIDDEN,parentcolumn HIDDEN)\x00SELECT \"%w\".\"%w\" FROM \"%w\" WHERE \"%w\".\"%w\"=?1\x00transitive_closure\x00rb\x00cannot open '%s' for reading\x00line %d: unescaped %c character\x00line %d: unterminated %c-quoted field\n\x00more than one '%s' parameter\x00true\x00no\x00off\x00false\x00header\x00more than one 'header' parameter\x00testflags\x00columns\x00more than one 'columns' parameter\x00column= value must be positive\x00bad parameter: '%s'\x00must specify either filename= or data= but not both\x00%sc%d TEXT\x00,\x00%s\"%w\" TEXT\x00bad schema: '%s' - %s\x00filename\x00data\x00schema\x00csv\x00csv_wr\x00decimal_sum\x00decimal\x00decimal_cmp\x00decimal_add\x00decimal_sub\x00decimal_mul\x00 \x00eval\x00CREATE TABLE x(addr,opcode,p1,p2,p3,p4,p5,comment,sql HIDDEN)\x00EXPLAIN %s\x00explain\x00wb\x00wrong number of arguments to function writefile()\x00failed to create symlink: %s\x00failed to create directory: %s\x00failed to write file: %s\x00CREATE TABLE x(name,mode,mtime,data,path HIDDEN,dir HIDDEN)\x00cannot read directory: %s\x00%s/%s\x00cannot stat file: %s\x00table function fsdir requires an argument\x00table function fsdir requires a non-NULL argument\x00fsdir\x00readfile\x00writefile\x00lsmode\x00%s: ruleset must be between 0 and %d\x00%s: wrong number of CREATE VIRTUAL TABLE arguments\x00CREATE TABLE x(word,distance,ruleset)\x00fuzzer\x00ieee754(%lld,%d)\x00ieee754\x00ieee754_mantissa\x00ieee754_exponent\x00ieee754_to_blob\x00ieee754_from_blob\x00BEGIN; SELECT * FROM %s%q%ssqlite_schema\x00'\x00'.\x00PRAGMA %s%q%spage_size\x00sqlite3_mmap_warm_cache: Warmed up %d pages of %s\x00END\x00AND (%s)\x00collate \"%w\"\x00SELECT %s FROM %s WHERE %s>=(?1 || ?2) %s   AND %s<=(?1 || char(1114111)) %s   %s ORDER BY 1 %s ASC LIMIT 1\x00next_char\x00NULL\x00is\x00not\x00in(\x00in(select\x00in(with\x00?,?,?\x002nd argument to percentile() is not a number between 0.0 and 100.0\x002nd argument to percentile() is not the same for all input rows\x001st argument to percentile() is not numeric\x00Inf input to percentile()\x00percentile\x00CREATE TABLE prefixes(prefix TEXT, original_string TEXT HIDDEN)\x00prefixes\x00prefix_length\x00unknown \\ escape\x00afnrtv\\()*.+?[$^{|}]\x00\a\f\n\r\t\v\x00unmatched '('\x00'*' without operand\x00'+' without operand\x00'?' without operand\x00'{m,n}' without operand\x00unmatched '{'\x00n less than m in '{m,n}'\x00both m and n are zero in '{m,n}'\x00POSIX character classes not supported\x00unclosed '['\x00unrecognized character\x00regexp\x00regexpi\x00remember\x00CREATE TABLE x(value,start hidden,stop hidden,step hidden)\x00generate_series() requires SQLite 3.8.12 or later\x00generate_series\x00.ABCDHLRMY9 ?\x00non-ASCII input to editdist()\x00NULL input to editdist()\x00SELECT iLang, cFrom, cTo, iCost FROM \"%w\" WHERE iLang>=0 ORDER BY iLang\x00editdist3\x00DROP TABLE IF EXISTS \"%w\".\"%w_vocab\"\x00CREATE TABLE x(word,rank,distance,langid, score, matchlen, phonehash HIDDEN, top HIDDEN, scope HIDDEN, srchcnt HIDDEN, soundslike HIDDEN, command HIDDEN)\x00CREATE TABLE IF NOT EXISTS \"%w\".\"%w_vocab\"(\n  id INTEGER PRIMARY KEY,\n  rank INT,\n  langid INT,\n  word TEXT,\n  k1 TEXT,\n  k2 TEXT\n);\n\x00CREATE INDEX IF NOT EXISTS \"%w\".\"%w_vocab_index_langid_k2\" ON \"%w_vocab\"(langid,k2);\x00edit_cost_table=\x00bad argument to spellfix1(): \"%s\"\x00SELECT id, word, rank, coalesce(k1,word)  FROM \"%w\".\"%w_vocab\" WHERE langid=%d AND k2>=?1 AND k2<?2\x00SELECT word, rank, NULL, langid, id FROM \"%w\".\"%w_vocab\"%s\x00 WHERE rowid=?\x00ROLLBACK\x00IGNORE\x00ABORT\x00REPLACE\x00DELETE FROM \"%w\".\"%w_vocab\"  WHERE id=%lld\x00NOT NULL constraint failed: %s.word\x00reset\x00null\x00unknown value for %s.command: \"%w\"\x00INSERT INTO \"%w\".\"%w_vocab\"(rank,langid,word,k1,k2) VALUES(%d,%d,%Q,nullif(%Q,%Q),%Q)\x00INSERT OR %s INTO \"%w\".\"%w_vocab\"(id,rank,langid,word,k1,k2) VALUES(%lld,%d,%d,%Q,nullif(%Q,%Q),%Q)\x00UPDATE OR %s \"%w\".\"%w_vocab\" SET id=%lld, rank=%d, langid=%d, word=%Q, k1=nullif(%Q,%Q), k2=%Q WHERE id=%lld\x00ALTER TABLE \"%w\".\"%w_vocab\" RENAME TO \"%w_vocab\"\x00spellfix1_translit\x00spellfix1_editdist\x00spellfix1_phonehash\x00spellfix1_scriptcode\x00spellfix1\x00922337203685477580\x00tointeger\x00toreal\x00sql error: %s\x00_rowid_\x00integer\x00no such rowid table: %s%s%s\x00.\x00SELECT group_concat(quote(name) || '.' || quote(type)) FROM pragma_table_info(?, ?)\x00source table schema mismatch\x00swarmvtab: no such SQL parameter: %s\x00maxopen\x00swarmvtab: illegal maxopen value\x00missing\x00swarmvtab: duplicate \"missing\" option\x00SELECT \"%w\"(?%s)\x00,?\x00openclose\x00swarmvtab: duplicate \"openclose\" option\x00SELECT \"%w\"(?,?%s)\x00swarmvtab: unrecognized option: %s\x00SELECT \"%w\"(?)\x00swarmvtab: parse error: %s\x00swarmvtab\x00unionvtab\x00temp\x00%s tables must be created in TEMP schema\x00wrong number of arguments for %s\x00SELECT * FROM (%z) ORDER BY 3\x00rowid range mismatch error\x00no source tables configured\x00SELECT 'CREATE TABLE xyz('    || group_concat(quote(name) || ' ' || type, ', ')    || ')',max((cid+1) * (type='INTEGER' COLLATE nocase AND pk=1))-1 FROM pragma_table_info(%Q, ?)\x00SELECT rowid, * FROM %Q %s %lld\x00WHERE _rowid_ <=\x00-- \x00%z%sSELECT rowid, * FROM %s%q%s%Q\x00 UNION ALL \x00%z WHERE rowid=%lld\x00WHERE\x00%z WHERE rowid>=%lld\x00AND\x00%z %s rowid<=%lld\x00CREATE TABLE x(value)\x00wholenumber\x00CREATE TABLE y(name PRIMARY KEY,mode,mtime,sz,rawdata,data,method,z HIDDEN) WITHOUT ROWID;\x00zipfile\x00zipfile constructor requires one argument\x00error in fread()\x00error in fwrite()\x00failed to read CDS at offset %lld\x00%.*s\x00failed to read LFH at offset %d\x001.2.11\x00inflateInit2() failed (%d)\x00inflate() failed (%d)\x00zipfile: deflate() error\x00cannot find end of central directory record\x00zipfile() function requires an argument\x00cannot open file: %s\x00-rwxrwxrwx\x00zipfile: mode does not match data\x00zipfile: parse error in mode: %s\x00zipfile: missing filename\x00ab+\x00zipfile: failed to open file %s for writing\x00sz must be NULL\x00rawdata must be NULL\x00unknown compression method: %d\x00%s/\x00duplicate name: \"%s\"\x00{\"version-made-by\" : %u, \"version-to-extract\" : %u, \"flags\" : %u, \"compression\" : %u, \"time\" : %u, \"date\" : %u, \"crc32\" : %u, \"compressed-size\" : %u, \"uncompressed-size\" : %u, \"file-name-length\" : %u, \"extra-field-length\" : %u, \"file-comment-length\" : %u, \"disk-number-start\" : %u, \"internal-attr\" : %u, \"external-attr\" : %u, \"offset\" : %u }\x00zipfile_cds\x00wrong number of arguments to function zipfile()\x00first argument to zipfile() must be non-NULL\x00illegal method value: %d\x00non-directory name must not end with /\x00rbu_delta\x00step\x00close\x00create_rbu_delta\x00savestate\x00dbMain_eval\x00SQL\x00bp_progress\x00db\x00RBU\x00state\x00progress\x00close_no_error\x00temp_size_limit\x00LIMIT\x00temp_size\x00dbRbu_eval\x00METHOD\x00method\x00 - \x00oal\x00move\x00checkpoint\x00done\x00error\x00NAME TARGET-DB RBU-DB ?STATE-DB?\x00NAME TARGET-DB ?STATE-DB?\x00?-default? NAME PARENT\x00NAME\x00sqlite3rbu_db(0, 0)!=0\x00sqlite3rbu\x00sqlite3rbu_vacuum\x00sqlite3rbu_create_vfs\x00sqlite3rbu_destroy_vfs\x00sqlite3rbu_internal_test\x00incrblob\x00incrblob_%d\x00%lld\x00sqlite_unlock_notify_arg\x00sqlite_unlock_notify_argcount\x00DELETE\x00INSERT\x00UPDATE\x00SQLITE_COPY\x00SQLITE_CREATE_INDEX\x00SQLITE_CREATE_TABLE\x00SQLITE_CREATE_TEMP_INDEX\x00SQLITE_CREATE_TEMP_TABLE\x00SQLITE_CREATE_TEMP_TRIGGER\x00SQLITE_CREATE_TEMP_VIEW\x00SQLITE_CREATE_TRIGGER\x00SQLITE_CREATE_VIEW\x00SQLITE_DELETE\x00SQLITE_DROP_INDEX\x00SQLITE_DROP_TABLE\x00SQLITE_DROP_TEMP_INDEX\x00SQLITE_DROP_TEMP_TABLE\x00SQLITE_DROP_TEMP_TRIGGER\x00SQLITE_DROP_TEMP_VIEW\x00SQLITE_DROP_TRIGGER\x00SQLITE_DROP_VIEW\x00SQLITE_INSERT\x00SQLITE_PRAGMA\x00SQLITE_READ\x00SQLITE_SELECT\x00SQLITE_TRANSACTION\x00SQLITE_UPDATE\x00SQLITE_ATTACH\x00SQLITE_DETACH\x00SQLITE_ALTER_TABLE\x00SQLITE_REINDEX\x00SQLITE_ANALYZE\x00SQLITE_CREATE_VTABLE\x00SQLITE_DROP_VTABLE\x00SQLITE_FUNCTION\x00SQLITE_SAVEPOINT\x00SQLITE_RECURSIVE\x00????\x00SQLITE_DENY\x00SQLITE_IGNORE\x00RELEASE _tcl_transaction\x00COMMIT\x00ROLLBACK TO _tcl_transaction ; RELEASE _tcl_transaction\x00option\x00?CALLBACK?\x00?DATABASE? FILENAME\x00cannot open target database: \x00backup failed: \x00CALLBACK\x00cache option ?arg?\x00flush\x00size\x00size n\x00cannot convert \"\x00\" to integer\x00bad option \"\x00\": must be flush or size\x00NAME SCRIPT\x00SCRIPT\x00?OPTION? ?BOOLEAN?\x00unknown config option: \"\x00\"\x00CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?\x00\t\x00Error: non-null separator required for copy\x00rollback\x00abort\x00fail\x00ignore\x00replace\x00Error: \"\x00\", conflict-algorithm must be one of: rollback, abort, fail, ignore, or replace\x00SELECT * FROM '%q'\x00Error: no such table: \x00Error: \x00Error: can't malloc()\x00INSERT OR %q INTO '%q' VALUES(?\x00Error: cannot open file: \x00BEGIN\x00Error: %s line %d: expected %d columns of data but found %d\x00, failed while processing line: \x00?DATABASE? VALUE\x00-maxsize\x00-readonly\x00unknown option: \x00unable to set MEMDB content\x00extension loading is turned off at compile-time\x00-withoutnulls\x00unknown option: \"\x00?OPTIONS? SQL ?ARRAY-NAME? ?SCRIPT?\x00NAME ?SWITCHES? SCRIPT\x00-argcount\x00option requires an argument: \x00number of arguments must be non-negative\x00-deterministic\x00-directonly\x00-innocuous\x00-returntype\x00real\x00text\x00blob\x00any\x00type\x00\": must be -argcount, -deterministic, -directonly, -innocuous, or -returntype\x00?-readonly? ?DB? TABLE COLUMN ROWID\x00NULLVALUE\x00N CALLBACK\x00KEY\x00cannot open source database: \x00restore failed: \x00restore failed: source database busy\x00?DATABASE?\x00(step|sort|autoindex)\x00sort\x00autoindex\x00vmstep\x00bad argument: should be autoindex, step, sort or vmstep\x00MILLISECONDS\x00?CALLBACK? ?MASK?\x00trace type\x00SAVEPOINT _tcl_transaction\x00[TYPE] SCRIPT\x00transaction type\x00BEGIN EXCLUSIVE\x00BEGIN IMMEDIATE\x00?SCRIPT?\x00SUB-COMMAND ?ARGS?\x00hook ?SCRIPT?\x00INDEX\x00-use-legacy-prepare\x00-last-stmt-ptr\x00%p\x00unknown argument: \x00authorizer\x00backup\x00bind_fallback\x00busy\x00cache\x00changes\x00collate\x00collation_needed\x00commit_hook\x00complete\x00config\x00copy\x00deserialize\x00enable_load_extension\x00errorcode\x00exists\x00function\x00interrupt\x00last_insert_rowid\x00nullvalue\x00onecolumn\x00preupdate\x00profile\x00rekey\x00restore\x00rollback_hook\x00serialize\x00status\x00timeout\x00total_changes\x00trace\x00trace_v2\x00transaction\x00unlock_notify\x00update_hook\x00version\x00wal_hook\x00defensive\x00dqs_ddl\x00dqs_dml\x00enable_fkey\x00enable_qpsg\x00enable_trigger\x00enable_view\x00fts3_tokenizer\x00legacy_alter_table\x00legacy_file_format\x00load_extension\x00no_ckpt_on_close\x00reset_database\x00trigger_eqp\x00trusted_schema\x00writable_schema\x00statement\x00row\x00deferred\x00exclusive\x00immediate\x00depth\x00hook\x00new\x00old\x00HANDLE ?FILENAME? ?-vfs VFSNAME? ?-readonly BOOLEAN? ?-create BOOLEAN? ?-nofollow BOOLEAN? ?-nomutex BOOLEAN? ?-fullmutex BOOLEAN? ?-uri BOOLEAN?\x00-version\x00-sourceid\x00-has-codec\x000\x00-key\x00-vfs\x00-create\x00-nofollow\x00-nomutex\x00-fullmutex\x00-uri\x00-translatefilename\x00sqlite3\x00sqlite\x003.36.0\x00if {[llength $argv]>=1} {\nset argv0 [lindex $argv 0]\nset argv [lrange $argv 1 end]\nsource $argv0\n} else {\nset line {}\nwhile {![eof stdin]} {\nif {$line!=\"\"} {\nputs -nonewline \"> \"\n} else {\nputs -nonewline \"% \"\n}\nflush stdout\nappend line [gets stdin]\nif {[info complete $line]} {\nif {[catch {uplevel #0 $line} result]} {\nputs stderr \"Error: $result\"\n} elseif {$result!=\"\"} {\nputs $result\n}\nset line {}\n} else {\nappend line \\n\n}\n}\n}\n\x00SQLITE_DEBUG_BREAK\x00attach debugger to process %d and press any key to continue.\n\x00utf-8\x00argc\x00argv0\x00argv\x00errorInfo\x00%s: %s\n\x00SQLITE-CONNECTION\x00command not found: \x00error code %s (%d) does not match sqlite3_errcode %s (%d)\x00OMIT_MISUSE\x00wrong # args: should be \"\x00 DB FORMAT STRING\x00 DB HEX\x00 DB\x00 DB SQL\x00%z%s%s\x00%s%n\x00abcdefghijklmnopqrstuvwxyz\x00 DB FORMAT STRING ?COUNT?\x00 DB\"\x00 FILENAME\"\x00%02x\x00%04x\x00tkt2213 is not fixed\x00text16\x00bytes\x00bytes16\x00noop\x00x_coalesce\x00hex8\x00hex16\x00tkt2213func\x00pointer_change\x00counter1\x00counter2\x00intreal\x00x_sqlite_exec\x00value of 40 handed to x_count\x00x_count totals to 42\x00x_count\x00legacy_count\x00 TEXT\"\x00 FORMAT INT INT INT\"\x00argument is not a valid 64-bit integer\x00 FORMAT INT INT ?STRING?\"\x00 INT FORMAT INT INT ?STRING?\"\x00N must be non-negative\x00 FORMAT INT INT DOUBLE\"\x00 FORMAT DOUBLE DOUBLE\"\x00 FORMAT STRING\"\x00%08x%08x\x002nd argument should be 16-characters of hex\x00?BOOLEAN?\x00DB BOOLEAN\x00DB dbname tblname colname\x00CHANNEL ROWID\x00DB-HANDLE NAME CMP-PROC DEL-PROC\x00sqlite3_create_collate_v2() failed to detect an invalid encoding\x00utf8\x00utf16\x00utf16le\x00utf16be\x00DB NAME NARG ENC SWITCHES...\x00encoding\x00-func\x00-step\x00-final\x00-destroy\x00switch\x00DB-HANDLE FILE ?PROC?\x00this build omits sqlite3_load_extension()\x00DB-HANDLE ONOFF\x00string\x00value\x00first argument should be one of: int int64 string double null value\x00 DB FUNCTION-NAME\x00 <STMT>\x00STMT PARAMETER RESETFLAG\x00SQLITE_STMTSTATUS_FULLSCAN_STEP\x00SQLITE_STMTSTATUS_SORT\x00SQLITE_STMTSTATUS_AUTOINDEX\x00SQLITE_STMTSTATUS_VM_STEP\x00SQLITE_STMTSTATUS_REPREPARE\x00SQLITE_STMTSTATUS_RUN\x00SQLITE_STMTSTATUS_MEMUSED\x00NBYTE\x00DB DBNAME\x00DB DBNAME SNAPSHOT\x00SNAPSHOT\x00SNAPSHOT1 SNAPSHOT2\x00bad SNAPSHOT\x00FILE\x00PATH\x00 DB STMT\x00 STMT\x00 FROM-STMT TO-STMT\x00 VM IDX VALUE (null|static|normal)\"\x00static\x00static-nbytes\x00normal\x00blob10\x00abc\x00xyz\x00pq\x004th argument should be \"null\" or \"static\" or \"normal\"\x00(%d) \x00test_collate\x00UTF-8\x00UTF-16LE\x00UTF-16BE\x00 <DB> <utf8> <utf16le> <utf16be>\x00utf16bin\x00utf16_unaligned\x00utf16_aligned\x00test_function\x00<error code>\x00STMT IDX N\x00 STMT N VALUE\x00NaN\x00SNaN\x00-NaN\x00-SNaN\x00+Inf\x00-Inf\x00Epsilon\x00-Epsilon\x00NaN0\x00-NaN0\x00 STMT N\x00 STMT N VALUE BYTES\x00 STMT N DATA BYTES\x00cannot use %d blob bytes, have %d\x00-transient\x00-static\x00-int32\x00-int64\x00-double\x00-text\x00--\x00text data must be either -static or -transient\x00cannot be both -static and -transient\x00[OPTIONS] STMT IDX VALUE ...\x00STMT\x00STMT N\x00STMT NAME\x00 DB sql bytes ?tailvar?\x00 DB sql bytes tailvar\x00 DB sql bytes flags tailvar\x00\x00SELECT 1\x00 filename options-list\x00FILENAME FLAGS VFS\x00SQLITE_OPEN_READONLY\x00SQLITE_OPEN_READWRITE\x00SQLITE_OPEN_CREATE\x00SQLITE_OPEN_DELETEONCLOSE\x00SQLITE_OPEN_EXCLUSIVE\x00SQLITE_OPEN_AUTOPROXY\x00SQLITE_OPEN_MAIN_DB\x00SQLITE_OPEN_TEMP_DB\x00SQLITE_OPEN_TRANSIENT_DB\x00SQLITE_OPEN_MAIN_JOURNAL\x00SQLITE_OPEN_TEMP_JOURNAL\x00SQLITE_OPEN_SUBJOURNAL\x00SQLITE_OPEN_SUPER_JOURNAL\x00SQLITE_OPEN_NOMUTEX\x00SQLITE_OPEN_FULLMUTEX\x00SQLITE_OPEN_SHAREDCACHE\x00SQLITE_OPEN_PRIVATECACHE\x00SQLITE_OPEN_WAL\x00SQLITE_OPEN_URI\x00flag\x00<utf-16 sql>\x00 STMT column\x00FLOAT\x00TEXT\x00BLOB\x00 DB MAGIC\x00SQLITE_MAGIC_OPEN\x00SQLITE_MAGIC_CLOSED\x00SQLITE_MAGIC_BUSY\x00SQLITE_MAGIC_ERROR\x00 DB function-name\x00VARIABLE\x00?N?\x001234567890000000\x00__one\x00__two\x00notadatabase\x00Unexpected non-zero errno: \x00DB [DBNAME]\x00%u\x00DB DBNAME SIZE\x00 DB PWD\x00 DB FLAG\x00%d %d\x00 DB ?AUXDB?\x00DB N\x00 DB ID VALUE\x00unknown limit type: \x00SQLITE_LIMIT_LENGTH\x00SQLITE_LIMIT_SQL_LENGTH\x00SQLITE_LIMIT_COLUMN\x00SQLITE_LIMIT_EXPR_DEPTH\x00SQLITE_LIMIT_COMPOUND_SELECT\x00SQLITE_LIMIT_VDBE_OP\x00SQLITE_LIMIT_FUNCTION_ARG\x00SQLITE_LIMIT_ATTACHED\x00SQLITE_LIMIT_LIKE_PATTERN_LENGTH\x00SQLITE_LIMIT_VARIABLE_NUMBER\x00SQLITE_LIMIT_TRIGGER_DEPTH\x00SQLITE_LIMIT_WORKER_THREADS\x00SQLITE_LIMIT_TOOSMALL\x00SQLITE_LIMIT_TOOBIG\x00SEED ?DB?\x00BOOLEAN\x00current\x00max\x00min\x00recyclable\x00DB ?NAME?\x00passive\x00full\x00restart\x00truncate\x00DB MODE ?NAME?\x00mode\x00DB VALUE\x00COMMAND ...\x00command has no objProc: \x00%d %d %d %s\n\x00SQLITE_TESTCTRL_LOCALTIME_FAULT\x00SQLITE_TESTCTRL_SORTER_MMAP\x00SQLITE_TESTCTRL_IMPOSTER\x00SQLITE_TESTCTRL_INTERNAL_FUNCTIONS\x00VERB ARGS...\x00VERB\x00ONOFF\x00DB LIMIT\x00DB dbName onOff tnum\x00ru_utime=%d.%06d ru_stime=%d.%06d ru_minflt=%d ru_majflt=%d\x00DB OPT BOOLEAN\x00unknown optimization - should be one of:\x00all\x00none\x00query-flattener\x00groupby-order\x00factor-constants\x00distinct-opt\x00cover-idx-scan\x00order-by-idx-join\x00transitive\x00omit-noop-join\x00stat4\x00skip-scan\x00push-down\x00DB NAME ...\x00no such extension: \x00initialization of \x00 failed: \x00amatch\x00appendvfs\x00closure\x00fileio\x00nextchar\x00series\x00spellfix\x00totype\x00BOOL\x00DB SQL1 NSTEP SQL2\x00data error: (a!=b)\x00checksum mismatch\x00sql error: \x00TYPE\x00Deliberate panic\x00DB SETTING [VALUE]\x00SQLITE_*\x00DBCONFIG_*\x00ENABLE_*\x00unknown sqlite3_db_config setting\x00FKEY\x00TRIGGER\x00FTS3_TOKENIZER\x00LOAD_EXTENSION\x00NO_CKPT_ON_CLOSE\x00QPSG\x00TRIGGER_EQP\x00RESET_DB\x00DEFENSIVE\x00WRITABLE_SCHEMA\x00LEGACY_ALTER_TABLE\x00DQS_DML\x00DQS_DDL\x00LEGACY_FILE_FORMAT\x00DB ?SCHEMA?\x00icecube\x00DB ?DBNAME?\x00DB OFFSET DATA\x00HEXDB\x00| size %d pagesize %d\x00bad 'pagesize' field\x00bad 'size' field\x00| page %d offset %d\x00| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\x00sqlite_search_count\x00sqlite_found_count\x00sqlite_sort_count\x00sqlite3_max_blobsize\x00sqlite_like_count\x00sqlite_interrupt_count\x00sqlite_open_file_count\x00sqlite_current_time\x00sqlite3_xferopt_count\x00sqlite3_pager_readdb_count\x00sqlite3_pager_writedb_count\x00sqlite3_pager_writej_count\x00unaligned_string_counter\x00sqlite_last_needed_collation\x00sqlite_query_plan\x00sqlite_opentemp_count\x00sqlite_static_bind_value\x00sqlite_static_bind_nbyte\x00sqlite_temp_directory\x00sqlite_data_directory\x00bitmask_size\x00longdouble_size\x00sqlite_sync_count\x00sqlite_fullsync_count\x00db_enter\x00db_leave\x00sqlite3_mprintf_int\x00sqlite3_mprintf_int64\x00sqlite3_mprintf_long\x00sqlite3_mprintf_str\x00sqlite3_snprintf_str\x00sqlite3_mprintf_stronly\x00sqlite3_mprintf_double\x00sqlite3_mprintf_scaled\x00sqlite3_mprintf_hexdouble\x00sqlite3_mprintf_z_test\x00sqlite3_mprintf_n_test\x00sqlite3_snprintf_int\x00sqlite3_last_insert_rowid\x00sqlite3_exec_printf\x00sqlite3_exec_hex\x00sqlite3_exec\x00sqlite3_exec_nr\x00sqlite3_get_table_printf\x00sqlite3_close\x00sqlite3_close_v2\x00sqlite3_create_function\x00sqlite3_create_aggregate\x00sqlite3_drop_modules\x00sqlite_register_test_function\x00sqlite_abort\x00sqlite_bind\x00breakpoint\x00sqlite3_key\x00sqlite3_rekey\x00sqlite_set_magic\x00sqlite3_interrupt\x00sqlite_delete_function\x00sqlite_delete_collation\x00sqlite3_get_autocommit\x00sqlite3_busy_timeout\x00printf\x00sqlite3IoTrace\x00clang_sanitize_address\x00sqlite3_db_config\x00sqlite3_txn_state\x00bad_behavior\x00register_dbstat_vtab\x00sqlite3_connection_pointer\x00intarray_addr\x00int64array_addr\x00doublearray_addr\x00textarray_addr\x00sqlite3_bind_int\x00sqlite3_bind_zeroblob\x00sqlite3_bind_zeroblob64\x00sqlite3_bind_int64\x00sqlite3_bind_double\x00sqlite3_bind_null\x00sqlite3_bind_text\x00sqlite3_bind_text16\x00sqlite3_bind_blob\x00sqlite3_carray_bind\x00sqlite3_bind_parameter_count\x00sqlite3_bind_parameter_name\x00sqlite3_bind_parameter_index\x00sqlite3_clear_bindings\x00sqlite3_sleep\x00sqlite3_errcode\x00sqlite3_extended_errcode\x00sqlite3_errmsg\x00sqlite3_errmsg16\x00sqlite3_open\x00sqlite3_open16\x00sqlite3_open_v2\x00sqlite3_complete16\x00sqlite3_normalize\x00sqlite3_prepare\x00sqlite3_prepare16\x00sqlite3_prepare_v2\x00sqlite3_prepare_v3\x00sqlite3_prepare_tkt3134\x00sqlite3_prepare16_v2\x00sqlite3_finalize\x00sqlite3_stmt_status\x00sqlite3_reset\x00sqlite3_expired\x00sqlite3_transfer_bindings\x00sqlite3_changes\x00sqlite3_step\x00sqlite3_sql\x00sqlite3_expanded_sql\x00sqlite3_next_stmt\x00sqlite3_stmt_readonly\x00sqlite3_stmt_isexplain\x00sqlite3_stmt_busy\x00uses_stmt_journal\x00sqlite3_release_memory\x00sqlite3_db_release_memory\x00sqlite3_db_cacheflush\x00sqlite3_system_errno\x00sqlite3_db_filename\x00sqlite3_db_readonly\x00sqlite3_soft_heap_limit\x00sqlite3_soft_heap_limit64\x00sqlite3_hard_heap_limit64\x00sqlite3_thread_cleanup\x00sqlite3_pager_refcounts\x00sqlite3_load_extension\x00sqlite3_enable_load_extension\x00sqlite3_extended_result_codes\x00sqlite3_limit\x00dbconfig_maindbname_icecube\x00save_prng_state\x00restore_prng_state\x00reset_prng_state\x00prng_seed\x00extra_schema_checks\x00database_never_corrupt\x00database_may_be_corrupt\x00optimization_control\x00tcl_objproc\x00sqlite3_column_count\x00sqlite3_data_count\x00sqlite3_column_type\x00sqlite3_column_blob\x00sqlite3_column_double\x00sqlite3_column_int64\x00sqlite3_column_text\x00sqlite3_column_name\x00sqlite3_column_int\x00sqlite3_column_bytes\x00sqlite3_column_decltype\x00sqlite3_column_database_name\x00sqlite3_column_table_name\x00sqlite3_column_origin_name\x00sqlite3_column_bytes16\x00sqlite3_column_text16\x00sqlite3_column_name16\x00add_alignment_test_collations\x00sqlite3_column_decltype16\x00sqlite3_column_database_name16\x00sqlite3_column_table_name16\x00sqlite3_column_origin_name16\x00sqlite3_create_collation_v2\x00sqlite3_global_recover\x00working_64bit_int\x00vfs_unlink_test\x00vfs_initfail_test\x00vfs_unregister_all\x00vfs_reregister_all\x00file_control_test\x00file_control_lasterrno_test\x00file_control_lockproxy_test\x00file_control_chunksize_test\x00file_control_sizehint_test\x00file_control_data_version\x00file_control_persist_wal\x00file_control_powersafe_overwrite\x00file_control_vfsname\x00file_control_reservebytes\x00file_control_tempfilename\x00file_control_external_reader\x00sqlite3_vfs_list\x00sqlite3_create_function_v2\x00add_test_collate\x00add_test_collate_needed\x00add_test_function\x00add_test_utf16bin_collate\x00sqlite3_test_errstr\x00tcl_variable_type\x00sqlite3_enable_shared_cache\x00sqlite3_shared_cache_report\x00sqlite3_libversion_number\x00sqlite3_table_column_metadata\x00sqlite3_blob_reopen\x00pcache_stats\x00sqlite3_unlock_notify\x00sqlite3_wal_checkpoint\x00sqlite3_wal_checkpoint_v2\x00sqlite3_wal_autocheckpoint\x00test_sqlite3_log\x00print_explain_query_plan\x00sqlite3_test_control\x00getrusage\x00load_static_extension\x00sorter_test_fakeheap\x00sorter_test_sort4_helper\x00vfs_current_time_int64\x00sqlite3_snapshot_get\x00sqlite3_snapshot_open\x00sqlite3_snapshot_free\x00sqlite3_snapshot_cmp\x00sqlite3_snapshot_recover\x00sqlite3_snapshot_get_blob\x00sqlite3_snapshot_open_blob\x00sqlite3_snapshot_cmp_blob\x00sqlite3_delete_database\x00atomic_batch_write\x00sqlite3_mmap_warm\x00sqlite3_config_sorterref\x00decode_hexdb\x00test_write_db\x00sqlite3_register_cksumvfs\x00sqlite3_unregister_cksumvfs\x00*** OBSOLETE VARIABLE ***\x00 FILENAME N-PAGE\"\x00 ID\"\x00ref\x00page\x00err\x00hit\x00miss\x00ovfl\x00 ID PGNO\"\x00 PAGE\"\x00 PAGE DATA\"\x00 N-MEGABYTES FILE\"\x00open failed: \x00Hello, World!\x00write failed: \x00 PENDING-BYTE\"\x00fault simulator script failed: [%s]\x00 SCRIPT\"\x00 SIZE PROGRAM\"\x00sqlite_io_error_pending\x00sqlite_io_error_persist\x00sqlite_io_error_hit\x00sqlite_io_error_hardhit\x00sqlite_diskfull_pending\x00sqlite_diskfull\x00sqlite_pending_byte\x00pager_open\x00pager_close\x00pager_commit\x00pager_rollback\x00pager_stmt_begin\x00pager_stmt_commit\x00pager_stmt_rollback\x00pager_stats\x00pager_pagecount\x00page_get\x00page_lookup\x00page_unref\x00page_read\x00page_write\x00page_number\x00pager_truncate\x00fake_big_file\x00sqlite3BitvecBuiltinTest\x00sqlite3_test_control_pending_byte\x00sqlite3_test_control_fault_install\x00 FILENAME NCACHE FLAGS\"\x00read\x00write\x00 ID TABLENUM WRITEABLE\"\x00 START MULTIPLIER COUNT INCREMENT\"\x00putVarint returned %d - should be between 1 and 9\x00putVarint returned %d and getVarint returned %d\x00Wrote 0x%016llx and got back 0x%016llx\x00putVarint returned %d and GetVarint32 returned %d\x00Wrote 0x%016llx and got back 0x%016llx from GetVarint32\x00 DB-HANDLE ?N?\"\x00No such db-handle: \"\x00 BT NCACHE\"\x00?-intkey? CSR KEY VALUE\x00btree_insert\x00btree_open\x00btree_close\x00btree_begin_transaction\x00btree_pager_stats\x00btree_cursor\x00btree_close_cursor\x00btree_next\x00btree_eof\x00btree_payload_size\x00btree_first\x00btree_varint_test\x00btree_from_db\x00btree_ismemdb\x00btree_set_cache_size\x00thread ID must be an upper case letter\x00 ID FILENAME\x00thread \x00 is already running\x00failed to create the thread\x00 ID\x00no such thread\x00 ID N\x00column number out of range\x00no database is open\x00 ID SQL\x00no virtual machine available\x00 IDL\x00 ID1 ID2\x00 ID DB\x00thread_create\x00thread_wait\x00thread_halt\x00thread_argc\x00thread_argv\x00thread_colname\x00thread_result\x00thread_error\x00thread_compile\x00thread_step\x00thread_finalize\x00thread_swap\x00thread_db_get\x00thread_db_put\x00thread_stmt_get\x00 <repeat-count> <do-calls>\x00hello world\x00UTF8\x00UTF16LE\x00UTF16BE\x00UTF16\x00No such encoding: \x00 <string/blob> <from enc> <to enc>\x00binarize\x00test_value_overhead\x00test_translate\x00translate_selftest\x00out of memory in the crash simulator\n\x00atomic\x00atomic512\x00atomic1k\x00atomic2k\x00atomic4k\x00atomic8k\x00atomic16k\x00atomic32k\x00atomic64k\x00sequential\x00safe_append\x00powersafe_overwrite\x00batch-atomic\x00-sectorsize\x00-characteristics\x00Bad option: \"\x00\" - must be \"-characteristics\" or \"-sectorsize\"\x00Option requires an argument: \"\x00no such flag\x00ENABLE ?DEFAULT?\x00crash\x00?OPTIONS? DELAY CRASHFILE\x00Filename is too long: \"\x00NWRITE\x00?-default? PARENT-VFS\x00-default\x00\": must be -default\x00Error in jt_register\x00sqlite3_crash_enable\x00sqlite3_crashparams\x00sqlite3_crash_now\x00sqlite3_simulate_device\x00sqlite3_crash_on_write\x00unregister_devsim\x00register_jt_vfs\x00unregister_jt_vfs\x00client_create\x00client_wait\x00client_halt\x00client_argc\x00client_argv\x00client_colname\x00client_result\x00client_error\x00client_compile\x00client_step\x00client_reset\x00client_finalize\x00client_swap\x00echo_module_fail(%s,%s)\x00echo-vtab-error: %s\x00SELECT * FROM %Q\x00PRAGMA index_list(%s)\x00PRAGMA index_info(%s)\x00echo_module\x00SELECT sql FROM sqlite_schema WHERE type = 'table' AND name = ?\x00%s%s\x00xCreate\x00CREATE TABLE %Q(logmsg)\x00xConnect\x00xDisconnect\x00xDestroy\x00DROP TABLE %Q\x00xOpen\x00xNext\x00xColumn\x00xFilter\x00, *\x00%z, %s\x00%z, NULL\x00echo_module_ignore_usable\x00xBestIndex\x00echo_module_cost\x00SELECT count(*) FROM %Q\x00SELECT rowid%z FROM %Q\x00rowid\x00=\x00<\x00>\x00<=\x00>=\x00LIKE\x00like\x00glob\x00 %s %s LIKE (SELECT '%%'||?||'%%')\x00 %s %s %s ?\x00DESC\x00ASC\x00 ORDER BY %s %s\x00xUpdate\x00 SET\x00UPDATE %Q\x00 SET rowid=?1 \x00%s %Q=?%d\x00 WHERE rowid=?%d\x00DELETE FROM %Q WHERE rowid = ?1\x00INSERT INTO %Q (\x00%s%Q\x00%s?%d\x00) VALUES(\x00echo(%s)\x00xBegin\x00echo_module_begin_fail\x00xSync\x00echo_module_sync_fail\x00xCommit\x00xRollback\x00::echo_glob_overload\x00xRename\x00ALTER TABLE %s RENAME TO %s%s\x00function_that_does_not_exist_0982ma98\x00echo\x00echo_v2\x00DB SQL\x00register_echo_module\x00sqlite3_declare_vtab\x00N/A\x00sqlite3_create_collation\x00Error testing function: \x00sqlite3_malloc\x00sqlite3_realloc\x00c_misuse_test\x00c_realloc_test\x00c_collation_test\x00sqlite3_reset_auto_extension\x00npage\x00finish\x00remaining\x00pagecount\x00CMDNAME DESTHANDLE DESTNAME SRCHANDLE SRCNAME\x00sqlite3_backup_init() failed\x00sqlite3_backup\x00wrong number of arguments\x00unexpected: %s\x00eq\x00gt\x00le\x00lt\x00ge\x00match\x00ne\x00isnot\x00isnotnull\x00isnull\x00op\x00column\x00usable\x00desc\x00cost\x00orderby\x00idxnum\x00idxstr\x00rows\x00use\x00omit\x00unexpected: %d\x00tcl\x00register_tcl_module\x00incrblob_\x00DB DATABASE TABLE COLUMN ROWID FLAGS VARNAME\x00HANDLE\x00CHANNEL OFFSET N\x00out of memory in testdata/sqlite-src-3360000/src/test_blob.c\x00HANDLE OFFSET DATA ?NDATA?\x00sqlite3_blob_open\x00sqlite3_blob_close\x00sqlite3_blob_bytes\x00sqlite3_blob_read\x00sqlite3_blob_write\x00sqlite_options\x00malloc_usable_size\x001\x00rowid32\x00casesensitivelike\x00configslower\x001.0\x00curdir\x00win32malloc\x00debug\x00default_ckptfullfsync\x00direct_read\x00dirsync\x00lfs\x00pagecache_overflow_stats\x00mmap\x00worker_threads\x008\x00memdebug\x008_3_names\x00cursorhints\x00hiddencolumns\x00mathlib\x00mem3\x00mem5\x00offset_sql_func\x00snapshot\x00mutex\x00mutex_noop\x00altertable\x00api_armor\x00atomicwrite\x00geopoly\x00json1\x00has_codec\x00like_match_blobs\x00attach\x00auth\x00autoinc\x00autoreset\x00autovacuum\x00default_autovacuum\x00between_opt\x00builtin_test\x00bloblit\x00cast\x00check\x00cte\x00columnmetadata\x00oversize_cell_check\x00compileoption_diags\x00compound\x00conflict\x00crashtest\x00datetime\x00decltype\x00deprecated\x00diskio\x00floatingpoint\x00foreignkey\x00fts1\x00fts2\x00fts3\x00fts5\x00fts3_unicode\x00fts4_deferred\x00gettable\x00icu\x00icu_collations\x00integrityck\x00legacyformat\x00like_opt\x00load_ext\x00localtime\x00lookaside\x00long_double\x00memorydb\x00memorymanage\x00mergesort\x00null_trim\x00or_opt\x00rbu\x00pager_pragmas\x00pragma\x00reindex\x00rtree\x00rtree_int_only\x00schema_pragmas\x00schema_version\x00session\x00stmtvtab\x00scanstatus\x00lock_proxy_pragmas\x00prefer_proxy_locking\x00shared_cache\x00subquery\x00tclvar\x00threadsafe\x00threadsafe1\x00threadsafe2\x00tempdb\x00trigger\x00truncate_opt\x00vacuum\x00view\x00vtab\x00wal\x00wsd\x00update_delete_limit\x00fast_secure_delete\x00secure_delete\x00userauth\x00multiplex_ext_overwrite\x00yytrackmaxstackdepth\x00sqllog\x00uri_00_error\x00normalize\x00windowfunc\x00SQLITE_MAX_LENGTH\x00SQLITE_MAX_COLUMN\x00SQLITE_MAX_SQL_LENGTH\x00SQLITE_MAX_EXPR_DEPTH\x00SQLITE_MAX_COMPOUND_SELECT\x00SQLITE_MAX_VDBE_OP\x00SQLITE_MAX_FUNCTION_ARG\x00SQLITE_MAX_VARIABLE_NUMBER\x00SQLITE_MAX_PAGE_SIZE\x00SQLITE_MAX_PAGE_COUNT\x00SQLITE_MAX_LIKE_PATTERN_LENGTH\x00SQLITE_MAX_TRIGGER_DEPTH\x00SQLITE_DEFAULT_CACHE_SIZE\x00SQLITE_DEFAULT_PAGE_SIZE\x00SQLITE_DEFAULT_FILE_FORMAT\x00SQLITE_DEFAULT_SYNCHRONOUS\x00SQLITE_DEFAULT_WAL_SYNCHRONOUS\x00SQLITE_MAX_ATTACHED\x00SQLITE_MAX_DEFAULT_PAGE_SIZE\x00SQLITE_MAX_WORKER_THREADS\x00TEMP_STORE\x00__GNUC__\x00%s-journal\x00%s-wal\x00%s-shm\x00%s%03d\x00%s-journal%03d\x00%s-wal%03d\x00devsym\x00writecrash\x00CREATE TABLE xyz(dir, name);\x00CREATE TABLE xyz(path, size, data);\x00WITH r(d) AS (  SELECT CASE WHEN dir=?2 THEN ?3 ELSE dir END || '/' || name     FROM fsdir WHERE dir=?1 AND name NOT LIKE '.%'  UNION ALL  SELECT dir || '/' || name FROM r, fsdir WHERE dir=d AND name NOT LIKE '.%') SELECT d FROM r;\x00/\x00CREATE TABLE x(path TEXT, data TEXT)\x00SELECT * FROM %Q.%Q WHERE rowid=?\x00fs\x00fstree\x00register_fs_module\x00abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-!,:*^+=_|?/<> \x00sqlite3_prepare_v2() error: %s\x000123456789abcdef\x00x'\x00test_agg_errmsg16\x00randstr\x00test_destructor\x00test_destructor16\x00hex_to_utf16be\x00hex_to_utf16le\x00hex_to_utf8\x00test_destructor_count\x00test_auxdata\x00test_error\x00test_eval\x00test_isolation\x00test_counter\x00real2hex\x00test_decode\x00test_extract\x00test_zeroblob\x00test_getsubtype\x00test_setsubtype\x00test_frombind\x00tx\x00funcxx_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789\x00nullx_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789\x00sqlite3_create_function abused test failed\x00invalid matchinfo blob passed to function rank()\x00wrong number of arguments to function rank()\x00rank\x00autoinstall_test_functions\x00abuse_create_function\x00install_fts3_rank_function\x000123456789ABCDEF\x00FILENAME OFFSET AMT\x00r\x00cannot open input file \x00FILENAME OFFSET HEXDATA\x00r+b\x00r+\x00cannot open output file \x00HEXDATA\x00[utf8_to_utf8] unavailable - SQLITE_DEBUG not defined\x00BLOB VARNAME\x00LIST\x00hexio_read\x00hexio_write\x00hexio_get_int\x00hexio_render_int16\x00hexio_render_int32\x00utf8_to_utf8\x00read_fts3varint\x00make_fts3record\x00mem\x00pcache\x00Unknown argument: \"\x00init_wrapper_install\x00init_wrapper_query\x00init_wrapper_uninstall\x00init_wrapper_clear\x00CREATE TABLE x(value INTEGER PRIMARY KEY)\x00CREATE VIRTUAL TABLE temp.%Q USING %Q\x00INTARRAY\x00SQLITE_NOMEM\x00sqlite3_intarray_create\x00sqlite3_intarray_bind\x00jt\x00-journal\x00NBYTES\x00PRIOR NBYTES\x00bad pointer: \x00PRIOR\x00ADDRESS SIZE HEX\x00size must be positive\x00no data\x00ADDRESS SIZE\x00?RESET?\x00DEPT\x00FILENAME\x00COUNTER ?OPTIONS?\x00-repeat\x00-benigncnt\x00TITLE\x00SUB-COMMAND ...\x00start\x00stop\x00dump\x00clear\x00sync\x00SIZE N\x00INSTALLFLAG DISCARDCHANCE PRNGSEEED HIGHSTRESS\x00discard-chance should be between 0 and 100\x00SIZE COUNT\x00BUFID SIZE COUNT\x00illegal arguments - see documentation\x00NBYTE NMINALLOC\x00[DB]\x00sqlite3_db_config(db, 99999) does not return SQLITE_ERROR\x00sqlite3_config(99999) does not return SQLITE_ERROR\x00PARAMETER RESETFLAG\x00SQLITE_STATUS_MEMORY_USED\x00SQLITE_STATUS_MALLOC_SIZE\x00SQLITE_STATUS_PAGECACHE_USED\x00SQLITE_STATUS_PAGECACHE_OVERFLOW\x00SQLITE_STATUS_PAGECACHE_SIZE\x00SQLITE_STATUS_SCRATCH_USED\x00SQLITE_STATUS_SCRATCH_OVERFLOW\x00SQLITE_STATUS_SCRATCH_SIZE\x00SQLITE_STATUS_PARSER_STACK\x00SQLITE_STATUS_MALLOC_COUNT\x00DB PARAMETER RESETFLAG\x00SQLITE_\x00DBSTATUS_\x00LOOKASIDE_USED\x00CACHE_USED\x00SCHEMA_USED\x00STMT_USED\x00LOOKASIDE_HIT\x00LOOKASIDE_MISS_SIZE\x00LOOKASIDE_MISS_FULL\x00CACHE_HIT\x00CACHE_MISS\x00CACHE_WRITE\x00DEFERRED_FKS\x00CACHE_USED_SHARED\x00CACHE_SPILL\x00?INTEGER?\x00sqlite3_free\x00memset\x00memget\x00sqlite3_memory_used\x00sqlite3_memory_highwater\x00sqlite3_memdebug_backtrace\x00sqlite3_memdebug_dump\x00sqlite3_memdebug_fail\x00sqlite3_memdebug_pending\x00sqlite3_memdebug_settitle\x00sqlite3_memdebug_malloc_count\x00sqlite3_memdebug_log\x00sqlite3_config_pagecache\x00sqlite3_config_alt_pcache\x00sqlite3_status\x00sqlite3_db_status\x00install_malloc_faultsim\x00sqlite3_config_heap\x00sqlite3_config_heap_size\x00sqlite3_config_memstatus\x00sqlite3_config_lookaside\x00sqlite3_config_error\x00sqlite3_config_uri\x00sqlite3_config_cis\x00sqlite3_config_pmasz\x00sqlite3_db_config_lookaside\x00sqlite3_dump_memsys3\x00sqlite3_dump_memsys5\x00sqlite3_install_memsys3\x00sqlite3_memdebug_vfs_oom_test\x00%05u\x00 FILENAME [OFFSET AMT]\"\x00unable to open file \"\x00\" for reading\x00md5\x00md5-10x8\x00md5file\x00md5file-10x8\x00md5sum\x00%03d\x00multiplexor.xAccess failure on %s\x00multiplexor.xOpen failure on %s\x00multiplex_control\x00chunksize\x00multiplex_truncate\x00multiplex/%z\x00multiplex\x00NAME MAKEDEFAULT\x00-force\x00?-force?\x00enable\x00chunk_size\x00max_chunks\x00HANDLE DBNAME SUB-COMMAND INT-VALUE\x00expected database handle, got \"\x00sqlite3_multiplex_initialize\x00sqlite3_multiplex_shutdown\x00sqlite3_multiplex_control\x00fast\x00recursive\x00static_main\x00static_mem\x00static_open\x00static_prng\x00static_lru\x00static_pmem\x00static_app1\x00static_app2\x00static_app3\x00static_vfs1\x00static_vfs2\x00static_vfs3\x00mutex counters are \x00already installed\x00not installed\x00singlethread\x00multithread\x00serialized\x00mutex name\x00disable_mutex_init\x00disable_mutex_try\x00sqlite3_shutdown\x00sqlite3_initialize\x00sqlite3_config\x00enter_static_mutex\x00leave_static_mutex\x00enter_db_mutex\x00leave_db_mutex\x00alloc_dealloc_mutex\x00install_mutex_counters\x00read_mutex_counters\x00clear_mutex_counters\x00\x00\x00\x00\x00\x00\x00\x00vfslog/%z\x00sqlite_ostrace1.....\x00xClose\x00xRead\x00xWrite\x00xTruncate\x00xFilesize\x00xLock\x00xUnlock\x00xCheckResLock\x00xFileControl\x00xSectorSize\x00xDeviceChar\x00xDelete\x00xAccess\x00xFullPathname\x00xRandomness\x00xSleep\x00xCurrentTime\x00xShmUnmap\x00xShmLock\x00xShmBarrier\x00xShmMap\x00annotation\x00CREATE TABLE xxx(event, file, click, rc, size, offset)\x00vfslog\x00VFS\x00failed\x00VFS PARENT LOGFILE\x00bad sqlite3 handle: \x00annotate\x00finalize\x00register\x00quota/%z\x00quota\x00::piLimit_\x00PATTERN LIMIT SCRIPT\x00FILENAME MODE\x00HANDLE SIZE NELEM\x00HANDLE SIZE NELEM CONTENT\x00HANDLE ?HARDSYNC?\x00HANDLE OFFSET WHENCE\x00SEEK_SET\x00SEEK_CUR\x00SEEK_END\x00WHENCE should be SEEK_SET, SEEK_CUR, or SEEK_END\x00HANDLE SIZE\x00PATTERN TEXT\x00sqlite3_quota_initialize\x00sqlite3_quota_shutdown\x00sqlite3_quota_set\x00sqlite3_quota_file\x00sqlite3_quota_dump\x00sqlite3_quota_fopen\x00sqlite3_quota_fread\x00sqlite3_quota_fwrite\x00sqlite3_quota_fclose\x00sqlite3_quota_fflush\x00sqlite3_quota_fseek\x00sqlite3_quota_rewind\x00sqlite3_quota_ftell\x00sqlite3_quota_ftruncate\x00sqlite3_quota_file_size\x00sqlite3_quota_file_truesize\x00sqlite3_quota_file_mtime\x00sqlite3_quota_remove\x00sqlite3_quota_glob\x00sqlite3_quota_file_available\x00sqlite3_quota_ferror\x00cube\x00circle\x00Qcircle\x00breadthfirstsearch\x00register_cube_geom\x00register_circle_geom\x00CREATE TABLE x(database,tablename,cid,name,type,not_null,dflt_value,pk)\x00SELECT name FROM sqlite_temp_schema WHERE type='table'\x00SELECT name FROM %Q.sqlite_schema WHERE type='table'\x00PRAGMA %Q.table_info(%Q)\x00PRAGMA database_list\x00register_schema_module\x00PRAGMA main.journal_mode\x00CMDNAME PATH ?VFS? ?BUSY-HANDLER-SCRIPT?\x00sqlite3demo_superlock\x00open\x00access\x00getcwd\x00stat\x00fstat\x00ftruncate\x00fcntl\x00pread\x00pread64\x00pwrite\x00pwrite64\x00fchmod\x00fallocate\x00mremap\x00SYSCALL-LIST\x00system-call\x00?COUNT PERSIST?\x00EACCES\x00EINTR\x00EIO\x00EOVERFLOW\x00ENOMEM\x00EAGAIN\x00ETIMEDOUT\x00EBUSY\x00EPERM\x00EDEADLK\x00ENOLCK\x00SYSCALL ERRNO\x00errno\x00PGSZ\x00getpagesize\x00pgsz out of range\x00fault\x00install\x00uninstall\x00list\x00defaultvfs\x00pagesize\x00VFS does not support xSetSystemCall\x00test_syscall\x00load_testfixture_extensions\x00SLAVE\x00CREATE TABLE x(  name TEXT,  arrayname TEXT,  value TEXT,  fullname TEXT PRIMARY KEY) WITHOUT ROWID\x00array names\x00tclvar_filter_cmd\x00%s(%s)\x00expr {[info exists ::tclvar_set_omit] && $::tclvar_set_omit}\x00the 'fullname' column must be TEXT\x00prohibited TCL variable change\x00proc like {pattern str} {\n  set p [string map {% * _ ?} $pattern]\n  string match $p $str\n}\nproc tclvar_filter_cmd {eq match glob regexp like} {\n  set res {}\n  set pattern $eq\n  if {$pattern=={}} { set pattern $match }\n  if {$pattern=={}} { set pattern * }\n  foreach v [uplevel #0 info vars $pattern] {\n    if {($glob=={} || [string match $glob [uplevel #0 set $v]])\n     && ($like=={} || [like $like [uplevel #0 set $v]])\n     && ($regexp=={} || [regexp $regexp [uplevel #0 set $v]])\n    } {\n      lappend res $v\n    }\n  }\n  set res\n}\n\x00register_tclvar_module\x00clock_seconds\x00sqlthread\x00sqlite3_blocking_step\x00sqlite3_blocking_prepare_v2\x00sqlite3_nonblocking_prepare_v2\x00set\x00Error in Tcl_CreateThread()\x00no parent thread\x00parent\x00spawn\x00VARNAME SCRIPT\x00DBNAME\x00id\x00%s \x00SQLITE_IOERR\x00SQLITE_LOCKED\x00SQLITE_BUSY\x00SQLITE_READONLY\x00SQLITE_READONLY_CANTINIT\x00SQLITE_NOTFOUND\x00SQLITE_OMIT\x00normal|dataonly\x00full|dataonly\x00xCheckReservedLock\x00BEGIN_ATOMIC_WRITE\x00COMMIT_ATOMIC_WRITE\x00ZIPVFS\x00anon\x00SQLITE_ACCESS_EXISTS\x00SQLITE_ACCESS_READWRITE\x00SQLITE_ACCESS_READ\x00xShmOpen\x00 lock\x00 unlock\x00 shared\x00 exclusive\x00shm\x00delete\x00filter\x00ioerr\x00fullerr\x00cantopenerr\x00script\x00devchar\x00sectorsize\x00subcommand\x00FILE ?VALUE?\x00failed to get full path: \x00no such file: \x00unknown method: \x00?CNT PERSIST?\x00default\x00undeletable_when_open\x00immutable\x00?ATTR-LIST?\x00bad flags: \x00?VALUE?\x00-noshm\x00-szosfile\x00-mxpathname\x00-iversion\x00-fullshm\x00VFSNAME ?-noshm BOOL? ?-fullshm BOOL? ?-default BOOL? ?-mxpathname INT? ?-szosfile INT? ?-iversion INT?\x00shared\x00lock\x00unlock\x00DB DBNAME (shared|exclusive) (lock|unlock) OFFSET N\x00ARG\x00DB DBNAME SLOT ?VALUE?\x00*-shm is not yet mapped\x00testvfs\x00vfs_shmlock\x00vfs_set_readmark\x00DB NAME XSTEP XFINAL XVALUE XINVERSE\x00fff\x00misuse test error\x00invalid argument\x00sumint\x00sum\x00sqlite3_create_window_function\x00test_create_window_function_misuse\x00test_create_sumint\x00test_override_sum\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
