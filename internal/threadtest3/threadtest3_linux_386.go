// Code generated by ccgo. DO NOT EDIT.

// threadtest3.c

// 2010-07-22
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
// May you do good and not evil.
// May you find forgiveness for yourself and forgive others.
// May you share freely, never taking more than you give.
//
// *************************************************************************
//
// The code in this file runs a few multi-threaded test cases using the
// SQLite library. It can be compiled to an executable on unix using the
// following command:
//
// gcc -O2 threadtest3.c sqlite3.c -ldl -lpthread -lm
//
// Even though threadtest3.c is the only C source code file mentioned on
// the compiler command-line, #include macros are used to pull in additional
// C code files named "tt3_*.c".
//
// After compiling, run this program with an optional argument telling
// which test to run.  All tests are run if no argument is given.  The
// argument can be a glob pattern to match multiple tests.  Examples:
//
// ./a.out                 -- Run all tests
// ./a.out walthread3      -- Run the "walthread3" test
// ./a.out 'wal*'          -- Run all of the wal* tests
// ./a.out --help          -- List all available tests
//
// The exit status is non-zero if any test fails.

// The "Set Error Line" macro.

package main

import (
	"math"
	"os"
	"unsafe"

	"github.com/cznic/crt"
	"github.com/cznic/sqlite/internal/bin"
)

var argv []*int8

func main() {
	for _, v := range os.Args {
		argv = append(argv, (*int8)(crt.CString(v)))
	}
	argv = append(argv, nil)
	X_start(crt.NewTLS(), int32(len(os.Args)), &argv[0])
}

func X_start(tls *crt.TLS, _argc int32, _argv **int8) {
	crt.X__register_stdfiles(tls, Xstdin, Xstdout, Xstderr)
	crt.X__builtin_exit(tls, Xmain(tls, _argc, _argv))
}

var Xstdin unsafe.Pointer

func init() {
	Xstdin = unsafe.Pointer(&X__stdfiles)
}

var X__stdfiles [3]unsafe.Pointer

var Xstdout unsafe.Pointer

func init() {
	Xstdout = (unsafe.Pointer)(uintptr(unsafe.Pointer(&X__stdfiles)) + 4)
}

var Xstderr unsafe.Pointer

func init() {
	Xstderr = (unsafe.Pointer)(uintptr(unsafe.Pointer(&X__stdfiles)) + 8)
}

func Xmain(tls *crt.TLS, _argc int32, _argv **int8) (r0 int32) {
	var _i, _iArg, _nTestfound, _4_rc int32
	var _2_zArg, _9_z *int8
	var _aTest [14]TThreadTest
	r0 = i32(0)
	_aTest = [14]TThreadTest{}
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(0)))).X0))) = _walthread1
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(0)))).X1))) = str(0)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(0)))).X2))) = i32(20000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(1)))).X0))) = _walthread2
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(1)))).X1))) = str(11)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(1)))).X2))) = i32(20000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(2)))).X0))) = _walthread3
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(2)))).X1))) = str(22)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(2)))).X2))) = i32(20000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(3)))).X0))) = _walthread4
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(3)))).X1))) = str(33)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(3)))).X2))) = i32(20000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(4)))).X0))) = _walthread5
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(4)))).X1))) = str(44)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(4)))).X2))) = i32(1000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(5)))).X0))) = _cgt_pager_1
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(5)))).X1))) = str(55)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(5)))).X2))) = i32(0)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(6)))).X0))) = _dynamic_triggers
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(6)))).X1))) = str(67)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(6)))).X2))) = i32(20000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(7)))).X0))) = _checkpoint_starvation_1
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(7)))).X1))) = str(84)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(7)))).X2))) = i32(10000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(8)))).X0))) = _checkpoint_starvation_2
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(8)))).X1))) = str(108)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(8)))).X2))) = i32(10000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(9)))).X0))) = _create_drop_index_1
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(9)))).X1))) = str(132)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(9)))).X2))) = i32(10000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(10)))).X0))) = _lookaside1
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(10)))).X1))) = str(152)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(10)))).X2))) = i32(10000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(11)))).X0))) = _vacuum1
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(11)))).X1))) = str(163)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(11)))).X2))) = i32(10000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(12)))).X0))) = _stress1
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(12)))).X1))) = str(171)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(12)))).X2))) = i32(10000)
	*(*func(*crt.TLS, int32))(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(13)))).X0))) = _stress2
	*(**int8)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(13)))).X1))) = str(179)
	*(*int32)(unsafe.Pointer(&((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(i32(13)))).X2))) = i32(60000)
	_nTestfound = i32(0)
	bin.Xsqlite3_config(tls, i32(2))
	if _argc < i32(2) {
		_argc = i32(2)
		_argv = (**int8)(unsafe.Pointer(&_mainØ00substArgvØ001))
	}
	_iArg = i32(1)
_1:
	if _iArg >= _argc {
		goto _4
	}
	_2_zArg = *(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_argv)) + 4*uintptr(_iArg)))
	if int32(*(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_2_zArg)) + 1*uintptr(i32(0))))) != i32(45) {
		goto _5
	}
	if bin.Xsqlite3_stricmp(tls, _2_zArg, str(187)) != i32(0) {
		goto _6
	}
	_4_rc = Xsqlite3_multiplex_initialize(tls, nil, i32(1))
	if _4_rc != i32(0) {
		crt.Xfprintf(tls, (*crt.XFILE)(Xstderr), str(200), _4_rc)
		return i32(253)
	}
	goto _8
_6:
	goto _usage
_8:
	goto _2
_5:
	_i = i32(0)
_9:
	if uint32(_i) >= u32(14) {
		goto _12
	}
	if bin.Xsqlite3_strglob(tls, _2_zArg, (*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest))+12*uintptr(_i))).X1) == i32(0) {
		goto _12
	}
	_i += 1
	goto _9
_12:
	if uint32(_i) >= u32(14) {
		goto _usage
	}
_2:
	_iArg += 1
	goto _1
_4:
	_iArg = i32(1)
_15:
	if _iArg >= _argc {
		goto _18
	}
	if int32(*(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_argv)) + 4*uintptr(_iArg))))) + 1*uintptr(i32(0))))) == i32(45) {
		goto _16
	}
	_i = i32(0)
_20:
	if uint32(_i) >= u32(14) {
		goto _23
	}
	_9_z = (*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(_i))).X1
	if bin.Xsqlite3_strglob(tls, *(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_argv)) + 4*uintptr(_iArg))), _9_z) == i32(0) {
		crt.Xprintf(tls, str(240), unsafe.Pointer(_9_z), ((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest))+12*uintptr(_i))).X2)/i32(1000))
		crt.Xfflush(tls, (*crt.XFILE)(Xstdout))
		((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest)) + 12*uintptr(_i))).X0)(tls, (*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest))+12*uintptr(_i))).X2)
		_nTestfound += 1
	}
	_i += 1
	goto _20
_23:
_16:
	_iArg += 1
	goto _15
_18:
	if _nTestfound == i32(0) {
		goto _usage
	}
	crt.Xprintf(tls, str(270), _nGlobalErr, _nTestfound)
	return func() int32 {
		if _nGlobalErr > i32(0) {
			return i32(255)
		}
		return i32(0)
	}()

_usage:
	crt.Xprintf(tls, str(297), unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_argv)) + 4*uintptr(i32(0))))))
	crt.Xprintf(tls, str(349))
	_i = i32(0)
_28:
	if uint32(_i) >= u32(14) {
		goto _31
	}
	crt.Xprintf(tls, str(371), unsafe.Pointer((*TThreadTest)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTest))+12*uintptr(_i))).X1))
	_i += 1
	goto _28
_31:
	return i32(254)

	_ = _aTest
	panic(0)
}

func _walthread1(tls *crt.TLS, _nMs int32) {
	var _i int32
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(987)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(988)
		}()
		return &_err
	}(), &_db, str(386))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(995)
		}()
		return &_err
	}(), &_db)
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(997)
		}()
		return &_err
	}(), _nMs)
	_i = i32(0)
_8:
	if _i >= i32(10) {
		goto _11
	}
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(999)
		}()
		return &_err
	}(), &_threads, _walthread1_thread, nil)
	_i += 1
	goto _8
_11:
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1001)
		}()
		return &_err
	}(), &_threads, _walthread1_ckpt_thread, nil)
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1002)
		}()
		return &_err
	}(), &_threads)
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
	_ = _threads
}

func _opendb_x(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _zFile *int8, _bDelete int32) {
	var _1_rc, _1_flags int32
	if (_pErr.X0) != i32(0) {
		goto _0
	}
	_1_flags = i32(70)
	if _bDelete != 0 {
		crt.Xunlink(tls, _zFile)
	}
	_1_rc = bin.Xsqlite3_open_v2(tls, _zFile, (**bin.Xsqlite3)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&(_pDb.X0))))), _1_flags, nil)
	if _1_rc != 0 {
		_sqlite_error(tls, _pErr, _pDb, str(562))
		bin.Xsqlite3_close(tls, (*bin.Xsqlite3)(_pDb.X0))
		*(*unsafe.Pointer)(unsafe.Pointer(&(_pDb.X0))) = nil
		goto _3
	}
	bin.Xsqlite3_create_function(tls, (*bin.Xsqlite3)(_pDb.X0), str(567), i32(-1), i32(1), nil, *(*func(*crt.TLS, *bin.Xsqlite3_context, int32, **bin.XMem))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int32, *unsafe.Pointer)
	}{nil})), *(*func(*crt.TLS, *bin.Xsqlite3_context, int32, **bin.XMem))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int32, *unsafe.Pointer)
	}{_md5step})), *(*func(*crt.TLS, *bin.Xsqlite3_context))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer)
	}{_md5finalize})))
	bin.Xsqlite3_busy_handler(tls, (*bin.Xsqlite3)(_pDb.X0), _busyhandler, nil)
	bin.Xsqlite3_exec(tls, (*bin.Xsqlite3)(_pDb.X0), str(574), nil, nil, nil)
_3:
_0:
}

func _sqlite_error(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _zFunc *int8) {
	*(*int32)(unsafe.Pointer(&(_pErr.X0))) = bin.Xsqlite3_errcode(tls, (*bin.Xsqlite3)(_pDb.X0))
	*(**int8)(unsafe.Pointer(&(_pErr.X2))) = bin.Xsqlite3_mprintf(tls, str(597), unsafe.Pointer(_zFunc), unsafe.Pointer(bin.Xsqlite3_errmsg(tls, (*bin.Xsqlite3)(_pDb.X0))), bin.Xsqlite3_extended_errcode(tls, (*bin.Xsqlite3)(_pDb.X0)))
}

// During testing, the special md5sum() aggregate function is available.
// inside SQLite.  The following routines implement that function.
func _md5step(tls *crt.TLS, _context unsafe.Pointer, _argc int32, _argv *unsafe.Pointer) {
	var _i int32
	var _2_zData *int8
	var _p *XMD5Context
	if _argc < i32(1) {
		return
	}
	_p = (*XMD5Context)(bin.Xsqlite3_aggregate_context(tls, (*bin.Xsqlite3_context)(_context), int32(u32(92))))
	if _p == nil {
		return
	}
	if (_p.X0) == 0 {
		_MD5Init(tls, _p)
	}
	_i = i32(0)
_3:
	if _i >= _argc {
		goto _6
	}
	_2_zData = (*int8)(unsafe.Pointer(bin.Xsqlite3_value_text(tls, (*bin.XMem)(*(*unsafe.Pointer)(unsafe.Pointer(uintptr((unsafe.Pointer)(_argv)) + 4*uintptr(_i)))))))
	if _2_zData != nil {
		_MD5Update(tls, _p, (*uint8)(unsafe.Pointer(_2_zData)), crt.Xstrlen(tls, _2_zData))
	}
	_i += 1
	goto _3
_6:
}

// * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
// * initialization constants.
func _MD5Init(tls *crt.TLS, _ctx *XMD5Context) {
	*(*int32)(unsafe.Pointer(&(_ctx.X0))) = i32(1)
	*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[4]uint32)(unsafe.Pointer(&(_ctx.X1))))) + 4*uintptr(i32(0)))) = uint32(i32(1732584193))
	*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[4]uint32)(unsafe.Pointer(&(_ctx.X1))))) + 4*uintptr(i32(1)))) = u32(4023233417)
	*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[4]uint32)(unsafe.Pointer(&(_ctx.X1))))) + 4*uintptr(i32(2)))) = u32(2562383102)
	*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[4]uint32)(unsafe.Pointer(&(_ctx.X1))))) + 4*uintptr(i32(3)))) = uint32(i32(271733878))
	*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[2]uint32)(unsafe.Pointer(&(_ctx.X2))))) + 4*uintptr(i32(0)))) = uint32(i32(0))
	*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[2]uint32)(unsafe.Pointer(&(_ctx.X2))))) + 4*uintptr(i32(1)))) = uint32(i32(0))
}

// * Update context to reflect the concatenation of another buffer full
// * of bytes.
func _MD5Update(tls *crt.TLS, _ctx *XMD5Context, _buf *uint8, _len uint32) {
	var _t uint32
	var _1_p *uint8
	_t = *(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[2]uint32)(unsafe.Pointer(&(_ctx.X2))))) + 4*uintptr(i32(0))))
	if store0((*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[2]uint32)(unsafe.Pointer(&(_ctx.X2)))))+4*uintptr(i32(0)))), _t+(_len<<uint(i32(3)))) < _t {
		*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[2]uint32)(unsafe.Pointer(&(_ctx.X2))))) + 4*uintptr(i32(1)))) += 1
	}
	{
		p := (*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[2]uint32)(unsafe.Pointer(&(_ctx.X2))))) + 4*uintptr(i32(1))))
		*p = (*p) + (_len >> uint(i32(29)))
		sink0(*p)
	}
	_t = (_t >> uint(i32(3))) & uint32(i32(63))
	if _t == 0 {
		goto _1
	}
	_1_p = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))))) + uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(_t)))))))
	_t = uint32(i32(64)) - _t
	if _len < _t {
		crt.Xmemcpy(tls, (unsafe.Pointer)(_1_p), (unsafe.Pointer)(_buf), _len)
		return
	}
	crt.Xmemcpy(tls, (unsafe.Pointer)(_1_p), (unsafe.Pointer)(_buf), _t)
	_byteReverse(tls, (*uint8)(unsafe.Pointer((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))), uint32(i32(16)))
	_MD5Transform(tls, (*[4]uint32)(unsafe.Pointer((*uint32)(unsafe.Pointer((*[4]uint32)(unsafe.Pointer(&(_ctx.X1))))))), (*[16]uint32)(unsafe.Pointer((*uint32)(unsafe.Pointer((*uint8)(unsafe.Pointer((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))))))))
	{
		p := &_buf
		*p = (*uint8)(unsafe.Pointer(uintptr((unsafe.Pointer)(*p)) + 1*uintptr(_t)))
		sink2(*p)
	}
	{
		p := &_len
		*p = (*p) - _t
		sink0(*p)
	}
_1:
	if _len >= uint32(i32(64)) {
		crt.Xmemcpy(tls, (unsafe.Pointer)((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3)))))), (unsafe.Pointer)(_buf), uint32(i32(64)))
		_byteReverse(tls, (*uint8)(unsafe.Pointer((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))), uint32(i32(16)))
		_MD5Transform(tls, (*[4]uint32)(unsafe.Pointer((*uint32)(unsafe.Pointer((*[4]uint32)(unsafe.Pointer(&(_ctx.X1))))))), (*[16]uint32)(unsafe.Pointer((*uint32)(unsafe.Pointer((*uint8)(unsafe.Pointer((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))))))))
		{
			p := &_buf
			*p = (*uint8)(unsafe.Pointer(uintptr((unsafe.Pointer)(*p)) + 1*uintptr(i32(64))))
			sink2(*p)
		}
		{
			p := &_len
			*p = (*p) - uint32(i32(64))
			sink0(*p)
		}
		goto _1
	}
	crt.Xmemcpy(tls, (unsafe.Pointer)((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3)))))), (unsafe.Pointer)(_buf), _len)
}

// * Note: this code is harmless on little-endian machines.
func _byteReverse(tls *crt.TLS, _buf *uint8, _longs uint32) {
	var _t uint32
_0:
	_t = (((uint32(*(*uint8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 1*uintptr(i32(3))))) << uint(i32(8))) | uint32(*(*uint8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 1*uintptr(i32(2)))))) << uint(i32(16))) | ((uint32(*(*uint8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 1*uintptr(i32(1))))) << uint(i32(8))) | uint32(*(*uint8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 1*uintptr(i32(0))))))
	*(*uint32)(unsafe.Pointer(_buf)) = _t
	{
		p := &_buf
		*p = (*uint8)(unsafe.Pointer(uintptr((unsafe.Pointer)(*p)) + 1*uintptr(i32(4))))
		sink2(*p)
	}
	if preInc0(&_longs, uint32(4294967295)) != 0 {
		goto _0
	}
}

// * The core of the MD5 algorithm, this alters an existing MD5 hash to
// * reflect the addition of 16 longwords of new data.  MD5Update blocks
// * the data and converts bytes into longwords for this routine.
func _MD5Transform(tls *crt.TLS, _buf *[4]uint32, _in *[16]uint32) {
	var _a, _b, _c, _d uint32
	_a = *(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 4*uintptr(i32(0))))
	_b = *(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 4*uintptr(i32(1))))
	_c = *(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 4*uintptr(i32(2))))
	_d = *(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 4*uintptr(i32(3))))
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_d ^ (_b & (_c ^ _d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(0)))))) + u32(3614090360))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(7))) | (_a >> uint(i32(25)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_c ^ (_a & (_b ^ _c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(1)))))) + u32(3905402710))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(12))) | (_d >> uint(i32(20)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_b ^ (_d & (_a ^ _b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(2)))))) + uint32(i32(606105819)))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(17))) | (_c >> uint(i32(15)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_a ^ (_c & (_d ^ _a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(3)))))) + u32(3250441966))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(22))) | (_b >> uint(i32(10)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_d ^ (_b & (_c ^ _d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(4)))))) + u32(4118548399))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(7))) | (_a >> uint(i32(25)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_c ^ (_a & (_b ^ _c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(5)))))) + uint32(i32(1200080426)))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(12))) | (_d >> uint(i32(20)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_b ^ (_d & (_a ^ _b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(6)))))) + u32(2821735955))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(17))) | (_c >> uint(i32(15)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_a ^ (_c & (_d ^ _a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(7)))))) + u32(4249261313))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(22))) | (_b >> uint(i32(10)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_d ^ (_b & (_c ^ _d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(8)))))) + uint32(i32(1770035416)))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(7))) | (_a >> uint(i32(25)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_c ^ (_a & (_b ^ _c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(9)))))) + u32(2336552879))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(12))) | (_d >> uint(i32(20)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_b ^ (_d & (_a ^ _b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(10)))))) + u32(4294925233))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(17))) | (_c >> uint(i32(15)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_a ^ (_c & (_d ^ _a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(11)))))) + u32(2304563134))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(22))) | (_b >> uint(i32(10)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_d ^ (_b & (_c ^ _d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(12)))))) + uint32(i32(1804603682)))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(7))) | (_a >> uint(i32(25)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_c ^ (_a & (_b ^ _c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(13)))))) + u32(4254626195))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(12))) | (_d >> uint(i32(20)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_b ^ (_d & (_a ^ _b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(14)))))) + u32(2792965006))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(17))) | (_c >> uint(i32(15)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_a ^ (_c & (_d ^ _a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(15)))))) + uint32(i32(1236535329)))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(22))) | (_b >> uint(i32(10)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_c ^ (_d & (_b ^ _c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(1)))))) + u32(4129170786))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(5))) | (_a >> uint(i32(27)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_b ^ (_c & (_a ^ _b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(6)))))) + u32(3225465664))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(9))) | (_d >> uint(i32(23)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_a ^ (_b & (_d ^ _a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(11)))))) + uint32(i32(643717713)))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(14))) | (_c >> uint(i32(18)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_d ^ (_a & (_c ^ _d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(0)))))) + u32(3921069994))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(20))) | (_b >> uint(i32(12)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_c ^ (_d & (_b ^ _c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(5)))))) + u32(3593408605))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(5))) | (_a >> uint(i32(27)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_b ^ (_c & (_a ^ _b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(10)))))) + uint32(i32(38016083)))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(9))) | (_d >> uint(i32(23)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_a ^ (_b & (_d ^ _a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(15)))))) + u32(3634488961))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(14))) | (_c >> uint(i32(18)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_d ^ (_a & (_c ^ _d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(4)))))) + u32(3889429448))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(20))) | (_b >> uint(i32(12)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_c ^ (_d & (_b ^ _c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(9)))))) + uint32(i32(568446438)))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(5))) | (_a >> uint(i32(27)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_b ^ (_c & (_a ^ _b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(14)))))) + u32(3275163606))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(9))) | (_d >> uint(i32(23)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_a ^ (_b & (_d ^ _a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(3)))))) + u32(4107603335))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(14))) | (_c >> uint(i32(18)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_d ^ (_a & (_c ^ _d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(8)))))) + uint32(i32(1163531501)))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(20))) | (_b >> uint(i32(12)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_c ^ (_d & (_b ^ _c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(13)))))) + u32(2850285829))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(5))) | (_a >> uint(i32(27)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_b ^ (_c & (_a ^ _b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(2)))))) + u32(4243563512))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(9))) | (_d >> uint(i32(23)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_a ^ (_b & (_d ^ _a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(7)))))) + uint32(i32(1735328473)))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(14))) | (_c >> uint(i32(18)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_d ^ (_a & (_c ^ _d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(12)))))) + u32(2368359562))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(20))) | (_b >> uint(i32(12)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + ((((_b ^ _c) ^ _d) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(5)))))) + u32(4294588738))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(4))) | (_a >> uint(i32(28)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + ((((_a ^ _b) ^ _c) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(8)))))) + u32(2272392833))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(11))) | (_d >> uint(i32(21)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + ((((_d ^ _a) ^ _b) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(11)))))) + uint32(i32(1839030562)))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(16))) | (_c >> uint(i32(16)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + ((((_c ^ _d) ^ _a) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(14)))))) + u32(4259657740))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(23))) | (_b >> uint(i32(9)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + ((((_b ^ _c) ^ _d) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(1)))))) + u32(2763975236))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(4))) | (_a >> uint(i32(28)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + ((((_a ^ _b) ^ _c) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(4)))))) + uint32(i32(1272893353)))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(11))) | (_d >> uint(i32(21)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + ((((_d ^ _a) ^ _b) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(7)))))) + u32(4139469664))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(16))) | (_c >> uint(i32(16)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + ((((_c ^ _d) ^ _a) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(10)))))) + u32(3200236656))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(23))) | (_b >> uint(i32(9)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + ((((_b ^ _c) ^ _d) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(13)))))) + uint32(i32(681279174)))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(4))) | (_a >> uint(i32(28)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + ((((_a ^ _b) ^ _c) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(0)))))) + u32(3936430074))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(11))) | (_d >> uint(i32(21)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + ((((_d ^ _a) ^ _b) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(3)))))) + u32(3572445317))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(16))) | (_c >> uint(i32(16)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + ((((_c ^ _d) ^ _a) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(6)))))) + uint32(i32(76029189)))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(23))) | (_b >> uint(i32(9)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + ((((_b ^ _c) ^ _d) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(9)))))) + u32(3654602809))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(4))) | (_a >> uint(i32(28)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + ((((_a ^ _b) ^ _c) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(12)))))) + u32(3873151461))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(11))) | (_d >> uint(i32(21)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + ((((_d ^ _a) ^ _b) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(15)))))) + uint32(i32(530742520)))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(16))) | (_c >> uint(i32(16)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + ((((_c ^ _d) ^ _a) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(2)))))) + u32(3299628645))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(23))) | (_b >> uint(i32(9)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_c ^ (_b | (^_d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(0)))))) + u32(4096336452))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(6))) | (_a >> uint(i32(26)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_b ^ (_a | (^_c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(7)))))) + uint32(i32(1126891415)))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(10))) | (_d >> uint(i32(22)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_a ^ (_d | (^_b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(14)))))) + u32(2878612391))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(15))) | (_c >> uint(i32(17)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_d ^ (_c | (^_a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(5)))))) + u32(4237533241))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(21))) | (_b >> uint(i32(11)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_c ^ (_b | (^_d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(12)))))) + uint32(i32(1700485571)))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(6))) | (_a >> uint(i32(26)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_b ^ (_a | (^_c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(3)))))) + u32(2399980690))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(10))) | (_d >> uint(i32(22)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_a ^ (_d | (^_b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(10)))))) + u32(4293915773))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(15))) | (_c >> uint(i32(17)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_d ^ (_c | (^_a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(1)))))) + u32(2240044497))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(21))) | (_b >> uint(i32(11)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_c ^ (_b | (^_d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(8)))))) + uint32(i32(1873313359)))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(6))) | (_a >> uint(i32(26)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_b ^ (_a | (^_c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(15)))))) + u32(4264355552))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(10))) | (_d >> uint(i32(22)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_a ^ (_d | (^_b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(6)))))) + u32(2734768916))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(15))) | (_c >> uint(i32(17)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_d ^ (_c | (^_a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(13)))))) + uint32(i32(1309151649)))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(21))) | (_b >> uint(i32(11)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_a
					*p = (*p) + (((_c ^ (_b | (^_d))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(4)))))) + u32(4149444226))
					sink0(*p)
				}
				return &_a
			}() = (_a << uint(i32(6))) | (_a >> uint(i32(26)))
			return &_a
		}()
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_d
					*p = (*p) + (((_b ^ (_a | (^_c))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(11)))))) + u32(3174756917))
					sink0(*p)
				}
				return &_d
			}() = (_d << uint(i32(10))) | (_d >> uint(i32(22)))
			return &_d
		}()
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_c
					*p = (*p) + (((_a ^ (_d | (^_b))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(2)))))) + uint32(i32(718787259)))
					sink0(*p)
				}
				return &_c
			}() = (_c << uint(i32(15))) | (_c >> uint(i32(17)))
			return &_c
		}()
		*p = (*p) + _d
		sink0(*p)
	}
	{
		p := func() *uint32 {
			*func() *uint32 {
				{
					p := &_b
					*p = (*p) + (((_d ^ (_c | (^_a))) + (*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_in)) + 4*uintptr(i32(9)))))) + u32(3951481745))
					sink0(*p)
				}
				return &_b
			}() = (_b << uint(i32(21))) | (_b >> uint(i32(11)))
			return &_b
		}()
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := (*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 4*uintptr(i32(0))))
		*p = (*p) + _a
		sink0(*p)
	}
	{
		p := (*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 4*uintptr(i32(1))))
		*p = (*p) + _b
		sink0(*p)
	}
	{
		p := (*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 4*uintptr(i32(2))))
		*p = (*p) + _c
		sink0(*p)
	}
	{
		p := (*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)(_buf)) + 4*uintptr(i32(3))))
		*p = (*p) + _d
		sink0(*p)
	}
}

func _md5finalize(tls *crt.TLS, _context unsafe.Pointer) {
	var _zBuf [33]int8
	var _digest [16]uint8
	var _p *XMD5Context
	_p = (*XMD5Context)(bin.Xsqlite3_aggregate_context(tls, (*bin.Xsqlite3_context)(_context), int32(u32(92))))
	_MD5Final(tls, (*[16]uint8)(unsafe.Pointer((*uint8)(unsafe.Pointer(&_digest)))), _p)
	_MD5DigestToBase16(tls, (*uint8)(unsafe.Pointer(&_digest)), (*int8)(unsafe.Pointer(&_zBuf)))
	bin.Xsqlite3_result_text(tls, (*bin.Xsqlite3_context)(_context), (*int8)(unsafe.Pointer(&_zBuf)), i32(-1), *(*func(*crt.TLS, unsafe.Pointer))(unsafe.Pointer(&struct{ f uintptr }{4294967295})))
	_ = _digest
	_ = _zBuf
}

// * Final wrapup - pad to 64-byte boundary with the bit pattern
// * 1 0* (64-bit count of bits processed, MSB-first)
func _MD5Final(tls *crt.TLS, _digest *[16]uint8, _ctx *XMD5Context) {
	var _count uint32
	var _p *uint8
	_count = ((*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[2]uint32)(unsafe.Pointer(&(_ctx.X2))))) + 4*uintptr(i32(0))))) >> uint(i32(3))) & uint32(i32(63))
	_p = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))))) + uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(_count)))))))
	*postInc2(&_p, 1) = uint8(i32(128))
	_count = uint32(i32(63)) - _count
	if _count < uint32(i32(8)) {
		crt.Xmemset(tls, (unsafe.Pointer)(_p), i32(0), _count)
		_byteReverse(tls, (*uint8)(unsafe.Pointer((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))), uint32(i32(16)))
		_MD5Transform(tls, (*[4]uint32)(unsafe.Pointer((*uint32)(unsafe.Pointer((*[4]uint32)(unsafe.Pointer(&(_ctx.X1))))))), (*[16]uint32)(unsafe.Pointer((*uint32)(unsafe.Pointer((*uint8)(unsafe.Pointer((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))))))))
		crt.Xmemset(tls, (unsafe.Pointer)((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3)))))), i32(0), uint32(i32(56)))
		goto _1
	}
	crt.Xmemset(tls, (unsafe.Pointer)(_p), i32(0), _count-uint32(i32(8)))
_1:
	_byteReverse(tls, (*uint8)(unsafe.Pointer((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))), uint32(i32(14)))
	*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[16]uint32)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))) + 4*uintptr(i32(14)))) = *(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[2]uint32)(unsafe.Pointer(&(_ctx.X2))))) + 4*uintptr(i32(0))))
	*(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[16]uint32)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))) + 4*uintptr(i32(15)))) = *(*uint32)(unsafe.Pointer(uintptr((unsafe.Pointer)((*[2]uint32)(unsafe.Pointer(&(_ctx.X2))))) + 4*uintptr(i32(1))))
	_MD5Transform(tls, (*[4]uint32)(unsafe.Pointer((*uint32)(unsafe.Pointer((*[4]uint32)(unsafe.Pointer(&(_ctx.X1))))))), (*[16]uint32)(unsafe.Pointer((*uint32)(unsafe.Pointer((*uint8)(unsafe.Pointer((*[64]uint8)(unsafe.Pointer((*t1)(unsafe.Pointer(&(_ctx.X3))))))))))))
	_byteReverse(tls, (*uint8)(unsafe.Pointer((*uint32)(unsafe.Pointer((*[4]uint32)(unsafe.Pointer(&(_ctx.X1))))))), uint32(i32(4)))
	crt.Xmemcpy(tls, (unsafe.Pointer)(_digest), (unsafe.Pointer)((*[4]uint32)(unsafe.Pointer(&(_ctx.X1)))), uint32(i32(16)))
	crt.Xmemset(tls, (unsafe.Pointer)(_ctx), i32(0), u32(92))
}

// Convert a 128-bit MD5 digest into a 32-digit base-16 number.
func _MD5DigestToBase16(tls *crt.TLS, _digest *uint8, _zBuf *int8) {
	var _i, _j, _1_a int32
	_j = store3(&_i, i32(0))
_0:
	if _i >= i32(16) {
		goto _3
	}
	_1_a = int32(*(*uint8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_digest)) + 1*uintptr(_i))))
	*(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_zBuf)) + 1*uintptr(postInc3(&_j, int32(1))))) = *(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_MD5DigestToBase16Ø00zEncodeØ001)) + 1*uintptr((_1_a>>uint(i32(4)))&i32(15))))
	*(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_zBuf)) + 1*uintptr(postInc3(&_j, int32(1))))) = *(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_MD5DigestToBase16Ø00zEncodeØ001)) + 1*uintptr(_1_a&i32(15))))
	_i += 1
	goto _0
_3:
	*(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_zBuf)) + 1*uintptr(_j))) = int8(i32(0))
}

var _MD5DigestToBase16Ø00zEncodeØ001 [17]int8

func init() {
	crt.Xstrncpy(nil, &_MD5DigestToBase16Ø00zEncodeØ001[0], str(620), 17)
}

func _busyhandler(tls *crt.TLS, _pArg unsafe.Pointer, _n int32) (r0 int32) {
	crt.Xusleep(tls, uint32(i32(10000)))
	return i32(1)
}

func _sql_script_x(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _zSql *int8) {
	if (_pErr.X0) == i32(0) {
		*(*int32)(unsafe.Pointer(&(_pErr.X0))) = bin.Xsqlite3_exec(tls, (*bin.Xsqlite3)(_pDb.X0), _zSql, nil, nil, (**int8)(unsafe.Pointer(&(_pErr.X2))))
	}
}

func _closedb_x(tls *crt.TLS, _pErr *XError, _pDb *XSqlite) {
	var _rc, _i int32
	var _pIter, _pNext *bin.Xsqlite3_pcache_page
	_pIter = (*bin.Xsqlite3_pcache_page)(_pDb.X1)
_0:
	if _pIter == nil {
		goto _3
	}
	_pNext = (*bin.Xsqlite3_pcache_page)(_pIter.X1)
	bin.Xsqlite3_finalize(tls, _pIter.X0)
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_pIter))
	_pIter = _pNext
	goto _0
_3:
	_i = i32(0)
_4:
	if _i >= (_pDb.X2) {
		goto _7
	}
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_pDb.X3)) + 4*uintptr(_i)))))
	_i += 1
	goto _4
_7:
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_pDb.X3))
	_rc = bin.Xsqlite3_close(tls, (*bin.Xsqlite3)(_pDb.X0))
	if _rc != 0 && ((_pErr.X0) == i32(0)) {
		*(**int8)(unsafe.Pointer(&(_pErr.X2))) = bin.Xsqlite3_mprintf(tls, str(637), unsafe.Pointer(bin.Xsqlite3_errmsg(tls, (*bin.Xsqlite3)(_pDb.X0))))
	}
	crt.Xmemset(tls, (unsafe.Pointer)(_pDb), i32(0), u32(16))
}

func _setstoptime_x(tls *crt.TLS, _pErr *XError, _nMs int32) {
	var _1_t float64
	if (_pErr.X0) == i32(0) {
		_1_t = _currentTime(tls)
		_timelimit = _1_t + (float64(_nMs) / (8.64e+07))
		bug20530(_timelimit)
	}
}

func _currentTime(tls *crt.TLS) (r0 float64) {
	var _1_tm int64
	var _t float64
	if _currentTimeØ00pTimelimitVfsØ001 == nil {
		_currentTimeØ00pTimelimitVfsØ001 = bin.Xsqlite3_vfs_find(tls, nil)
		bug20530(_currentTimeØ00pTimelimitVfsØ001)
	}
	if ((_currentTimeØ00pTimelimitVfsØ001.X0) >= i32(2)) && (*(*unsafe.Pointer)(unsafe.Pointer(&struct {
		f func(*crt.TLS, *bin.Xsqlite3_vfs, *int64) int32
	}{(*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int64) int32
	}{(_currentTimeØ00pTimelimitVfsØ001.X18)})))})) != *(*unsafe.Pointer)(unsafe.Pointer(&struct {
		f func(*crt.TLS, *bin.Xsqlite3_vfs, *int64) int32
	}{nil}))) {
		(*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int64) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, *int64) int32
		}{(_currentTimeØ00pTimelimitVfsØ001.X18)})))(tls, _currentTimeØ00pTimelimitVfsØ001, &_1_tm)
		_t = float64(_1_tm) / (8.64e+07)
		goto _3
	}
	(*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *float64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *float64) int32
	}{(_currentTimeØ00pTimelimitVfsØ001.X16)})))(tls, _currentTimeØ00pTimelimitVfsØ001, &_t)
_3:
	return _t
}

var _currentTimeØ00pTimelimitVfsØ001 *bin.Xsqlite3_vfs

var _timelimit float64

func _launch_thread_x(tls *crt.TLS, _pErr *XError, _pThreads *bin.T_ht, _xProc func(*crt.TLS, int32, unsafe.Pointer) *int8, _pArg unsafe.Pointer) {
	var _1_iTid, _1_rc int32
	var _1_p *XThread
	if (_pErr.X0) != i32(0) {
		goto _0
	}
	_1_iTid = preInc3((*int32)(unsafe.Pointer(&(_pThreads.X0))), 1)
	_1_p = (*XThread)(bin.Xsqlite3_malloc(tls, int32(u32(20))))
	crt.Xmemset(tls, (unsafe.Pointer)(_1_p), i32(0), u32(20))
	*(*int32)(unsafe.Pointer(&(_1_p.X0))) = _1_iTid
	*(*unsafe.Pointer)(unsafe.Pointer(&(_1_p.X1))) = _pArg
	*(*func(*crt.TLS, int32, unsafe.Pointer) *int8)(unsafe.Pointer(&(_1_p.X3))) = _xProc
	_1_rc = crt.Xpthread_create(tls, (*uint32)(unsafe.Pointer(&(_1_p.X2))), (*crt.Xpthread_attr_t)(unsafe.Pointer(nil)), _launch_thread_main, (unsafe.Pointer)(_1_p))
	if _1_rc != i32(0) {
		_system_error(tls, _pErr, _1_rc)
		bin.Xsqlite3_free(tls, (unsafe.Pointer)(_1_p))
		goto _2
	}
	*(**XThread)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&(_1_p.X4))))) = (*XThread)(_pThreads.X1)
	*(**XThread)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&(_pThreads.X1))))) = _1_p
_2:
_0:
}

func _launch_thread_main(tls *crt.TLS, _pArg unsafe.Pointer) (r0 unsafe.Pointer) {
	var _p *XThread
	_p = (*XThread)(_pArg)
	return (unsafe.Pointer)((_p.X3)(tls, _p.X0, _p.X1))
}

func _system_error(tls *crt.TLS, _pErr *XError, _iSys int32) {
	*(*int32)(unsafe.Pointer(&(_pErr.X0))) = _iSys
	*(**int8)(unsafe.Pointer(&(_pErr.X2))) = (*int8)(bin.Xsqlite3_malloc(tls, i32(512)))
	crt.Xstrerror_r(tls, _iSys, _pErr.X2, uint32(i32(512)))
	*(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_pErr.X2)) + 1*uintptr(i32(511)))) = int8(i32(0))
}

func _walthread1_thread(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _nIter int32
	var _1_z1, _1_z2, _1_z3 *int8
	var _1_azSql [2]*int8
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_nIter = i32(0)
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(929)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(930)
		}()
		return &_err
	}()) != 0 {
		goto _3
	}
	_1_azSql = [2]*int8{}
	*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_1_azSql)) + 4*uintptr(i32(0)))) = str(640)
	*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_1_azSql)) + 4*uintptr(i32(1)))) = str(708)
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(937)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(767)))
	_integrity_check_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(938)
		}()
		return &_err
	}(), &_db)
	_1_z1 = _execsql_text_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(939)
		}()
		return &_err
	}(), &_db, i32(1), unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_1_azSql)) + 4*uintptr(i32(0))))))
	_1_z2 = _execsql_text_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(940)
		}()
		return &_err
	}(), &_db, i32(2), unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_1_azSql)) + 4*uintptr(i32(1))))))
	_1_z3 = _execsql_text_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(941)
		}()
		return &_err
	}(), &_db, i32(3), unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_1_azSql)) + 4*uintptr(i32(0))))))
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(942)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(773)))
	if crt.Xstrcmp(tls, _1_z1, _1_z2) != 0 || crt.Xstrcmp(tls, _1_z1, _1_z3) != 0 {
		_test_error_x(tls, &_err, bin.Xsqlite3_mprintf(tls, str(780), unsafe.Pointer(_1_z1), unsafe.Pointer(_1_z2), unsafe.Pointer(_1_z3)))
	}
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(948)
		}()
		return &_err
	}(), &_db, str(802))
	_nIter += 1
	goto _2
_3:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(957)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(934), _nIter)

	_ = _err
	_ = _db
	_ = _1_azSql
	panic(0)
}

func _timetostop_x(tls *crt.TLS, _pErr *XError) (r0 int32) {
	var _ret int32
	var _1_t float64
	_ret = i32(1)
	if (_pErr.X0) == i32(0) {
		_1_t = _currentTime(tls)
		_ret = bool2int(_1_t >= _timelimit)
	}
	return _ret
}

func _execsql_i64_x(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, args ...interface{}) (r0 int64) {
	var _2_first int32
	var _iRet int64
	var _1_pStmt unsafe.Pointer
	var _1_ap []interface{}
	_iRet = i64(0)
	if (_pErr.X0) != i32(0) {
		goto _0
	}
	_1_ap = args
	_1_pStmt = _getAndBindSqlStatement(tls, _pErr, _pDb, _1_ap)
	if _1_pStmt == nil {
		goto _1
	}
	_2_first = i32(1)
_2:
	if i32(100) != bin.Xsqlite3_step(tls, _1_pStmt) {
		goto _3
	}
	if _2_first != 0 && (bin.Xsqlite3_column_count(tls, _1_pStmt) > i32(0)) {
		_iRet = bin.Xsqlite3_column_int64(tls, _1_pStmt, i32(0))
	}
	_2_first = i32(0)
	goto _2
_3:
	if i32(0) != bin.Xsqlite3_reset(tls, _1_pStmt) {
		_sqlite_error(tls, _pErr, _pDb, str(948))
	}
_1:
	_1_ap = nil
_0:
	return _iRet
}

func _getAndBindSqlStatement(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _ap []interface{}) (r0 unsafe.Pointer) {
	var _i int32
	var _1_zName *int8
	var _pStmt, _1_pArg unsafe.Pointer
	var _pStatement *bin.Xsqlite3_pcache_page
	_pStatement = _getSqlStatement(tls, _pErr, _pDb, (*int8)(crt.VAPointer(&_ap)))
	if _pStatement == nil {
		return nil
	}
	_pStmt = _pStatement.X0
	_i = i32(1)
_1:
	if _i > bin.Xsqlite3_bind_parameter_count(tls, _pStmt) {
		goto _4
	}
	_1_zName = bin.Xsqlite3_bind_parameter_name(tls, _pStmt, _i)
	_1_pArg = crt.VAPointer(&_ap)
	switch int32(*(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_1_zName)) + 1*uintptr(i32(1))))) {
	case i32(105):
		goto _6
	default:
		goto _7
	}

_6:
	bin.Xsqlite3_bind_int64(tls, _pStmt, _i, *(*int64)(_1_pArg))
	goto _8
_7:
	*(*int32)(unsafe.Pointer(&(_pErr.X0))) = i32(1)
	*(**int8)(unsafe.Pointer(&(_pErr.X2))) = bin.Xsqlite3_mprintf(tls, str(954), unsafe.Pointer(_1_zName))
	_pStmt = nil
	goto _8
_8:
	_i += 1
	goto _1
_4:
	return _pStmt
}

func _getSqlStatement(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _zSql *int8) (r0 *bin.Xsqlite3_pcache_page) {
	var _rc int32
	var _pRet *bin.Xsqlite3_pcache_page
	_pRet = (*bin.Xsqlite3_pcache_page)(_pDb.X1)
_0:
	if _pRet == nil {
		goto _3
	}
	if i32(0) == crt.Xstrcmp(tls, bin.Xsqlite3_sql(tls, _pRet.X0), _zSql) {
		return _pRet
	}
	_pRet = (*bin.Xsqlite3_pcache_page)(_pRet.X1)
	goto _0
_3:
	_pRet = (*bin.Xsqlite3_pcache_page)(bin.Xsqlite3_malloc(tls, int32(u32(8))))
	_rc = bin.Xsqlite3_prepare_v2(tls, (*bin.Xsqlite3)(_pDb.X0), _zSql, i32(-1), (*unsafe.Pointer)(unsafe.Pointer(&(_pRet.X0))), nil)
	if _rc != i32(0) {
		_sqlite_error(tls, _pErr, _pDb, str(980))
		return nil
	}
	func() {
		if i32(0) != crt.Xstrcmp(tls, bin.Xsqlite3_sql(tls, _pRet.X0), _zSql) {
			crt.X__builtin_fprintf(tls, Xstderr, str(991), unsafe.Pointer(str(1027)), i32(614), unsafe.Pointer((*int8)(unsafe.Pointer(&_getSqlStatementØ00__func__Ø000))), unsafe.Pointer(str(1085)))
			crt.X__builtin_abort(tls)
		}
	}()
	*(**bin.Xsqlite3_pcache_page)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&(_pRet.X1))))) = (*bin.Xsqlite3_pcache_page)(_pDb.X1)
	*(**bin.Xsqlite3_pcache_page)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&(_pDb.X1))))) = _pRet
	return _pRet
}

var _getSqlStatementØ00__func__Ø000 [16]int8

func init() {
	crt.Xstrncpy(nil, &_getSqlStatementØ00__func__Ø000[0], str(1127), 16)
}

func _integrity_check_x(tls *crt.TLS, _pErr *XError, _pDb *XSqlite) {
	var _1_zErr, _3_z *int8
	var _2_pStmt unsafe.Pointer
	var _1_pStatement *bin.Xsqlite3_pcache_page
	if (_pErr.X0) != i32(0) {
		goto _0
	}
	_1_zErr = nil
	_1_pStatement = _getSqlStatement(tls, _pErr, _pDb, str(1143))
	if _1_pStatement == nil {
		goto _1
	}
	_2_pStmt = _1_pStatement.X0
_2:
	if i32(100) != bin.Xsqlite3_step(tls, _2_pStmt) {
		goto _3
	}
	_3_z = (*int8)(unsafe.Pointer(bin.Xsqlite3_column_text(tls, _2_pStmt, i32(0))))
	if crt.Xstrcmp(tls, _3_z, str(1166)) == 0 {
		goto _4
	}
	if _1_zErr == nil {
		_1_zErr = bin.Xsqlite3_mprintf(tls, str(637), unsafe.Pointer(_3_z))
		goto _6
	}
	_1_zErr = bin.Xsqlite3_mprintf(tls, str(1169), unsafe.Pointer(_1_zErr), unsafe.Pointer(_3_z))
_6:
_4:
	goto _2
_3:
	bin.Xsqlite3_reset(tls, _2_pStmt)
	if _1_zErr != nil {
		*(**int8)(unsafe.Pointer(&(_pErr.X2))) = _1_zErr
		*(*int32)(unsafe.Pointer(&(_pErr.X0))) = i32(1)
	}
_1:
_0:
}

func _execsql_text_x(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _iSlot int32, args ...interface{}) (r0 *int8) {
	var _1_nByte, _3_first int32
	var _zRet *int8
	var _2_pStmt unsafe.Pointer
	var _2_ap []interface{}
	_zRet = nil
	if _iSlot >= (_pDb.X2) {
		_1_nByte = int32(u32(4) * uint32(_iSlot+i32(1)))
		*(***int8)(unsafe.Pointer(&(_pDb.X3))) = (**int8)(bin.Xsqlite3_realloc(tls, (unsafe.Pointer)(_pDb.X3), _1_nByte))
		crt.Xmemset(tls, (unsafe.Pointer)((**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_pDb.X3))+4*uintptr(_pDb.X2)))), i32(0), u32(4)*uint32((_iSlot+i32(1))-(_pDb.X2)))
		*(*int32)(unsafe.Pointer(&(_pDb.X2))) = _iSlot + i32(1)
	}
	if (_pErr.X0) != i32(0) {
		goto _1
	}
	_2_ap = args
	_2_pStmt = _getAndBindSqlStatement(tls, _pErr, _pDb, _2_ap)
	if _2_pStmt == nil {
		goto _2
	}
	_3_first = i32(1)
_3:
	if i32(100) != bin.Xsqlite3_step(tls, _2_pStmt) {
		goto _4
	}
	if _3_first != 0 && (bin.Xsqlite3_column_count(tls, _2_pStmt) > i32(0)) {
		_zRet = bin.Xsqlite3_mprintf(tls, str(637), unsafe.Pointer(bin.Xsqlite3_column_text(tls, _2_pStmt, i32(0))))
		bin.Xsqlite3_free(tls, (unsafe.Pointer)(*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_pDb.X3)) + 4*uintptr(_iSlot)))))
		*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_pDb.X3)) + 4*uintptr(_iSlot))) = _zRet
	}
	_3_first = i32(0)
	goto _3
_4:
	if i32(0) != bin.Xsqlite3_reset(tls, _2_pStmt) {
		_sqlite_error(tls, _pErr, _pDb, str(948))
	}
_2:
	_2_ap = nil
_1:
	return _zRet
}

func _test_error_x(tls *crt.TLS, _pErr *XError, _zErr *int8) {
	if (_pErr.X0) == i32(0) {
		*(*int32)(unsafe.Pointer(&(_pErr.X0))) = i32(1)
		*(**int8)(unsafe.Pointer(&(_pErr.X2))) = _zErr
		goto _1
	}
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_zErr))
_1:
}

func _print_and_free_err(tls *crt.TLS, _p *XError) {
	_print_err(tls, _p)
	_free_err(tls, _p)
}

func _print_err(tls *crt.TLS, _p *XError) {
	var _1_isWarn int32
	if (_p.X0) == i32(0) {
		goto _0
	}
	_1_isWarn = i32(0)
	if (_p.X0) == i32(17) {
		_1_isWarn = i32(1)
	}
	if bin.Xsqlite3_strglob(tls, str(1175), _p.X2) == i32(0) {
		_1_isWarn = i32(1)
	}
	crt.Xprintf(tls, str(1196), unsafe.Pointer(func() *int8 {
		if _1_isWarn != 0 {
			return str(1222)
		}
		return str(1230)
	}()), _p.X0, unsafe.Pointer(_p.X2), _p.X1)
	if _1_isWarn == 0 {
		_nGlobalErr += 1
	}
	crt.Xfflush(tls, (*crt.XFILE)(Xstdout))
_0:
}

var _nGlobalErr int32

func _free_err(tls *crt.TLS, _p *XError) {
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_p.X2))
	*(**int8)(unsafe.Pointer(&(_p.X2))) = nil
	*(*int32)(unsafe.Pointer(&(_p.X0))) = i32(0)
}

func _walthread1_ckpt_thread(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _nCkpt int32
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_nCkpt = i32(0)
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(968)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(969)
		}()
		return &_err
	}()) != 0 {
		goto _3
	}
	crt.Xusleep(tls, uint32(i32(500000)))
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(971)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(1236)))
	if (_err.X0) == i32(0) {
		_nCkpt += 1
	}
	_clear_error_x(tls, &_err, i32(5))
	goto _2
_3:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(975)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(1258), _nCkpt)

	_ = _err
	_ = _db
	panic(0)
}

func _clear_error_x(tls *crt.TLS, _pErr *XError, _rc int32) {
	if (_pErr.X0) == _rc {
		*(*int32)(unsafe.Pointer(&(_pErr.X0))) = i32(0)
		bin.Xsqlite3_free(tls, (unsafe.Pointer)(_pErr.X2))
		*(**int8)(unsafe.Pointer(&(_pErr.X2))) = nil
	}
}

func _join_all_threads_x(tls *crt.TLS, _pErr *XError, _pThreads *bin.T_ht) {
	var _1_rc int32
	var _1_ret unsafe.Pointer
	var _p, _pNext *XThread
	_p = (*XThread)(_pThreads.X1)
_0:
	if _p == nil {
		goto _3
	}
	_pNext = (*XThread)(_p.X4)
	_1_rc = crt.Xpthread_join(tls, _p.X2, &_1_ret)
	if _1_rc == i32(0) {
		goto _4
	}
	if (_pErr.X0) == i32(0) {
		_system_error(tls, _pErr, _1_rc)
	}
	goto _6
_4:
	crt.Xprintf(tls, str(1273), _p.X0, unsafe.Pointer(func() *int8 {
		if _1_ret == nil {
			return str(1293)
		}
		return (*int8)(_1_ret)
	}()))
	crt.Xfflush(tls, (*crt.XFILE)(Xstdout))
_6:
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_p))
	_p = _pNext
	goto _0
_3:
	*(**XThread)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&(_pThreads.X1))))) = nil
}

func _walthread2(tls *crt.TLS, _nMs int32) {
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1050)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1051)
		}()
		return &_err
	}(), &_db, str(1297))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1052)
		}()
		return &_err
	}(), &_db)
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1054)
		}()
		return &_err
	}(), _nMs)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1055)
		}()
		return &_err
	}(), &_threads, _walthread2_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1056)
		}()
		return &_err
	}(), &_threads, _walthread2_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1057)
		}()
		return &_err
	}(), &_threads, _walthread2_thread, (unsafe.Pointer)(uintptr(u32(1))))
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1058)
		}()
		return &_err
	}(), &_threads, _walthread2_thread, (unsafe.Pointer)(uintptr(u32(1))))
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1059)
		}()
		return &_err
	}(), &_threads)
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
	_ = _threads
}

func _walthread2_thread(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _iArg, _2_journal_exists, _2_wal_exists int32
	var _zJournal *int8
	var _anTrans [2]int32
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_anTrans = [2]int32{}
	_iArg = int32(uintptr(_pArg))
	_zJournal = str(1346)
	if _iArg != 0 {
		_zJournal = str(1372)
	}
_0:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1016)
		}()
		return &_err
	}()) != 0 {
		goto _2
	}
	_2_journal_exists = i32(0)
	_2_wal_exists = i32(0)
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1020)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1022)
		}()
		return &_err
	}(), &_db, _zJournal)
	_clear_error_x(tls, &_err, i32(5))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1024)
		}()
		return &_err
	}(), &_db, str(767))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1025)
		}()
		return &_err
	}(), &_db, str(1401))
	_2_journal_exists = bool2int(_filesize_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1027)
		}()
		return &_err
	}(), str(1446)) >= int64(i32(0)))
	_2_wal_exists = bool2int(_filesize_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1028)
		}()
		return &_err
	}(), str(1462)) >= int64(i32(0)))
	if (_2_journal_exists + _2_wal_exists) != i32(1) {
		_test_error_x(tls, &_err, bin.Xsqlite3_mprintf(tls, str(1474), _2_journal_exists, _2_wal_exists))
	}
	*(*int32)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_anTrans)) + 4*uintptr(_2_journal_exists))) += 1
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1036)
		}()
		return &_err
	}(), &_db, str(773))
	_integrity_check_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1037)
		}()
		return &_err
	}(), &_db)
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1038)
		}()
		return &_err
	}(), &_db)
	goto _0
_2:
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(1511), *(*int32)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_anTrans)) + 4*uintptr(i32(0)))), *(*int32)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_anTrans)) + 4*uintptr(i32(1)))))

	_ = _err
	_ = _db
	_ = _anTrans
	panic(0)
}

func _filesize_x(tls *crt.TLS, _pErr *XError, _zFile *int8) (r0 int64) {
	var _iRet int64
	var _1_sStat crt.Xstruct_stat64
	_iRet = i64(0)
	if (_pErr.X0) != i32(0) {
		goto _0
	}
	if crt.Xstat64(tls, _zFile, &_1_sStat) != 0 {
		_iRet = int64(i32(-1))
		goto _2
	}
	_iRet = _1_sStat.X9
_2:
_0:
	return _iRet

	_ = _1_sStat
	panic(0)
}

func _walthread3(tls *crt.TLS, _nMs int32) {
	var _i int32
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1107)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1108)
		}()
		return &_err
	}(), &_db, str(1521))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1115)
		}()
		return &_err
	}(), &_db)
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1117)
		}()
		return &_err
	}(), _nMs)
	_i = i32(0)
_8:
	if _i >= i32(6) {
		goto _11
	}
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1119)
		}()
		return &_err
	}(), &_threads, _walthread3_thread, (unsafe.Pointer)(uintptr(_i)))
	_i += 1
	goto _8
_11:
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1121)
		}()
		return &_err
	}(), &_threads)
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
	_ = _threads
}

func _walthread3_thread(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _iArg, _1_stop int32
	var _iNextWrite, _1_sum1, _1_sum2, _2_iMax int64
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_iArg = int32(uintptr(_pArg))
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1070)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1071)
		}()
		return &_err
	}(), &_db, str(1680))
	_iNextWrite = int64(_iArg + i32(1))
_4:
	_1_stop = i32(0)
_6:
	if i32(0) != store3(&_1_stop, _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1079)
		}()
		return &_err
	}())) {
		goto _7
	}
	_2_iMax = _execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1080)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(1711)))
	if (_2_iMax + int64(i32(1))) == _iNextWrite {
		goto _7
	}
	goto _6
_7:
	if _1_stop != 0 {
		goto _5
	}
	_1_sum1 = _execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1085)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(1735)))
	_1_sum2 = _execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1086)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(1759)))
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1087)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(1784)), unsafe.Pointer(&_iNextWrite), unsafe.Pointer(&_1_sum1), unsafe.Pointer(&_1_sum2))
	_integrity_check_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1091)
		}()
		return &_err
	}(), &_db)
	{
		p := &_iNextWrite
		*p = (*p) + int64(i32(6))
		sink4(*p)
	}
	goto _4
_5:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1096)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return nil

	_ = _err
	_ = _db
	_ = _1_sum1
	_ = _1_sum2
	panic(0)
}

func _walthread4(tls *crt.TLS, _nMs int32) {
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1165)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1166)
		}()
		return &_err
	}(), &_db, str(1835))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1170)
		}()
		return &_err
	}(), &_db)
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1172)
		}()
		return &_err
	}(), _nMs)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1173)
		}()
		return &_err
	}(), &_threads, _walthread4_reader_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1174)
		}()
		return &_err
	}(), &_threads, _walthread4_writer_thread, nil)
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1175)
		}()
		return &_err
	}(), &_threads)
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
	_ = _threads
}

func _walthread4_reader_thread(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1130)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1131)
		}()
		return &_err
	}()) == 0 {
		_integrity_check_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(1132)
			}()
			return &_err
		}(), &_db)
		goto _2
	}
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1134)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return nil

	_ = _err
	_ = _db
	panic(0)
}

func _walthread4_writer_thread(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _iRow int64
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_iRow = i64(1)
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1145)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1146)
		}()
		return &_err
	}(), &_db, str(1911))
_4:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1147)
		}()
		return &_err
	}()) != 0 {
		goto _5
	}
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1148)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(1943)), unsafe.Pointer(&_iRow))
	_iRow += 1
	if _iRow == int64(i32(10)) {
		_iRow = int64(i32(0))
	}
	goto _4
_5:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1154)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return nil

	_ = _err
	_ = _db
	panic(0)
}

func _walthread5(tls *crt.TLS, _nMs int32) {
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1198)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1199)
		}()
		return &_err
	}(), &_db, str(1990))
	_filecopy_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1224)
		}()
		return &_err
	}(), str(378), str(3150))
	_filecopy_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1225)
		}()
		return &_err
	}(), str(1462), str(3161))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1226)
		}()
		return &_err
	}(), &_db)
	_filecopy_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1228)
		}()
		return &_err
	}(), str(3150), str(378))
	_filecopy_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1229)
		}()
		return &_err
	}(), str(3161), str(1462))
	if (_err.X0) == i32(0) {
		crt.Xprintf(tls, str(3176), int32(_filesize_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(1232)
			}()
			return &_err
		}(), str(1462))))
		crt.Xprintf(tls, str(3200), int32(_filesize_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(1233)
			}()
			return &_err
		}(), str(378))))
	}
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1236)
		}()
		return &_err
	}(), _nMs)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1237)
		}()
		return &_err
	}(), &_threads, _walthread5_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1238)
		}()
		return &_err
	}(), &_threads, _walthread5_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1239)
		}()
		return &_err
	}(), &_threads, _walthread5_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1240)
		}()
		return &_err
	}(), &_threads, _walthread5_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1241)
		}()
		return &_err
	}(), &_threads, _walthread5_thread, nil)
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1242)
		}()
		return &_err
	}(), &_threads)
	if (_err.X0) == i32(0) {
		crt.Xprintf(tls, str(3176), int32(_filesize_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(1245)
			}()
			return &_err
		}(), str(1462))))
		crt.Xprintf(tls, str(3200), int32(_filesize_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(1246)
			}()
			return &_err
		}(), str(378))))
	}
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
	_ = _threads
}

func _filecopy_x(tls *crt.TLS, _pErr *XError, _zFrom *int8, _zTo *int8) {
	var _3_fd1, _3_fd2, _6_nCopy int32
	var _1_nByte, _3_iOff int64
	var _3_aBuf [1024]int8
	if (_pErr.X0) != i32(0) {
		goto _0
	}
	_1_nByte = _filesize_x(tls, _pErr, _zFrom)
	if _1_nByte < int64(i32(0)) {
		_test_error_x(tls, _pErr, bin.Xsqlite3_mprintf(tls, str(3217), unsafe.Pointer(_zFrom)))
		goto _2
	}
	crt.Xunlink(tls, _zTo)
	_3_fd1 = crt.Xopen64(tls, _zFrom, i32(0))
	if _3_fd1 < i32(0) {
		_system_error(tls, _pErr, *crt.X__errno_location(tls))
		return
	}
	_3_fd2 = crt.Xopen64(tls, _zTo, i32(194), i32(420))
	if _3_fd2 < i32(0) {
		_system_error(tls, _pErr, *crt.X__errno_location(tls))
		crt.Xclose(tls, _3_fd1)
		return
	}
	_3_iOff = int64(i32(0))
_5:
	if _3_iOff >= _1_nByte {
		goto _6
	}
	_6_nCopy = int32(u32(1024))
	if (int64(_6_nCopy) + _3_iOff) > _1_nByte {
		_6_nCopy = int32(_1_nByte - _3_iOff)
	}
	if _6_nCopy != crt.Xread(tls, _3_fd1, (unsafe.Pointer)(&_3_aBuf), uint32(_6_nCopy)) {
		_system_error(tls, _pErr, *crt.X__errno_location(tls))
		goto _6
	}
	if _6_nCopy != crt.Xwrite(tls, _3_fd2, (unsafe.Pointer)(&_3_aBuf), uint32(_6_nCopy)) {
		_system_error(tls, _pErr, *crt.X__errno_location(tls))
		goto _6
	}
	{
		p := &_3_iOff
		*p = (*p) + int64(_6_nCopy)
		sink4(*p)
	}
	goto _5
_6:
	crt.Xclose(tls, _3_fd1)
	crt.Xclose(tls, _3_fd2)
_2:
_0:
	_ = _3_aBuf
}

func _walthread5_thread(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _nRow int64
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1185)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
	_nRow = _execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1186)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(3234)))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1187)
		}()
		return &_err
	}(), &_db)
	if _nRow != int64(i32(65536)) {
		_test_error_x(tls, &_err, bin.Xsqlite3_mprintf(tls, str(3258), int32(_nRow)))
	}
	_print_and_free_err(tls, &_err)
	return nil

	_ = _err
	_ = _db
	panic(0)
}

func _cgt_pager_1(tls *crt.TLS, _nMs int32) {
	var _err XError
	var _db XSqlite
	var _xSub func(*crt.TLS, *XError, *XSqlite)
	_err = XError{}
	_db = XSqlite{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1289)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1290)
		}()
		return &_err
	}(), &_db, str(3276))
	_xSub = _cgt_pager_1_populate
	_xSub(tls, &_err, &_db)
	_xSub = _cgt_pager_1_update
	_xSub(tls, &_err, &_db)
	_xSub = _cgt_pager_1_read
	_xSub(tls, &_err, &_db)
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1300)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
}

func _cgt_pager_1_populate(tls *crt.TLS, _pErr *XError, _pDb *XSqlite) {
	var _iRow, _1_iBlob int64
	var _zInsert *int8
	_zInsert = str(3373)
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(1259)
		}()
		return _pErr
	}(), _pDb, str(767))
	_iRow = int64(i32(1))
_2:
	if _iRow > int64(i32(10000)) {
		goto _5
	}
	_1_iBlob = int64(i32(600)) + (_iRow % int64(i32(300)))
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(1262)
		}()
		return _pErr
	}(), _pDb, unsafe.Pointer(_zInsert), unsafe.Pointer(&_iRow), unsafe.Pointer(&_1_iBlob))
	_iRow += 1
	goto _2
_5:
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(1264)
		}()
		return _pErr
	}(), _pDb, str(773))
	_ = _1_iBlob
}

func _cgt_pager_1_update(tls *crt.TLS, _pErr *XError, _pDb *XSqlite) {
	var _iRow, _1_iBlob int64
	var _zUpdate *int8
	_zUpdate = str(3420)
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(1269)
		}()
		return _pErr
	}(), _pDb, str(767))
	_iRow = int64(i32(1))
_2:
	if _iRow > int64(i32(10000)) {
		goto _5
	}
	_1_iBlob = int64(i32(600)) + ((_iRow + int64(i32(100))) % int64(i32(300)))
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(1272)
		}()
		return _pErr
	}(), _pDb, unsafe.Pointer(_zUpdate), unsafe.Pointer(&_1_iBlob), unsafe.Pointer(&_iRow))
	_iRow += 1
	goto _2
_5:
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(1274)
		}()
		return _pErr
	}(), _pDb, str(773))
	_ = _1_iBlob
}

func _cgt_pager_1_read(tls *crt.TLS, _pErr *XError, _pDb *XSqlite) {
	var _iRow int64
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(1278)
		}()
		return _pErr
	}(), _pDb, str(767))
	_iRow = int64(i32(1))
_2:
	if _iRow > int64(i32(10000)) {
		goto _5
	}
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(1280)
		}()
		return _pErr
	}(), _pDb, unsafe.Pointer(str(3471)), unsafe.Pointer(&_iRow))
	_iRow += 1
	goto _2
_5:
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(1282)
		}()
		return _pErr
	}(), _pDb, str(773))
}

func _dynamic_triggers(tls *crt.TLS, _nMs int32) {
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1396)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1397)
		}()
		return &_err
	}(), &_db, str(3504))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1410)
		}()
		return &_err
	}(), &_db)
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1412)
		}()
		return &_err
	}(), _nMs)
	bin.Xsqlite3_enable_shared_cache(tls, i32(1))
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1415)
		}()
		return &_err
	}(), &_threads, _dynamic_triggers_2, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1416)
		}()
		return &_err
	}(), &_threads, _dynamic_triggers_2, nil)
	crt.Xsleep(tls, uint32(i32(2)))
	bin.Xsqlite3_enable_shared_cache(tls, i32(0))
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1421)
		}()
		return &_err
	}(), &_threads, _dynamic_triggers_2, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1422)
		}()
		return &_err
	}(), &_threads, _dynamic_triggers_1, nil)
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1424)
		}()
		return &_err
	}(), &_threads)
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
	_ = _threads
}

func _dynamic_triggers_2(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _nInsert, _nDelete int32
	var _iVal int64
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_iVal = i64(0)
	_nInsert = i32(0)
	_nDelete = i32(0)
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1371)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1372)
		}()
		return &_err
	}()) != 0 {
		goto _3
	}
_6:
	_iVal = (_iVal + int64(i32(1))) % int64(i32(100))
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1375)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(3753)), unsafe.Pointer(&_iVal), unsafe.Pointer(&_iVal))
	_nInsert += 1
	if _iVal != 0 {
		goto _6
	}
_9:
	_iVal = (_iVal + int64(i32(1))) % int64(i32(100))
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1381)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(3787)), unsafe.Pointer(&_iVal))
	_nDelete += 1
	if _iVal != 0 {
		goto _9
	}
	goto _2
_3:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1385)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(3816), _nInsert, _nDelete)

	_ = _err
	_ = _db
	panic(0)
}

func _dynamic_triggers_1(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _nDrop, _nCreate, _1_i int32
	var _2_zSql, _3_zSql, _4_zSql, _5_zSql *int8
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_nDrop = i32(0)
	_nCreate = i32(0)
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1318)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1319)
		}()
		return &_err
	}()) != 0 {
		goto _3
	}
	_1_i = i32(1)
_6:
	if _1_i >= i32(9) {
		goto _9
	}
	_2_zSql = bin.Xsqlite3_mprintf(tls, str(3839), _1_i, _1_i, _1_i+i32(1))
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1328)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(_2_zSql))
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_2_zSql))
	_nCreate += 1
	_1_i += 1
	goto _6
_9:
	_1_i = i32(1)
_12:
	if _1_i >= i32(9) {
		goto _15
	}
	_3_zSql = bin.Xsqlite3_mprintf(tls, str(3929), _1_i, _1_i, _1_i+i32(1))
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1339)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(_3_zSql))
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_3_zSql))
	_nCreate += 1
	_1_i += 1
	goto _12
_15:
	_1_i = i32(1)
_18:
	if _1_i >= i32(9) {
		goto _21
	}
	_4_zSql = bin.Xsqlite3_mprintf(tls, str(4015), _1_i)
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1346)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(_4_zSql))
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_4_zSql))
	_nDrop += 1
	_1_i += 1
	goto _18
_21:
	_1_i = i32(1)
_24:
	if _1_i >= i32(9) {
		goto _27
	}
	_5_zSql = bin.Xsqlite3_mprintf(tls, str(4034), _1_i)
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1353)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(_5_zSql))
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_5_zSql))
	_nDrop += 1
	_1_i += 1
	goto _24
_27:
	goto _2
_3:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(1358)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(4053), _nCreate, _nDrop)

	_ = _err
	_ = _db
	panic(0)
}

func _checkpoint_starvation_1(tls *crt.TLS, _nMs int32) {
	var _ctx crt.Xstruct_timeval
	var _err XError
	_err = XError{}
	_ctx = crt.Xstruct_timeval{}
	_checkpoint_starvation_main(tls, _nMs, &_ctx)
	if (_ctx.X1) < i32(500) {
		_test_error_x(tls, &_err, bin.Xsqlite3_mprintf(tls, str(4076), _ctx.X1))
	}
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _ctx
}

func _checkpoint_starvation_main(tls *crt.TLS, _nMs int32, _p *crt.Xstruct_timeval) {
	var _nInsert, _i int32
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_nInsert = i32(0)
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(99)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(100)
		}()
		return &_err
	}(), &_db, str(4107))
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(106)
		}()
		return &_err
	}(), _nMs)
	_i = i32(0)
_6:
	if _i >= i32(4) {
		goto _9
	}
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(109)
		}()
		return &_err
	}(), &_threads, _checkpoint_starvation_reader, nil)
	crt.Xusleep(tls, uint32(i32(25000)))
	_i += 1
	goto _6
_9:
	bin.Xsqlite3_wal_hook(tls, (*bin.Xsqlite3)(_db.X0), *(*func(*crt.TLS, unsafe.Pointer, *bin.Xsqlite3, *int8, int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, *int8, int32) int32
	}{_checkpoint_starvation_walhook})), (unsafe.Pointer)(_p))
_12:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(114)
		}()
		return &_err
	}()) == 0 {
		_sql_script_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(115)
			}()
			return &_err
		}(), &_db, str(4177))
		_nInsert += 1
		goto _12
	}
	crt.Xprintf(tls, str(4217), unsafe.Pointer(func() *int8 {
		if (_p.X0) == i32(0) {
			return str(4241)
		}
		return str(4249)
	}()))
	crt.Xprintf(tls, str(4257), _p.X1)
	crt.Xprintf(tls, str(4288), _nInsert)
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(125)
		}()
		return &_err
	}(), &_threads)
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(126)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
	_ = _threads
}

func _checkpoint_starvation_reader(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _1_iCount1, _1_iCount2 int64
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(73)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(74)
		}()
		return &_err
	}()) != 0 {
		goto _3
	}
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(76)
		}()
		return &_err
	}(), &_db, str(767))
	_1_iCount1 = _execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(77)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(4325)))
	crt.Xusleep(tls, uint32(i32(100000)))
	_1_iCount2 = _execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(79)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(4325)))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(80)
		}()
		return &_err
	}(), &_db, str(773))
	if _1_iCount1 != _1_iCount2 {
		_test_error_x(tls, &_err, bin.Xsqlite3_mprintf(tls, str(4349), _1_iCount1, _1_iCount2))
	}
	goto _2
_3:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(86)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return nil

	_ = _err
	_ = _db
	panic(0)
}

func _checkpoint_starvation_walhook(tls *crt.TLS, _pCtx unsafe.Pointer, _db unsafe.Pointer, _zDb *int8, _nFrame int32) (r0 int32) {
	var _p *crt.Xstruct_timeval
	_p = (*crt.Xstruct_timeval)(_pCtx)
	if _nFrame > (_p.X1) {
		*(*int32)(unsafe.Pointer(&(_p.X1))) = _nFrame
	}
	if _nFrame >= i32(50) {
		bin.Xsqlite3_wal_checkpoint_v2(tls, (*bin.Xsqlite3)(_db), _zDb, _p.X0, nil, nil)
	}
	return i32(0)
}

func _checkpoint_starvation_2(tls *crt.TLS, _nMs int32) {
	var _ctx crt.Xstruct_timeval
	var _err XError
	_err = XError{}
	_ctx = crt.Xstruct_timeval{X0: i32(2), X1: i32(0)}
	_checkpoint_starvation_main(tls, _nMs, &_ctx)
	if (_ctx.X1) > i32(60) {
		_test_error_x(tls, &_err, bin.Xsqlite3_mprintf(tls, str(4379), _ctx.X1))
	}
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _ctx
}

func _create_drop_index_1(tls *crt.TLS, _nMs int32) {
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(54)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(55)
		}()
		return &_err
	}(), &_db, str(4410))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(60)
		}()
		return &_err
	}(), &_db)
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(62)
		}()
		return &_err
	}(), _nMs)
	bin.Xsqlite3_enable_shared_cache(tls, i32(1))
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(65)
		}()
		return &_err
	}(), &_threads, _create_drop_index_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(66)
		}()
		return &_err
	}(), &_threads, _create_drop_index_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(67)
		}()
		return &_err
	}(), &_threads, _create_drop_index_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(68)
		}()
		return &_err
	}(), &_threads, _create_drop_index_thread, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(69)
		}()
		return &_err
	}(), &_threads, _create_drop_index_thread, nil)
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(71)
		}()
		return &_err
	}(), &_threads)
	bin.Xsqlite3_enable_shared_cache(tls, i32(0))
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
	_ = _threads
}

func _create_drop_index_thread(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
_0:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(21)
		}()
		return &_err
	}()) == 0 {
		_opendb_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(22)
			}()
			return &_err
		}(), &_db, str(378), i32(0))
		_sql_script_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(24)
			}()
			return &_err
		}(), &_db, str(4551))
		_clear_error_x(tls, &_err, i32(6))
		_closedb_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(42)
			}()
			return &_err
		}(), &_db)
		goto _0
	}
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(1166))

	_ = _err
	_ = _db
	panic(0)
}

func _lookaside1(tls *crt.TLS, _nMs int32) {
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(71)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(72)
		}()
		return &_err
	}(), &_db, str(4924))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(85)
		}()
		return &_err
	}(), &_db)
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(87)
		}()
		return &_err
	}(), _nMs)
	bin.Xsqlite3_enable_shared_cache(tls, i32(1))
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(90)
		}()
		return &_err
	}(), &_threads, _lookaside1_thread_reader, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(91)
		}()
		return &_err
	}(), &_threads, _lookaside1_thread_reader, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(92)
		}()
		return &_err
	}(), &_threads, _lookaside1_thread_reader, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(93)
		}()
		return &_err
	}(), &_threads, _lookaside1_thread_reader, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(94)
		}()
		return &_err
	}(), &_threads, _lookaside1_thread_reader, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(95)
		}()
		return &_err
	}(), &_threads, _lookaside1_thread_writer, nil)
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(96)
		}()
		return &_err
	}(), &_threads)
	bin.Xsqlite3_enable_shared_cache(tls, i32(0))
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
	_ = _threads
}

func _lookaside1_thread_reader(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _1_rc int32
	var _1_pStmt unsafe.Pointer
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(25)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(27)
		}()
		return &_err
	}()) != 0 {
		goto _3
	}
	_1_pStmt = nil
	bin.Xsqlite3_prepare_v2(tls, (*bin.Xsqlite3)(_db.X0), str(5276), i32(-1), &_1_pStmt, nil)
_6:
	if bin.Xsqlite3_step(tls, _1_pStmt) == i32(100) {
		_execsql_i64_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(33)
			}()
			return &_err
		}(), &_db, unsafe.Pointer(str(5293)))
		goto _6
	}
	_1_rc = bin.Xsqlite3_finalize(tls, _1_pStmt)
	if ((_err.X0) == i32(0)) && (_1_rc != i32(0)) {
		_sqlite_error(tls, &_err, &_db, str(5324))
	}
	goto _2
_3:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(41)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(1166))

	_ = _err
	_ = _db
	panic(0)
}

func _lookaside1_thread_writer(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(50)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(53)
		}()
		return &_err
	}(), &_db, str(5333))
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(58)
		}()
		return &_err
	}()) == 0 {
		goto _2
	}
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(60)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(1166))

	_ = _err
	_ = _db
	panic(0)
}

func _vacuum1(tls *crt.TLS, _nMs int32) {
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(72)
		}()
		return &_err
	}(), &_db, str(378), i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(73)
		}()
		return &_err
	}(), &_db, str(5379))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(77)
		}()
		return &_err
	}(), &_db)
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(79)
		}()
		return &_err
	}(), _nMs)
	bin.Xsqlite3_enable_shared_cache(tls, i32(1))
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(82)
		}()
		return &_err
	}(), &_threads, _vacuum1_thread_writer, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(83)
		}()
		return &_err
	}(), &_threads, _vacuum1_thread_writer, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(84)
		}()
		return &_err
	}(), &_threads, _vacuum1_thread_writer, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(85)
		}()
		return &_err
	}(), &_threads, _vacuum1_thread_vacuumer, nil)
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(86)
		}()
		return &_err
	}(), &_threads)
	bin.Xsqlite3_enable_shared_cache(tls, i32(0))
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _db
	_ = _threads
}

func _vacuum1_thread_writer(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _i int64
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(26)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
	_i = i64(0)
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(29)
		}()
		return &_err
	}()) == 0 {
		_i += 1
		_execsql_i64_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(33)
			}()
			return &_err
		}(), &_db, unsafe.Pointer(str(5444)))
		_execsql_i64_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(39)
			}()
			return &_err
		}(), &_db, unsafe.Pointer(str(5579)), unsafe.Pointer(&_i))
		_clear_error_x(tls, &_err, i32(6))
		_execsql_i64_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(43)
			}()
			return &_err
		}(), &_db, unsafe.Pointer(str(5611)))
		_clear_error_x(tls, &_err, i32(6))
		goto _2
	}
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(47)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(1166))

	_ = _err
	_ = _db
	_ = _i
	panic(0)
}

func _vacuum1_thread_vacuumer(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(55)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(58)
		}()
		return &_err
	}(), &_db, str(5639))
	_clear_error_x(tls, &_err, i32(6))
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(60)
		}()
		return &_err
	}()) == 0 {
		goto _2
	}
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(62)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(1166))

	_ = _err
	_ = _db
	panic(0)
}

func _stress1(tls *crt.TLS, _nMs int32) {
	var _threads bin.T_ht
	var _err XError
	_err = XError{}
	_threads = bin.T_ht{}
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(138)
		}()
		return &_err
	}(), _nMs)
	bin.Xsqlite3_enable_shared_cache(tls, i32(1))
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(141)
		}()
		return &_err
	}(), &_threads, _stress_thread_1, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(142)
		}()
		return &_err
	}(), &_threads, _stress_thread_1, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(144)
		}()
		return &_err
	}(), &_threads, _stress_thread_2, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(145)
		}()
		return &_err
	}(), &_threads, _stress_thread_2, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(147)
		}()
		return &_err
	}(), &_threads, _stress_thread_3, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(148)
		}()
		return &_err
	}(), &_threads, _stress_thread_3, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(150)
		}()
		return &_err
	}(), &_threads, _stress_thread_4, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(151)
		}()
		return &_err
	}(), &_threads, _stress_thread_4, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(153)
		}()
		return &_err
	}(), &_threads, _stress_thread_5, nil)
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(154)
		}()
		return &_err
	}(), &_threads, _stress_thread_5, (unsafe.Pointer)(uintptr(u32(1))))
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(156)
		}()
		return &_err
	}(), &_threads)
	bin.Xsqlite3_enable_shared_cache(tls, i32(0))
	_print_and_free_err(tls, &_err)
	_ = _err
	_ = _threads
}

// Thread 1. CREATE and DROP a table.
func _stress_thread_1(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(24)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(25)
		}()
		return &_err
	}()) == 0 {
		_sql_script_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(26)
			}()
			return &_err
		}(), &_db, str(5646))
		_clear_error_x(tls, &_err, i32(6))
		_sql_script_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(28)
			}()
			return &_err
		}(), &_db, str(5694))
		_clear_error_x(tls, &_err, i32(6))
		goto _2
	}
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(31)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(1166))

	_ = _err
	_ = _db
	panic(0)
}

// Thread 2. Open and close database connections.
func _stress_thread_2(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
_0:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(42)
		}()
		return &_err
	}()) == 0 {
		_opendb_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(43)
			}()
			return &_err
		}(), &_db, str(378), i32(0))
		_sql_script_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(44)
			}()
			return &_err
		}(), &_db, str(5718))
		_clear_error_x(tls, &_err, i32(6))
		_closedb_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(46)
			}()
			return &_err
		}(), &_db)
		goto _0
	}
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(1166))

	_ = _err
	_ = _db
	panic(0)
}

// Thread 3. Attempt many small SELECT statements.
func _stress_thread_3(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _i1, _i2 int32
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_i1 = i32(0)
	_i2 = i32(0)
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(62)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(63)
		}()
		return &_err
	}()) != 0 {
		goto _3
	}
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(64)
		}()
		return &_err
	}(), &_db, str(5747))
	_i1 += 1
	if (_err.X0) != 0 {
		_i2 += 1
	}
	_clear_error_x(tls, &_err, i32(6))
	_clear_error_x(tls, &_err, i32(1))
	goto _2
_3:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(70)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(5776), _i2, _i1)

	_ = _err
	_ = _db
	panic(0)
}

// Thread 5. Attempt INSERT statements.
func _stress_thread_4(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _i1, _i2, _iArg int32
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_i1 = i32(0)
	_i2 = i32(0)
	_iArg = int32(uintptr(_pArg))
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(85)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(86)
		}()
		return &_err
	}()) != 0 {
		goto _3
	}
	if _iArg != 0 {
		_closedb_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(88)
			}()
			return &_err
		}(), &_db)
		_opendb_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(89)
			}()
			return &_err
		}(), &_db, str(378), i32(0))
	}
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(91)
		}()
		return &_err
	}(), &_db, str(5799))
	_i1 += 1
	if (_err.X0) != 0 {
		_i2 += 1
	}
	_clear_error_x(tls, &_err, i32(6))
	_clear_error_x(tls, &_err, i32(1))
	goto _2
_3:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(100)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(5922), _i2, _i1)

	_ = _err
	_ = _db
	panic(0)
}

// Thread 6. Attempt DELETE operations.
func _stress_thread_5(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _iArg, _i1, _i2 int32
	var _1_i int64
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_iArg = int32(uintptr(_pArg))
	_i1 = i32(0)
	_i2 = i32(0)
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(116)
		}()
		return &_err
	}(), &_db, str(378), i32(0))
_2:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(117)
		}()
		return &_err
	}()) != 0 {
		goto _3
	}
	_1_i = int64(_i1 % i32(4))
	if _iArg != 0 {
		_closedb_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(120)
			}()
			return &_err
		}(), &_db)
		_opendb_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(121)
			}()
			return &_err
		}(), &_db, str(378), i32(0))
	}
	_execsql_i64_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(123)
		}()
		return &_err
	}(), &_db, unsafe.Pointer(str(5946)), unsafe.Pointer(&_1_i))
	_i1 += 1
	if (_err.X0) != 0 {
		_i2 += 1
	}
	_clear_error_x(tls, &_err, i32(6))
	goto _2
_3:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(128)
		}()
		return &_err
	}(), &_db)
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(5983), _i2, _i1)

	_ = _err
	_ = _db
	_ = _1_i
	panic(0)
}

func _stress2(tls *crt.TLS, _nMs int32) {
	var _i int32
	var _zDb *int8
	var _threads bin.T_ht
	var _err XError
	var _db XSqlite
	var _aTask [13]TStress2Task
	_aTask = [13]TStress2Task{}
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(0)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload1}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(1)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload2}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(2)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload3}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(3)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload4}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(4)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload5}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(5)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload6}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(6)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload7}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(7)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload8}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(8)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload9}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(9)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload10}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(10)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload11}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(11)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload14}))
	*(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(i32(12)))).X0))) = *(*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, *XError, *XSqlite, int32)
	}{_stress2_workload17}))
	_zDb = str(378)
	_err = XError{}
	_db = XSqlite{}
	_threads = bin.T_ht{}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(345)
		}()
		return &_err
	}(), &_db, _zDb, i32(1))
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(346)
		}()
		return &_err
	}(), &_db, str(6014))
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(350)
		}()
		return &_err
	}(), &_db)
	_setstoptime_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(352)
		}()
		return &_err
	}(), _nMs)
	bin.Xsqlite3_enable_shared_cache(tls, i32(1))
	_i = i32(0)
_8:
	if uint32(_i) >= u32(13) {
		goto _11
	}
	_stress2_launch_thread_loop(tls, &_err, &_threads, _zDb, *(*func(*crt.TLS, *XError, *XSqlite, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32)
	}{((*TStress2Task)(unsafe.Pointer(uintptr((unsafe.Pointer)(&_aTask)) + 4*uintptr(_i))).X0)})))
	_i += 1
	goto _8
_11:
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(358)
		}()
		return &_err
	}(), &_threads, _stress2_workload19, (unsafe.Pointer)(_zDb))
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(359)
		}()
		return &_err
	}(), &_threads, _stress2_workload19, (unsafe.Pointer)(_zDb))
	_join_all_threads_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(361)
		}()
		return &_err
	}(), &_threads)
	bin.Xsqlite3_enable_shared_cache(tls, i32(0))
	_print_and_free_err(tls, &_err)
	_ = _aTask
	_ = _err
	_ = _db
	_ = _threads
}

func _stress2_workload1(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	var _iTab int32
	_iTab = (_i % i32(4)) + i32(1)
	_sql_script_printf_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(193)
		}()
		return _pErr
	}(), _pDb, str(6105), _iTab)
}

func _sql_script_printf_x(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _zFormat *int8, args ...interface{}) {
	var _1_zSql *int8
	var _ap []interface{}
	_ap = args
	if (_pErr.X0) == i32(0) {
		_1_zSql = bin.Xsqlite3_vmprintf(tls, _zFormat, _ap)
		*(*int32)(unsafe.Pointer(&(_pErr.X0))) = bin.Xsqlite3_exec(tls, (*bin.Xsqlite3)(_pDb.X0), _1_zSql, nil, nil, (**int8)(unsafe.Pointer(&(_pErr.X2))))
		bin.Xsqlite3_free(tls, (unsafe.Pointer)(_1_zSql))
	}
	_ap = nil
}

func _stress2_workload2(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	var _iTab int32
	_iTab = (_i % i32(4)) + i32(1)
	_sql_script_printf_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(200)
		}()
		return _pErr
	}(), _pDb, str(6158), _iTab)
}

func _stress2_workload3(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(204)
		}()
		return _pErr
	}(), _pDb, str(6184))
}

func _stress2_workload4(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(208)
		}()
		return _pErr
	}(), _pDb, str(6219))
}

func _stress2_workload5(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(212)
		}()
		return _pErr
	}(), _pDb, str(6252))
}

func _stress2_workload6(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(218)
		}()
		return _pErr
	}(), _pDb, str(6321))
}

func _stress2_workload7(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_printf_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(224)
		}()
		return _pErr
	}(), _pDb, str(6387), _i)
}

func _stress2_workload8(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_printf_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(231)
		}()
		return _pErr
	}(), _pDb, str(6469), _i)
}

func _stress2_workload9(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_printf_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(239)
		}()
		return _pErr
	}(), _pDb, str(6546), _i)
}

func _stress2_workload10(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_printf_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(244)
		}()
		return _pErr
	}(), _pDb, str(6602), _i)
}

func _stress2_workload11(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(250)
		}()
		return _pErr
	}(), _pDb, str(5639))
}

func _stress2_workload14(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(254)
		}()
		return _pErr
	}(), _pDb, str(1143))
}

func _stress2_workload17(tls *crt.TLS, _pErr *XError, _pDb *XSqlite, _i int32) {
	_sql_script_printf_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(258)
		}()
		return _pErr
	}(), _pDb, str(6656), unsafe.Pointer(func() *int8 {
		if (_i % i32(2)) != 0 {
			return str(6681)
		}
		return str(6688)
	}()))
}

func _stress2_launch_thread_loop(tls *crt.TLS, _pErr *XError, _pThreads *bin.T_ht, _zDb *int8, _x func(*crt.TLS, *XError, *XSqlite, int32)) {
	var _pCtx *XStress2Ctx
	_pCtx = (*XStress2Ctx)(bin.Xsqlite3_malloc(tls, int32(u32(8))))
	*(**int8)(unsafe.Pointer(&(_pCtx.X0))) = _zDb
	*(*func(*crt.TLS, *XError, *XSqlite, int32))(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32))(unsafe.Pointer(&(_pCtx.X1))))) = _x
	_launch_thread_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_pErr.X1))) = func() int32 {
			if (_pErr.X0) != 0 {
				return (_pErr.X1)
			}
			return i32(316)
		}()
		return _pErr
	}(), _pThreads, _stress2_thread_wrapper, (unsafe.Pointer)(_pCtx))
}

func _stress2_thread_wrapper(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _i1, _i2, _1_cnt int32
	var _err XError
	var _db XSqlite
	var _pCtx *XStress2Ctx
	_pCtx = (*XStress2Ctx)(_pArg)
	_err = XError{}
	_db = XSqlite{}
	_i1 = i32(0)
	_i2 = i32(0)
_0:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(291)
		}()
		return &_err
	}()) != 0 {
		goto _1
	}
	_opendb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(293)
		}()
		return &_err
	}(), &_db, _pCtx.X0, i32(0))
	_1_cnt = i32(0)
_6:
	if (_err.X0) != i32(0) || _1_cnt >= i32(5) {
		goto _10
	}
	(*(*func(*crt.TLS, *XError, *XSqlite, int32))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32)
	}{(_pCtx.X1)})))(tls, &_err, &_db, _i1)
	{
		p := &_i2
		*p = (*p) + bool2int((_err.X0) == i32(0))
		sink3(*p)
	}
	_clear_error_x(tls, &_err, i32(6))
	_i1 += 1
	_1_cnt += 1
	goto _6
_10:
	_closedb_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(300)
		}()
		return &_err
	}(), &_db)
	goto _0
_1:
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(6692), _i2, _i1)

	_ = _err
	_ = _db
	panic(0)
}

func _stress2_workload19(tls *crt.TLS, _iTid int32, _pArg unsafe.Pointer) (r0 *int8) {
	var _zDb *int8
	var _err XError
	var _db XSqlite
	_err = XError{}
	_db = XSqlite{}
	_zDb = (*int8)(_pArg)
_0:
	if _timetostop_x(tls, func() *XError {
		*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
			if (_err.X0) != 0 {
				return (_err.X1)
			}
			return i32(267)
		}()
		return &_err
	}()) == 0 {
		_opendb_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(268)
			}()
			return &_err
		}(), &_db, _zDb, i32(0))
		_sql_script_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(269)
			}()
			return &_err
		}(), &_db, str(5718))
		_clear_error_x(tls, &_err, i32(6))
		_closedb_x(tls, func() *XError {
			*(*int32)(unsafe.Pointer(&(_err.X1))) = func() int32 {
				if (_err.X0) != 0 {
					return (_err.X1)
				}
				return i32(271)
			}()
			return &_err
		}(), &_db)
		goto _0
	}
	_print_and_free_err(tls, &_err)
	return bin.Xsqlite3_mprintf(tls, str(1166))

	_ = _err
	_ = _db
	panic(0)
}

var _mainØ00substArgvØ001 [3]*int8

func init() {
	_mainØ00substArgvØ001 = [3]*int8{nil, str(6701), nil}
}

// ************************* Public Interfaces ****************************

// CAPI: Initialize the multiplex VFS shim - sqlite3_multiplex_initialize()
//
// Use the VFS named zOrigVfsName as the VFS that does the actual work.
// Use the default if zOrigVfsName==NULL.
//
// The multiplex VFS shim is named "multiplex".  It will become the default
// VFS if makeDefault is non-zero.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once
// during start-up.
func Xsqlite3_multiplex_initialize(tls *crt.TLS, _zOrigVfsName *int8, _makeDefault int32) (r0 int32) {
	var _pOrigVfs *bin.Xsqlite3_vfs
	if (_gMultiplex.X4) != 0 {
		return i32(21)
	}
	_pOrigVfs = bin.Xsqlite3_vfs_find(tls, _zOrigVfsName)
	if _pOrigVfs == nil {
		return i32(1)
	}
	func() {
		if _pOrigVfs == (*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))) {
			crt.X__builtin_fprintf(tls, Xstderr, str(991), unsafe.Pointer(str(6703)), i32(1099), unsafe.Pointer((*int8)(unsafe.Pointer(&_sqlite3_multiplex_initializeØ00__func__Ø000))), unsafe.Pointer(str(6763)))
			crt.X__builtin_abort(tls)
		}
	}()
	*(*int32)(unsafe.Pointer(&(_gMultiplex.X4))) = i32(1)
	*(**bin.Xsqlite3_vfs)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&(_gMultiplex.X0))))) = _pOrigVfs
	*(*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))) = *_pOrigVfs
	{
		p := (*int32)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X1)))
		*p = int32(uint32(*p) + u32(8))
		sink3(*p)
	}
	*(**int8)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X4))) = str(6794)
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, *bin.Xsqlite3_file, int32, *int32) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, *int8, unsafe.Pointer, int32, *int32) int32)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X6))))) = _multiplexOpen
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, *int8, int32) int32)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X7))))) = _multiplexDelete
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32, *int32) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, *int8, int32, *int32) int32)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X8))))) = _multiplexAccess
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32, *int8) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, *int8, int32, *int8) int32)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X9))))) = _multiplexFullPathname
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8) unsafe.Pointer)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, *int8) unsafe.Pointer)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X10))))) = _multiplexDlOpen
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, int32, *int8))(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32, *int8))(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X11))))) = _multiplexDlError
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, unsafe.Pointer, *int8) func(*crt.TLS))(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, *int8) func(*crt.TLS))(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X12))))) = _multiplexDlSym
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, unsafe.Pointer))(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer))(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X13))))) = _multiplexDlClose
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, int32, *int8) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32, *int8) int32)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X14))))) = _multiplexRandomness
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, int32) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32) int32)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X15))))) = _multiplexSleep
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *float64) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, *float64) int32)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X16))))) = _multiplexCurrentTime
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, int32, *int8) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32, *int8) int32)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X17))))) = _multiplexGetLastError
	*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int64) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, *int64) int32)(unsafe.Pointer(&((*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))).X18))))) = _multiplexCurrentTimeInt64
	*(*int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X0))) = i32(1)
	*(*func(*crt.TLS, *bin.Xsqlite3_file) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X1))))) = _multiplexClose
	*(*func(*crt.TLS, *bin.Xsqlite3_file, unsafe.Pointer, int32, int64) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32, int64) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X2))))) = _multiplexRead
	*(*func(*crt.TLS, *bin.Xsqlite3_file, unsafe.Pointer, int32, int64) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32, int64) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X3))))) = _multiplexWrite
	*(*func(*crt.TLS, *bin.Xsqlite3_file, int64) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int64) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X4))))) = _multiplexTruncate
	*(*func(*crt.TLS, *bin.Xsqlite3_file, int32) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X5))))) = _multiplexSync
	*(*func(*crt.TLS, *bin.Xsqlite3_file, *int64) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, *int64) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X6))))) = _multiplexFileSize
	*(*func(*crt.TLS, *bin.Xsqlite3_file, int32) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X7))))) = _multiplexLock
	*(*func(*crt.TLS, *bin.Xsqlite3_file, int32) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X8))))) = _multiplexUnlock
	*(*func(*crt.TLS, *bin.Xsqlite3_file, *int32) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, *int32) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X9))))) = _multiplexCheckReservedLock
	*(*func(*crt.TLS, *bin.Xsqlite3_file, int32, unsafe.Pointer) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32, unsafe.Pointer) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X10))))) = _multiplexFileControl
	*(*func(*crt.TLS, *bin.Xsqlite3_file) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X11))))) = _multiplexSectorSize
	*(*func(*crt.TLS, *bin.Xsqlite3_file) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2))).X12))))) = _multiplexDeviceCharacteristics
	*(*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X3))) = _gMultiplex.X2
	*(*int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X3))).X0))) = i32(2)
	*(*func(*crt.TLS, *bin.Xsqlite3_file, int32, int32, int32, *unsafe.Pointer) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32, int32, int32, *unsafe.Pointer) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X3))).X13))))) = _multiplexShmMap
	*(*func(*crt.TLS, *bin.Xsqlite3_file, int32, int32, int32) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32, int32, int32) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X3))).X14))))) = _multiplexShmLock
	*(*func(*crt.TLS, *bin.Xsqlite3_file))(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer))(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X3))).X15))))) = _multiplexShmBarrier
	*(*func(*crt.TLS, *bin.Xsqlite3_file, int32) int32)(unsafe.Pointer((*func(*crt.TLS, unsafe.Pointer, int32) int32)(unsafe.Pointer(&((*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X3))).X16))))) = _multiplexShmUnmap
	bin.Xsqlite3_vfs_register(tls, (*bin.Xsqlite3_vfs)(unsafe.Pointer(&(_gMultiplex.X1))), _makeDefault)
	bin.Xsqlite3_auto_extension(tls, *(*func(*crt.TLS))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, **int8, *bin.Xsqlite3_api_routines) int32
	}{_multiplexFuncInit})))
	return i32(0)
}

var _gMultiplex t5

var _sqlite3_multiplex_initializeØ00__func__Ø000 [29]int8

func init() {
	crt.Xstrncpy(nil, &_sqlite3_multiplex_initializeØ00__func__Ø000[0], str(6804), 29)
}

// This is the xOpen method used for the "multiplex" VFS.
//
// Most of the work is done by the underlying original VFS.  This method
// simply links the new file into the appropriate multiplex group if it is a
// file that needs to be tracked.
func _multiplexOpen(tls *crt.TLS, _pVfs *bin.Xsqlite3_vfs, _zName *int8, _pConn *bin.Xsqlite3_file, _flags int32, _pOutFlags *int32) (r0 int32) {
	var _rc, _nName, _sz, _9_bExists, _12_iChunk int32
	var _8_sz64 int64
	var _zToFree, _3_zUri, _4_p *int8
	var _pSubOpen *bin.Xsqlite3_file
	var _pOrigVfs *bin.Xsqlite3_vfs
	var _pGroup *XmultiplexGroup
	var _pMultiplexOpen *XmultiplexConn
	_rc = i32(0)
	_pGroup = nil
	_pSubOpen = nil
	_pOrigVfs = (*bin.Xsqlite3_vfs)(_gMultiplex.X0)
	_nName = i32(0)
	_sz = i32(0)
	_zToFree = nil

	crt.Xmemset(tls, (unsafe.Pointer)(_pConn), i32(0), uint32(_pVfs.X1))
	func() {
		if _zName == nil && (_flags&i32(8)) == 0 {
			crt.X__builtin_fprintf(tls, Xstderr, str(991), unsafe.Pointer(str(6703)), i32(484), unsafe.Pointer((*int8)(unsafe.Pointer(&_multiplexOpenØ00__func__Ø000))), unsafe.Pointer(str(6833)))
			crt.X__builtin_abort(tls)
		}
	}()
	_pMultiplexOpen = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	if _rc != i32(0) {
		goto _3
	}
	_nName = func() int32 {
		if _zName != nil {
			return _multiplexStrlen30(tls, _zName)
		}
		return i32(0)
	}()
	_sz = int32((u32(28) + uint32(_nName)) + uint32(i32(1)))
	_pGroup = (*XmultiplexGroup)(bin.Xsqlite3_malloc64(tls, uint64(_sz)))
	if _pGroup == nil {
		_rc = i32(7)
	}
_3:
	if _rc != i32(0) {
		goto _7
	}
	_3_zUri = func() *int8 {
		if (_flags & i32(64)) != 0 {
			return _zName
		}
		return nil
	}()
	crt.Xmemset(tls, (unsafe.Pointer)(_pGroup), i32(0), uint32(_sz))
	*(**XmultiplexGroup)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&(_pMultiplexOpen.X1))))) = _pGroup
	*(*uint8)(unsafe.Pointer(&(_pGroup.X6))) = u8(255)
	*(*uint8)(unsafe.Pointer(&(_pGroup.X7))) = uint8(bin.Xsqlite3_uri_boolean(tls, _3_zUri, str(6878), bool2int((_flags&i32(256)) == i32(0))))
	*(*uint32)(unsafe.Pointer(&(_pGroup.X5))) = uint32(int32(bin.Xsqlite3_uri_int64(tls, _3_zUri, str(6887), int64(i32(2147418112)))))
	*(*uint32)(unsafe.Pointer(&(_pGroup.X5))) = ((_pGroup.X5) + uint32(i32(65535))) & uint32(i32(-65536))
	if _zName != nil {
		_4_p = (*int8)(unsafe.Pointer((*XmultiplexGroup)(unsafe.Pointer(uintptr((unsafe.Pointer)(_pGroup)) + 28*uintptr(i32(1))))))
		*(**int8)(unsafe.Pointer(&(_pGroup.X2))) = _4_p
		crt.Xmemcpy(tls, (unsafe.Pointer)(_pGroup.X2), (unsafe.Pointer)(_zName), uint32(_nName+i32(1)))
		*(*int32)(unsafe.Pointer(&(_pGroup.X3))) = _nName
	}
	if (_pGroup.X6) == 0 {
		goto _11
	}
_12:
	if (uint32(bin.Xsqlite3PendingByte()) % (_pGroup.X5)) >= ((_pGroup.X5) - uint32(i32(65536))) {
		{
			p := (*uint32)(unsafe.Pointer(&(_pGroup.X5)))
			*p = (*p) + uint32(i32(65536))
			sink0(*p)
		}
		goto _12
	}
_11:
	*(*int32)(unsafe.Pointer(&(_pGroup.X4))) = _flags
	_rc = _multiplexSubFilename(tls, _pGroup, i32(1))
	if _rc != i32(0) {
		goto _14
	}
	_pSubOpen = _multiplexSubOpen(tls, _pGroup, i32(0), &_rc, _pOutFlags, i32(0))
	if (_pSubOpen == nil) && (_rc == i32(0)) {
		_rc = i32(14)
	}
_14:
	if _rc != i32(0) {
		goto _17
	}
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, *int64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int64) int32
	}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X6)})))(tls, _pSubOpen, &_8_sz64)
	if _rc != i32(0) || _zName == nil {
		goto _19
	}
	if (_flags & i32(16384)) != 0 {
		*(*uint8)(unsafe.Pointer(&(_pGroup.X6))) = uint8(i32(0))
		goto _29
	}
	if _8_sz64 != int64(i32(0)) {
		goto _22
	}
	if (_flags & i32(2048)) == 0 {
		goto _23
	}
	_12_iChunk = i32(1)
_24:
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32, *int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8, int32, *int32) int32
	}{(_pOrigVfs.X8)})))(tls, _pOrigVfs, (*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_12_iChunk))).X1, i32(0), &_9_bExists)
	if _rc != i32(0) || _9_bExists == 0 {
		goto _26
	}
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8, int32) int32
	}{(_pOrigVfs.X7)})))(tls, _pOrigVfs, (*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_12_iChunk))).X1, i32(0))
	if _rc == i32(0) {
		_rc = _multiplexSubFilename(tls, _pGroup, preInc3(&_12_iChunk, 1))
	}
_26:
	if (_rc == i32(0)) && _9_bExists != 0 {
		goto _24
	}
_23:
	goto _29
_22:
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32, *int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8, int32, *int32) int32
	}{(_pOrigVfs.X8)})))(tls, _pOrigVfs, (*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(i32(1)))).X1, i32(0), &_9_bExists)
	_9_bExists = bool2int(_multiplexSubSize(tls, _pGroup, i32(1), &_rc) > int64(i32(0)))
	if ((((_rc == i32(0)) && _9_bExists != 0) && (_8_sz64 == (_8_sz64 & int64(u32(4294901760))))) && (_8_sz64 > int64(i32(0)))) && (_8_sz64 != int64(_pGroup.X5)) {
		*(*uint32)(unsafe.Pointer(&(_pGroup.X5))) = uint32(int32(_8_sz64))
		goto _38
	}
	if ((_rc == i32(0)) && (_9_bExists == 0)) && (_8_sz64 > int64(_pGroup.X5)) {
		*(*uint8)(unsafe.Pointer(&(_pGroup.X6))) = uint8(i32(0))
	}
_38:
_29:
_19:
_17:
	if _rc != i32(0) {
		goto _39
	}
	if ((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X0) == i32(1) {
		*(**bin.Xsqlite3_io_methods)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&((*bin.Xsqlite3_file)(unsafe.Pointer(&(_pMultiplexOpen.X0))).X0))))) = (*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X2)))
		goto _41
	}
	*(**bin.Xsqlite3_io_methods)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&((*bin.Xsqlite3_file)(unsafe.Pointer(&(_pMultiplexOpen.X0))).X0))))) = (*bin.Xsqlite3_io_methods)(unsafe.Pointer(&(_gMultiplex.X3)))
_41:
	goto _42
_39:
	_multiplexFreeComponents(tls, _pGroup)
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_pGroup))
_42:
_7:
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_zToFree))
	return _rc
}

var _multiplexOpenØ00__func__Ø000 [14]int8

func init() {
	crt.Xstrncpy(nil, &_multiplexOpenØ00__func__Ø000[0], str(6897), 14)
}

// ************************ Utility Routines ********************************

// Compute a string length that is limited to what can be stored in
// lower 30 bits of a 32-bit signed integer.
//
// The value returned will never be negative.  Nor will it ever be greater
// than the actual length of the string.  For very long strings (greater
// than 1GiB) the value returned might be less than the true string length.
func _multiplexStrlen30(tls *crt.TLS, _z *int8) (r0 int32) {
	var _z2 *int8
	_z2 = _z
	if _z == nil {
		return i32(0)
	}
_0:
	if (*_z2) != 0 {
		*(*uintptr)(unsafe.Pointer(&_z2)) += uintptr(1)
		goto _0
	}
	return i32(1073741823) & int32((uintptr(unsafe.Pointer(_z2))-uintptr(unsafe.Pointer(_z)))/1)
}

// Compute the filename for the iChunk-th chunk
func _multiplexSubFilename(tls *crt.TLS, _pGroup *XmultiplexGroup, _iChunk int32) (r0 int32) {
	var _3_n int32
	var _3_z *int8
	var _1_p *bin.XanalysisInfo
	if _iChunk < (_pGroup.X1) {
		goto _0
	}
	_1_p = (*bin.XanalysisInfo)(bin.Xsqlite3_realloc64(tls, _pGroup.X0, uint64(uint32(_iChunk+i32(1))*u32(8))))
	if _1_p == nil {
		return i32(7)
	}
	crt.Xmemset(tls, (unsafe.Pointer)((*bin.XanalysisInfo)(unsafe.Pointer(uintptr((unsafe.Pointer)(_1_p))+8*uintptr(_pGroup.X1)))), i32(0), u32(8)*uint32((_iChunk+i32(1))-(_pGroup.X1)))
	*(**bin.XanalysisInfo)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&(_pGroup.X0))))) = _1_p
	*(*int32)(unsafe.Pointer(&(_pGroup.X1))) = _iChunk + i32(1)
_0:
	if (_pGroup.X2) == nil || ((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_iChunk))).X1) != nil {
		goto _3
	}
	_3_n = _pGroup.X3
	*(**int8)(unsafe.Pointer(&((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0) + 8*uintptr(_iChunk))).X1))) = store6(&_3_z, (*int8)(bin.Xsqlite3_malloc64(tls, uint64(_3_n+i32(5)))))
	if _3_z == nil {
		return i32(7)
	}
	_multiplexFilename(tls, _pGroup.X2, _pGroup.X3, _pGroup.X4, _iChunk, _3_z)
_3:
	return i32(0)
}

// Generate the file-name for chunk iChunk of the group with base name
// zBase. The file-name is written to buffer zOut before returning. Buffer
// zOut must be allocated by the caller so that it is at least (nBase+5)
// bytes in size, where nBase is the length of zBase, not including the
// nul-terminator.
//
// If iChunk is 0 (or 400 - the number for the first journal file chunk),
// the output is a copy of the input string. Otherwise, if
// SQLITE_ENABLE_8_3_NAMES is not defined or the input buffer does not contain
// a "." character, then the output is a copy of the input string with the
// three-digit zero-padded decimal representation if iChunk appended to it.
// For example:
//
// zBase="test.db", iChunk=4  ->  zOut="test.db004"
//
// Or, if SQLITE_ENABLE_8_3_NAMES is defined and the input buffer contains
// a "." character, then everything after the "." is replaced by the
// three-digit representation of iChunk.
//
// zBase="test.db", iChunk=4  ->  zOut="test.004"
//
// The output buffer string is terminated by 2 0x00 bytes. This makes it safe
// to pass to sqlite3_uri_parameter() and similar.
func _multiplexFilename(tls *crt.TLS, _zBase *int8, _nBase int32, _flags int32, _iChunk int32, _zOut *int8) {
	var _n int32
	_n = _nBase
	crt.Xmemcpy(tls, (unsafe.Pointer)(_zOut), (unsafe.Pointer)(_zBase), uint32(_n+i32(1)))
	if (_iChunk != i32(0)) && (_iChunk <= i32(299)) {
		bin.Xsqlite3_snprintf(tls, i32(4), (*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_zOut))+1*uintptr(_n))), str(6911), _iChunk)
		{
			p := &_n
			*p = (*p) + i32(3)
			sink3(*p)
		}
	}
	func() {
		if int32(*(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_zOut)) + 1*uintptr(_n)))) != i32(0) {
			crt.X__builtin_fprintf(tls, Xstderr, str(991), unsafe.Pointer(str(6703)), i32(250), unsafe.Pointer((*int8)(unsafe.Pointer(&_multiplexFilenameØ00__func__Ø000))), unsafe.Pointer(str(6916)))
			crt.X__builtin_abort(tls)
		}
	}()
	*(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_zOut)) + 1*uintptr(_n+i32(1)))) = int8(i32(0))
}

var _multiplexFilenameØ00__func__Ø000 [18]int8

func init() {
	crt.Xstrncpy(nil, &_multiplexFilenameØ00__func__Ø000[0], str(6930), 18)
}

// Translate an sqlite3_file* that is really a multiplexGroup* into
// the sqlite3_file* for the underlying original VFS.
//
// For chunk 0, the pGroup->flags determines whether or not a new file
// is created if it does not already exist.  For chunks 1 and higher, the
// file is created only if createFlag is 1.
func _multiplexSubOpen(tls *crt.TLS, _pGroup *XmultiplexGroup, _iChunk int32, _rc *int32, _pOutFlags *int32, _createFlag int32) (r0 *bin.Xsqlite3_file) {
	var _1_flags, _1_bExists int32
	var _pSubOpen *bin.Xsqlite3_file
	var _pOrigVfs *bin.Xsqlite3_vfs
	_pSubOpen = nil
	_pOrigVfs = (*bin.Xsqlite3_vfs)(_gMultiplex.X0)
	*_rc = _multiplexSubFilename(tls, _pGroup, _iChunk)
	if (*_rc) != i32(0) || store7(&_pSubOpen, (*bin.Xsqlite3_file)((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_iChunk))).X0)) != nil {
		goto _1
	}
	_1_flags = _pGroup.X4
	if _createFlag != 0 {
		{
			p := &_1_flags
			*p = (*p) | i32(4)
			sink3(*p)
		}
		goto _7
	}
	if _iChunk == i32(0) {
		goto _7
	}
	if ((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0) + 8*uintptr(_iChunk))).X1) == nil {
		return nil
	}
	*_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32, *int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8, int32, *int32) int32
	}{(_pOrigVfs.X8)})))(tls, _pOrigVfs, (*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_iChunk))).X1, i32(0), &_1_bExists)
	if (*_rc) == 0 && _1_bExists != 0 {
		goto _9
	}
	if (*_rc) != 0 {
		bin.Xsqlite3_log(tls, *_rc, str(6948), unsafe.Pointer((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_iChunk))).X1))
	}
	return nil

_9:
	{
		p := &_1_flags
		*p = (*p) & i32(-5)
		sink3(*p)
	}
_7:
	_pSubOpen = (*bin.Xsqlite3_file)(bin.Xsqlite3_malloc64(tls, uint64(_pOrigVfs.X1)))
	if _pSubOpen == nil {
		*_rc = i32(3082)
		return nil
	}
	*(**bin.Xsqlite3_file)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0) + 8*uintptr(_iChunk))).X0))))) = _pSubOpen
	*_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, *bin.Xsqlite3_file, int32, *int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8, unsafe.Pointer, int32, *int32) int32
	}{(_pOrigVfs.X6)})))(tls, _pOrigVfs, (*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_iChunk))).X1, _pSubOpen, _1_flags, _pOutFlags)
	if (*_rc) != i32(0) {
		bin.Xsqlite3_log(tls, *_rc, str(6982), unsafe.Pointer((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_iChunk))).X1))
		bin.Xsqlite3_free(tls, (unsafe.Pointer)(_pSubOpen))
		*(**bin.Xsqlite3_file)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0) + 8*uintptr(_iChunk))).X0))))) = nil
		return nil
	}
_1:
	return _pSubOpen
}

// Return the size, in bytes, of chunk number iChunk.  If that chunk
// does not exist, then return 0.  This function does not distingish between
// non-existant files and zero-length files.
func _multiplexSubSize(tls *crt.TLS, _pGroup *XmultiplexGroup, _iChunk int32, _rc *int32) (r0 int64) {
	var _sz int64
	var _pSub *bin.Xsqlite3_file
	_sz = i64(0)
	if (*_rc) != 0 {
		return int64(i32(0))
	}
	_pSub = _multiplexSubOpen(tls, _pGroup, _iChunk, _rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _pSub == nil {
		return int64(i32(0))
	}
	*_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, *int64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int64) int32
	}{((*bin.Xsqlite3_io_methods)(_pSub.X0).X6)})))(tls, _pSub, &_sz)
	return _sz
}

// Deallocate memory held by a multiplexGroup
func _multiplexFreeComponents(tls *crt.TLS, _pGroup *XmultiplexGroup) {
	var _i int32
	_i = i32(0)
_0:
	if _i >= (_pGroup.X1) {
		goto _3
	}
	_multiplexSubClose(tls, _pGroup, _i, nil)
	_i += 1
	goto _0
_3:
	bin.Xsqlite3_free(tls, _pGroup.X0)
	*(**bin.XanalysisInfo)(unsafe.Pointer((*unsafe.Pointer)(unsafe.Pointer(&(_pGroup.X0))))) = nil
	*(*int32)(unsafe.Pointer(&(_pGroup.X1))) = i32(0)
}

// Close a single sub-file in the connection group.
func _multiplexSubClose(tls *crt.TLS, _pGroup *XmultiplexGroup, _iChunk int32, _pOrigVfs *bin.Xsqlite3_vfs) {
	var _pSubOpen *bin.Xsqlite3_file
	_pSubOpen = (*bin.Xsqlite3_file)((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0) + 8*uintptr(_iChunk))).X0)
	if _pSubOpen == nil {
		goto _0
	}
	(*(*func(*crt.TLS, *bin.Xsqlite3_file) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer) int32
	}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X1)})))(tls, _pSubOpen)
	if (_pOrigVfs != nil) && (((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0) + 8*uintptr(_iChunk))).X1) != nil) {
		(*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, *int8, int32) int32
		}{(_pOrigVfs.X7)})))(tls, _pOrigVfs, (*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_iChunk))).X1, i32(0))
	}
	bin.Xsqlite3_free(tls, (*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_iChunk))).X0)
_0:
	bin.Xsqlite3_free(tls, (unsafe.Pointer)((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_iChunk))).X1))
	crt.Xmemset(tls, (unsafe.Pointer)((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0)+8*uintptr(_iChunk)))), i32(0), u32(8))
}

// This is the xDelete method used for the "multiplex" VFS.
// It attempts to delete the filename specified.
func _multiplexDelete(tls *crt.TLS, _pVfs *bin.Xsqlite3_vfs, _zName *int8, _syncDir int32) (r0 int32) {
	var _rc, _1_nName, _3_iChunk, _3_bExists int32
	var _1_z *int8
	var _pOrigVfs *bin.Xsqlite3_vfs
	_pOrigVfs = (*bin.Xsqlite3_vfs)(_gMultiplex.X0)
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8, int32) int32
	}{(_pOrigVfs.X7)})))(tls, _pOrigVfs, _zName, _syncDir)
	if _rc != i32(0) {
		goto _0
	}
	_1_nName = int32(crt.Xstrlen(tls, _zName))
	_1_z = (*int8)(bin.Xsqlite3_malloc64(tls, uint64(_1_nName+i32(5))))
	if _1_z == nil {
		_rc = i32(3082)
		goto _2
	}
	_3_iChunk = i32(0)
_3:
	_multiplexFilename(tls, _zName, _1_nName, i32(2048), preInc3(&_3_iChunk, 1), _1_z)
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32, *int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8, int32, *int32) int32
	}{(_pOrigVfs.X8)})))(tls, _pOrigVfs, _1_z, i32(0), &_3_bExists)
	if (_rc == i32(0)) && _3_bExists != 0 {
		goto _3
	}
_5:
	if (_rc == i32(0)) && (_3_iChunk > i32(1)) {
		_multiplexFilename(tls, _zName, _1_nName, i32(2048), preInc3(&_3_iChunk, -1), _1_z)
		_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, *int8, int32) int32
		}{(_pOrigVfs.X7)})))(tls, _pOrigVfs, _1_z, _syncDir)
		goto _5
	}
	if _rc != i32(0) {
		goto _8
	}
	_3_iChunk = i32(0)
_9:
	_multiplexFilename(tls, _zName, _1_nName, i32(524288), preInc3(&_3_iChunk, 1), _1_z)
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32, *int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8, int32, *int32) int32
	}{(_pOrigVfs.X8)})))(tls, _pOrigVfs, _1_z, i32(0), &_3_bExists)
	if (_rc == i32(0)) && _3_bExists != 0 {
		goto _9
	}
_11:
	if (_rc == i32(0)) && (_3_iChunk > i32(1)) {
		_multiplexFilename(tls, _zName, _1_nName, i32(524288), preInc3(&_3_iChunk, -1), _1_z)
		_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, *int8, int32) int32
		}{(_pOrigVfs.X7)})))(tls, _pOrigVfs, _1_z, _syncDir)
		goto _11
	}
_8:
_2:
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_1_z))
_0:
	return _rc
}

func _multiplexAccess(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b *int8, _c int32, _d *int32) (r0 int32) {
	return (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32, *int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8, int32, *int32) int32
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X8)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b, _c, _d)
}

func _multiplexFullPathname(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b *int8, _c int32, _d *int8) (r0 int32) {
	return (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8, int32, *int8) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8, int32, *int8) int32
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X9)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b, _c, _d)
}

func _multiplexDlOpen(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b *int8) (r0 unsafe.Pointer) {
	return (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int8) unsafe.Pointer)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int8) unsafe.Pointer
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X10)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b)
}

func _multiplexDlError(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b int32, _c *int8) {
	(*(*func(*crt.TLS, *bin.Xsqlite3_vfs, int32, *int8))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int32, *int8)
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X11)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b, _c)
}

func _multiplexDlSym(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b unsafe.Pointer, _c *int8) (r0 func(*crt.TLS)) {
	return (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, unsafe.Pointer, *int8) func(*crt.TLS))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, *int8) func(*crt.TLS)
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X12)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b, _c)
}

func _multiplexDlClose(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b unsafe.Pointer) {
	(*(*func(*crt.TLS, *bin.Xsqlite3_vfs, unsafe.Pointer))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, unsafe.Pointer)
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X13)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b)
}

func _multiplexRandomness(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b int32, _c *int8) (r0 int32) {
	return (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, int32, *int8) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int32, *int8) int32
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X14)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b, _c)
}

func _multiplexSleep(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b int32) (r0 int32) {
	return (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int32) int32
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X15)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b)
}

func _multiplexCurrentTime(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b *float64) (r0 int32) {
	return (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *float64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *float64) int32
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X16)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b)
}

func _multiplexGetLastError(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b int32, _c *int8) (r0 int32) {
	if (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, int32, *int8) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int32, *int8) int32
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X17)}))) != nil {
		return (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, int32, *int8) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, int32, *int8) int32
		}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X17)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b, _c)
	}
	return i32(0)
}

func _multiplexCurrentTimeInt64(tls *crt.TLS, _a *bin.Xsqlite3_vfs, _b *int64) (r0 int32) {
	return (*(*func(*crt.TLS, *bin.Xsqlite3_vfs, *int64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int64) int32
	}{((*bin.Xsqlite3_vfs)(_gMultiplex.X0).X18)})))(tls, (*bin.Xsqlite3_vfs)(_gMultiplex.X0), _b)
}

// xClose requests get passed through to the original VFS.
// We loop over all open chunk handles and close them.
// The group structure for this file is unlinked from
// our list of groups and freed.
func _multiplexClose(tls *crt.TLS, _pConn *bin.Xsqlite3_file) (r0 int32) {
	var _rc int32
	var _pGroup *XmultiplexGroup
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pGroup = (*XmultiplexGroup)(_p.X1)
	_rc = i32(0)
	_multiplexFreeComponents(tls, _pGroup)
	bin.Xsqlite3_free(tls, (unsafe.Pointer)(_pGroup))
	return _rc
}

// Pass xRead requests thru to the original VFS after
// determining the correct chunk to operate on.
// Break up reads across chunk boundaries.
func _multiplexRead(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _pBuf unsafe.Pointer, _iAmt int32, _iOfst int64) (r0 int32) {
	var _rc, _5_i, _6_extra int32
	var _1_pSubOpen, _5_pSubOpen *bin.Xsqlite3_file
	var _pGroup *XmultiplexGroup
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pGroup = (*XmultiplexGroup)(_p.X1)
	_rc = i32(0)
	if (_pGroup.X6) != 0 {
		goto _0
	}
	_1_pSubOpen = _multiplexSubOpen(tls, _pGroup, i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _1_pSubOpen == nil {
		_rc = i32(266)
		goto _2
	}
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, unsafe.Pointer, int32, int64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32, int64) int32
	}{((*bin.Xsqlite3_io_methods)(_1_pSubOpen.X0).X2)})))(tls, _1_pSubOpen, _pBuf, _iAmt, _iOfst)
_2:
	goto _3
_0:
_4:
	if _iAmt <= i32(0) {
		goto _5
	}
	_5_i = int32(_iOfst / int64(_pGroup.X5))
	_5_pSubOpen = _multiplexSubOpen(tls, _pGroup, _5_i, &_rc, (*int32)(unsafe.Pointer(nil)), i32(1))
	if _5_pSubOpen == nil {
		goto _6
	}
	_6_extra = int32(uint32(int32(_iOfst%int64(_pGroup.X5))+_iAmt) - (_pGroup.X5))
	if _6_extra < i32(0) {
		_6_extra = i32(0)
	}
	{
		p := &_iAmt
		*p = (*p) - _6_extra
		sink3(*p)
	}
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, unsafe.Pointer, int32, int64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32, int64) int32
	}{((*bin.Xsqlite3_io_methods)(_5_pSubOpen.X0).X2)})))(tls, _5_pSubOpen, _pBuf, _iAmt, _iOfst%int64(_pGroup.X5))
	if _rc != i32(0) {
		goto _5
	}
	_pBuf = (unsafe.Pointer)((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(_pBuf))) + uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(_iAmt))))))))
	{
		p := &_iOfst
		*p = (*p) + int64(_iAmt)
		sink4(*p)
	}
	_iAmt = _6_extra
	goto _9
_6:
	_rc = i32(266)
	goto _5
_9:
	goto _4
_5:
_3:
	return _rc
}

// Pass xWrite requests thru to the original VFS after
// determining the correct chunk to operate on.
// Break up writes across chunk boundaries.
func _multiplexWrite(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _pBuf unsafe.Pointer, _iAmt int32, _iOfst int64) (r0 int32) {
	var _rc, _5_i, _6_extra int32
	var _1_pSubOpen, _5_pSubOpen *bin.Xsqlite3_file
	var _pGroup *XmultiplexGroup
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pGroup = (*XmultiplexGroup)(_p.X1)
	_rc = i32(0)
	if (_pGroup.X6) != 0 {
		goto _0
	}
	_1_pSubOpen = _multiplexSubOpen(tls, _pGroup, i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _1_pSubOpen == nil {
		_rc = i32(778)
		goto _2
	}
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, unsafe.Pointer, int32, int64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32, int64) int32
	}{((*bin.Xsqlite3_io_methods)(_1_pSubOpen.X0).X3)})))(tls, _1_pSubOpen, _pBuf, _iAmt, _iOfst)
_2:
	goto _3
_0:
_4:
	if _rc != i32(0) || _iAmt <= i32(0) {
		goto _5
	}
	_5_i = int32(_iOfst / int64(_pGroup.X5))
	_5_pSubOpen = _multiplexSubOpen(tls, _pGroup, _5_i, &_rc, (*int32)(unsafe.Pointer(nil)), i32(1))
	if _5_pSubOpen == nil {
		goto _7
	}
	_6_extra = int32(uint32(int32(_iOfst%int64(_pGroup.X5))+_iAmt) - (_pGroup.X5))
	if _6_extra < i32(0) {
		_6_extra = i32(0)
	}
	{
		p := &_iAmt
		*p = (*p) - _6_extra
		sink3(*p)
	}
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, unsafe.Pointer, int32, int64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32, int64) int32
	}{((*bin.Xsqlite3_io_methods)(_5_pSubOpen.X0).X3)})))(tls, _5_pSubOpen, _pBuf, _iAmt, _iOfst%int64(_pGroup.X5))
	_pBuf = (unsafe.Pointer)((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(_pBuf))) + uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(_iAmt))))))))
	{
		p := &_iOfst
		*p = (*p) + int64(_iAmt)
		sink4(*p)
	}
	_iAmt = _6_extra
_7:
	goto _4
_5:
_3:
	return _rc
}

// Pass xTruncate requests thru to the original VFS after
// determining the correct chunk to operate on.  Delete any
// chunks above the truncate mark.
func _multiplexTruncate(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _size int64) (r0 int32) {
	var _rc, _4_i, _4_iBaseGroup int32
	var _1_pSubOpen, _4_pSubOpen *bin.Xsqlite3_file
	var _4_pOrigVfs *bin.Xsqlite3_vfs
	var _pGroup *XmultiplexGroup
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pGroup = (*XmultiplexGroup)(_p.X1)
	_rc = i32(0)
	if (_pGroup.X6) != 0 {
		goto _0
	}
	_1_pSubOpen = _multiplexSubOpen(tls, _pGroup, i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _1_pSubOpen == nil {
		_rc = i32(1546)
		goto _2
	}
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, int64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int64) int32
	}{((*bin.Xsqlite3_io_methods)(_1_pSubOpen.X0).X4)})))(tls, _1_pSubOpen, _size)
_2:
	goto _3
_0:
	_4_iBaseGroup = int32(_size / int64(_pGroup.X5))
	_4_pOrigVfs = (*bin.Xsqlite3_vfs)(_gMultiplex.X0)
	_4_i = (_pGroup.X1) - i32(1)
_4:
	if _4_i <= _4_iBaseGroup || _rc != i32(0) {
		goto _8
	}
	if (_pGroup.X7) != 0 {
		_multiplexSubClose(tls, _pGroup, _4_i, _4_pOrigVfs)
		goto _10
	}
	_4_pSubOpen = _multiplexSubOpen(tls, _pGroup, _4_i, &_rc, nil, i32(0))
	if _4_pSubOpen != nil {
		_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, int64) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, int64) int32
		}{((*bin.Xsqlite3_io_methods)(_4_pSubOpen.X0).X4)})))(tls, _4_pSubOpen, int64(i32(0)))
	}
_10:
	_4_i -= 1
	goto _4
_8:
	if _rc != i32(0) {
		goto _12
	}
	_4_pSubOpen = _multiplexSubOpen(tls, _pGroup, _4_iBaseGroup, &_rc, nil, i32(0))
	if _4_pSubOpen != nil {
		_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, int64) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, int64) int32
		}{((*bin.Xsqlite3_io_methods)(_4_pSubOpen.X0).X4)})))(tls, _4_pSubOpen, _size%int64(_pGroup.X5))
	}
_12:
	if _rc != 0 {
		_rc = i32(1546)
	}
_3:
	return _rc
}

// Pass xSync requests through to the original VFS without change
func _multiplexSync(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _flags int32) (r0 int32) {
	var _rc, _i, _2_rc2 int32
	var _1_pSubOpen *bin.Xsqlite3_file
	var _pGroup *XmultiplexGroup
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pGroup = (*XmultiplexGroup)(_p.X1)
	_rc = i32(0)
	_i = i32(0)
_0:
	if _i >= (_pGroup.X1) {
		goto _3
	}
	_1_pSubOpen = (*bin.Xsqlite3_file)((*bin.XanalysisInfo)(unsafe.Pointer(uintptr(_pGroup.X0) + 8*uintptr(_i))).X0)
	if _1_pSubOpen == nil {
		goto _4
	}
	_2_rc2 = (*(*func(*crt.TLS, *bin.Xsqlite3_file, int32) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int32) int32
	}{((*bin.Xsqlite3_io_methods)(_1_pSubOpen.X0).X5)})))(tls, _1_pSubOpen, _flags)
	if _2_rc2 != i32(0) {
		_rc = _2_rc2
	}
_4:
	_i += 1
	goto _0
_3:
	return _rc
}

// Pass xFileSize requests through to the original VFS.
// Aggregate the size of all the chunks before returning.
func _multiplexFileSize(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _pSize *int64) (r0 int32) {
	var _rc, _i int32
	var _5_sz int64
	var _1_pSubOpen *bin.Xsqlite3_file
	var _pGroup *XmultiplexGroup
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pGroup = (*XmultiplexGroup)(_p.X1)
	_rc = i32(0)
	if (_pGroup.X6) != 0 {
		goto _0
	}
	_1_pSubOpen = _multiplexSubOpen(tls, _pGroup, i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _1_pSubOpen == nil {
		_rc = i32(1802)
		goto _2
	}
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, *int64) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, *int64) int32
	}{((*bin.Xsqlite3_io_methods)(_1_pSubOpen.X0).X6)})))(tls, _1_pSubOpen, _pSize)
_2:
	goto _3
_0:
	*_pSize = int64(i32(0))
	_i = i32(0)
_4:
	if _rc != i32(0) {
		goto _7
	}
	_5_sz = _multiplexSubSize(tls, _pGroup, _i, &_rc)
	if _5_sz == int64(i32(0)) {
		goto _7
	}
	*_pSize = (int64(_i) * int64(_pGroup.X5)) + _5_sz
	_i += 1
	goto _4
_7:
_3:
	return _rc
}

// Pass xLock requests through to the original VFS unchanged.
func _multiplexLock(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _lock int32) (r0 int32) {
	var _rc int32
	var _pSubOpen *bin.Xsqlite3_file
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pSubOpen = _multiplexSubOpen(tls, (*XmultiplexGroup)(_p.X1), i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _pSubOpen != nil {
		return (*(*func(*crt.TLS, *bin.Xsqlite3_file, int32) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, int32) int32
		}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X7)})))(tls, _pSubOpen, _lock)
	}
	return i32(5)

	_ = _rc
	panic(0)
}

// Pass xUnlock requests through to the original VFS unchanged.
func _multiplexUnlock(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _lock int32) (r0 int32) {
	var _rc int32
	var _pSubOpen *bin.Xsqlite3_file
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pSubOpen = _multiplexSubOpen(tls, (*XmultiplexGroup)(_p.X1), i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _pSubOpen != nil {
		return (*(*func(*crt.TLS, *bin.Xsqlite3_file, int32) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, int32) int32
		}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X8)})))(tls, _pSubOpen, _lock)
	}
	return i32(2058)

	_ = _rc
	panic(0)
}

// Pass xCheckReservedLock requests through to the original VFS unchanged.
func _multiplexCheckReservedLock(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _pResOut *int32) (r0 int32) {
	var _rc int32
	var _pSubOpen *bin.Xsqlite3_file
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pSubOpen = _multiplexSubOpen(tls, (*XmultiplexGroup)(_p.X1), i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _pSubOpen != nil {
		return (*(*func(*crt.TLS, *bin.Xsqlite3_file, *int32) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, *int32) int32
		}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X9)})))(tls, _pSubOpen, _pResOut)
	}
	return i32(3594)

	_ = _rc
	panic(0)
}

// Pass xFileControl requests through to the original VFS unchanged,
// except for any MULTIPLEX_CTRL_* requests here.
func _multiplexFileControl(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _op int32, _pArg unsafe.Pointer) (r0 int32) {
	var _rc, _2_bEnabled int32
	var _3_szChunk uint32
	var _6_aFcntl **int8
	var _pSubOpen *bin.Xsqlite3_file
	var _pGroup *XmultiplexGroup
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pGroup = (*XmultiplexGroup)(_p.X1)
	_rc = i32(1)
	if (_gMultiplex.X4) == 0 {
		return i32(21)
	}
	switch _op {
	case i32(5):
		goto _5
	case i32(6):
		goto _5
	case i32(14):
		goto _7
	case i32(214014):
		goto _2
	case i32(214015):
		goto _3
	case i32(214016):
		goto _4
	default:
		goto _8
	}

_2:
	if _pArg != nil {
		_2_bEnabled = *(*int32)(_pArg)
		*(*uint8)(unsafe.Pointer(&(_pGroup.X6))) = uint8(_2_bEnabled)
		_rc = i32(0)
	}
	goto _10
_3:
	if _pArg == nil {
		goto _11
	}
	_3_szChunk = *(*uint32)(_pArg)
	if _3_szChunk < uint32(i32(1)) {
		_rc = i32(21)
		goto _13
	}
	_3_szChunk = _3_szChunk + uint32(i32(65535))
	{
		p := &_3_szChunk
		*p = (*p) & uint32(i32(-65536))
		sink0(*p)
	}
	*(*uint32)(unsafe.Pointer(&(_pGroup.X5))) = _3_szChunk
	_rc = i32(0)
_13:
_11:
	goto _10
_4:
	_rc = i32(0)
	goto _10
_5:
	_rc = i32(0)
	goto _10
_7:
	_6_aFcntl = (**int8)(_pArg)
	if (*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_6_aFcntl)) + 4*uintptr(i32(1))))) == nil || bin.Xsqlite3_stricmp(tls, *(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_6_aFcntl)) + 4*uintptr(i32(1)))), str(7014)) != i32(0) {
		goto _15
	}
	if (*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_6_aFcntl)) + 4*uintptr(i32(2))))) == nil || (*(*int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_6_aFcntl)) + 4*uintptr(i32(2)))))) + 1*uintptr(i32(0))))) == 0 {
		goto _17
	}
	if (bin.Xsqlite3_stricmp(tls, *(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_6_aFcntl)) + 4*uintptr(i32(2)))), str(7033)) == i32(0)) || (bin.Xsqlite3_stricmp(tls, *(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_6_aFcntl)) + 4*uintptr(i32(2)))), str(7036)) == i32(0)) {
		*(*uint8)(unsafe.Pointer(&(_pGroup.X7))) = uint8(i32(1))
		goto _22
	}
	if (bin.Xsqlite3_stricmp(tls, *(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_6_aFcntl)) + 4*uintptr(i32(2)))), str(7038)) == i32(0)) || (bin.Xsqlite3_stricmp(tls, *(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_6_aFcntl)) + 4*uintptr(i32(2)))), str(7042)) == i32(0)) {
		*(*uint8)(unsafe.Pointer(&(_pGroup.X7))) = uint8(i32(0))
	}
_22:
_17:
	*(**int8)(unsafe.Pointer(uintptr((unsafe.Pointer)(_6_aFcntl)) + 4*uintptr(i32(0)))) = bin.Xsqlite3_mprintf(tls, func() *int8 {
		if (_pGroup.X7) != 0 {
			return str(7033)
		}
		return str(7038)
	}())
	_rc = i32(0)
	goto _10
_15:
_8:
	_pSubOpen = _multiplexSubOpen(tls, _pGroup, i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _pSubOpen == nil {
		goto _25
	}
	_rc = (*(*func(*crt.TLS, *bin.Xsqlite3_file, int32, unsafe.Pointer) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int32, unsafe.Pointer) int32
	}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X10)})))(tls, _pSubOpen, _op, _pArg)
	if (_op == i32(12)) && (_rc == i32(0)) {
		*(**int8)(_pArg) = bin.Xsqlite3_mprintf(tls, str(7044), unsafe.Pointer(*(**int8)(_pArg)))
	}
_25:
	goto _10
_10:
	return _rc
}

// Pass xSectorSize requests through to the original VFS unchanged.
func _multiplexSectorSize(tls *crt.TLS, _pConn *bin.Xsqlite3_file) (r0 int32) {
	var _rc int32
	var _pSubOpen *bin.Xsqlite3_file
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pSubOpen = _multiplexSubOpen(tls, (*XmultiplexGroup)(_p.X1), i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if (_pSubOpen != nil) && ((*(*func(*crt.TLS, *bin.Xsqlite3_file) int32)(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer) int32
	}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X11)}))) != nil) {
		return (*(*func(*crt.TLS, *bin.Xsqlite3_file) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer) int32
		}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X11)})))(tls, _pSubOpen)
	}
	return i32(4096)

	_ = _rc
	panic(0)
}

// Pass xDeviceCharacteristics requests through to the original VFS unchanged.
func _multiplexDeviceCharacteristics(tls *crt.TLS, _pConn *bin.Xsqlite3_file) (r0 int32) {
	var _rc int32
	var _pSubOpen *bin.Xsqlite3_file
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pSubOpen = _multiplexSubOpen(tls, (*XmultiplexGroup)(_p.X1), i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _pSubOpen != nil {
		return (*(*func(*crt.TLS, *bin.Xsqlite3_file) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer) int32
		}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X12)})))(tls, _pSubOpen)
	}
	return i32(0)

	_ = _rc
	panic(0)
}

// Pass xShmMap requests through to the original VFS unchanged.
func _multiplexShmMap(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _iRegion int32, _szRegion int32, _bExtend int32, _pp *unsafe.Pointer) (r0 int32) {
	var _rc int32
	var _pSubOpen *bin.Xsqlite3_file
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pSubOpen = _multiplexSubOpen(tls, (*XmultiplexGroup)(_p.X1), i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _pSubOpen != nil {
		return (*(*func(*crt.TLS, *bin.Xsqlite3_file, int32, int32, int32, *unsafe.Pointer) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, int32, int32, int32, *unsafe.Pointer) int32
		}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X13)})))(tls, _pSubOpen, _iRegion, _szRegion, _bExtend, _pp)
	}
	return i32(10)

	_ = _rc
	panic(0)
}

// Pass xShmLock requests through to the original VFS unchanged.
func _multiplexShmLock(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _ofst int32, _n int32, _flags int32) (r0 int32) {
	var _rc int32
	var _pSubOpen *bin.Xsqlite3_file
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pSubOpen = _multiplexSubOpen(tls, (*XmultiplexGroup)(_p.X1), i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _pSubOpen != nil {
		return (*(*func(*crt.TLS, *bin.Xsqlite3_file, int32, int32, int32) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, int32, int32, int32) int32
		}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X14)})))(tls, _pSubOpen, _ofst, _n, _flags)
	}
	return i32(5)

	_ = _rc
	panic(0)
}

// Pass xShmBarrier requests through to the original VFS unchanged.
func _multiplexShmBarrier(tls *crt.TLS, _pConn *bin.Xsqlite3_file) {
	var _rc int32
	var _pSubOpen *bin.Xsqlite3_file
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pSubOpen = _multiplexSubOpen(tls, (*XmultiplexGroup)(_p.X1), i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _pSubOpen != nil {
		(*(*func(*crt.TLS, *bin.Xsqlite3_file))(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer)
		}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X15)})))(tls, _pSubOpen)
	}
	_ = _rc
}

// Pass xShmUnmap requests through to the original VFS unchanged.
func _multiplexShmUnmap(tls *crt.TLS, _pConn *bin.Xsqlite3_file, _deleteFlag int32) (r0 int32) {
	var _rc int32
	var _pSubOpen *bin.Xsqlite3_file
	var _p *XmultiplexConn
	_p = (*XmultiplexConn)(unsafe.Pointer(_pConn))
	_pSubOpen = _multiplexSubOpen(tls, (*XmultiplexGroup)(_p.X1), i32(0), &_rc, (*int32)(unsafe.Pointer(nil)), i32(0))
	if _pSubOpen != nil {
		return (*(*func(*crt.TLS, *bin.Xsqlite3_file, int32) int32)(unsafe.Pointer(&struct {
			f func(*crt.TLS, unsafe.Pointer, int32) int32
		}{((*bin.Xsqlite3_io_methods)(_pSubOpen.X0).X16)})))(tls, _pSubOpen, _deleteFlag)
	}
	return i32(0)

	_ = _rc
	panic(0)
}

// This is the entry point to register the auto-extension for the
// multiplex_control() function.
func _multiplexFuncInit(tls *crt.TLS, _db unsafe.Pointer, _pzErrMsg **int8, _pApi *bin.Xsqlite3_api_routines) (r0 int32) {
	var _rc int32
	_rc = bin.Xsqlite3_create_function(tls, (*bin.Xsqlite3)(_db), str(7057), i32(2), i32(5), nil, *(*func(*crt.TLS, *bin.Xsqlite3_context, int32, **bin.XMem))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int32, *unsafe.Pointer)
	}{_multiplexControlFunc})), *(*func(*crt.TLS, *bin.Xsqlite3_context, int32, **bin.XMem))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer, int32, *unsafe.Pointer)
	}{nil})), *(*func(*crt.TLS, *bin.Xsqlite3_context))(unsafe.Pointer(&struct {
		f func(*crt.TLS, unsafe.Pointer)
	}{nil})))
	return _rc
}

// This is the implementation of the multiplex_control() SQL function.
func _multiplexControlFunc(tls *crt.TLS, _context unsafe.Pointer, _argc int32, _argv *unsafe.Pointer) {
	var _rc, _op, _iVal int32
	var _db unsafe.Pointer
	_rc = i32(0)
	_db = unsafe.Pointer(bin.Xsqlite3_context_db_handle(tls, (*bin.Xsqlite3_context)(_context)))
	_op = i32(0)
	if (_db == nil) || (_argc != i32(2)) {
		_rc = i32(1)
		goto _2
	}
	_op = bin.Xsqlite3_value_int(tls, (*bin.XMem)(*(*unsafe.Pointer)(unsafe.Pointer(uintptr((unsafe.Pointer)(_argv)) + 4*uintptr(i32(0))))))
	_iVal = bin.Xsqlite3_value_int(tls, (*bin.XMem)(*(*unsafe.Pointer)(unsafe.Pointer(uintptr((unsafe.Pointer)(_argv)) + 4*uintptr(i32(1))))))
	switch _op {
	case i32(1):
		goto _4
	case i32(2):
		goto _5
	case i32(3):
		goto _6
	default:
		goto _7
	}

_4:
	_op = i32(214014)
	goto _8
_5:
	_op = i32(214015)
	goto _8
_6:
	_op = i32(214016)
	goto _8
_7:
	_rc = i32(12)
	goto _8
_8:
_2:
	if _rc == i32(0) {
		_rc = bin.Xsqlite3_file_control(tls, (*bin.Xsqlite3)(_db), nil, _op, (unsafe.Pointer)(&_iVal))
	}
	bin.Xsqlite3_result_error_code(tls, (*bin.Xsqlite3_context)(_context), _rc)
	_ = _iVal
}

func bool2int(b bool) int32 {
	if b {
		return 1
	}
	return 0
}
func bug20530(interface{}) {} //TODO remove when https://github.com/golang/go/issues/20530 is fixed.
func i16(n int16) int16    { return n }
func i32(n int32) int32    { return n }
func i64(n int64) int64    { return n }
func i8(n int8) int8       { return n }
func init()                { nzf32 *= -1; nzf64 *= -1 }
func u16(n uint16) uint16  { return n }
func u32(n uint32) uint32  { return n }
func u64(n uint64) uint64  { return n }
func u8(n byte) byte       { return n }

var inf = math.Inf(1)
var nzf32 float32  // -0.0
var nzf64 float64  // -0.0
func sink2(*uint8) {} //TODO report GC bug
func sink3(int32)  {} //TODO report GC bug
func sink4(int64)  {} //TODO report GC bug
func sink0(uint32) {} //TODO report GC bug
func postInc2(p **uint8, d int) *uint8 {
	q := (*uintptr)(unsafe.Pointer(p))
	v := *q
	*q += uintptr(d)
	return (*uint8)(unsafe.Pointer(v))
}
func postInc3(p *int32, d int32) int32                                      { v := *p; *p += d; return v }
func preInc3(p *int32, d int32) int32                                       { v := *p + d; *p = v; return v }
func preInc0(p *uint32, d uint32) uint32                                    { v := *p + d; *p = v; return v }
func store6(p **int8, v *int8) *int8                                        { *p = v; return v }
func store7(p **bin.Xsqlite3_file, v *bin.Xsqlite3_file) *bin.Xsqlite3_file { *p = v; return v }
func store3(p *int32, v int32) int32                                        { *p = v; return v }
func store0(p *uint32, v uint32) uint32                                     { *p = v; return v }

type XmultiplexGroup struct {
	X0 unsafe.Pointer
	X1 int32
	X2 *int8
	X3 int32
	X4 int32
	X5 uint32
	X6 uint8
	X7 uint8
} // t8 struct{*struct{},int32,*int8,int32,int32,uint32,uint8,uint8}

type XmultiplexConn struct {
	X0 struct{ X0 unsafe.Pointer }
	X1 unsafe.Pointer
} // t9 struct{struct{*struct{}},*struct{}}

type XMD5Context struct {
	X0 int32
	X1 [4]uint32
	X2 [2]uint32
	X3 struct {
		X [0]struct {
			X0 [64]uint8
			X1 [16]uint32
		}
		U [64]byte
	}
} // t10 struct{int32,[4]uint32,[2]uint32,union{[64]uint8,[16]uint32}}

type XError struct {
	X0 int32
	X1 int32
	X2 *int8
} // t11 struct{int32,int32,*int8}

type XSqlite struct {
	X0 unsafe.Pointer
	X1 unsafe.Pointer
	X2 int32
	X3 **int8
} // t12 struct{*struct{},*struct{},int32,**int8}

type XThread struct {
	X0 int32
	X1 unsafe.Pointer
	X2 uint32
	X3 func(*crt.TLS, int32, unsafe.Pointer) *int8
	X4 unsafe.Pointer
} // t13 struct{int32,*struct{},uint32,*func(int32,*struct{})*int8,*struct{}}

type XStress2Ctx struct {
	X0 *int8
	X1 func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32)
} // t14 struct{*int8,*func(*struct{},*struct{},int32)}

type TStress2Task struct {
	X0 func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32)
} // t15 struct{*func(*struct{},*struct{},int32)}

type TThreadTest struct {
	X0 func(*crt.TLS, int32)
	X1 *int8
	X2 int32
} // t16 struct{*func(int32),*int8,int32}

type t5 struct {
	X0 unsafe.Pointer
	X1 struct {
		X0  int32
		X1  int32
		X2  int32
		X3  unsafe.Pointer
		X4  *int8
		X5  unsafe.Pointer
		X6  func(*crt.TLS, unsafe.Pointer, *int8, unsafe.Pointer, int32, *int32) int32
		X7  func(*crt.TLS, unsafe.Pointer, *int8, int32) int32
		X8  func(*crt.TLS, unsafe.Pointer, *int8, int32, *int32) int32
		X9  func(*crt.TLS, unsafe.Pointer, *int8, int32, *int8) int32
		X10 func(*crt.TLS, unsafe.Pointer, *int8) unsafe.Pointer
		X11 func(*crt.TLS, unsafe.Pointer, int32, *int8)
		X12 func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, *int8) func(*crt.TLS)
		X13 func(*crt.TLS, unsafe.Pointer, unsafe.Pointer)
		X14 func(*crt.TLS, unsafe.Pointer, int32, *int8) int32
		X15 func(*crt.TLS, unsafe.Pointer, int32) int32
		X16 func(*crt.TLS, unsafe.Pointer, *float64) int32
		X17 func(*crt.TLS, unsafe.Pointer, int32, *int8) int32
		X18 func(*crt.TLS, unsafe.Pointer, *int64) int32
		X19 func(*crt.TLS, unsafe.Pointer, *int8, func(*crt.TLS)) int32
		X20 func(*crt.TLS, unsafe.Pointer, *int8) func(*crt.TLS)
		X21 func(*crt.TLS, unsafe.Pointer, *int8) *int8
	}
	X2 struct {
		X0  int32
		X1  func(*crt.TLS, unsafe.Pointer) int32
		X2  func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32, int64) int32
		X3  func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32, int64) int32
		X4  func(*crt.TLS, unsafe.Pointer, int64) int32
		X5  func(*crt.TLS, unsafe.Pointer, int32) int32
		X6  func(*crt.TLS, unsafe.Pointer, *int64) int32
		X7  func(*crt.TLS, unsafe.Pointer, int32) int32
		X8  func(*crt.TLS, unsafe.Pointer, int32) int32
		X9  func(*crt.TLS, unsafe.Pointer, *int32) int32
		X10 func(*crt.TLS, unsafe.Pointer, int32, unsafe.Pointer) int32
		X11 func(*crt.TLS, unsafe.Pointer) int32
		X12 func(*crt.TLS, unsafe.Pointer) int32
		X13 func(*crt.TLS, unsafe.Pointer, int32, int32, int32, *unsafe.Pointer) int32
		X14 func(*crt.TLS, unsafe.Pointer, int32, int32, int32) int32
		X15 func(*crt.TLS, unsafe.Pointer)
		X16 func(*crt.TLS, unsafe.Pointer, int32) int32
		X17 func(*crt.TLS, unsafe.Pointer, int64, int32, *unsafe.Pointer) int32
		X18 func(*crt.TLS, unsafe.Pointer, int64, unsafe.Pointer) int32
	}
	X3 struct {
		X0  int32
		X1  func(*crt.TLS, unsafe.Pointer) int32
		X2  func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32, int64) int32
		X3  func(*crt.TLS, unsafe.Pointer, unsafe.Pointer, int32, int64) int32
		X4  func(*crt.TLS, unsafe.Pointer, int64) int32
		X5  func(*crt.TLS, unsafe.Pointer, int32) int32
		X6  func(*crt.TLS, unsafe.Pointer, *int64) int32
		X7  func(*crt.TLS, unsafe.Pointer, int32) int32
		X8  func(*crt.TLS, unsafe.Pointer, int32) int32
		X9  func(*crt.TLS, unsafe.Pointer, *int32) int32
		X10 func(*crt.TLS, unsafe.Pointer, int32, unsafe.Pointer) int32
		X11 func(*crt.TLS, unsafe.Pointer) int32
		X12 func(*crt.TLS, unsafe.Pointer) int32
		X13 func(*crt.TLS, unsafe.Pointer, int32, int32, int32, *unsafe.Pointer) int32
		X14 func(*crt.TLS, unsafe.Pointer, int32, int32, int32) int32
		X15 func(*crt.TLS, unsafe.Pointer)
		X16 func(*crt.TLS, unsafe.Pointer, int32) int32
		X17 func(*crt.TLS, unsafe.Pointer, int64, int32, *unsafe.Pointer) int32
		X18 func(*crt.TLS, unsafe.Pointer, int64, unsafe.Pointer) int32
	}
	X4 int32
} // struct{*struct{},struct{int32,int32,int32,*struct{},*int8,*struct{},*func(*struct{},*int8,*struct{},int32,*int32)int32,*func(*struct{},*int8,int32)int32,*func(*struct{},*int8,int32,*int32)int32,*func(*struct{},*int8,int32,*int8)int32,*func(*struct{},*int8)*struct{},*func(*struct{},int32,*int8),*func(*struct{},*struct{},*int8)*func(),*func(*struct{},*struct{}),*func(*struct{},int32,*int8)int32,*func(*struct{},int32)int32,*func(*struct{},*float64)int32,*func(*struct{},int32,*int8)int32,*func(*struct{},*int64)int32,*func(*struct{},*int8,*func())int32,*func(*struct{},*int8)*func(),*func(*struct{},*int8)*int8},struct{int32,*func(*struct{})int32,*func(*struct{},*struct{},int32,int64)int32,*func(*struct{},*struct{},int32,int64)int32,*func(*struct{},int64)int32,*func(*struct{},int32)int32,*func(*struct{},*int64)int32,*func(*struct{},int32)int32,*func(*struct{},int32)int32,*func(*struct{},*int32)int32,*func(*struct{},int32,*struct{})int32,*func(*struct{})int32,*func(*struct{})int32,*func(*struct{},int32,int32,int32,**struct{})int32,*func(*struct{},int32,int32,int32)int32,*func(*struct{}),*func(*struct{},int32)int32,*func(*struct{},int64,int32,**struct{})int32,*func(*struct{},int64,*struct{})int32},struct{int32,*func(*struct{})int32,*func(*struct{},*struct{},int32,int64)int32,*func(*struct{},*struct{},int32,int64)int32,*func(*struct{},int64)int32,*func(*struct{},int32)int32,*func(*struct{},*int64)int32,*func(*struct{},int32)int32,*func(*struct{},int32)int32,*func(*struct{},*int32)int32,*func(*struct{},int32,*struct{})int32,*func(*struct{})int32,*func(*struct{})int32,*func(*struct{},int32,int32,int32,**struct{})int32,*func(*struct{},int32,int32,int32)int32,*func(*struct{}),*func(*struct{},int32)int32,*func(*struct{},int64,int32,**struct{})int32,*func(*struct{},int64,*struct{})int32},int32}

type t1 struct {
	X [0]struct {
		X0 [64]uint8
		X1 [16]uint32
	}
	U [64]byte
}                       // union{[64]uint8,[16]uint32}
func str(n int) *int8   { return (*int8)(unsafe.Pointer(&strTab[n])) }
func wstr(n int) *int32 { return (*int32)(unsafe.Pointer(&strTab[n])) }

var strTab = []byte("walthread1\x00walthread2\x00walthread3\x00walthread4\x00walthread5\x00cgt_pager_1\x00dynamic_triggers\x00checkpoint_starvation_1\x00checkpoint_starvation_2\x00create_drop_index_1\x00lookaside1\x00vacuum1\x00stress1\x00stress2\x00-multiplexor\x00Failed to install multiplexor VFS (%d)\x0a\x00Running %s for %d seconds...\x0a\x00%d errors out of %d tests\x0a\x00Usage: %s [-multiplexor] [testname|testprefix*]...\x0a\x00Available tests are:\x0a\x00   %s\x0a\x00test.db\x00PRAGMA journal_mode = WAL;CREATE TABLE t1(x PRIMARY KEY);INSERT INTO t1 VALUES(randomblob(100));INSERT INTO t1 VALUES(randomblob(100));INSERT INTO t1 SELECT md5sum(x) FROM t1;\x00open\x00md5sum\x00PRAGMA synchronous=OFF\x00sqlite3_%s() - %s (%d)\x000123456789abcdef\x00%s\x00SELECT md5sum(x) FROM t1 WHERE rowid != (SELECT max(rowid) FROM t1)\x00SELECT x FROM t1 WHERE rowid = (SELECT max(rowid) FROM t1)\x00BEGIN\x00COMMIT\x00Failed read: %s %s %s\x00BEGIN;INSERT INTO t1 VALUES(randomblob(100));INSERT INTO t1 VALUES(randomblob(100));INSERT INTO t1 SELECT md5sum(x) FROM t1;COMMIT;\x00%d iterations\x00reset\x00Cannot discern type: \"%s\"\x00prepare_v2\x00%s:%i: assertion failure in %s: %s\x0a\x00../../../sqlite.org/sqlite-src-3190300/test/threadtest3.c\x000==strcmp(sqlite3_sql(pRet->pStmt), zSql)\x00getSqlStatement\x00PRAGMA integrity_check\x00ok\x00%z\x0a%s\x00* - no such table: *\x00%s: (%d) \"%s\" at line %d\x0a\x00Warning\x00Error\x00PRAGMA wal_checkpoint\x00%d checkpoints\x00Thread %d says: %s\x0a\x00...\x00CREATE TABLE t1(x INTEGER PRIMARY KEY, y UNIQUE)\x00PRAGMA journal_mode = WAL\x00PRAGMA journal_mode = DELETE\x00INSERT INTO t1 VALUES(NULL, randomblob(100))\x00test.db-journal\x00test.db-wal\x00File system looks incorrect (%d, %d)\x00W %d R %d\x00PRAGMA journal_mode = WAL;CREATE TABLE t1(cnt PRIMARY KEY, sum1, sum2);CREATE INDEX i1 ON t1(sum1);CREATE INDEX i2 ON t1(sum2);INSERT INTO t1 VALUES(0, 0, 0);\x00PRAGMA wal_autocheckpoint = 10\x00SELECT max(cnt) FROM t1\x00SELECT sum(cnt) FROM t1\x00SELECT sum(sum1) FROM t1\x00INSERT INTO t1 VALUES(:iNextWrite, :iSum1, :iSum2)\x00PRAGMA journal_mode = WAL;CREATE TABLE t1(a INTEGER PRIMARY KEY, b UNIQUE);\x00PRAGMA wal_autocheckpoint = 15;\x00REPLACE INTO t1 VALUES(:iRow, randomblob(300))\x00PRAGMA wal_autocheckpoint = 0;PRAGMA page_size = 1024;PRAGMA journal_mode = WAL;CREATE TABLE t1(x);BEGIN;INSERT INTO t1 VALUES(randomblob(900));INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*     2 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*     4 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*     8 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*    16 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*    32 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*    64 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*   128 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*   256 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*   512 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*  1024 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*  2048 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*  4096 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /*  8192 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /* 16384 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /* 32768 */INSERT INTO t1 SELECT randomblob(900) FROM t1;      /* 65536 */COMMIT;\x00test_sv.db\x00test_sv.db-wal\x00  WAL file is %d bytes,\x00 DB file is %d.\x0a\x00no such file: %s\x00SELECT count(*) FROM t1\x00Bad row count: %d\x00PRAGMA cache_size = 2000;PRAGMA page_size = 1024;CREATE TABLE t1(a INTEGER PRIMARY KEY, b BLOB);\x00INSERT INTO t1 VALUES(:iRow, zeroblob(:iBlob))\x00UPDATE t1 SET b = zeroblob(:iBlob) WHERE a = :iRow\x00SELECT * FROM t1 WHERE a = :iRow\x00PRAGMA page_size = 1024;PRAGMA journal_mode = WAL;CREATE TABLE t1(x, y);CREATE TABLE t2(x, y);CREATE TABLE t3(x, y);CREATE TABLE t4(x, y);CREATE TABLE t5(x, y);CREATE TABLE t6(x, y);CREATE TABLE t7(x, y);CREATE TABLE t8(x, y);CREATE TABLE t9(x, y);\x00INSERT INTO t1 VALUES(:iX, :iY+1)\x00DELETE FROM t1 WHERE x = :iX\x00%d inserts, %d deletes\x00CREATE TRIGGER itr%d BEFORE INSERT ON t%d BEGIN INSERT INTO t%d VALUES(new.x, new.y);END;\x00CREATE TRIGGER dtr%d BEFORE DELETE ON t%d BEGIN DELETE FROM t%d WHERE x = old.x; END;\x00DROP TRIGGER itr%d\x00DROP TRIGGER dtr%d\x00%d created, %d dropped\x00WAL failed to grow - %d frames\x00PRAGMA page_size = 1024;PRAGMA journal_mode = WAL;CREATE TABLE t1(x);\x00INSERT INTO t1 VALUES(randomblob(1200))\x00 Checkpoint mode  : %s\x0a\x00PASSIVE\x00RESTART\x00 Peak WAL         : %d frames\x0a\x00 Transaction count: %d transactions\x0a\x00SELECT count(x) FROM t1\x00Isolation failure - %lld %lld\x00WAL grew too large - %d frames\x00CREATE TABLE t11(a, b, c, d);WITH data(x) AS (SELECT 1 UNION ALL SELECT x+1 FROM data WHERE x<100) INSERT INTO t11 SELECT x,x,x,x FROM data;\x00DROP INDEX IF EXISTS i1;DROP INDEX IF EXISTS i2;DROP INDEX IF EXISTS i3;DROP INDEX IF EXISTS i4;CREATE INDEX IF NOT EXISTS i1 ON t11(a);CREATE INDEX IF NOT EXISTS i2 ON t11(b);CREATE INDEX IF NOT EXISTS i3 ON t11(c);CREATE INDEX IF NOT EXISTS i4 ON t11(d);SELECT * FROM t11 ORDER BY a;SELECT * FROM t11 ORDER BY b;SELECT * FROM t11 ORDER BY c;SELECT * FROM t11 ORDER BY d;\x00CREATE TABLE t1(x PRIMARY KEY) WITHOUT ROWID;WITH data(x,y) AS (  SELECT 1, quote(randomblob(750)) UNION ALL   SELECT x*2, y||y FROM data WHERE x<5) INSERT INTO t1 SELECT y FROM data;CREATE TABLE t3(x PRIMARY KEY,i) WITHOUT ROWID;INSERT INTO t3 VALUES(1, 1);CREATE TABLE t2(x,y,z);INSERT INTO t2 VALUES(randomblob(50), randomblob(50), randomblob(50));\x00SELECT 1 FROM t1\x00SELECT length(x||y||z) FROM t2\x00finalize\x00BEGIN;UPDATE t3 SET i=i+1 WHERE x=1;ROLLBACK;\x00CREATE TABLE t1(x PRIMARY KEY, y BLOB);CREATE INDEX i1 ON t1(y);\x00WITH loop(i) AS (SELECT 1 UNION ALL SELECT i+1 FROM loop WHERE i<100) INSERT INTO t1 SELECT randomblob(50), randomblob(2500) FROM loop\x00DELETE FROM t1 WHERE rowid = :i\x00SELECT * FROM t1 ORDER BY x\x00VACUUM\x00CREATE TABLE IF NOT EXISTS t1(a PRIMARY KEY, b)\x00DROP TABLE IF EXISTS t1\x00SELECT * FROM sqlite_master;\x00SELECT * FROM t1 ORDER BY a;\x00read t1 %d/%d attempts\x00WITH loop(i) AS (SELECT 1 UNION ALL SELECT i+1 FROM loop LIMIT 200) INSERT INTO t1 VALUES(randomblob(60), randomblob(60));\x00wrote t1 %d/%d attempts\x00DELETE FROM t1 WHERE (rowid % 4)==:i\x00deleted from t1 %d/%d attempts\x00CREATE TABLE IF NOT EXISTS t0(x PRIMARY KEY, y, z);CREATE INDEX IF NOT EXISTS i0 ON t0(y);\x00CREATE TABLE IF NOT EXISTS t%d(x PRIMARY KEY, y, z);\x00DROP TABLE IF EXISTS t%d;\x00SELECT * FROM t0 WHERE z = 'small'\x00SELECT * FROM t0 WHERE z = 'big'\x00INSERT INTO t0 VALUES(hex(random()), hex(randomblob(200)), 'small');\x00INSERT INTO t0 VALUES(hex(random()), hex(randomblob(57)), 'big');\x00UPDATE t0 SET y = hex(randomblob(200)) WHERE x LIKE hex((%d %% 5)) AND z='small';\x00UPDATE t0 SET y = hex(randomblob(57)) WHERE x LIKE hex(%d %% 5) AND z='big';\x00DELETE FROM t0 WHERE x LIKE hex(%d %% 5) AND z='small';\x00DELETE FROM t0 WHERE x LIKE hex(%d %% 5) AND z='big';\x00PRAGMA journal_mode = %q\x00delete\x00wal\x00ok %d/%d\x00*\x00../../../sqlite.org/sqlite-src-3190300/src/test_multiplex.c\x00pOrigVfs!=&gMultiplex.sThisVfs\x00multiplex\x00sqlite3_multiplex_initialize\x00zName || (flags & SQLITE_OPEN_DELETEONCLOSE)\x00truncate\x00chunksize\x00multiplexOpen\x00%03d\x00zOut[n]=='\\0'\x00multiplexFilename\x00multiplexor.xAccess failure on %s\x00multiplexor.xOpen failure on %s\x00multiplex_truncate\x00on\x001\x00off\x000\x00multiplex/%z\x00multiplex_control\x00")
