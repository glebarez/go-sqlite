// Code generated by ccgo. DO NOT EDIT.

// mptest
//  /*
//  ** 2013-04-05
//  **
//  ** The author disclaims copyright to this source code.  In place of
//  ** a legal notice, here is a blessing:
//  **
//  **    May you do good and not evil.
//  **    May you find forgiveness for yourself and forgive others.
//  **    May you share freely, never taking more than you give.
//  **
//  *************************************************************************
//  **
//  ** This is a program used for testing SQLite, and specifically for testing
//  ** the ability of independent processes to access the same SQLite database
//  ** concurrently.
//  **
//  ** Compile this program as follows:
//  **
//  **    gcc -g -c -Wall sqlite3.c $(OPTS)
//  **    gcc -g -o mptest mptest.c sqlite3.o $(LIBS)
//  **
//  ** Recommended options:
//  **
//  **    -DHAVE_USLEEP
//  **    -DSQLITE_NO_SYNC
//  **    -DSQLITE_THREADSAFE=0
//  **    -DSQLITE_OMIT_LOAD_EXTENSION
//  **
//  ** Run like this:
//  **
//  **     ./mptest $database $script
//  **
//  ** where $database is the database to use for testing and $script is a
//  ** test script.
//  */
package main

import (
	"math"
	"os"
	"unsafe"

	"github.com/cznic/crt"
	"github.com/cznic/sqlite/internal/bin"
)

var argv []*int8

func main() {
	for _, v := range os.Args {
		argv = append(argv, (*int8)(crt.CString(v)))
	}
	argv = append(argv, nil)
	X_start(crt.NewTLS(), int32(len(os.Args)), &argv[0])
}

func X_start(tls *crt.TLS, _argc int32, _argv **int8) {
	crt.X__register_stdfiles(tls, Xstdin, Xstdout, Xstderr)
	crt.X__builtin_exit(tls, Xmain(tls, _argc, _argv))
}

var Xstdin unsafe.Pointer

func init() {
	Xstdin = unsafe.Pointer(&X__stdfiles)
}

var X__stdfiles [3]unsafe.Pointer

var Xstdout unsafe.Pointer

func init() {
	Xstdout = unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdfiles)) + 8)
}

var Xstderr unsafe.Pointer

func init() {
	Xstderr = unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdfiles)) + 16)
}

func Xmain(tls *crt.TLS, _argc int32, _argv **int8) (r0 int32) {
	var _iClient, _n, _i, _openFlags, _rc, _taskId, _nRep, _iRep, _iTmout, _7_nTry, _15_iTimeout int32
	var _zClient, _zScript, _zTrace, _zCOption, _zJMode, _zNRep, _zTmout, _14_zTaskName *int8
	var _15_pStmt unsafe.Pointer
	r0 = int32(0)
	_openFlags = int32(2)
	_nRep = int32(1)
	_iTmout = int32(0)
	_g.Xargv0 = *elem0(_argv, 0)
	_g.XiTrace = int32(1)
	if _argc < int32(2) {
		_usage(tls, *elem0(_argv, 0))
	}
	_g.XzDbFile = *elem0(_argv, uintptr(1))
	if Xstrglob(tls, str(0), _g.XzDbFile) != 0 {
		_usage(tls, *elem0(_argv, 0))
	}
	if crt.Xstrcmp(tls, bin.Xsqlite3_sourceid(tls), str(7)) != int32(0) {
		crt.Xfprintf(tls, (*crt.XFILE)(Xstderr), str(92), unsafe.Pointer(bin.Xsqlite3_sourceid(tls)), unsafe.Pointer(str(7)))
		crt.Xexit(tls, int32(1))
	}
	_n = _argc - int32(2)
	bin.Xsqlite3_snprintf(tls, int32(32), (*int8)(unsafe.Pointer(&_g.XzName)), str(152), crt.Xgetpid(tls))
	_zJMode = _findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(164), int32(1))
	_zNRep = _findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(176), int32(1))
	if _zNRep != nil {
		_nRep = crt.Xatoi(tls, _zNRep)
	}
	if _nRep < int32(1) {
		_nRep = int32(1)
	}
	_g.XzVfs = _findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(183), int32(1))
	_zClient = _findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(187), int32(1))
	_g.XzErrLog = _findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(194), int32(1))
	_g.XzLog = _findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(201), int32(1))
	_zTrace = _findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(205), int32(1))
	if _zTrace != nil {
		_g.XiTrace = crt.Xatoi(tls, _zTrace)
	}
	if _findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(211), int32(0)) != nil {
		_g.XiTrace = int32(0)
	}
	_zTmout = _findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(217), int32(1))
	if _zTmout != nil {
		_iTmout = crt.Xatoi(tls, _zTmout)
	}
	_g.XbSqlTrace = bool2int(_findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(225), int32(0)) != nil)
	_g.XbSync = bool2int(_findOption(tls, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))), &_n, str(234), int32(0)) != nil)
	if _g.XzErrLog != nil {
		*(**crt.XFILE)(unsafe.Pointer(&_g.XpErrLog)) = crt.Xfopen64(tls, _g.XzErrLog, str(239))
		goto _9
	}
	*(**crt.XFILE)(unsafe.Pointer(&_g.XpErrLog)) = (*crt.XFILE)(Xstderr)
_9:
	if _g.XzLog != nil {
		*(**crt.XFILE)(unsafe.Pointer(&_g.XpLog)) = crt.Xfopen64(tls, _g.XzLog, str(239))
		goto _11
	}
	*(**crt.XFILE)(unsafe.Pointer(&_g.XpLog)) = (*crt.XFILE)(Xstdout)
_11:
	bin.Xsqlite3_config(tls, int32(16), _sqlErrorCallback, int32(0))
	if _zClient == nil {
		goto _12
	}
	_iClient = crt.Xatoi(tls, _zClient)
	if _iClient < int32(1) {
		_fatalError(tls, str(241), _iClient)
	}
	bin.Xsqlite3_snprintf(tls, int32(32), (*int8)(unsafe.Pointer(&_g.XzName)), str(268), crt.Xgetpid(tls), _iClient)
	goto _14
_12:
	_7_nTry = int32(0)
	if _g.XiTrace <= int32(0) {
		goto _15
	}
	crt.Xprintf(tls, str(284), unsafe.Pointer(*elem0(_argv, 0)))
	_i = int32(1)
_16:
	if _i >= _argc {
		goto _19
	}
	crt.Xprintf(tls, str(294), unsafe.Pointer(*elem0(_argv, uintptr(_i))))
	_i += 1
	goto _16
_19:
	crt.Xprintf(tls, str(298))
	crt.Xprintf(tls, str(300))
	_i = int32(0)
_20:
	if store1(&_zCOption, bin.Xsqlite3_compileoption_get(tls, _i)) == nil {
		goto _23
	}
	crt.Xprintf(tls, str(405), unsafe.Pointer(_zCOption))
	_i += 1
	goto _20
_23:
	crt.Xfflush(tls, (*crt.XFILE)(Xstdout))
_15:
	_iClient = int32(0)
_24:
	if (_7_nTry % int32(5)) == int32(4) {
		crt.Xprintf(tls, str(418), unsafe.Pointer(func() *int8 {
			if _7_nTry > int32(5) {
				return str(447)
			}
			return str(454)
		}()), unsafe.Pointer(_g.XzDbFile))
	}
	_rc = crt.Xunlink(tls, _g.XzDbFile)
	if _rc != 0 && ((*crt.X__errno_location(tls)) == int32(2)) {
		_rc = int32(0)
	}
	if ((_rc != int32(0)) && (preInc2(&_7_nTry, 1) < int32(60))) && (bin.Xsqlite3_sleep(tls, int32(1000)) > int32(0)) {
		goto _24
	}
	if _rc != int32(0) {
		_fatalError(tls, str(455), unsafe.Pointer(_g.XzDbFile), _7_nTry)
	}
	_openFlags |= int32(4)
_14:
	_rc = bin.Xsqlite3_open_v2(tls, _g.XzDbFile, (**bin.Xsqlite3)(unsafe.Pointer(&_g.Xdb)), _openFlags, _g.XzVfs)
	if _rc != 0 {
		_fatalError(tls, str(496), unsafe.Pointer(_g.XzDbFile))
	}
	if _iTmout > int32(0) {
		bin.Xsqlite3_busy_timeout(tls, (*bin.Xsqlite3)(_g.Xdb), _iTmout)
	}
	if _zJMode != nil {
		_runSql(tls, str(513), unsafe.Pointer(_zJMode))
	}
	if _g.XbSync == 0 {
		_trySql(tls, str(537))
	}
	bin.Xsqlite3_enable_load_extension(tls, (*bin.Xsqlite3)(_g.Xdb), int32(1))
	bin.Xsqlite3_busy_handler(tls, (*bin.Xsqlite3)(_g.Xdb), _busyHandler, nil)
	bin.Xsqlite3_create_function(tls, (*bin.Xsqlite3)(_g.Xdb), str(560), int32(0), int32(1), nil, func() func(*crt.TLS, *bin.Xsqlite3_context, int32, **bin.XMem) {
		v := _vfsNameFunc
		return *(*func(*crt.TLS, *bin.Xsqlite3_context, int32, **bin.XMem))(unsafe.Pointer(&v))
	}(), nil, nil)
	bin.Xsqlite3_create_function(tls, (*bin.Xsqlite3)(_g.Xdb), str(568), int32(1), int32(1), nil, func() func(*crt.TLS, *bin.Xsqlite3_context, int32, **bin.XMem) {
		v := _evalFunc
		return *(*func(*crt.TLS, *bin.Xsqlite3_context, int32, **bin.XMem))(unsafe.Pointer(&v))
	}(), nil, nil)
	_g.XiTimeout = int32(10000)
	if _g.XbSqlTrace != 0 {
		bin.Xsqlite3_trace(tls, (*bin.Xsqlite3)(_g.Xdb), _sqlTraceCallback, nil)
	}
	if _iClient <= int32(0) {
		goto _38
	}
	if _n > int32(0) {
		_unrecognizedArguments(tls, *elem0(_argv, 0), _n, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))))
	}
	if _g.XiTrace != 0 {
		_logMessage(tls, str(573))
	}
_40:
	_14_zTaskName = nil
	_rc = _startScript(tls, _iClient, &_zScript, &_taskId, &_14_zTaskName)
	if _rc == int32(101) {
		goto _42
	}
	if _g.XiTrace != 0 {
		_logMessage(tls, str(586), unsafe.Pointer(_14_zTaskName), _taskId)
	}
	_runScript(tls, _iClient, _taskId, _zScript, _14_zTaskName)
	if _g.XiTrace != 0 {
		_logMessage(tls, str(600), unsafe.Pointer(_14_zTaskName), _taskId)
	}
	_finishScript(tls, _iClient, _taskId, int32(0))
	bin.Xsqlite3_free(tls, unsafe.Pointer(_14_zTaskName))
	bin.Xsqlite3_sleep(tls, int32(10))
	goto _40
_42:
	if _g.XiTrace != 0 {
		_logMessage(tls, str(612))
	}
	goto _47
_38:
	if _n == int32(0) {
		_fatalError(tls, str(623))
	}
	if _n > int32(1) {
		_unrecognizedArguments(tls, *elem0(_argv, 0), _n, (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv))+uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(int32(2))*uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(uintptr(8))))))))))))
	}
	_runSql(tls, str(647))
	_zScript = _readFile(tls, *elem0(_argv, uintptr(2)))
	_iRep = int32(1)
_50:
	if _iRep > _nRep {
		goto _53
	}
	if _g.XiTrace != 0 {
		_logMessage(tls, str(1083), unsafe.Pointer(*elem0(_argv, uintptr(2))), _iRep)
	}
	_runScript(tls, int32(0), int32(0), _zScript, *elem0(_argv, uintptr(2)))
	if _g.XiTrace != 0 {
		_logMessage(tls, str(1111), unsafe.Pointer(*elem0(_argv, uintptr(2))), _iRep)
	}
	_iRep += 1
	goto _50
_53:
	bin.Xsqlite3_free(tls, unsafe.Pointer(_zScript))
	_waitForClient(tls, int32(0), int32(2000), str(1137))
	_trySql(tls, str(1157))
	bin.Xsqlite3_sleep(tls, int32(10))
	_g.XiTimeout = int32(0)
	_15_iTimeout = int32(1000)
_56:
	if ((store2(&_rc, _trySql(tls, str(1186))) == int32(5)) || (_rc == int32(100))) && (_15_iTimeout > int32(0)) {
		bin.Xsqlite3_sleep(tls, int32(10))
		_15_iTimeout -= int32(10)
		goto _56
	}
	bin.Xsqlite3_sleep(tls, int32(100))
	_15_pStmt = _prepareSql(tls, str(1207))
	_15_iTimeout = int32(1000)
_60:
	if (store2(&_rc, bin.Xsqlite3_step(tls, _15_pStmt)) == int32(5)) && (_15_iTimeout > int32(0)) {
		bin.Xsqlite3_sleep(tls, int32(10))
		_15_iTimeout -= int32(10)
		goto _60
	}
	if _rc == int32(100) {
		_g.XnError += bin.Xsqlite3_column_int(tls, _15_pStmt, int32(0))
		_g.XnTest += bin.Xsqlite3_column_int(tls, _15_pStmt, int32(1))
	}
	bin.Xsqlite3_finalize(tls, _15_pStmt)
_47:
	bin.Xsqlite3_close(tls, (*bin.Xsqlite3)(_g.Xdb))
	_maybeClose(tls, (*crt.XFILE)(_g.XpLog))
	_maybeClose(tls, (*crt.XFILE)(_g.XpErrLog))
	if _iClient != int32(0) {
		goto _64
	}
	crt.Xprintf(tls, str(1242), _g.XnError, _g.XnTest)
	crt.Xprintf(tls, str(1278), unsafe.Pointer(*elem0(_argv, 0)))
	_i = int32(1)
_65:
	if _i >= _argc {
		goto _68
	}
	crt.Xprintf(tls, str(294), unsafe.Pointer(*elem0(_argv, uintptr(_i))))
	_i += 1
	goto _65
_68:
	crt.Xprintf(tls, str(298))
_64:
	return bool2int(_g.XnError > int32(0))
}

// C comment
//  /* Global data
//  */
var _g TGlobal

// C comment
//  /* Print a usage message for the program and exit */
func _usage(tls *crt.TLS, _argv0 *int8) {
	var _i int32
	var _zTail *int8
	_zTail = _argv0
	_i = int32(0)
_0:
	if (*elem1(_argv0, uintptr(_i))) == 0 {
		goto _3
	}
	if int32(*elem1(_argv0, uintptr(_i))) == int32(47) {
		_zTail = (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_argv0))+uintptr(_i))))) + uintptr(int32(1))))
	}
	_i += 1
	goto _0
_3:
	crt.Xfprintf(tls, (*crt.XFILE)(Xstderr), str(1286), unsafe.Pointer(_zTail))
	crt.Xfprintf(tls, (*crt.XFILE)(Xstderr), str(1325))
	crt.Xexit(tls, int32(1))
}

// C comment
//  /*
//  ** Return TRUE if string z[] matches glob pattern zGlob[].
//  ** Return FALSE if the pattern does not match.
//  **
//  ** Globbing rules:
//  **
//  **      '*'       Matches any sequence of zero or more characters.
//  **
//  **      '?'       Matches exactly one character.
//  **
//  **     [...]      Matches one character from the enclosed list of
//  **                characters.
//  **
//  **     [^...]     Matches one character not in the enclosed list.
//  **
//  **      '#'       Matches any sequence of one or more digits with an
//  **                optional + or - sign in front
//  */
func Xstrglob(tls *crt.TLS, _zGlob *int8, _z *int8) (r0 int32) {
	var _c, _c2, _invert, _seen, _10_prior_c int32
_0:
	if store2(&_c, int32(*postInc1(&_zGlob, 1))) == int32(0) {
		goto _1
	}
	if _c != int32(42) {
		goto _2
	}
_3:
	if store2(&_c, int32(*postInc1(&_zGlob, 1))) != int32(42) && _c != int32(63) {
		goto _4
	}
	if (_c == int32(63)) && (int32(*postInc1(&_z, 1)) == int32(0)) {
		return int32(0)
	}
	goto _3
_4:
	if _c == int32(0) {
		return int32(1)
	}
	if _c != int32(91) {
		goto _10
	}
_11:
	if ((*_z) != 0) && Xstrglob(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zGlob))-uintptr(int32(1)))), _z) != 0 {
		*(*uintptr)(unsafe.Pointer(&_z)) += uintptr(1)
		goto _11
	}
	return bool2int(int32(*_z) != int32(0))

_10:
	if store2(&_c2, int32(*postInc1(&_z, 1))) == int32(0) {
		goto _15
	}
_16:
	if _c2 == _c {
		goto _17
	}
	_c2 = int32(*postInc1(&_z, 1))
	if _c2 == int32(0) {
		return int32(0)
	}
	goto _16
_17:
	if Xstrglob(tls, _zGlob, _z) != 0 {
		return int32(1)
	}
	goto _10
_15:
	return int32(0)

_2:
	if _c != int32(63) {
		goto _21
	}
	if int32(*postInc1(&_z, 1)) == int32(0) {
		return int32(0)
	}
	goto _50
_21:
	if _c != int32(91) {
		goto _24
	}
	_10_prior_c = int32(0)
	_seen = int32(0)
	_invert = int32(0)
	_c = int32(*postInc1(&_z, 1))
	if _c == int32(0) {
		return int32(0)
	}
	_c2 = int32(*postInc1(&_zGlob, 1))
	if _c2 == int32(94) {
		_invert = int32(1)
		_c2 = int32(*postInc1(&_zGlob, 1))
	}
	if _c2 != int32(93) {
		goto _27
	}
	if _c == int32(93) {
		_seen = int32(1)
	}
	_c2 = int32(*postInc1(&_zGlob, 1))
_27:
	if _c2 == 0 || _c2 == int32(93) {
		goto _30
	}
	if _c2 != int32(45) || int32(*elem1(_zGlob, 0)) == int32(93) || int32(*elem1(_zGlob, 0)) == int32(0) || _10_prior_c <= int32(0) {
		goto _35
	}
	_c2 = int32(*postInc1(&_zGlob, 1))
	if (_c >= _10_prior_c) && (_c <= _c2) {
		_seen = int32(1)
	}
	_10_prior_c = int32(0)
	goto _38
_35:
	if _c == _c2 {
		_seen = int32(1)
	}
	_10_prior_c = _c2
_38:
	_c2 = int32(*postInc1(&_zGlob, 1))
	goto _27
_30:
	if (_c2 == int32(0)) || ((_seen ^ _invert) == int32(0)) {
		return int32(0)
	}
	goto _50
_24:
	if _c != int32(35) {
		goto _43
	}
	if ((int32(*elem1(_z, 0)) == int32(45)) || (int32(*elem1(_z, 0)) == int32(43))) && (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_z, uintptr(1)))))))&int32(2048)) != 0 {
		*(*uintptr)(unsafe.Pointer(&_z)) += uintptr(1)
	}
	if (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_z, 0)))))) & int32(2048)) == 0 {
		return int32(0)
	}
	*(*uintptr)(unsafe.Pointer(&_z)) += uintptr(1)
_48:
	if (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_z, 0)))))) & int32(2048)) != 0 {
		*(*uintptr)(unsafe.Pointer(&_z)) += uintptr(1)
		goto _48
	}
	goto _50
_43:
	if _c != int32(*postInc1(&_z, 1)) {
		return int32(0)
	}
_50:
	goto _0
_1:
	return bool2int(int32(*_z) == int32(0))
}

// C comment
//  /*
//  ** Look for a command-line option.  If present, return a pointer.
//  ** Return NULL if missing.
//  **
//  ** hasArg==0 means the option is a flag.  It is either present or not.
//  ** hasArg==1 means the option has an argument.  Return a pointer to the
//  ** argument.
//  */
func _findOption(tls *crt.TLS, _azArg **int8, _pnArg *int32, _zOption *int8, _hasArg int32) (r0 *int8) {
	var _i, _j, _nArg int32
	var _zReturn, _1_z *int8
	_zReturn = nil
	_nArg = *_pnArg
	func() {
		if _hasArg != int32(0) && _hasArg != int32(1) {
			crt.X__builtin_fprintf(tls, Xstderr, str(1897), unsafe.Pointer(str(1933)), int32(1211), unsafe.Pointer(&_findOptionØ00__func__Ø000), unsafe.Pointer(str(1988)))
			crt.X__builtin_abort(tls)
		}
	}()
	_i = int32(0)
_3:
	if _i >= _nArg {
		goto _6
	}
	if (_i + _hasArg) >= _nArg {
		goto _6
	}
	_1_z = *elem0(_azArg, uintptr(_i))
	if int32(*elem1(_1_z, 0)) != int32(45) {
		goto _4
	}
	*(*uintptr)(unsafe.Pointer(&_1_z)) += uintptr(1)
	if int32(*elem1(_1_z, 0)) != int32(45) {
		goto _9
	}
	if int32(*elem1(_1_z, uintptr(1))) == int32(0) {
		goto _6
	}
	*(*uintptr)(unsafe.Pointer(&_1_z)) += uintptr(1)
_9:
	if crt.Xstrcmp(tls, _1_z, _zOption) != int32(0) {
		goto _11
	}
	if _hasArg != 0 && (_i == (_nArg - int32(1))) {
		_fatalError(tls, str(2011), unsafe.Pointer(_1_z))
	}
	if _hasArg != 0 {
		_zReturn = *elem0(_azArg, uintptr(_i+int32(1)))
		goto _15
	}
	_zReturn = *elem0(_azArg, uintptr(_i))
_15:
	_j = (_i + int32(1)) + bool2int(_hasArg != int32(0))
_16:
	if _j < _nArg {
		*elem0(_azArg, uintptr(postInc2(&_i, 1))) = *elem0(_azArg, uintptr(postInc2(&_j, 1)))
		goto _16
	}
	*_pnArg = _i
	return _zReturn

_11:
_4:
	_i += 1
	goto _3
_6:
	return _zReturn
}

var _findOptionØ00__func__Ø000 [11]int8

func init() {
	crt.Xstrncpy(nil, &_findOptionØ00__func__Ø000[0], str(2059), 11)
}

// C comment
//  /*
//  ** Print an error message and then quit.
//  */
func _fatalError(tls *crt.TLS, _zFormat *int8, args ...interface{}) {
	var _3_nTry int32
	var _zMsg *int8
	var _ap []interface{}
	var _zPrefix [30]int8
	_ap = args
	_zMsg = bin.Xsqlite3_vmprintf(tls, _zFormat, _ap)
	_ap = nil
	bin.Xsqlite3_snprintf(tls, int32(30), (*int8)(unsafe.Pointer(&_zPrefix)), str(2070), unsafe.Pointer(&_g.XzName))
	if _g.XpLog != nil {
		_printWithPrefix(tls, (*crt.XFILE)(_g.XpLog), (*int8)(unsafe.Pointer(&_zPrefix)), _zMsg)
		crt.Xfflush(tls, (*crt.XFILE)(_g.XpLog))
		_maybeClose(tls, (*crt.XFILE)(_g.XpLog))
	}
	if (_g.XpErrLog != nil) && _safe_strcmp(tls, _g.XzErrLog, _g.XzLog) != 0 {
		_printWithPrefix(tls, (*crt.XFILE)(_g.XpErrLog), (*int8)(unsafe.Pointer(&_zPrefix)), _zMsg)
		crt.Xfflush(tls, (*crt.XFILE)(_g.XpErrLog))
		_maybeClose(tls, (*crt.XFILE)(_g.XpErrLog))
	}
	bin.Xsqlite3_free(tls, unsafe.Pointer(_zMsg))
	if _g.Xdb == nil {
		goto _3
	}
	_3_nTry = int32(0)
	_g.XiTimeout = int32(0)
_4:
	if (_trySql(tls, str(2081)) == int32(5)) && (postInc2(&_3_nTry, 1) < int32(100)) {
		bin.Xsqlite3_sleep(tls, int32(10))
		goto _4
	}
_3:
	bin.Xsqlite3_close(tls, (*bin.Xsqlite3)(_g.Xdb))
	crt.Xexit(tls, int32(1))
	_ = _zPrefix
	_ = _3_nTry
}

// C comment
//  /*
//  ** Print a message adding zPrefix[] to the beginning of every line.
//  */
func _printWithPrefix(tls *crt.TLS, _pOut *crt.XFILE, _zPrefix *int8, _zMsg *int8) {
	var _1_i int32
_0:
	if _zMsg == nil || (*elem1(_zMsg, 0)) == 0 {
		goto _1
	}
	_1_i = int32(0)
_3:
	if (*elem1(_zMsg, uintptr(_1_i))) == 0 || int32(*elem1(_zMsg, uintptr(_1_i))) == int32(10) || int32(*elem1(_zMsg, uintptr(_1_i))) == int32(13) {
		goto _8
	}
	_1_i += 1
	goto _3
_8:
	crt.Xfprintf(tls, _pOut, str(2111), unsafe.Pointer(_zPrefix), _1_i, unsafe.Pointer(_zMsg))
	*(*uintptr)(unsafe.Pointer(&_zMsg)) += uintptr(_1_i)
_9:
	if (int32(*elem1(_zMsg, 0)) == int32(10)) || (int32(*elem1(_zMsg, 0)) == int32(13)) {
		*(*uintptr)(unsafe.Pointer(&_zMsg)) += uintptr(1)
		goto _9
	}
	goto _0
_1:
}

// C comment
//  /*
//  ** Close output stream pOut if it is not stdout or stderr
//  */
func _maybeClose(tls *crt.TLS, _pOut *crt.XFILE) {
	if (unsafe.Pointer(_pOut) != Xstdout) && (_pOut != (*crt.XFILE)(Xstderr)) {
		crt.Xfclose(tls, _pOut)
	}
}

// C comment
//  /*
//  ** Compare two pointers to strings, where the pointers might be NULL.
//  */
func _safe_strcmp(tls *crt.TLS, _a *int8, _b *int8) (r0 int32) {
	if _a == _b {
		return int32(0)
	}
	if _a == nil {
		return int32(-1)
	}
	if _b == nil {
		return int32(1)
	}
	return crt.Xstrcmp(tls, _a, _b)
}

// C comment
//  /*
//  ** Try to run arbitrary SQL.  Return success code.
//  */
func _trySql(tls *crt.TLS, _zFormat *int8, args ...interface{}) (r0 int32) {
	var _rc int32
	var _zSql *int8
	var _ap []interface{}
	_ap = args
	_zSql = bin.Xsqlite3_vmprintf(tls, _zFormat, _ap)
	_ap = nil
	_rc = bin.Xsqlite3_exec(tls, (*bin.Xsqlite3)(_g.Xdb), _zSql, nil, nil, nil)
	bin.Xsqlite3_free(tls, unsafe.Pointer(_zSql))
	return _rc
}

// C comment
//  /*
//  ** SQL error log callback
//  */
func _sqlErrorCallback(tls *crt.TLS, _pArg unsafe.Pointer, _iErrCode int32, _zMsg *int8) {
	if (_iErrCode == int32(1)) && _g.XbIgnoreSqlErrors != 0 {
		return
	}
	if ((_iErrCode & int32(255)) == int32(17)) && (_g.XiTrace < int32(3)) {
		return
	}
	if ((_g.XiTimeout == int32(0)) && ((_iErrCode & int32(255)) == int32(5))) && (_g.XiTrace < int32(3)) {
		return
	}
	if (_iErrCode & int32(255)) == int32(27) {
		_logMessage(tls, str(2119), unsafe.Pointer(_zMsg))
		goto _8
	}
	_errorMessage(tls, str(2129), _iErrCode, unsafe.Pointer(_zMsg))
_8:
}

// C comment
//  /*
//  ** Print a log message
//  */
func _logMessage(tls *crt.TLS, _zFormat *int8, args ...interface{}) {
	var _zMsg *int8
	var _ap []interface{}
	var _zPrefix [30]int8
	_ap = args
	_zMsg = bin.Xsqlite3_vmprintf(tls, _zFormat, _ap)
	_ap = nil
	bin.Xsqlite3_snprintf(tls, int32(30), (*int8)(unsafe.Pointer(&_zPrefix)), str(2145), unsafe.Pointer(&_g.XzName))
	if _g.XpLog != nil {
		_printWithPrefix(tls, (*crt.XFILE)(_g.XpLog), (*int8)(unsafe.Pointer(&_zPrefix)), _zMsg)
		crt.Xfflush(tls, (*crt.XFILE)(_g.XpLog))
	}
	bin.Xsqlite3_free(tls, unsafe.Pointer(_zMsg))
	_ = _zPrefix
}

// C comment
//  /*
//  ** Print an error message
//  */
func _errorMessage(tls *crt.TLS, _zFormat *int8, args ...interface{}) {
	var _zMsg *int8
	var _ap []interface{}
	var _zPrefix [30]int8
	_ap = args
	_zMsg = bin.Xsqlite3_vmprintf(tls, _zFormat, _ap)
	_ap = nil
	bin.Xsqlite3_snprintf(tls, int32(30), (*int8)(unsafe.Pointer(&_zPrefix)), str(2150), unsafe.Pointer(&_g.XzName))
	if _g.XpLog != nil {
		_printWithPrefix(tls, (*crt.XFILE)(_g.XpLog), (*int8)(unsafe.Pointer(&_zPrefix)), _zMsg)
		crt.Xfflush(tls, (*crt.XFILE)(_g.XpLog))
	}
	if (_g.XpErrLog != nil) && _safe_strcmp(tls, _g.XzErrLog, _g.XzLog) != 0 {
		_printWithPrefix(tls, (*crt.XFILE)(_g.XpErrLog), (*int8)(unsafe.Pointer(&_zPrefix)), _zMsg)
		crt.Xfflush(tls, (*crt.XFILE)(_g.XpErrLog))
	}
	bin.Xsqlite3_free(tls, unsafe.Pointer(_zMsg))
	_g.XnError += 1
	_ = _zPrefix
}

// C comment
//  /*
//  ** Run arbitrary SQL.  Issue a fatal error on failure.
//  */
func _runSql(tls *crt.TLS, _zFormat *int8, args ...interface{}) {
	var _rc int32
	var _zSql *int8
	var _ap []interface{}
	_ap = args
	_zSql = bin.Xsqlite3_vmprintf(tls, _zFormat, _ap)
	_ap = nil
	_rc = bin.Xsqlite3_exec(tls, (*bin.Xsqlite3)(_g.Xdb), _zSql, nil, nil, nil)
	if _rc != int32(0) {
		_fatalError(tls, str(2161), unsafe.Pointer(bin.Xsqlite3_errmsg(tls, (*bin.Xsqlite3)(_g.Xdb))), unsafe.Pointer(_zSql))
	}
	bin.Xsqlite3_free(tls, unsafe.Pointer(_zSql))
}

// C comment
//  /*
//  ** Busy handler with a g.iTimeout-millisecond timeout
//  */
func _busyHandler(tls *crt.TLS, _pCD unsafe.Pointer, _count int32) (r0 int32) {
	if (_count * int32(10)) <= _g.XiTimeout {
		goto _0
	}
	if _g.XiTimeout > int32(0) {
		_errorMessage(tls, str(2168), _g.XiTimeout)
	}
	return int32(0)

_0:
	bin.Xsqlite3_sleep(tls, int32(10))
	return int32(1)
}

// C comment
//  /*
//  ** Auxiliary SQL function to return the name of the VFS
//  */
func _vfsNameFunc(tls *crt.TLS, _context unsafe.Pointer, _argc int32, _argv *unsafe.Pointer) {
	var _zVfs *int8
	var _db unsafe.Pointer
	_db = unsafe.Pointer(bin.Xsqlite3_context_db_handle(tls, (*bin.Xsqlite3_context)(_context)))
	_zVfs = nil

	bin.Xsqlite3_file_control(tls, (*bin.Xsqlite3)(_db), str(2187), int32(12), unsafe.Pointer(&_zVfs))
	if _zVfs != nil {
		bin.Xsqlite3_result_text(tls, (*bin.Xsqlite3_context)(_context), _zVfs, int32(-1), bin.Xsqlite3_free)
	}
}

// C comment
//  /*
//  ** Auxiliary SQL function to recursively evaluate SQL.
//  */
func _evalFunc(tls *crt.TLS, _context unsafe.Pointer, _argc int32, _argv *unsafe.Pointer) {
	var _rc int32
	var _zSql, _zErrMsg *int8
	var _db unsafe.Pointer
	var _res XString
	_db = unsafe.Pointer(bin.Xsqlite3_context_db_handle(tls, (*bin.Xsqlite3_context)(_context)))
	_zSql = (*int8)(unsafe.Pointer(bin.Xsqlite3_value_text(tls, (*bin.XMem)(*elem4(_argv, 0)))))
	_zErrMsg = nil

	crt.Xmemset(tls, unsafe.Pointer(&_res), int32(0), uint64(16))
	_rc = bin.Xsqlite3_exec(tls, (*bin.Xsqlite3)(_db), _zSql, _evalCallback, unsafe.Pointer(&_res), &_zErrMsg)
	if _zErrMsg != nil {
		bin.Xsqlite3_result_error(tls, (*bin.Xsqlite3_context)(_context), _zErrMsg, int32(-1))
		bin.Xsqlite3_free(tls, unsafe.Pointer(_zErrMsg))
		goto _3
	}
	if _rc != 0 {
		bin.Xsqlite3_result_error_code(tls, (*bin.Xsqlite3_context)(_context), _rc)
		goto _3
	}
	bin.Xsqlite3_result_text(tls, (*bin.Xsqlite3_context)(_context), _res.Xz, int32(-1), func() func(*crt.TLS, unsafe.Pointer) {
		v := uint64(18446744073709551615)
		return *(*func(*crt.TLS, unsafe.Pointer))(unsafe.Pointer(&v))
	}())
_3:
	_stringFree(tls, &_res)
}

// C comment
//  /*
//  ** Callback function for evalSql()
//  */
func _evalCallback(tls *crt.TLS, _pCData unsafe.Pointer, _argc int32, _argv **int8, _azCol **int8) (r0 int32) {
	var _i int32
	var _p *XString
	_p = (*XString)(_pCData)

	_i = int32(0)
_0:
	if _i >= _argc {
		goto _3
	}
	_stringAppendTerm(tls, _p, *elem0(_argv, uintptr(_i)))
	_i += 1
	goto _0
_3:
	return int32(0)
}

// C comment
//  /* Append a new token onto the end of the string */
func _stringAppendTerm(tls *crt.TLS, _p *XString, _z *int8) {
	var _i int32
	if _p.Xn != 0 {
		_stringAppend(tls, _p, str(2192), int32(1))
	}
	if _z == nil {
		_stringAppend(tls, _p, str(2194), int32(3))
		return
	}
	_i = int32(0)
_2:
	if (*elem1(_z, uintptr(_i))) == 0 || (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_z, uintptr(_i)))))))&int32(8192)) != 0 {
		goto _6
	}
	_i += 1
	goto _2
_6:
	if (_i > int32(0)) && (int32(*elem1(_z, uintptr(_i))) == int32(0)) {
		_stringAppend(tls, _p, _z, _i)
		return
	}
	_stringAppend(tls, _p, str(2198), int32(1))
_9:
	if (*elem1(_z, 0)) == 0 {
		goto _10
	}
	_i = int32(0)
_11:
	if (*elem1(_z, uintptr(_i))) == 0 || int32(*elem1(_z, uintptr(_i))) == int32(39) {
		goto _15
	}
	_i += 1
	goto _11
_15:
	if (*elem1(_z, uintptr(_i))) != 0 {
		_stringAppend(tls, _p, _z, _i+int32(1))
		_stringAppend(tls, _p, str(2198), int32(1))
		*(*uintptr)(unsafe.Pointer(&_z)) += uintptr(_i + int32(1))
		goto _17
	}
	_stringAppend(tls, _p, _z, _i)
	goto _10
_17:
	goto _9
_10:
	_stringAppend(tls, _p, str(2198), int32(1))
}

// C comment
//  /* Append n bytes of text to a string.  If n<0 append the entire string. */
func _stringAppend(tls *crt.TLS, _p *XString, _z *int8, _n int32) {
	var _1_nAlloc int32
	var _1_zNew *int8
	if _n < int32(0) {
		_n = int32(crt.Xstrlen(tls, _z))
	}
	if (_p.Xn + _n) < _p.XnAlloc {
		goto _1
	}
	_1_nAlloc = ((_p.XnAlloc * int32(2)) + _n) + int32(100)
	_1_zNew = (*int8)(bin.Xsqlite3_realloc(tls, unsafe.Pointer(_p.Xz), _1_nAlloc))
	if _1_zNew == nil {
		_fatalError(tls, str(2200))
	}
	_p.Xz = _1_zNew
	_p.XnAlloc = _1_nAlloc
_1:
	crt.Xmemcpy(tls, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_p.Xz))+uintptr(_p.Xn)))), unsafe.Pointer(_z), uint64(_n))
	_p.Xn += _n
	*elem1(_p.Xz, uintptr(_p.Xn)) = 0
}

// C comment
//  /* Free a string */
func _stringFree(tls *crt.TLS, _p *XString) {
	if _p.Xz != nil {
		bin.Xsqlite3_free(tls, unsafe.Pointer(_p.Xz))
	}
	crt.Xmemset(tls, unsafe.Pointer(_p), int32(0), uint64(16))
}

// C comment
//  /*
//  ** SQL Trace callback
//  */
func _sqlTraceCallback(tls *crt.TLS, _NotUsed1 unsafe.Pointer, _zSql *int8) {
	_logMessage(tls, str(2214), _clipLength(tls, _zSql), unsafe.Pointer(_zSql))
}

// C comment
//  /*
//  ** Return the length of a string omitting trailing whitespace
//  */
func _clipLength(tls *crt.TLS, _z *int8) (r0 int32) {
	var _n int32
	_n = int32(crt.Xstrlen(tls, _z))
_0:
	if (_n > int32(0)) && (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_z, uintptr(_n-int32(1))))))))&int32(8192)) != 0 {
		_n -= 1
		goto _0
	}
	return _n
}

// C comment
//  /* Report on unrecognized arguments */
func _unrecognizedArguments(tls *crt.TLS, _argv0 *int8, _nArg int32, _azArg **int8) {
	var _i int32
	crt.Xfprintf(tls, (*crt.XFILE)(Xstderr), str(2221), unsafe.Pointer(_argv0))
	_i = int32(0)
_0:
	if _i >= _nArg {
		goto _3
	}
	crt.Xfprintf(tls, (*crt.XFILE)(Xstderr), str(294), unsafe.Pointer(*elem0(_azArg, uintptr(_i))))
	_i += 1
	goto _0
_3:
	crt.Xfprintf(tls, (*crt.XFILE)(Xstderr), str(298))
	crt.Xexit(tls, int32(1))
}

// C comment
//  /*
//  ** Look up the next task for client iClient in the database.
//  ** Return the task script and the task number and mark that
//  ** task as being under way.
//  */
func _startScript(tls *crt.TLS, _iClient int32, _pzScript **int8, _pTaskId *int32, _pzTaskName **int8) (r0 int32) {
	var _taskId, _rc, _totalTime, _6_n int32
	var _pStmt unsafe.Pointer
	_pStmt = nil
	_totalTime = int32(0)
	*_pzScript = nil
	_g.XiTimeout = int32(0)
_0:
	_rc = _trySql(tls, str(2249))
	if _rc == int32(5) {
		bin.Xsqlite3_sleep(tls, int32(10))
		_totalTime += int32(10)
		goto _0
	}
	if _rc != int32(0) {
		_fatalError(tls, str(2265), unsafe.Pointer(bin.Xsqlite3_errmsg(tls, (*bin.Xsqlite3)(_g.Xdb))))
	}
	if _g.XnError != 0 || _g.XnTest != 0 {
		_runSql(tls, str(2284), _g.XnError, _g.XnTest)
		_g.XnError = int32(0)
		_g.XnTest = int32(0)
	}
	_pStmt = _prepareSql(tls, str(2337), _iClient)
	_rc = bin.Xsqlite3_step(tls, _pStmt)
	bin.Xsqlite3_finalize(tls, _pStmt)
	if _rc == int32(100) {
		_runSql(tls, str(2383), _iClient)
		_g.XiTimeout = int32(10000)
		_runSql(tls, str(2414))
		return int32(101)
	}
	_pStmt = _prepareSql(tls, str(2434), _iClient)
	_rc = bin.Xsqlite3_step(tls, _pStmt)
	if _rc == int32(100) {
		_6_n = bin.Xsqlite3_column_bytes(tls, _pStmt, int32(0))
		*_pzScript = (*int8)(bin.Xsqlite3_malloc(tls, _6_n+int32(1)))
		crt.Xstrcpy(tls, *_pzScript, (*int8)(unsafe.Pointer(bin.Xsqlite3_column_text(tls, _pStmt, int32(0)))))
		*_pTaskId = store2(&_taskId, bin.Xsqlite3_column_int(tls, _pStmt, int32(1)))
		*_pzTaskName = bin.Xsqlite3_mprintf(tls, str(2526), unsafe.Pointer(bin.Xsqlite3_column_text(tls, _pStmt, int32(2))))
		bin.Xsqlite3_finalize(tls, _pStmt)
		_runSql(tls, str(2529), _taskId)
		_g.XiTimeout = int32(10000)
		_runSql(tls, str(2414))
		return int32(0)
	}
	bin.Xsqlite3_finalize(tls, _pStmt)
	if _rc != int32(101) {
		goto _8
	}
	if _totalTime > int32(30000) {
		_errorMessage(tls, str(2612))
		_runSql(tls, str(2661), _iClient)
		bin.Xsqlite3_close(tls, (*bin.Xsqlite3)(_g.Xdb))
		crt.Xexit(tls, int32(1))
	}
_9:
	if _trySql(tls, str(2701)) == int32(5) {
		bin.Xsqlite3_sleep(tls, int32(10))
		_totalTime += int32(10)
		goto _9
	}
	bin.Xsqlite3_sleep(tls, int32(100))
	_totalTime += int32(100)
	goto _0
_8:
	_fatalError(tls, str(2526), unsafe.Pointer(bin.Xsqlite3_errmsg(tls, (*bin.Xsqlite3)(_g.Xdb))))
	goto _0
}

// C comment
//  /*
//  ** Prepare an SQL statement.  Issue a fatal error if unable.
//  */
func _prepareSql(tls *crt.TLS, _zFormat *int8, args ...interface{}) (r0 unsafe.Pointer) {
	var _rc int32
	var _zSql *int8
	var _pStmt unsafe.Pointer
	var _ap []interface{}
	_pStmt = nil
	_ap = args
	_zSql = bin.Xsqlite3_vmprintf(tls, _zFormat, _ap)
	_ap = nil
	_rc = bin.Xsqlite3_prepare_v2(tls, (*bin.Xsqlite3)(_g.Xdb), _zSql, int32(-1), &_pStmt, nil)
	if _rc != int32(0) {
		bin.Xsqlite3_finalize(tls, _pStmt)
		_fatalError(tls, str(2161), unsafe.Pointer(bin.Xsqlite3_errmsg(tls, (*bin.Xsqlite3)(_g.Xdb))), unsafe.Pointer(_zSql))
	}
	bin.Xsqlite3_free(tls, unsafe.Pointer(_zSql))
	return _pStmt
}

// C comment
//  /*
//  ** Run a script.
//  */
func _runScript(tls *crt.TLS, _iClient int32, _taskId int32, _zScript *int8, _zFilename *int8) {
	var _lineno, _prevLine, _ii, _iBegin, _n, _c, _j, _len, _nArg, _8_rc, _12_jj, _15_jj, _15_isGlob, _20_k, _23_jj, _25_jj, _25_rc, _30_iNewClient, _32_iTimeout, _33_iTarget, _33_iEnd int32
	var _4_zSql, _12_zAns, _15_zAns, _15_zCopy, _19_zNewFile, _19_zNewScript, _19_zToDel, _33_zTask, _33_zTName, _41_zSql *int8
	var _25_pStmt unsafe.Pointer
	var _zError [1000]int8
	var _zCmd [30]int8
	var _sResult XString
	var _azArg [2][100]int8
	_lineno = int32(1)
	_prevLine = int32(1)
	_ii = int32(0)
	_iBegin = int32(0)
	crt.Xmemset(tls, unsafe.Pointer(&_sResult), int32(0), uint64(16))
	_stringReset(tls, &_sResult)
_0:
	if store2(&_c, int32(*elem1(_zScript, uintptr(_ii)))) == int32(0) {
		goto _1
	}
	_prevLine = _lineno
	_len = _tokenLength(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii))), &_lineno)
	if (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(_c)))))&int32(8192)) != 0 || ((_c == int32(47)) && (int32(*elem1(_zScript, uintptr(_ii+int32(1)))) == int32(42))) {
		_ii += _len
		goto _0
	}
	if ((_c != int32(45)) || (int32(*elem1(_zScript, uintptr(_ii+int32(1)))) != int32(45))) || ((int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(*elem1(_zScript, uintptr(_ii+int32(2))))))) & int32(1024)) == 0) {
		_ii += _len
		goto _0
	}
	if _ii > _iBegin {
		_4_zSql = bin.Xsqlite3_mprintf(tls, str(2708), _ii-_iBegin, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_iBegin)))))
		_evalSql(tls, &_sResult, _4_zSql)
		bin.Xsqlite3_free(tls, unsafe.Pointer(_4_zSql))
		_iBegin = _ii + _len
	}
	if _g.XiTrace >= int32(2) {
		_logMessage(tls, str(2708), _len, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))
	}
	_n = _extractToken(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))+uintptr(int32(2)))), _len-int32(2), (*int8)(unsafe.Pointer(&_zCmd)), int32(30))
	_nArg = int32(0)
_10:
	if _n >= (_len-int32(2)) || _nArg >= int32(2) {
		goto _14
	}
_15:
	if (_n < (_len - int32(2))) && (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_zScript, uintptr((_ii+int32(2))+_n)))))))&int32(8192)) != 0 {
		_n += 1
		goto _15
	}
	if _n >= (_len - int32(2)) {
		goto _14
	}
	_n += _extractToken(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))+uintptr(int32(2))))))+uintptr(_n))), (_len-int32(2))-_n, (*int8)(unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), uintptr(_nArg)))), int32(100))
	_nArg += 1
	goto _10
_14:
	_j = _nArg
_19:
	if _j >= int32(2) {
		goto _22
	}
	*elem1((*int8)(unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), uintptr(postInc2(&_j, 1))))), 0) = 0
	_j += 1
	goto _19
_22:
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2713)) == int32(0) {
		bin.Xsqlite3_sleep(tls, crt.Xatoi(tls, (*int8)(unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), 0)))))
		goto _108
	}
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2719)) != int32(0) {
		goto _25
	}
	_8_rc = crt.Xatoi(tls, (*int8)(unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), 0))))
	_finishScript(tls, _iClient, _taskId, int32(1))
	if _8_rc == int32(0) {
		bin.Xsqlite3_close(tls, (*bin.Xsqlite3)(_g.Xdb))
	}
	crt.Xexit(tls, _8_rc)
	goto _108
_25:
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2724)) != int32(0) {
		goto _28
	}
	if _g.XiTrace == int32(1) {
		_logMessage(tls, str(2708), _len-int32(1), unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))
	}
	_stringReset(tls, &_sResult)
	goto _108
_28:
	if (crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2733)) == int32(0)) && (_iClient > int32(0)) {
		_finishScript(tls, _iClient, _taskId, int32(1))
		goto _108
	}
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2740)) == int32(0) {
		_stringReset(tls, &_sResult)
		goto _108
	}
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2746)) != int32(0) {
		goto _36
	}
	_12_zAns = (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript)) + uintptr(_ii)))
	_12_jj = int32(7)
_37:
	if _12_jj >= (_len-int32(1)) || (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_12_zAns, uintptr(_12_jj)))))))&int32(8192)) == 0 {
		goto _41
	}
	_12_jj += 1
	goto _37
_41:
	*(*uintptr)(unsafe.Pointer(&_12_zAns)) += uintptr(_12_jj)
	if (((_len - _12_jj) - int32(1)) != _sResult.Xn) || crt.Xstrncmp(tls, _sResult.Xz, _12_zAns, uint64((_len-_12_jj)-int32(1))) != 0 {
		_errorMessage(tls, str(2752), _prevLine, unsafe.Pointer(_zFilename), (_len-_12_jj)-int32(1), unsafe.Pointer(_12_zAns), unsafe.Pointer(_sResult.Xz))
	}
	_g.XnTest += 1
	_stringReset(tls, &_sResult)
	goto _108
_36:
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2797)) != int32(0) && crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2802)) != int32(0) {
		goto _46
	}
	_15_zAns = (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript)) + uintptr(_ii)))
	_15_isGlob = bool2int(int32(*elem1((*int8)(unsafe.Pointer(&_zCmd)), 0)) == int32(103))
	_15_jj = int32(9) - (int32(3) * _15_isGlob)
_47:
	if _15_jj >= (_len-int32(1)) || (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_15_zAns, uintptr(_15_jj)))))))&int32(8192)) == 0 {
		goto _51
	}
	_15_jj += 1
	goto _47
_51:
	*(*uintptr)(unsafe.Pointer(&_15_zAns)) += uintptr(_15_jj)
	_15_zCopy = bin.Xsqlite3_mprintf(tls, str(2708), (_len-_15_jj)-int32(1), unsafe.Pointer(_15_zAns))
	if (bool2int(bin.Xsqlite3_strglob(tls, _15_zCopy, _sResult.Xz) == int32(0)) ^ _15_isGlob) != 0 {
		_errorMessage(tls, str(2810), _prevLine, unsafe.Pointer(_zFilename), unsafe.Pointer(_15_zCopy), unsafe.Pointer(_sResult.Xz))
	}
	bin.Xsqlite3_free(tls, unsafe.Pointer(_15_zCopy))
	_g.XnTest += 1
	_stringReset(tls, &_sResult)
	goto _108
_46:
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2853)) == int32(0) {
		_logMessage(tls, str(2526), unsafe.Pointer(_sResult.Xz))
		goto _108
	}
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2860)) != int32(0) {
		goto _56
	}
	_19_zToDel = nil
	_19_zNewFile = (*int8)(unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), 0)))
	if int32(*elem1(_19_zNewFile, 0)) == int32(47) {
		goto _57
	}
	_20_k = int32(crt.Xstrlen(tls, _zFilename)) - int32(1)
_58:
	if _20_k < int32(0) || int32(*elem1(_zFilename, uintptr(_20_k))) == int32(47) {
		goto _62
	}
	_20_k -= 1
	goto _58
_62:
	if _20_k > int32(0) {
		_19_zNewFile = store1(&_19_zToDel, bin.Xsqlite3_mprintf(tls, str(2867), _20_k, unsafe.Pointer(_zFilename), unsafe.Pointer(_19_zNewFile)))
	}
_57:
	_19_zNewScript = _readFile(tls, _19_zNewFile)
	if _g.XiTrace != 0 {
		_logMessage(tls, str(2875), unsafe.Pointer(_19_zNewFile))
	}
	_runScript(tls, int32(0), int32(0), _19_zNewScript, _19_zNewFile)
	bin.Xsqlite3_free(tls, unsafe.Pointer(_19_zNewScript))
	if _g.XiTrace != 0 {
		_logMessage(tls, str(2894), unsafe.Pointer(_19_zNewFile))
	}
	bin.Xsqlite3_free(tls, unsafe.Pointer(_19_zToDel))
	goto _108
_56:
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2911)) != int32(0) {
		goto _67
	}
	_23_jj = int32(7)
_68:
	if _23_jj >= _len || (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_zScript, uintptr(_ii+_23_jj)))))))&int32(8192)) == 0 {
		goto _72
	}
	_23_jj += 1
	goto _68
_72:
	_logMessage(tls, str(2708), _len-_23_jj, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))+uintptr(_23_jj)))))
	goto _108
_67:
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2917)) != int32(0) {
		goto _74
	}
	_25_jj = int32(4)
_75:
	if _25_jj >= _len || (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_zScript, uintptr(_ii+_25_jj)))))))&int32(8192)) == 0 {
		goto _79
	}
	_25_jj += 1
	goto _75
_79:
	_25_pStmt = _prepareSql(tls, str(2920), _len-_25_jj, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))+uintptr(_25_jj)))))
	_25_rc = bin.Xsqlite3_step(tls, _25_pStmt)
	if (_25_rc != int32(100)) || (bin.Xsqlite3_column_int(tls, _25_pStmt, int32(0)) == int32(0)) {
		_ii += _findEndif(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))+uintptr(_len))), int32(1), &_lineno)
	}
	bin.Xsqlite3_finalize(tls, _25_pStmt)
	goto _108
_74:
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2932)) == int32(0) {
		_ii += _findEndif(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))+uintptr(_len))), int32(0), &_lineno)
		goto _108
	}
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2937)) == int32(0) {
		goto _108
	}
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2943)) != int32(0) || _iClient != int32(0) {
		goto _88
	}
	_30_iNewClient = crt.Xatoi(tls, (*int8)(unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), 0))))
	if _30_iNewClient > int32(0) {
		_startClient(tls, _30_iNewClient)
	}
	goto _108
_88:
	if (crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2949)) == int32(0)) && (_iClient == int32(0)) {
		_32_iTimeout = func() int32 {
			if _nArg >= int32(2) {
				return crt.Xatoi(tls, (*int8)(unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), uintptr(1)))))
			}
			return int32(10000)
		}()
		bin.Xsqlite3_snprintf(tls, int32(1000), (*int8)(unsafe.Pointer(&_zError)), str(2954), _prevLine, unsafe.Pointer(_zFilename))
		_waitForClient(tls, crt.Xatoi(tls, (*int8)(unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), 0)))), _32_iTimeout, (*int8)(unsafe.Pointer(&_zError)))
		goto _108
	}
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(2969)) != int32(0) || _iClient != int32(0) {
		goto _97
	}
	_33_iTarget = crt.Xatoi(tls, (*int8)(unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), 0))))
	_33_iEnd = _findEnd(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))+uintptr(_len))), &_lineno)
	if _33_iTarget < int32(0) {
		_errorMessage(tls, str(2974), _prevLine, unsafe.Pointer(_zFilename), _33_iTarget)
		goto _99
	}
	_33_zTask = bin.Xsqlite3_mprintf(tls, str(2708), _33_iEnd, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))+uintptr(_len)))))
	if _nArg > int32(1) {
		_33_zTName = bin.Xsqlite3_mprintf(tls, str(2526), unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), uintptr(1))))
		goto _101
	}
	_33_zTName = bin.Xsqlite3_mprintf(tls, str(3011), unsafe.Pointer(_filenameTail(tls, _zFilename)), _prevLine)
_101:
	_startClient(tls, _33_iTarget)
	_runSql(tls, str(3017), _33_iTarget, unsafe.Pointer(_33_zTask), unsafe.Pointer(_33_zTName))
	bin.Xsqlite3_free(tls, unsafe.Pointer(_33_zTask))
	bin.Xsqlite3_free(tls, unsafe.Pointer(_33_zTName))
_99:
	_33_iEnd += _tokenLength(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_ii)))))+uintptr(_len)))))+uintptr(_33_iEnd))), &_lineno)
	_len += _33_iEnd
	_iBegin = _ii + _len
	goto _108
_97:
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(3073)) == int32(0) {
		_test_breakpoint(tls)
		goto _108
	}
	if crt.Xstrcmp(tls, (*int8)(unsafe.Pointer(&_zCmd)), str(3084)) == int32(0) {
		_g.XbIgnoreSqlErrors = func() int32 {
			if _nArg >= int32(1) {
				return bool2int(_booleanValue(tls, (*int8)(unsafe.Pointer(elem5((*[100]int8)(unsafe.Pointer(&_azArg)), 0)))) == 0)
			}
			return int32(1)
		}()
		goto _108
	}
	_errorMessage(tls, str(3100), _prevLine, unsafe.Pointer(_zFilename), unsafe.Pointer(&_zCmd))
_108:
	_ii += _len
	goto _0
_1:
	if _iBegin < _ii {
		_41_zSql = bin.Xsqlite3_mprintf(tls, str(2708), _ii-_iBegin, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_zScript))+uintptr(_iBegin)))))
		_runSql(tls, _41_zSql)
		bin.Xsqlite3_free(tls, unsafe.Pointer(_41_zSql))
	}
	_stringFree(tls, &_sResult)
	_ = _zCmd
	_ = _zError
	_ = _azArg
}

// C comment
//  /* Reset a string to an empty string */
func _stringReset(tls *crt.TLS, _p *XString) {
	if _p.Xz == nil {
		_stringAppend(tls, _p, str(2192), int32(1))
	}
	_p.Xn = int32(0)
	*elem1(_p.Xz, 0) = 0
}

// C comment
//  /*
//  ** Return the length of the next token.
//  */
func _tokenLength(tls *crt.TLS, _z *int8, _pnLine *int32) (r0 int32) {
	var _n, _1_inC, _1_c, _10_delim, _13_c int32
	_n = int32(0)
	if (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_z, 0))))))&int32(8192)) == 0 && (int32(*elem1(_z, 0)) != int32(47) || int32(*elem1(_z, uintptr(1))) != int32(42)) {
		goto _2
	}
	_1_inC = int32(0)
	if int32(*elem1(_z, 0)) == int32(47) {
		_1_inC = int32(1)
		_n = int32(2)
	}
_3:
	if store2(&_1_c, int32(*elem1(_z, uintptr(postInc2(&_n, 1))))) == int32(0) {
		goto _5
	}
	if _1_c == int32(10) {
		*_pnLine += 1
	}
	if (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(_1_c))))) & int32(8192)) != 0 {
		goto _3
	}
	if (_1_inC != 0 && (_1_c == int32(42))) && (int32(*elem1(_z, uintptr(_n))) == int32(47)) {
		_n += 1
		_1_inC = int32(0)
		goto _16
	}
	if ((_1_inC == 0) && (_1_c == int32(47))) && (int32(*elem1(_z, uintptr(_n))) == int32(42)) {
		_n += 1
		_1_inC = int32(1)
		goto _16
	}
	if _1_inC == 0 {
		goto _5
	}
_16:
	goto _3
_5:
	_n -= 1
	goto _36
_2:
	if int32(*elem1(_z, 0)) != int32(45) || int32(*elem1(_z, uintptr(1))) != int32(45) {
		goto _19
	}
	_n = int32(2)
_20:
	if (*elem1(_z, uintptr(_n))) == 0 || int32(*elem1(_z, uintptr(_n))) == int32(10) {
		goto _24
	}
	_n += 1
	goto _20
_24:
	if (*elem1(_z, uintptr(_n))) != 0 {
		*_pnLine += 1
		_n += 1
	}
	goto _36
_19:
	if int32(*elem1(_z, 0)) != int32(34) && int32(*elem1(_z, 0)) != int32(39) {
		goto _28
	}
	_10_delim = int32(*elem1(_z, 0))
	_n = int32(1)
_29:
	if (*elem1(_z, uintptr(_n))) == 0 {
		goto _32
	}
	if int32(*elem1(_z, uintptr(_n))) == int32(10) {
		*_pnLine += 1
	}
	if int32(*elem1(_z, uintptr(_n))) != _10_delim {
		goto _34
	}
	_n += 1
	if int32(*elem1(_z, uintptr(_n+int32(1)))) != _10_delim {
		goto _32
	}
_34:
	_n += 1
	goto _29
_32:
	goto _36
_28:
	_n = int32(1)
_37:
	if store2(&_13_c, int32(*elem1(_z, uintptr(_n)))) == int32(0) || (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(_13_c)))))&int32(8192)) != 0 || _13_c == int32(34) || _13_c == int32(39) || _13_c == int32(59) {
		goto _44
	}
	_n += 1
	goto _37
_44:
_36:
	return _n
}

// C comment
//  /*
//  ** Run arbitrary SQL and record the results in an output string
//  ** given by the first parameter.
//  */
func _evalSql(tls *crt.TLS, _p *XString, _zFormat *int8, args ...interface{}) (r0 int32) {
	var _rc int32
	var _zSql, _zErrMsg *int8
	var _ap []interface{}
	var _1_zErr [30]int8
	_zErrMsg = nil
	_ap = args
	_zSql = bin.Xsqlite3_vmprintf(tls, _zFormat, _ap)
	_ap = nil
	func() {
		if _g.XiTimeout <= int32(0) {
			crt.X__builtin_fprintf(tls, Xstderr, str(1897), unsafe.Pointer(str(1933)), int32(494), unsafe.Pointer(&_evalSqlØ00__func__Ø000), unsafe.Pointer(str(3136)))
			crt.X__builtin_abort(tls)
		}
	}()
	_rc = bin.Xsqlite3_exec(tls, (*bin.Xsqlite3)(_g.Xdb), _zSql, _evalCallback, unsafe.Pointer(_p), &_zErrMsg)
	bin.Xsqlite3_free(tls, unsafe.Pointer(_zSql))
	if _rc == 0 {
		goto _2
	}
	bin.Xsqlite3_snprintf(tls, int32(30), (*int8)(unsafe.Pointer(&_1_zErr)), str(3149), _rc)
	_stringAppendTerm(tls, _p, (*int8)(unsafe.Pointer(&_1_zErr)))
	if _zErrMsg != nil {
		_stringAppendTerm(tls, _p, _zErrMsg)
		bin.Xsqlite3_free(tls, unsafe.Pointer(_zErrMsg))
	}
_2:
	return _rc

	_ = _1_zErr
	panic(0)
}

var _evalSqlØ00__func__Ø000 [8]int8

func init() {
	crt.Xstrncpy(nil, &_evalSqlØ00__func__Ø000[0], str(3159), 8)
}

// C comment
//  /*
//  ** Copy a single token into a string buffer.
//  */
func _extractToken(tls *crt.TLS, _zIn *int8, _nIn int32, _zOut *int8, _nOut int32) (r0 int32) {
	var _i int32
	if _nIn <= int32(0) {
		*elem1(_zOut, 0) = 0
		return int32(0)
	}
	_i = int32(0)
_1:
	if _i >= _nIn || _i >= (_nOut-int32(1)) || (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_zIn, uintptr(_i)))))))&int32(8192)) != 0 {
		goto _6
	}
	*elem1(_zOut, uintptr(_i)) = *elem1(_zIn, uintptr(_i))
	_i += 1
	goto _1
_6:
	*elem1(_zOut, uintptr(_i)) = 0
	return _i
}

// C comment
//  /*
//  ** Mark a script as having finished.   Remove the CLIENT table entry
//  ** if bShutdown is true.
//  */
func _finishScript(tls *crt.TLS, _iClient int32, _taskId int32, _bShutdown int32) (r0 int32) {
	_runSql(tls, str(3167), _taskId)
	if _bShutdown != 0 {
		_runSql(tls, str(2383), _iClient)
	}
	return int32(0)
}

// C comment
//  /*
//  ** Read the entire content of a file into memory
//  */
func _readFile(tls *crt.TLS, _zFilename *int8) (r0 *int8) {
	var _sz int64
	var _z *int8
	var _in *crt.XFILE
	_in = crt.Xfopen64(tls, _zFilename, str(3248))
	if _in == nil {
		_fatalError(tls, str(3251), unsafe.Pointer(_zFilename))
	}
	crt.Xfseek(tls, _in, 0, int32(2))
	_sz = crt.Xftell(tls, _in)
	crt.Xrewind(tls, _in)
	_z = (*int8)(bin.Xsqlite3_malloc(tls, int32(_sz+int64(1))))
	_sz = int64(crt.Xfread(tls, unsafe.Pointer(_z), uint64(1), uint64(_sz), _in))
	*elem1(_z, uintptr(_sz)) = 0
	crt.Xfclose(tls, _in)
	return _z
}

// C comment
//  /*
//  ** Find the number of characters up to the first character past the
//  ** of the next "--endif"  or "--else" token. Nested --if commands are
//  ** also skipped.
//  */
func _findEndif(tls *crt.TLS, _z *int8, _stopAtElse int32, _pnLine *int32) (r0 int32) {
	var _n, _1_len, _3_skip int32
	_n = int32(0)
_0:
	if (*elem1(_z, uintptr(_n))) == 0 {
		goto _1
	}
	_1_len = _tokenLength(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_z))+uintptr(_n))), _pnLine)
	if ((crt.Xstrncmp(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_z))+uintptr(_n))), str(3280), uint64(7)) == int32(0)) && (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_z, uintptr(_n+int32(7))))))))&int32(8192)) != 0) || ((_stopAtElse != 0 && (crt.Xstrncmp(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_z))+uintptr(_n))), str(3288), uint64(6)) == int32(0))) && (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_z, uintptr(_n+int32(6))))))))&int32(8192)) != 0) {
		return _n + _1_len
	}
	if (crt.Xstrncmp(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_z))+uintptr(_n))), str(3295), uint64(4)) == int32(0)) && (int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_z, uintptr(_n+int32(4))))))))&int32(8192)) != 0 {
		_3_skip = _findEndif(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_z))+uintptr(_n)))))+uintptr(_1_len))), int32(0), _pnLine)
		_n += _3_skip + _1_len
		goto _9
	}
	_n += _1_len
_9:
	goto _0
_1:
	return _n
}

// C comment
//  /*
//  ** Start up a client process for iClient, if it is not already
//  ** running.  If the client is already running, then this routine
//  ** is a no-op.
//  */
func _startClient(tls *crt.TLS, _iClient int32) {
	var _1_rc int32
	var _1_zSys *int8
	_runSql(tls, str(3300), _iClient)
	if bin.Xsqlite3_changes(tls, (*bin.Xsqlite3)(_g.Xdb)) == 0 {
		goto _0
	}
	_1_zSys = bin.Xsqlite3_mprintf(tls, str(3342), unsafe.Pointer(_g.Xargv0), unsafe.Pointer(_g.XzDbFile), _iClient, _g.XiTrace)
	if _g.XbSqlTrace != 0 {
		_1_zSys = bin.Xsqlite3_mprintf(tls, str(3373), unsafe.Pointer(_1_zSys))
	}
	if _g.XbSync != 0 {
		_1_zSys = bin.Xsqlite3_mprintf(tls, str(3387), unsafe.Pointer(_1_zSys))
	}
	if _g.XzVfs != nil {
		_1_zSys = bin.Xsqlite3_mprintf(tls, str(3397), unsafe.Pointer(_1_zSys), unsafe.Pointer(_g.XzVfs))
	}
	if _g.XiTrace >= int32(2) {
		_logMessage(tls, str(3411), unsafe.Pointer(_1_zSys))
	}
	_1_zSys = bin.Xsqlite3_mprintf(tls, str(3424), unsafe.Pointer(_1_zSys))
	_1_rc = crt.Xsystem(tls, _1_zSys)
	if _1_rc != 0 {
		_errorMessage(tls, str(3429), _1_rc)
	}
	bin.Xsqlite3_free(tls, unsafe.Pointer(_1_zSys))
_0:
}

// C comment
//  /*
//  ** Wait for a client process to complete all its tasks
//  */
func _waitForClient(tls *crt.TLS, _iClient int32, _iTimeout int32, _zErrPrefix *int8) {
	var _rc int32
	var _pStmt unsafe.Pointer
	if _iClient > int32(0) {
		_pStmt = _prepareSql(tls, str(3463), _iClient)
		goto _1
	}
	_pStmt = _prepareSql(tls, str(3559))
_1:
	_g.XiTimeout = int32(0)
_2:
	if ((store2(&_rc, bin.Xsqlite3_step(tls, _pStmt)) == int32(5)) || (_rc == int32(100))) && (_iTimeout > int32(0)) {
		bin.Xsqlite3_reset(tls, _pStmt)
		bin.Xsqlite3_sleep(tls, int32(50))
		_iTimeout -= int32(50)
		goto _2
	}
	bin.Xsqlite3_finalize(tls, _pStmt)
	_g.XiTimeout = int32(10000)
	if _rc == int32(101) {
		goto _6
	}
	if _zErrPrefix == nil {
		_zErrPrefix = str(454)
	}
	if _iClient > int32(0) {
		_errorMessage(tls, str(3640), unsafe.Pointer(_zErrPrefix), _iClient)
		goto _9
	}
	_errorMessage(tls, str(3672), unsafe.Pointer(_zErrPrefix))
_9:
_6:
}

// C comment
//  /*
//  ** Find the number of characters up to the start of the next "--end" token.
//  */
func _findEnd(tls *crt.TLS, _z *int8, _pnLine *int32) (r0 int32) {
	var _n int32
	_n = int32(0)
_0:
	if ((*elem1(_z, uintptr(_n))) != 0) && (crt.Xstrncmp(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_z))+uintptr(_n))), str(3706), uint64(5)) != 0 || ((int32(*elem3(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*elem1(_z, uintptr(_n+int32(5)))))))) & int32(8192)) == 0)) {
		_n += _tokenLength(tls, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_z))+uintptr(_n))), _pnLine)
		goto _0
	}
	return _n
}

// C comment
//  /* Return a pointer to the tail of a filename
//  */
func _filenameTail(tls *crt.TLS, _z *int8) (r0 *int8) {
	var _i, _j int32
	_i = store2(&_j, int32(0))
_0:
	if (*elem1(_z, uintptr(_i))) == 0 {
		goto _3
	}
	if int32(*elem1(_z, uintptr(_i))) == int32(47) {
		_j = _i + int32(1)
	}
	_i += 1
	goto _0
_3:
	return (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(_z)) + uintptr(_j)))
}

// C comment
//  /* This routine exists as a convenient place to set a debugger
//  ** breakpoint.
//  */
func _test_breakpoint(tls *crt.TLS) {
	_test_breakpointØ00cntØ001 += 1
}

// C comment
//  /* This routine exists as a convenient place to set a debugger
//  ** breakpoint.
//  */
var _test_breakpointØ00cntØ001 int32

// C comment
//  /*
//  ** Interpret zArg as a boolean value.  Return either 0 or 1.
//  */
func _booleanValue(tls *crt.TLS, _zArg *int8) (r0 int32) {
	var _i int32
	if _zArg == nil {
		return int32(0)
	}
	_i = int32(0)
_1:
	if int32(*elem1(_zArg, uintptr(_i))) < int32(48) || int32(*elem1(_zArg, uintptr(_i))) > int32(57) {
		goto _5
	}
	_i += 1
	goto _1
_5:
	if (_i > int32(0)) && (int32(*elem1(_zArg, uintptr(_i))) == int32(0)) {
		return crt.Xatoi(tls, _zArg)
	}
	if (bin.Xsqlite3_stricmp(tls, _zArg, str(3712)) == int32(0)) || (bin.Xsqlite3_stricmp(tls, _zArg, str(3715)) == int32(0)) {
		return int32(1)
	}
	if (bin.Xsqlite3_stricmp(tls, _zArg, str(3719)) == int32(0)) || (bin.Xsqlite3_stricmp(tls, _zArg, str(3723)) == int32(0)) {
		return int32(0)
	}
	_errorMessage(tls, str(3726), unsafe.Pointer(_zArg))
	return int32(0)
}

func bool2int(b bool) int32 {
	if b {
		return 1
	}
	return 0
}
func bug20530(interface{}) {} //TODO remove when https://github.com/golang/go/issues/20530 is fixed.
func init()                { nzf32 *= -1; nzf64 *= -1 }

var inf = math.Inf(1)
var nzf32 float32 // -0.0
var nzf64 float64 // -0.0
func elem0(a **int8, index uintptr) **int8 {
	return (**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + 8*index))
}
func elem4(a *unsafe.Pointer, index uintptr) *unsafe.Pointer {
	return (*unsafe.Pointer)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + 8*index))
}
func elem5(a *[100]int8, index uintptr) *[100]int8 {
	return (*[100]int8)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + 100*index))
}
func elem1(a *int8, index uintptr) *int8 {
	return (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + 1*index))
}
func elem3(a *uint16, index uintptr) *uint16 {
	return (*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + 2*index))
}
func postInc1(p **int8, d int) *int8 {
	q := (*uintptr)(unsafe.Pointer(p))
	v := *q
	*q += uintptr(d)
	return (*int8)(unsafe.Pointer(v))
}
func postInc2(p *int32, d int32) int32 { v := *p; *p += d; return v }
func preInc2(p *int32, d int32) int32  { v := *p + d; *p = v; return v }
func store1(p **int8, v *int8) *int8   { *p = v; return v }
func store2(p *int32, v int32) int32   { *p = v; return v }

type TGlobal struct {
	Xargv0            *int8
	XzVfs             *int8
	XzDbFile          *int8
	Xdb               unsafe.Pointer
	XzErrLog          *int8
	XpErrLog          unsafe.Pointer
	XzLog             *int8
	XpLog             unsafe.Pointer
	XzName            [32]int8
	XtaskId           int32
	XiTrace           int32
	XbSqlTrace        int32
	XbIgnoreSqlErrors int32
	XnError           int32
	XnTest            int32
	XiTimeout         int32
	XbSync            int32
} // t6 struct{*int8,*int8,*int8,*struct{},*int8,*struct{},*int8,*struct{},[32]int8,int32,int32,int32,int32,int32,int32,int32,int32}

type XString struct {
	Xz      *int8
	Xn      int32
	XnAlloc int32
}                       // t7 struct{*int8,int32,int32}
func str(n int) *int8   { return (*int8)(unsafe.Pointer(&strTab[n])) }
func wstr(n int) *int32 { return (*int32)(unsafe.Pointer(&strTab[n])) }

var strTab = []byte("*.test\x002017-06-08 14:26:16 0ee482a1e0eae22e08edc8978c9733a96603d4509645f348ebf55b579e89636b\x00SQLite library and header mismatch\x0aLibrary: %s\x0aHeader:  %s\x0a\x00%05d.mptest\x00journalmode\x00repeat\x00vfs\x00client\x00errlog\x00log\x00trace\x00quiet\x00timeout\x00sqltrace\x00sync\x00a\x00illegal client number: %d\x0a\x00%05d.client%02d\x00BEGIN: %s\x00 %s\x00\x0a\x00With SQLite 3.19.3 2017-06-08 14:26:16 0ee482a1e0eae22e08edc8978c9733a96603d4509645f348ebf55b579e89636b\x0a\x00-DSQLITE_%s\x0a\x00... %strying to unlink '%s'\x0a\x00still \x00\x00unable to unlink '%s' after %d attempts\x0a\x00cannot open [%s]\x00PRAGMA journal_mode=%Q;\x00PRAGMA synchronous=OFF\x00vfsname\x00eval\x00start-client\x00begin %s (%d)\x00end %s (%d)\x00end-client\x00missing script filename\x00DROP TABLE IF EXISTS task;\x0aDROP TABLE IF EXISTS counters;\x0aDROP TABLE IF EXISTS client;\x0aCREATE TABLE task(\x0a  id INTEGER PRIMARY KEY,\x0a  name TEXT,\x0a  client INTEGER,\x0a  starttime DATE,\x0a  endtime DATE,\x0a  script TEXT\x0a);CREATE INDEX task_i1 ON task(client, starttime);\x0aCREATE INDEX task_i2 ON task(client, endtime);\x0aCREATE TABLE counters(nError,nTest);\x0aINSERT INTO counters VALUES(0,0);\x0aCREATE TABLE client(id INTEGER PRIMARY KEY, wantHalt);\x0a\x00begin script [%s] cycle %d\x0a\x00end script [%s] cycle %d\x0a\x00during shutdown...\x0a\x00UPDATE client SET wantHalt=1\x00SELECT 1 FROM client\x00SELECT nError, nTest FROM counters\x00Summary: %d errors out of %d tests\x0a\x00END: %s\x00Usage: %s DATABASE ?OPTIONS? ?SCRIPT?\x0a\x00Options:\x0a   --errlog FILENAME           Write errors to FILENAME\x0a   --journalmode MODE          Use MODE as the journal_mode\x0a   --log FILENAME              Log messages to FILENAME\x0a   --quiet                     Suppress unnecessary output\x0a   --vfs NAME                  Use NAME as the VFS\x0a   --repeat N                  Repeat the test N times\x0a   --sqltrace                  Enable SQL tracing\x0a   --sync                      Enable synchronous disk writes\x0a   --timeout MILLISEC          Busy timeout is MILLISEC\x0a   --trace BOOLEAN             Enable or disable tracing\x0a\x00%s:%i: assertion failure in %s: %s\x0a\x00../../../sqlite.org/sqlite-src-3190300/mptest/mptest.c\x00hasArg==0 || hasArg==1\x00command-line option \"--%s\" requires an argument\x00findOption\x00%s:FATAL: \x00UPDATE client SET wantHalt=1;\x00%s%.*s\x0a\x00(info) %s\x00(errcode=%d) %s\x00%s: \x00%s:ERROR: \x00%s\x0a%s\x0a\x00timeout after %dms\x00main\x00 \x00nil\x00'\x00out of memory\x00[%.*s]\x00%s: unrecognized arguments:\x00BEGIN IMMEDIATE\x00in startScript: %s\x00UPDATE counters SET nError=nError+%d, nTest=nTest+%d\x00SELECT 1 FROM client WHERE id=%d AND wantHalt\x00DELETE FROM client WHERE id=%d\x00COMMIT TRANSACTION;\x00SELECT script, id, name FROM task WHERE client=%d AND starttime IS NULL ORDER BY id LIMIT 1\x00%s\x00UPDATE task   SET starttime=strftime('%%Y-%%m-%%d %%H:%%M:%%f','now') WHERE id=%d;\x00Waited over 30 seconds with no work.  Giving up.\x00DELETE FROM client WHERE id=%d; COMMIT;\x00COMMIT\x00%.*s\x00sleep\x00exit\x00testcase\x00finish\x00reset\x00match\x00line %d of %s:\x0aExpected [%.*s]\x0a     Got [%s]\x00glob\x00notglob\x00line %d of %s:\x0aExpected [%s]\x0a     Got [%s]\x00output\x00source\x00%.*s/%s\x00begin script [%s]\x0a\x00end script [%s]\x0a\x00print\x00if\x00SELECT %.*s\x00else\x00endif\x00start\x00wait\x00line %d of %s\x0a\x00task\x00line %d of %s: bad client number: %d\x00%s:%d\x00INSERT INTO task(client,script,name) VALUES(%d,'%q',%Q)\x00breakpoint\x00show-sql-errors\x00line %d of %s: unknown command --%s\x00g.iTimeout>0\x00error(%d)\x00evalSql\x00UPDATE task   SET endtime=strftime('%%Y-%%m-%%d %%H:%%M:%%f','now') WHERE id=%d;\x00rb\x00cannot open \"%s\" for reading\x00--endif\x00--else\x00--if\x00INSERT OR IGNORE INTO client VALUES(%d,0)\x00%s \"%s\" --client %d --trace %d\x00%z --sqltrace\x00%z --sync\x00%z --vfs \"%s\"\x00system('%q')\x00%z &\x00system() fails with error code %d\x00SELECT 1 FROM task WHERE client=%d   AND client IN (SELECT id FROM client)  AND endtime IS NULL\x00SELECT 1 FROM task WHERE client IN (SELECT id FROM client)   AND endtime IS NULL\x00%stimeout waiting for client %d\x00%stimeout waiting for all clients\x00--end\x00on\x00yes\x00off\x00no\x00unknown boolean: [%s]\x00")
